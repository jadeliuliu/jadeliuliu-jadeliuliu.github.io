<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jadeliu&#39;s blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Jadeliu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jade liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jadeliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jadeliu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/20/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/20/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/shell/" class="post-title-link" itemprop="url">shell常规</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-20 22:32:07 / Modified: 22:47:02" itemprop="dateCreated datePublished" datetime="2023-02-20T22:32:07+08:00">2023-02-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> !/bin/bash  #表示当前脚本使用的shell解释器为bash</span><br><span class="line">echo &quot;hello!&quot;</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">sum=$(($a+$b))  #注意=前后不能有空格</span><br><span class="line">multi=$(($a*$b))</span><br><span class="line">echo $sum</span><br><span class="line">echo $multi</span><br><span class="line">res=`expr $a \* $b`  #注意\*前后有空格</span><br><span class="line">echo $res</span><br></pre></td></tr></table></figure>

<p>shell用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_28836875/article/details/113707668">https://blog.csdn.net/weixin_28836875/article/details/113707668</a></p>
<p>expr命令：expr命令计算给定表达式并显示其相应的输出，其被使用用于：基本操作像加法、减法、乘法、除法和模等等整数，求值正则表达式，字符串操作，如子字符串，字符串长度等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">加法：expr 12 + 9</span><br><span class="line"></span><br><span class="line">乘法：expr 12 \* 2</span><br></pre></td></tr></table></figure>

<p>对shell脚本中的变量执行操作，注意保存成.sh文件并赋权限755再执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Enter two numbers&quot;</span><br><span class="line">read x </span><br><span class="line">read y</span><br><span class="line">sum=`expr $x + $y`</span><br><span class="line">echo &quot;Sum = $sum&quot;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/19/myblog/%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/19/myblog/%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="post-title-link" itemprop="url">《深入理解java虚拟机》笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-19 14:30:11" itemprop="dateCreated datePublished" datetime="2023-02-19T14:30:11+08:00">2023-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-25 23:52:17" itemprop="dateModified" datetime="2023-02-25T23:52:17+08:00">2023-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一章-走进java"><a href="#第一章-走进java" class="headerlink" title="第一章 走进java"></a>第一章 走进java</h2><h4 id="1-java体系"><a href="#1-java体系" class="headerlink" title="1.java体系"></a>1.java体系</h4><p>java技术体系：<br>1.Java程序运行的虚拟机<br>2.java类库<br>3.java编程语言<br>4.第三方框架 spring、mybatis</p>
<p>虚拟机层面隐藏了底层技术的复杂性以及机器与操作系统的差异性。虚拟机完成对硬件平台的兼容和对内存等资源的管理工作。</p>
<p>程序性能、稳定性、扩展性上，需要知道虚拟机的特性及调节方式。</p>
<p>java语言 + java虚拟机 + java类库 = jdk（支持java程序开发的最小环境）<br>java类库中java se api + java虚拟机 = jre（java程序运行的标准环境）</p>
<p>1991年 james gosling 目标开发一种在电子产品上运行的程序架构。1995年改名为java，口号：write once， run anywhere。<br>1998年sun将java体系分为三个方向：面向桌面应用开发的j2se，面向企业级开发的j2ee，面向手机等移动终端开发的j2me。<br>2006年sun将java开源，建立openjdk组织进行管理源码，2009年oracle收购sun。<br>2013年java8发布，有lambda表达式（拥有函数式表达能力）、移除hotspot的永久代。<br>2018年oracle放弃java，所有权直接赠送给eclipse基金会。redhat（ibm的）负责了jdk历史版本的维护。</p>
<p>为什么喜欢用java8？<br>java8是一个功能强大的版本，新特性例如lambda表达式、stream api、新的日期/时间api，这些可以提高开发效率。其次，java8可以兼容早期的java版本，提高开发效率。基于可维护的考量，java8可以保证程序的可维护性。</p>
<h4 id="2-java虚拟机家族"><a href="#2-java虚拟机家族" class="headerlink" title="2.java虚拟机家族"></a>2.java虚拟机家族</h4><p>1996年，sun发布的jdk1.0中携带的虚拟机：Classic VM，只能使用纯解释器方式来执行，需要外挂编译器。Exact VM：热点探测、准确内存管理，摒弃掉Classic VM中基于句柄的对象查找方式。</p>
<p>HotSpot是Sun/Oracle JDK和OpenJDK中的默认java虚拟机。开始由小公司研发，热点代码探测技术、即时编译。2014年JDK 8 中移除了永久带。</p>
<p>BEA JRockit 专注于服务器硬件和服务端应用，不关心启动速度，里面不包含解释器。</p>
<p>IBM J9 VM。</p>
<p>Apache Harmony 没有大规模商用，但是他的许多java类库被吸纳。</p>
<h4 id="3-展望java的技术"><a href="#3-展望java的技术" class="headerlink" title="3.展望java的技术"></a>3.展望java的技术</h4><p>java：庞大的用户群和及其成熟的软件生态。</p>
<p>在hotspot基础上增强而成的跨语言全栈虚拟机：Graal VM，可以作为任何语言的运行平台使用。原理是用解释器来解释中间代码。（无语言倾向）</p>
<p>即时编译器：Graal编译器，代替C2。已经在java10中引入，不过要改参数来启用。</p>
<p>跑个helloworld也需要百兆的JRE，在近几年大型单体应用架构向小型微服务应用架构发展的技术潮流下，java不适应。在微服务架构视角下，应用拆分，高可用的服务集群，不需要单个服务不间断运行。但是java启动时间长，需要预热才能达到最高性能，有悖于微服务场景。所以发展提前编译。</p>
<p>hotspot虚拟机拥有了组合拆分功能的特性，源码中是接口与实现的分离。开放了编译器接口，重构了java虚拟机的垃圾回收器接口。</p>
<p>语言特性和语法糖：协程、不可变类型、JNI调用本地代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/22/myblog/spring/springboot%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/22/myblog/spring/springboot%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">springboot学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-22 18:37:23" itemprop="dateCreated datePublished" datetime="2022-12-22T18:37:23+08:00">2022-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 15:40:41" itemprop="dateModified" datetime="2023-08-20T15:40:41+08:00">2023-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="springboot创建工程"><a href="#springboot创建工程" class="headerlink" title="springboot创建工程"></a>springboot创建工程</h2><p>微服务体系下不可或缺。<br>ssm(spring+springMvc+mybatis) -&gt; springboot -&gt; springcloud</p>
<p>springboot：约定优于配置，不用专注于配置。2014年发布。</p>
<p>springboot的位置：是spring的顶级项目，和springFramework(ioc、aop)是同等级的。</p>
<p>springboot使用最小配置快速构建spring项目。springboot不是spring功能上的增强，而是提供一种快速开发spring项目的方式。</p>
<p>spring缺点：<br>&lt;1&gt; 写配置文件，繁琐<br>&lt;2&gt; 依赖繁琐，maven坐标版本问题</p>
<p>springboot提供的优点：<br>&lt;1&gt; 自动配置，应用程序启动时的过程<br>&lt;2&gt; 起步依赖，坐标pom打包到一起，对其他库的依赖传递<br>&lt;3&gt; 其他：嵌入式服务器，安全，健康检测</p>
<hr>
<p>✅ 用springboot搭建一个web项目：<br>&lt;1&gt; 创建maven项目<br>&lt;2&gt; 引入起步依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--springboot工程需要继承的父工程   --&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--  web开发的起步依赖  --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>&lt;3&gt; 写一个controller</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-12-22 23:28</span><br><span class="line"> **/</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/h&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;4&gt; 写引导类，springboot项目入口，然后运行main方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-12-22 23:38</span><br><span class="line"> **/</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(StartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>✅ 快速构建</p>
<p>用idea，选Spring Initializr，选maven project，选jar打包方式，勾选依赖。</p>
<h2 id="springboot起步依赖"><a href="#springboot起步依赖" class="headerlink" title="springboot起步依赖"></a>springboot起步依赖</h2><p>spring-boot-starter-parent，往里看源码，最终是spring-boot-dependency包，其中pom文件中<code>&lt;dependencyManagement&gt;</code> 是版本锁定，父工程中定义的版本信息，自己工程中就可以不写版本号。</p>
<p>spring-boot-starter-web，往里看，发现引入了spring-web、spring-webmvc。</p>
<p>总结：<br>1.在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。<br>2.在各种starter中，定义了完成该功能的坐标合集，其中大部分版本信息来自于父工程。<br>3.我们工程继承自parent，引入starter，通过依赖传递，就可以简单方便获取需要的jar包，并且不会存在版本冲突问题。</p>
<h2 id="springboot配置"><a href="#springboot配置" class="headerlink" title="springboot配置"></a>springboot配置</h2><p>配置文件分类：properties文件、yaml/yml文件。<br>profile文件，三种环境动态切换。</p>
<p>springboot基于约定，配置有默认值，替换的话，用application.properties/application.yml文件来配置。resource根目录下，application.properties/yml/yaml 文件里面放程序自动识别的内容，也可以写自己定义的内容。</p>
<p>同一级目录下，配置文件的加载顺序：properties &gt; yml &gt; yaml</p>
<p>yaml：不是一个标记语言，是直观的能被电脑识别的数据序列化格式，以数据为核心，比xml更加简洁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xml:</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line"></span><br><span class="line">yml:</span><br><span class="line">server:</span><br><span class="line">    port: 8080</span><br><span class="line"></span><br><span class="line">properties:</span><br><span class="line">server.port=8080</span><br></pre></td></tr></table></figure>

<p>yaml语法：大小写敏感、数据值前必须有空格（至少一个）、缩进表示层级关系，缩进空格个数不重要，但要左对齐、#注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line"></span><br><span class="line">person:</span><br><span class="line">  name: liu</span><br><span class="line">  address: [beijing, shanghai]</span><br><span class="line"></span><br><span class="line">msg1: &quot;hello \n world&quot;  #双引号识别转义字符</span><br><span class="line">msg2: &#x27;hello \n world&#x27;  #单引号原样输出</span><br><span class="line"></span><br><span class="line">参数引用：$&#123;name&#125;</span><br></pre></td></tr></table></figure>


<p>读取配置文件内容：</p>
<p>1.@Value方法，单个属性注入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;person.name&#125;&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;person.address[0]&#125;&quot;)</span><br><span class="line">private String address;</span><br></pre></td></tr></table></figure>

<p>2.Environment</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Environment env;    </span><br><span class="line"></span><br><span class="line">env.getProperty(&quot;person.name&quot;)</span><br></pre></td></tr></table></figure>

<p>3.@ConfigurationProperties，对象和配置的绑定</p>
<p>在实体类Person上加注解 <code>@ConfigurationProperties(prefix=&quot;person&quot;)</code></p>
<hr>
<p>profile：一套程序通常需要部署在不同的环境下，开发测试生产，如果每次打包都要修改配置文件，麻烦，profile提供进行动态配置切换的方式。</p>
<p>配置方式：<br>1.多profile文件方式：提供多个配置文件，每个代表一个环境<br>application-dev.properties/yml<br>application-test.properties/yml<br>application-pro.properties/yml</p>
<p>2.yml单文件方式<br>用—分割不同环境配置</p>
<p>激活方式：<br>1.配置方式：<br><code>spring.profiles.active=dev</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    profiles:</span><br><span class="line">        active: dev</span><br></pre></td></tr></table></figure>

<p>2.虚拟机参数<br>在VM option中输入：<code>-Dspring.profiles.active=test</code></p>
<p>3.命令行参数<br>先package打包<br><code>java -jar ...jar --spring.profiles.active=test</code></p>
<hr>
<p>打包过程中，遇到：jar中没有主清单属性</p>
<p>原因：打包后的jar文件中的MANIFEST.MF缺少项目启动项，即没有Main-Class</p>
<p>解决方案：<br>1、指定MANIFEST.MF路径<br>项目打包前：<br>第一步 file–&gt;project structure 弹框后选中Atifacts—&gt; + —-&gt;jar—-&gt;from module with dependenceis<br>第二步 选择一个Main Class，选的StartApplication文件</p>
<p>2、项目pom.xml文件中添加插件spring-boot-maven-plugin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>内部配置加载顺序：</p>
<p>1.项目根目录下的config文件夹下<br>2.项目根目录（idea点project files的根目录）下<br>3.classPath（resource目录下）的config文件夹下<br>4.classPath（resource目录下）下</p>
<p>前两个不会打进jar包里</p>
<hr>
<p>外部配置加载顺序：</p>
<p>1.命令行指定端口号：<code>java -jar spring-boot-study-api-1.0-SNAPSHOT.jar --server.port=8086</code><br>指定默认前缀路径：<code>--server.servlet.context-path=/default</code><br>2.指定外部配置文件路径：<code>--spring.config.location=路径</code><br>3.在jar包同目录下（target文件夹下），加一个配置文件<code>application.properties</code>，同样生效，外部配置优先生效</p>
<h2 id="springboot整合其他框架"><a href="#springboot整合其他框架" class="headerlink" title="springboot整合其他框架"></a>springboot整合其他框架</h2><h3 id="springboot整合Junit"><a href="#springboot整合Junit" class="headerlink" title="springboot整合Junit"></a>springboot整合Junit</h3><p>1.引入spring-boot-starter-test 起步依赖<br>2.在测试类上加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class) //springboot2不用加</span><br><span class="line">@SpringBootTest(classes = StartApplication.class) //如果与StartApplication在一个包下，可以不加括号里的</span><br></pre></td></tr></table></figure>


<h3 id="springboot整合redis"><a href="#springboot整合redis" class="headerlink" title="springboot整合redis"></a>springboot整合redis</h3><p>1.引入spring-boot-starter-data-redis依赖<br>2.连接本地的redis，不需要任何配置<br>3.直接用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;liu&quot;);</span><br><span class="line">Object o = redisTemplate.boundValueOps(&quot;name&quot;).get();</span><br></pre></td></tr></table></figure>
<p>4.其他ip的，需要配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br></pre></td></tr></table></figure>


<h3 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h3><p>1.引入mybatis起步依赖 <code>mybatis-spring-boot-starter</code> （不同于其他，这个是mybatis提供的，用3.0.1的有点问题，改用2.1.0），添加mysql驱动 <code>mysql-connector-java</code><br>2.配置datasource和mybatis</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:///test?serverTimezone=UTC</span><br><span class="line">    #db.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    username: liuxuan</span><br><span class="line">    password: jade</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>3.创建表，并编写实体类<br>4.纯注解开发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from student&quot;)</span><br><span class="line">    public List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 .xml映射文件形式开发<br>Mapper接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface StudentXmlMapper &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.liuxuan.repository.mapper.StudentXmlMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.liuxuan.repository.domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>增加mybatis配置(不在spring下)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  # Mapper映射文件路径</span><br><span class="line">  mapper-locations: classpath:mapper/*Mapper.xml</span><br><span class="line">  # 包扫描</span><br><span class="line">  type-aliases-package: com.liuxuan.repository.domain</span><br></pre></td></tr></table></figure>


<h2 id="springboot原理分析"><a href="#springboot原理分析" class="headerlink" title="springboot原理分析"></a>springboot原理分析</h2><h3 id="springboot自动配置"><a href="#springboot自动配置" class="headerlink" title="springboot自动配置"></a>springboot自动配置</h3><p>Condition是spring4.0增加的条件判断功能，可以实现选择性地创建Bean操作。</p>
<h4 id="✅需求1-创建bean增加条件"><a href="#✅需求1-创建bean增加条件" class="headerlink" title="✅需求1:创建bean增加条件"></a>✅需求1:创建bean增加条件</h4><p>1.自定义条件类，继承Condition接口，实现matches方法，方法中进行逻辑判断，参数context可以获取上下文容器等，metadata可以获取注解属性。<br>2.判断条件，初始化bean时使用@Conditional(条件类.class)注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">需要加注解@Conditional：</span><br><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @Conditional(ClassCondition.class)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">自己定义一个实现了Condition接口的类，里面实现条件判断matches方法：</span><br><span class="line">public class ClassCondition implements Condition &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 写创建bean的条件：导入jedis坐标后创建bean</span><br><span class="line">        try &#123;</span><br><span class="line">            Class cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获取bean：</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 启动springboot应用，获取spring的ioc容器</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 获取bean</span><br><span class="line">        Object user = context.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="✅需求2-用自定义注解实现动态Condition"><a href="#✅需求2-用自定义注解实现动态Condition" class="headerlink" title="✅需求2:用自定义注解实现动态Condition"></a>✅需求2:用自定义注解实现动态Condition</h4><p>定义自定义注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Conditional(ClassCondition.class)</span><br><span class="line">public @interface ConditionOnClass &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Config中加注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">//    @Conditional(ClassCondition.class)</span><br><span class="line">    @ConditionOnClass(&quot;redis.clients.jedis.Jedis&quot;)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承Condition接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ClassCondition implements Condition &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param context  上下文对象。用于获取环境、Ioc容器、classLoader对象</span><br><span class="line">     * @param metadata 注解元对象，可以用于获取注解定义的属性值</span><br><span class="line">     * @return boolean</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 需求1：写创建bean的条件：导入jedis坐标后创建bean</span><br><span class="line">//        try &#123;</span><br><span class="line">//            Class cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);</span><br><span class="line">//        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">//            return false;</span><br><span class="line">//        &#125;</span><br><span class="line">//        return true;</span><br><span class="line"></span><br><span class="line">        // 需求2：通过注解属性值value指定坐标后创建bean</span><br><span class="line">        Map&lt;String, Object&gt; map = metadata.getAnnotationAttributes(ConditionOnClass.class.getName());</span><br><span class="line">        String[] value = (String[])map.get(&quot;value&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            for (String className : value) &#123;</span><br><span class="line">                Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看包spring-boot-anto-configuration中，springboot已经定义好了很多condition注解，例如：@ConditionalOnClass。</p>
<hr>
<h4 id="✅切换内置服务器"><a href="#✅切换内置服务器" class="headerlink" title="✅切换内置服务器"></a>✅切换内置服务器</h4><p>spring-boot-starter-web</p>
<p>spring-boot-autoconfiguration 包的web的embedded中内置了四种服务器，包括jetty、netty、tomcat、undertom。</p>
<p>里面还有个类负责选择web服务器，原理也是用了@ConditionalOnClass注解，看导入了什么坐标来选择服务器。</p>
<p>用<exclusions> 把spring-boot-starter-web 中的 spring-boot-starter-tomcat 排除掉。再引入jetty的依赖，就会切换为jetty服务器。</exclusions></p>
<hr>
<h4 id="✅-Enable-注解"><a href="#✅-Enable-注解" class="headerlink" title="✅ @Enable*注解"></a>✅ @Enable*注解</h4><p>SpringBoot提供了很多@Enable开头的注解，用于动态启动某些功能(获取一些bean)，其底层原理是使用@Import注解导入一些配置类，实现Bean的动态加载。</p>
<p>看注解 @SpringBootApplication</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration --内部@Configuration可配置bean</span><br><span class="line">@EnableAutoConfiguration --重点</span><br><span class="line">@ComponentScan(   --包扫描</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication</span><br><span class="line"></span><br><span class="line">其中Enable注解下：</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">重要的是Import注解</span><br></pre></td></tr></table></figure>

<p>⚠️启动子模块的启动类，无法启动父工程的controller。</p>
<p>springboot工程不可以直接获取其他jar包中定义的bean，比如redisTemplate。</p>
<p>原因：@ComponentScan 包扫描的范围是：当前引导类所在包及其子包，其他项目配置Bean的包不在该范围内。</p>
<p>尝试：另外创建一个子模块，子模块引入另一个子模块的pom，然后尝试获取另一个子模块的bean。<br>报错：NoSuchBeanDefinitionException。</p>
<p>如何获取Bean：<br>1.在启动类上加@ComponentScan注解，扫描要引入Bean的包。<br>缺点：要写包太累赘<br>2.使用@Import注解加载要导入bean的配置类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Import &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value中的这些类会被spring创建并放入IOC容器中。<br>缺点：要记类的名字<br>3.对Import注解进行封装<br>自定义一个Enable注解，把Import注解封装进去，要想用这个bean的时候，直接用Enable注解就可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(UserConfig.class)</span><br><span class="line">public @interface EnableUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) //排除此类的AutoConfig</span><br><span class="line">//@ComponentScan(&quot;com.liuxuan.condition&quot;)</span><br><span class="line">//@Import(UserConfig.class)</span><br><span class="line">@EnableUser</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 启动springboot应用，获取spring的ioc容器</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 获取bean</span><br><span class="line">        Object user = context.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>😊<code>@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;)</code></p>
<p>exclude，排除此类的AutoConfig，即禁止 SpringBoot 自动注入数据源配置。</p>
<p>DataSourceAutoConfiguration.class 会自动查找 application.yml 或者 properties 文件里的 spring.datasource.* 相关属性并自动配置单数据源「注意这里提到的单数据源」。</p>
<p>那么问题来了，排除了自动配置，Spring还怎么识别到数据库配置呢？</p>
<p>答：显然接下来就需要手动配置，如果你发现项目中存在这个排除的操作，可以在项目中搜一下Java关键字@ConfigurationProperties(“spring.datasource)，你可能会发现手动配置数据源的类。</p>
<p>再来回答为何要手动配置数据源，因为要配置多数据源，上边有提到DataSourceAutoConfiguration.class默认会帮我们自动配置单数据源，所以，如果想在项目中使用多数据源就需要排除它，手动指定多数据源。</p>
<p>@SpringBootApplication注解中exclude参数使用及原理:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_20150804/article/details/116104742">https://blog.csdn.net/csdn_20150804/article/details/116104742</a></p>
<h4 id="✅-Import注解"><a href="#✅-Import注解" class="headerlink" title="✅ @Import注解"></a>✅ @Import注解</h4><p>@Enable*底层依赖@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中，@Import提供四种用法：</p>
<p>1.导入Bean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StartApplication上：</span><br><span class="line">@Import(User.class)</span><br><span class="line"></span><br><span class="line">StartApplication中：</span><br><span class="line">// 根据类型获取bean</span><br><span class="line">Object user = context.getBean(User.class);</span><br><span class="line">System.out.println(user);</span><br><span class="line">// 获取bean名称</span><br><span class="line">Map&lt;String, User&gt; map = context.getBeansOfType(User.class);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<p>2.导入配置类<br>这种方式，配置类上的@Configuration注解可以不加</p>
<p>3.导入ImportSelect实现类。一般用于加载配置文件中的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Import(MyImportSelector.class)</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class MyImportSelector implements ImportSelector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        return new String[]&#123;&quot;com.liuxuan.condition.User&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.导入ImportBeanDefinitionRegistrar实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Import(MyImportBeanDefinitionRegistrar.class)</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(User.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(&quot;beanName&quot;, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="✅-EnableAutoConfiguration注解"><a href="#✅-EnableAutoConfiguration注解" class="headerlink" title="✅@EnableAutoConfiguration注解"></a>✅@EnableAutoConfiguration注解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@EnableAutoConfiguration</span><br><span class="line"></span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line"></span><br><span class="line">AutoConfigurationImportSelector中：</span><br><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return NO_IMPORTS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">核心代码：getAutoConfigurationEntry</span><br><span class="line">List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"></span><br><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">意思是：从spring-boot-autoconfiguration的jar包下面的META-INF/spring.factories文件中加载。</span><br><span class="line">看到这个文件中可以看到：</span><br><span class="line"> # Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">有很多配置文件类</span><br></pre></td></tr></table></figure>

<p>总结：<br>@EnableAutoConfiguration 如何实现自动配置<br>1.@EnableAutoConfiguration注解内部使用@Import({AutoConfigurationImportSelector.class}) 来加载配置类<br>2.配置文件位置：META-INF/spring.factories，该配置文件中定义了大量的配置类，当springboot应用启动时，会自动加载这些配置类，初始化bean<br>3.并不是所有的bean都会被初始化，在配置类中使用Condition来加载满足条件的bean</p>
<h4 id="✅自定义starter实现"><a href="#✅自定义starter实现" class="headerlink" title="✅自定义starter实现"></a>✅自定义starter实现</h4><p>看mybatis-spring-boot-starter如何实现：<br>1.看到mybatis-spring-boot-starter包下没什么，只有一个pom文件，里面引入mybatis-spring-boot-autoconfigure包<br>2.mybatis-spring-boot-autoconfigure包的META-INF/spring.factories文件中定义了MybatisAutoConfiguration<br>3.@EnableAutoConfiguration会自动识别到META-INF/spring.factories文件，从而识别到MybatisAutoConfiguration，模块中初始化的bean就创建出来</p>
<p>需求：自定义redis-starter，当导入redis-starter坐标时，springboot自动创建jedis的bean。</p>
<p>1.创建一个redis-autoconfiguration模块，在里面提供jedis的bean，并实现自动配置。</p>
<p>⚠️亲测，一个模块的配置了8082端口，另一个模块没配置端口，但是运行该模块的StartApplication，要用的是8082端口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RedisAutoConfiguration.class:</span><br><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class) //RedisProperties被spring识别，创建bean</span><br><span class="line">@ConditionalOnClass(Jedis.class)  //疑问：没有Jedis坐标则不配置，创建之前不是没这个Bean吗？导入坐标和有bean的关系？</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(name = &quot;jedis&quot;)  //已经定义了就不定义</span><br><span class="line">    public Jedis getJedisBean(RedisProperties redisProperties) &#123;</span><br><span class="line">        System.out.println(&quot;RedisAutoConfiguration...&quot;);</span><br><span class="line">        return new Jedis(redisProperties.getIp(), redisProperties.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RedisProperties.class:</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ConfigurationProperties(prefix = &quot;redis&quot;) //与配置文件中对应</span><br><span class="line">public class RedisProperties &#123;</span><br><span class="line">    private String ip = &quot;localhost&quot;; //没提供时给默认值</span><br><span class="line">    private Integer port = 6379;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建META-INF/spring.factories文件，其中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">    com.liuxuan.redis.configuration.RedisAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>3.创建redis-starter模块，pom文件中引入redis-configuration依赖。</p>
<p>4.在另一个模块中，pom文件中引入redis-starter依赖。在StartApplication中尝试获取bean。这个模块中导入了Jedis依赖，但是并没有Jedis的bean的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line">Jedis jedis = context.getBean(Jedis.class);</span><br><span class="line">System.out.println(jedis);</span><br><span class="line"></span><br><span class="line">jedis.set(&quot;hello&quot;, &quot;hi&quot;);</span><br><span class="line">System.out.println(jedis.get(&quot;hello&quot;));</span><br></pre></td></tr></table></figure>

<p>5.可以在使用的模块中进行配置redis的ip和host</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis.port=6379</span><br><span class="line">redis.ip=localhost</span><br></pre></td></tr></table></figure>

<p>总结：StartApplication上的@SpringBootApplication注解中的@EnableAutoConfiguration中的@Import({AutoConfigurationImportSelector.class})中会自动去找jar包中的META-INF/spring.factories文件，识别到需要加载的配置类，再获取配置类创建的bean，从而实现自动配置bean。</p>
<p>看spring-boot-autoconfiguration包下的data下的redis下的文件中，就定义了RedisAutoConfiguration，和上面实现类似。</p>
<h3 id="springboot监听机制"><a href="#springboot监听机制" class="headerlink" title="springboot监听机制"></a>springboot监听机制</h3><p>springboot的监听机制，其实是对java提供的事件监听机制的封装。</p>
<p>java中的事件监听机制定义了以下几个角色：<br>1.事件：Event，继承java.util.EventObject类的对象<br>2.事件源：Source，任意对象Object<br>3.监听器：Listener，实现java.util.EventListener接口的对象</p>
<p>springboot不需要这么麻烦，springboot在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作。</p>
<p>ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner</p>
<p>1 .继承这些接口，重写方法，并打印对应操作，@Component注册bean。</p>
<p>2 .启动发现只有后两个有打印。<br>CommandLineRunner、ApplicationRunner在项目启动后执行run方法，可以帮助做一些事情，比如：缓存预热(提前把数据库的数据加到缓存)<br>打印这两个方法的args，发现是空数组，在配置中的environment中的program arguments中添加hello world，就会返回[hello, world]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyCommandLineRunner implements CommandLineRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyCommandLineRunner run...&quot;);</span><br><span class="line">        System.out.println(&quot;MyCommandLineRunner args:&quot; + Arrays.asList(args));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyApplicationRunner implements ApplicationRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner run...&quot;);</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner args:&quot; + Arrays.asList(args.getSourceArgs()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3 .其他两个监听器怎么用：在META-INF/spring.factories（固定的写法，工程启动时会被自动扫描到）中配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">  com.liuxuan.listener.MyApplicationContextInitializer</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">  com.liuxuan.listener.MySpringApplicationRunListener</span><br></pre></td></tr></table></figure>

<p>MyApplicationContextInitializer的initialize方法：项目还没有准备ioc容器之前，可以检测一些资源是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyApplicationContextInitializer implements ApplicationContextInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void initialize(ConfigurableApplicationContext applicationContext) &#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationContextInitializer project start..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>MySpringApplicationRunListener 报错：<code>java.lang.NoSuchMethodException: com.liuxuan.listener.MySpringApplicationRunListener.&lt;init&gt;(org.springframework.boot.SpringApplication, [Ljava.lang.String;)</code><br>表示需要一个构造方法。<br>看一下代码中提供的一个实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//入参SpringApplication表示项目启动时的事件源</span><br><span class="line">public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123;</span><br><span class="line">    private final SpringApplication application;</span><br><span class="line">    private final String[] args;</span><br><span class="line">    private final SimpleApplicationEventMulticaster initialMulticaster;</span><br><span class="line"></span><br><span class="line">    public EventPublishingRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">        this.application = application;</span><br><span class="line">        this.args = args;</span><br><span class="line">        this.initialMulticaster = new SimpleApplicationEventMulticaster();</span><br><span class="line">        Iterator var3 = application.getListeners().iterator();</span><br><span class="line"></span><br><span class="line">        while(var3.hasNext()) &#123;</span><br><span class="line">            ApplicationListener&lt;?&gt; listener = (ApplicationListener)var3.next();</span><br><span class="line">            this.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，加一个构造方法，并把@Component去掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class MySpringApplicationRunListener implements SpringApplicationRunListener &#123;</span><br><span class="line"></span><br><span class="line">    public MySpringApplicationRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void starting(ConfigurableBootstrapContext bootstrapContext) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 环境对象开始准备中(还不能获取配置信息)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 上下文对象开始准备(还没加载ioc容器)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 上下文对象开始加载(创建springboot启动的bean)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context, Duration timeTaken) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 加载完成...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void ready(ConfigurableApplicationContext context, Duration timeTaken) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动完成开始运行...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动失败...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看spring-boot包下的context下的event包下的一些定义好的事件Event，往里看都是继承自java的util包下的EventObject的。所以说springboot的事件监听是对java事件监听的封装。</p>
<h3 id="springboot启动流程"><a href="#springboot启动流程" class="headerlink" title="springboot启动流程"></a>springboot启动流程</h3><p>观察者模式：观察者和被观察者，被观察者：事件和事件源，观察者：监听器。</p>
<h4 id="✅初始化"><a href="#✅初始化" class="headerlink" title="✅初始化"></a>✅初始化</h4><p>debug一下启动类StartApplication中的<code>SpringApplication.run</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;</span><br><span class="line">    return (new SpringApplication(primarySources)).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个SpringApplication对象（事件源对象）。</p>
<p>SpringApplication构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    this.sources = new LinkedHashSet();</span><br><span class="line">    this.bannerMode = Mode.CONSOLE;</span><br><span class="line">    this.logStartupInfo = true;</span><br><span class="line">    this.addCommandLineProperties = true;</span><br><span class="line">    this.addConversionService = true;</span><br><span class="line">    this.headless = true;</span><br><span class="line">    this.registerShutdownHook = true;</span><br><span class="line">    this.additionalProfiles = Collections.emptySet();</span><br><span class="line">    this.isCustomEnvironment = false;</span><br><span class="line">    this.lazyInitialization = false;</span><br><span class="line">    this.applicationContextFactory = ApplicationContextFactory.DEFAULT;</span><br><span class="line">    this.applicationStartup = ApplicationStartup.DEFAULT;</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));  //有没有主类</span><br><span class="line">    this.webApplicationType = WebApplicationType.deduceFromClasspath();   //是否是web环境</span><br><span class="line">    this.bootstrapRegistryInitializers = new ArrayList(this.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line">    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));  //从springfactory文件中加载initializers</span><br><span class="line">    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));  //从springfactory配置文件中加载listener（放到set集合中）</span><br><span class="line">    this.mainApplicationClass = this.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/springboot%E5%90%AF%E5%8A%A8.png"></p>
<h4 id="✅run方法"><a href="#✅run方法" class="headerlink" title="✅run方法"></a>✅run方法</h4><p>StartApplication的run方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    long startTime = System.nanoTime();  //监控耗时，也可以用StopWatch</span><br><span class="line">    DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();</span><br><span class="line">    ConfigurableApplicationContext context = null;  //定一个容器</span><br><span class="line">    this.configureHeadlessProperty();  //加载东西</span><br><span class="line">    SpringApplicationRunListeners listeners = this.getRunListeners(args);  //获取RunListener</span><br><span class="line">    listeners.starting(bootstrapContext, this.mainApplicationClass);  //调用runListener的starting方法</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);  //准备环境，回调runListener的prepareEnvironment方法，环境对象Environment就有信息了</span><br><span class="line">        this.configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = this.printBanner(environment);  //打印spring图标，可以替换banner.txt</span><br><span class="line">        context = this.createApplicationContext();  //创建ioc容器</span><br><span class="line">        context.setApplicationStartup(this.applicationStartup);</span><br><span class="line">        this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);  //加载ioc容器</span><br><span class="line">        // 可以看context里的beanFactory里的beanDefinitionMap，里面是真正的bean，这时还没加载bean</span><br><span class="line">        this.refreshContext(context);  //这里从配置文件里找，创建bean（耗时操作）</span><br><span class="line">        this.afterRefresh(context, applicationArguments);</span><br><span class="line">        Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        if (this.logStartupInfo) &#123;</span><br><span class="line">            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), timeTakenToStartup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.started(context, timeTakenToStartup);  //项目启动成功，加载成功</span><br><span class="line">        this.callRunners(context, applicationArguments);  //commandLineRunner和applicationRunner 回调执行</span><br><span class="line">    &#125; catch (Throwable var12) &#123;</span><br><span class="line">        this.handleRunFailure(context, var12, listeners);</span><br><span class="line">        throw new IllegalStateException(var12);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        listeners.ready(context, timeTakenToReady);</span><br><span class="line">        return context;</span><br><span class="line">    &#125; catch (Throwable var11) &#123;</span><br><span class="line">        this.handleRunFailure(context, var11, (SpringApplicationRunListeners)null);</span><br><span class="line">        throw new IllegalStateException(var11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>以上，通过debug源码的方式，探索了springboot启动流程，看了监听器方法在哪里执行回调。</p>
<h2 id="springboot监控"><a href="#springboot监控" class="headerlink" title="springboot监控"></a>springboot监控</h2><h3 id="url方式"><a href="#url方式" class="headerlink" title="url方式"></a>url方式</h3><p>SpringBoot自带监控功能Actuator，可以帮助实现对程序内部运行情况监控，比如监控状况、Bean加载情况、配置属性 、日志信息等。</p>
<p>使用步骤</p>
<p>① 导入依赖坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>② 访问<a target="_blank" rel="noopener" href="http://localhost:8080/actuator">http://localhost:8080/actuator</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_links&quot;:&#123;</span><br><span class="line">        &quot;self&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator&quot;,</span><br><span class="line">            &quot;templated&quot;:false</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health-path&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator/health/&#123;*path&#125;&quot;,</span><br><span class="line">            &quot;templated&quot;:true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator/health&quot;,</span><br><span class="line">            &quot;templated&quot;:false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">路径	描述</span><br><span class="line">/beans	描述应用程序上下文里全部的Bean，以及它们的关系</span><br><span class="line">/env	获取全部环境属性</span><br><span class="line">/env/&#123;name&#125;	根据名称获取特定的环境属性值</span><br><span class="line">/health	报告应用程序的健康指标，这些值由HealthIndicator的实现类提供</span><br><span class="line">/info	获取应用程序的定制信息，这些信息由info打头的属性提供</span><br><span class="line">/mappings	描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系</span><br><span class="line">/metrics	报告各种应用程序度量信息，比如内存用量和HTTP请求计数</span><br><span class="line">/metrics/&#123;name&#125;	报告指定名称的应用程序度量值</span><br><span class="line">/trace	提供基本的HTTP请求跟踪信息(时间戳、HTTP头等)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">info:</span><br><span class="line">  name: hello</span><br><span class="line">  age: 23</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  #开启健康检查的完整信息</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: always</span><br><span class="line">  #将所有的监控endPoints暴漏出来</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: *</span><br></pre></td></tr></table></figure>

<h3 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h3><p>监控的可视化界面，只不过需要自己再起个监控服务。</p>
<p>Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。</p>
<p>Spring Boot Admin 有两个角色，客户端(Client)和服务端(Server)。</p>
<p>应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册</p>
<p>Spring Boot Admin Server 的UI界面将Spring Boot Admin Client的Actuator Endpoint上的一些监控信息.</p>
<p>使用步骤：</p>
<p>admin-server（监控服务）</p>
<p>① 创建 admin-server 模块</p>
<p>② 导入依赖坐标 admin-starter-server</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>③ 在引导类上启用监控功能@EnableAdminServer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableAdminServer</span><br><span class="line">public class SpringbootAdminServerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootAdminServerApplication.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>admin-client（被监控服务）</p>
<p>① 创建 admin-client 模块</p>
<p>② 导入依赖坐标 admin-starter-client</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>③ 配置相关信息：server地址等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指定admin.server地址，server在9000端口号，相当于向server注册</span><br><span class="line">spring.boot.admin.client.url=http://localhost:9000</span><br><span class="line">展示健康检查详细详细展示出来</span><br><span class="line">management.endpoint.health.show-details=always</span><br><span class="line">开启所有配置</span><br><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure>

<p>④ 启动server和client服务，访问server<br><a target="_blank" rel="noopener" href="http://localhost:9000/applications">http://localhost:9000/applications</a></p>
<hr>
<p>出现问题：<br>Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured.</p>
<p>原因：当前项目没有配置DataSource相关配置。springboot自动配置时，检测到添加了mysql的依赖包，但是配置文件中却没添加数据库的相关配置。<br>该案例中：mysql依赖在父pom中引入，该子工程不用mysql。</p>
<p>解决办法：@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) 排除自动注入数据库配置</p>
<hr>
<p>不知道是不是包的版本不对，有的版本报错，有的版本运行了却没显示。<br>idea中点EndPoins就可以图形化界面的方式来监控，不用那么麻烦，</p>
<h2 id="springboot项目部署"><a href="#springboot项目部署" class="headerlink" title="springboot项目部署"></a>springboot项目部署</h2><p>SpringBoot 项目开发完毕后，支持两种方式部署到服务器：</p>
<p>① jar包(官方推荐) 用内置的tomcat启动</p>
<p>② war包</p>
<h3 id="jar打包方式"><a href="#jar打包方式" class="headerlink" title="jar打包方式"></a>jar打包方式</h3><p>将当前模块打包：idea右边maven中选择要打包的模块，点lifecycle，点package。</p>
<p>打好的jar包在项目的target目录下。直接<code>java -jar .\jar包名称</code>，启动成功。</p>
<h3 id="war打包方式"><a href="#war打包方式" class="headerlink" title="war打包方式"></a>war打包方式</h3><p>pom.xml里更改打包方式：<code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>如果想改war包的名字：<code>&lt;finalName&gt;</code>标签</p>
<p>在引导类继承SpringBootServletInitializer类，并重写configure方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootDeployApplication extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootDeployApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">        return builder.sources(SpringBootDeployApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，打好的war包可以被外部tomcat识别，将其放在tomcat目录下的webapps目录下，启动tomcat即可（startup.bat），浏览器访问需要加项目的包名称，因为WEB-INF文件在其之下。并且，内置项目的端口号配置就不生效了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/22/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/sqlite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/22/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/sqlite/" class="post-title-link" itemprop="url">sqlite</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-22 11:49:15" itemprop="dateCreated datePublished" datetime="2022-12-22T11:49:15+08:00">2022-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-05 12:19:43" itemprop="dateModified" datetime="2023-02-05T12:19:43+08:00">2023-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是sqlite"><a href="#什么是sqlite" class="headerlink" title="什么是sqlite"></a>什么是sqlite</h2><p>SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 SQL 数据库引擎。</p>
<p>它是一个零配置的数据库，这意味着与其他数据库不一样，您不需要在系统中配置。</p>
<hr>
<p>sqlite的优点：</p>
<p>&lt;1&gt; 不需要一个单独的服务器进程或操作的系统（无服务器的）<br>&lt;2&gt; SQLite 不需要配置，这意味着不需要安装或管理。<br>&lt;3&gt; 一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。<br>&lt;4&gt; SQLite 是非常小的，是轻量级的，完全配置时小于 400KB<br>&lt;5&gt; SQLite 是自给自足的，这意味着不需要任何外部的依赖。<br>&lt;6&gt; SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。</p>
<h2 id="安装sqlite"><a href="#安装sqlite" class="headerlink" title="安装sqlite"></a>安装sqlite</h2><p>linux和macOS，基本都系统预装了。<br>输入<code>sqlite3</code>检查是否安装。</p>
<p>如果未安装，下载网址：<a target="_blank" rel="noopener" href="https://www.sqlite.org/download.html">https://www.sqlite.org/download.html</a><br>下载<code>sqlite-autoconf-*.tar.gz。</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tar xvzf sqlite-autoconf-3071502.tar.gz</span><br><span class="line">$ cd sqlite-autoconf-3071502</span><br><span class="line">$ ./configure --prefix=/usr/local</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<h2 id="sqlite命令"><a href="#sqlite命令" class="headerlink" title="sqlite命令"></a>sqlite命令</h2><p><code>.show </code>命名，查看 SQLite 命令提示符的默认设置。</p>
<p>更改配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt;.header on    </span><br><span class="line">sqlite&gt;.mode column</span><br><span class="line">sqlite&gt;.timer on</span><br></pre></td></tr></table></figure>

<p>创建数据库：<br><code>$ sqlite3 DatabaseName.db </code> 或 <code>sqlite&gt;.open test.db </code></p>
<p>创建的数据库文件位于 sqlite3 命令同一目录下。<br>打开已存在数据库也是用 .open 命令，以上命令如果 test.db 存在则直接会打开，不存在就创建它。</p>
<p><code>.databases</code> 展示数据库列表<br><code>.quit</code> 退出<br><code>testDB.db .dump &gt; testDB.sql</code> 导出完整的数据库到文本文件中<br><code>testDB.db &lt; testDB.sql</code> 恢复db文件</p>
<p><code>attach database file_name AS database_name;</code> 将同一文件夹下的db文件附加进来，并给个别名。<br>数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加。</p>
<p><code>detach database &#39;database_name&#39;;</code> 断开给定名称的连接，而其余的仍然有效</p>
<p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE database_name.table_name(</span><br><span class="line">   ID INT PRIMARY KEY     NOT NULL,</span><br><span class="line">   NAME           TEXT    NOT NULL,</span><br><span class="line">   AGE            INT     NOT NULL,</span><br><span class="line">   ADDRESS        CHAR(50),</span><br><span class="line">   SALARY         REAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>.tables</code> 查看创建的表</p>
<p><code>.schema tableName</code> 得到表的完整信息（建表语句）</p>
<h2 id="java使用sqlite"><a href="#java使用sqlite" class="headerlink" title="java使用sqlite"></a>java使用sqlite</h2><p>SQLite相比大多数数据库而言，具有免安装等优势，广泛应用于测试、Android等领域。通过一个.db文件就能实现数据库连接、DDL操作语句、DML命令。</p>
<p>导入<code>sqlite-jdbc</code>依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.xerial&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.40.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>软件：DB Browser for SQLite</p>
<p>sqlite没有像mysql使用comment增加字段/表名注释，使用–注释内容。</p>
<p>✅建表、插入、查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan.service;</span><br><span class="line"></span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.ToString;</span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2023-01-20 09:41</span><br><span class="line"> **/</span><br><span class="line">@Service</span><br><span class="line">public class SqliteService &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String filePath = &quot;/Users/liuxuan/Downloads/test.db&quot;;</span><br><span class="line">        Connection conn = createConnection(filePath);</span><br><span class="line">        // 创建表</span><br><span class="line">        String query = &quot;create table if not exists table_test (\n&quot; +</span><br><span class="line">                &quot;id integer PRIMARY KEY AUTOINCREMENT,\n&quot; +</span><br><span class="line">                &quot;num INTEGER(11),\n&quot; +</span><br><span class="line">                &quot;`desc` varchar(10) not null);&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            Statement stmt = conn.createStatement();</span><br><span class="line">            stmt.executeUpdate(query);</span><br><span class="line">            stmt.close();</span><br><span class="line">//            conn.commit();</span><br><span class="line">//            conn.close();</span><br><span class="line">        &#125; catch (SQLException e)&#123;</span><br><span class="line">            System.out.println(&quot;建立表存在异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 插入数据</span><br><span class="line">        String sql = &quot;insert into table_test (num, desc) &quot; +</span><br><span class="line">                &quot;values(1, &#x27;one&#x27;);&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            Statement stmt = conn.createStatement();</span><br><span class="line">            stmt.executeUpdate(sql);</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125; catch (SQLException e)&#123;</span><br><span class="line">            System.out.println(&quot;插入数据存在异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 查询数据</span><br><span class="line">        try &#123;</span><br><span class="line">            Statement stmt = conn.createStatement();</span><br><span class="line">            ResultSet rs = stmt.executeQuery( &quot;SELECT * FROM table_test;&quot; );</span><br><span class="line">            while (rs.next() ) &#123;</span><br><span class="line">                int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">                int num = rs.getInt(&quot;num&quot;);</span><br><span class="line">                String desc = rs.getString(&quot;desc&quot;);</span><br><span class="line">                System.out.println(id + &quot;,&quot; + num + &quot;,&quot; + desc);</span><br><span class="line">            &#125;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; catch (SQLException e)&#123;</span><br><span class="line">            System.out.println(&quot;查询数据存在异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 分页查询 用commons-dbutils包下的QueryRunner</span><br><span class="line">        String selectSql = &quot;select * from table_test&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;SqliteDO&gt; list = selectList(selectSql, conn, SqliteDO.class, 1, 10);</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            System.out.println(&quot;查询数据list存在异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取数据库连接</span><br><span class="line">     **/</span><br><span class="line">    public static Connection createConnection(String filePath) &#123;</span><br><span class="line">        Connection conn = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            Class.forName(&quot;org.sqlite.JDBC&quot;);</span><br><span class="line">            conn = DriverManager.getConnection(String.format(&quot;jdbc:sqlite:%s&quot;, filePath));</span><br><span class="line">        &#125;catch(ClassNotFoundException e)&#123;</span><br><span class="line">            System.out.println(&quot;不存在sqlite驱动包！&quot;);</span><br><span class="line">        &#125;catch (SQLException e)&#123;</span><br><span class="line">            System.out.println(&quot;与sqlite数据库连接失败！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; List&lt;T&gt; selectList(String sql, Connection connection, Class&lt;T&gt;objType, int currentPage, int pageSize) throws SQLException &#123;</span><br><span class="line">        sql = sql + &quot; limit ?,?&quot;;</span><br><span class="line">        QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">        List&lt;T&gt; dataList = queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(objType), pageSize * (currentPage - 1), pageSize);</span><br><span class="line">        return dataList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ToString</span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    public static class SqliteDO &#123;</span><br><span class="line">        private Integer id;</span><br><span class="line">        private Integer num;</span><br><span class="line">        private String desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅线程安全</p>
<p>sqlite是线程安全的，可以多线程插入。</p>
<p>✅sqlite在java中批量插入数据巨慢</p>
<p>开始是插入一条就构造一条insert语句，一条一条插入，慢。<br>后来改成多线程插入，还是慢。<br>再后来，一条insert语句插入1000条，快了很多。</p>
<p>一个说事务控制批量插入的：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiao-tangyuan/p/9556114.html">https://www.cnblogs.com/xiao-tangyuan/p/9556114.html</a></p>
<hr>
<p>SQLite——Java使用：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38322527/article/details/125717093">https://blog.csdn.net/qq_38322527/article/details/125717093</a></p>
<p>SQLite数据库基本使用（Java）：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44102521/article/details/119884521">https://blog.csdn.net/weixin_44102521/article/details/119884521</a></p>
<p>查询获取list：<br><a target="_blank" rel="noopener" href="https://m.runoob.com/sqlite/sqlite-java.html?ivk_sa=1024320u">https://m.runoob.com/sqlite/sqlite-java.html?ivk_sa=1024320u</a></p>
<p>sqlite没有comment：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qinxu0611/article/details/128609756">https://blog.csdn.net/qinxu0611/article/details/128609756</a></p>
<p>SQLite 线程安全和并发：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/feng9exe/p/10682567.html">https://www.cnblogs.com/feng9exe/p/10682567.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/10/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/elasticsearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/10/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/elasticsearch/" class="post-title-link" itemprop="url">elasticsearch</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-10 15:22:27" itemprop="dateCreated datePublished" datetime="2022-12-10T15:22:27+08:00">2022-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-22 11:49:00" itemprop="dateModified" datetime="2022-12-22T11:49:00+08:00">2022-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是elasticsearch"><a href="#什么是elasticsearch" class="headerlink" title="什么是elasticsearch"></a>什么是elasticsearch</h2><p>ES=elaticsearch简写， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。<br>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，通过面向文档从而让全文搜索变得简单。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45081813/article/details/113061113">https://blog.csdn.net/weixin_45081813/article/details/113061113</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/27/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/27/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-11-27 19:31:18 / Modified: 22:10:25" itemprop="dateCreated datePublished" datetime="2022-11-27T19:31:18+08:00">2022-11-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是用工厂方法代替new操作的一种模式。例如，Executors创建线程池ExecutorService的方法，就是工厂模式。</p>
<p>工厂模式在Java程序系统可以说是随处可见。因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A()，工厂模式也是用来创建实例对象。使用工厂模式创建实例对象，会给你系统带来更大的可扩展性和尽量少的修改量（降低耦合）。</p>
<h3 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h3><p>简单工厂模式不属于GOF的23种经典设计模式，相当于一种编程习惯。</p>
<p>简单工厂模式包含如下三种角色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">抽象产品：定义了产品的规范，描述了产品的主要特性和功能。（可以是接口）</span><br><span class="line">具体产品：实现或者继承抽象产品的子类。</span><br><span class="line">具体工厂：提供了创建产品的方法，使用者通过该方法来获取产品。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 在工厂方法中根据类型创建不同的具体对象</span><br><span class="line">**/</span><br><span class="line">public class SimpleCoffeeFactory &#123;</span><br><span class="line">	// 根据type判断类型，实例化并返回对应对象</span><br><span class="line">    public Coffee createCoffee(String type) &#123;</span><br><span class="line">        Coffee coffee = null;</span><br><span class="line">        if(&quot;americano&quot;.equals(type)) &#123;</span><br><span class="line">            coffee = new AmericanoCoffee();</span><br><span class="line">        &#125; else if(&quot;latte&quot;.equals(type)) &#123;</span><br><span class="line">            coffee = new LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        return coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂处理创建对象的细节，一旦有了工厂，后期如果需要对象直接从工厂中获取即可。这样也就解除了和实现类的耦合，不需要关注创建对象的细节，但同时又产生了新的耦合。后期如果再添加新的类，就必须修改工厂类的代码，违反了开闭原则。</p>
<hr>
<p>静态工厂模式：在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleCoffeeFactory &#123;</span><br><span class="line">    public static Coffee createCoffee(String type) &#123;</span><br><span class="line">        Coffee coffee = null;</span><br><span class="line">        if(&quot;americano&quot;.equals(type)) &#123;</span><br><span class="line">            coffee = new AmericanoCoffee();</span><br><span class="line">        &#125; else if(&quot;latte&quot;.equals(type)) &#123;</span><br><span class="line">            coffee = new LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        return coffe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h3><p>针对简单工厂模式的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p>
<p>工厂方法模式（FACTORY METHOD）是一种常用的类创建型设计模式,此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。它的核心结构有四个角色，分别是抽象工厂、具体工厂、抽象产品、具体产品。</p>
<p>四个角色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</span><br><span class="line">具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</span><br><span class="line">抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</span><br><span class="line">具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 抽象工厂</span><br><span class="line">**/</span><br><span class="line">public interface CoffeeFactory &#123;</span><br><span class="line">    Coffee createCoffee();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 具体工厂</span><br><span class="line">* </span><br><span class="line">* 抽象产品为coffee，具体产品为LatteCoffee和AmericanCoffee</span><br><span class="line">* 这种工厂模式可以通过不同的具体工厂创建出不同的具体产品</span><br><span class="line">**/</span><br><span class="line">public class LatteCoffeeFactory implements CoffeeFactory &#123;</span><br><span class="line">    public Coffee createCoffee() &#123;</span><br><span class="line">        return new LatteCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AmericanCoffeeFactory implements CoffeeFactory &#123;</span><br><span class="line">    public Coffee createCoffee() &#123;</span><br><span class="line">        return new AmericanCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要增加产品类时不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点，但要相应地增加工厂类。</p>
<p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p>
<p>优点：<br>在获取对象时只需要知道具体工厂的名称就可以得到对应的对象，无须知道具体创建过程；在系统增加新的类时只需要添加对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</p>
<p>缺点：<br>每增加一个类就要增加一个对应的具体工厂类，增加了系统的复杂度。</p>
<h3 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h3><p>抽象工厂模式（Abstract Factory Pattern）隶属于设计模式中的创建型模式，用于产品族的构建。抽象工厂是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂是指当有多个抽象角色时使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体情况下，创建<strong>多个产品族</strong>中的产品对象。</p>
<p>工厂模式中的每一个形态都是针对一定问题的解决方案，工厂方法针对的是多个产品系列结构；而抽象工厂模式针对的是多个产品族结构，一个产品族内有多个产品系列。</p>
<p>抽象工厂模式的主要角色如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</span><br><span class="line">具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</span><br><span class="line">抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</span><br><span class="line">具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 抽象工厂</span><br><span class="line">**/</span><br><span class="line">public interface DessertFactory &#123;</span><br><span class="line">    Coffee createCoffee();</span><br><span class="line">    Dessert createDessert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 具体工厂</span><br><span class="line">**/</span><br><span class="line">public class AmericanDessertFactory implements DessertFactory &#123;</span><br><span class="line">    public Coffee createCoffee() &#123;</span><br><span class="line">        return new AmericanCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">    public Dessert createDessert() &#123;</span><br><span class="line">        return new MatchaMousse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ItalyDessertFactory implements DessertFactory &#123;</span><br><span class="line">    public Coffee createCoffee() &#123;</span><br><span class="line">        return new LatteCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">    public Dessert createDessert() &#123;</span><br><span class="line">        return new Tiramisu();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。</p>
<p>优点：<br>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p>缺点：<br>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<h3 id="四、模式扩展（简单工厂-配置文件解除耦合）"><a href="#四、模式扩展（简单工厂-配置文件解除耦合）" class="headerlink" title="四、模式扩展（简单工厂+配置文件解除耦合）"></a>四、模式扩展（简单工厂+配置文件解除耦合）</h3><p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接获取即可。</p>
<p>创建配置文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">american=cn.com.supercoder.pattern.AmericanCoffee</span><br><span class="line">latte=cn.com.supercoder.pattern.LatteCoffee</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CoffeeFactory &#123;</span><br><span class="line">    private static Map&lt;String,Coffee&gt; map = new HashMap();</span><br><span class="line">    // 加载配置文件</span><br><span class="line">    static &#123;</span><br><span class="line">        Properties p = new Properties();</span><br><span class="line">        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            p.load(is);</span><br><span class="line">            // 遍历Properties集合对象</span><br><span class="line">            Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">            for (Object key : keys) &#123;</span><br><span class="line">                // 根据键获取值（全类名）</span><br><span class="line">                String className = p.getProperty((String) key);</span><br><span class="line">                // 获取Class对象</span><br><span class="line">                Class clazz = Class.forName(className);</span><br><span class="line">                // 实例化对象</span><br><span class="line">                Coffee obj = (Coffee) clazz.newInstance();</span><br><span class="line">                // 将对象以键值对的形式存入map</span><br><span class="line">                map.put((String)key,obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	* 获取对象时直接根据配置文件中的key获取对应的对象</span><br><span class="line">	**/</span><br><span class="line">    public static Coffee createCoffee(String name) &#123;</span><br><span class="line">        return map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45867375/article/details/124597130">https://blog.csdn.net/qq_45867375/article/details/124597130</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/05/myblog/JAVA/Page%E5%88%86%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/05/myblog/JAVA/Page%E5%88%86%E9%A1%B5/" class="post-title-link" itemprop="url">Page分页</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-05 12:55:45" itemprop="dateCreated datePublished" datetime="2022-11-05T12:55:45+08:00">2022-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-23 23:09:22" itemprop="dateModified" datetime="2023-02-23T23:09:22+08:00">2023-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h2><p>新建一个子工程web-repository。</p>
<p>mybatis依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.35&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--web-repository</span><br><span class="line"> --src</span><br><span class="line">  --main</span><br><span class="line">   --java</span><br><span class="line">     --config</span><br><span class="line">       --SpringConfig.java</span><br><span class="line">     --domain</span><br><span class="line">       --StudentDO.java</span><br><span class="line">     --StudentDao.java</span><br><span class="line">   --resource</span><br><span class="line">     --mapper</span><br><span class="line">  --test</span><br></pre></td></tr></table></figure>

<p>✅spring配置类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;org.example&quot;&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要引入spring依赖。</p>
<p>spring配置：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengyupinglan/p/14517267.html">https://www.cnblogs.com/fengyupinglan/p/14517267.html</a></p>
<p>✅spring整合mybatis</p>
<p>首先，spring配置文件可以是xml文件在resource文件夹下，也可以是注解方式的java文件。先写一个spring配置文件，自动装配搞上去。还有mybatis的一些bean要配置上去。</p>
<h3 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h3><p>xml文件方式，spring-mybatis.xml<br>开启自动扫描和配置bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描,扫描多个包用,隔开--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启Aspect生成代理对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--加载properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">ignore-unresolvable</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">location</span>=<span class="string">&#x27;classpath:dbconfig.properties&#x27;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.配置阿里druid连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置数据库基本信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.maxActive&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.配置spring的数据源，声明事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3.配置 mybatis，扫描mapper.xml文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3.1 配置 mybatis config --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3.2 配置扫描mybatis映射文件路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.类似于 jdbcTemplate 帮助类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描了所有的*Mapper.xml对应的mapper接口文件，这样就不用一个一个手动配置Mapper的映射了，只要Mapper接口类和Mapper映射文件对应起来就可以了。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.example.mysql&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>druid需要依赖包：druid<br>SqlSessionFactoryBean 需要依赖包：spring-jdbc<br>还需要 ibatis-common</p>
<p>dbconfig.properties:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">db.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">db.password=jade</span><br><span class="line">db.username=liuxuan</span><br><span class="line">db.maxActive=5</span><br><span class="line">db.initialSize=1</span><br></pre></td></tr></table></figure>

<p>mybatis配置文件，mybatis-config.xml<br>一些configuration setting</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//ybatis.org//DTD SQL Map Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;REUSE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml方式spring整合mybatis，mybatis配置项的意义：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45797116/article/details/117105095">https://blog.csdn.net/qq_45797116/article/details/117105095</a></p>
<p>xml文件中如果想引入其他xml文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;import resource=&quot;.../...xml&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>注解方式，SpringConfig.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package org.example.mysql.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;org.example&quot;&#125;)</span><br><span class="line">@ImportResource(&quot;classpath:spring-mybatis.xml&quot;) //导入xml配置项</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，可以用@Import导入其他注解方式的配置文件，以及用@ImportResource导入xml方式的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Import(CDPlayerConfig.class)  </span><br><span class="line">@ImportResource(&quot;classpath:cons-injec.xml&quot;) //导入xml配置项</span><br></pre></td></tr></table></figure>

<p>注解方式倒入配置文件：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42107384/article/details/116475637">https://blog.csdn.net/weixin_42107384/article/details/116475637</a></p>
<p>纯注解方式的整合spring和mybatis配置：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44226181/article/details/127343597">https://blog.csdn.net/weixin_44226181/article/details/127343597</a></p>
<p>还有一个一行代码的基于注解整合的：<br><a target="_blank" rel="noopener" href="https://www.pudn.com/news/62f1dcb95425817ffc22c172.html">https://www.pudn.com/news/62f1dcb95425817ffc22c172.html</a></p>
<h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">public class StudentDaoTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectById() &#123;</span><br><span class="line"></span><br><span class="line">        // xml：</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        UserMapper mapper = (UserMapper) context.getBean(&quot;userMapper&quot;);</span><br><span class="line"></span><br><span class="line">        // 注解：</span><br><span class="line">        ApplicationContext context =new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        StudentDao studentDao = (StudentDao) context.getBean(&quot;studentDao&quot;);</span><br><span class="line"></span><br><span class="line">        StudentDO studentDO = studentDao.selectById(1L);</span><br><span class="line">        System.out.println(studentDO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试验证及xml中配置SqlSessionFactory的bean和扫描的bean：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28082757/article/details/103488364">https://blog.csdn.net/qq_28082757/article/details/103488364</a></p>
<p>配置数据库连接池有几种方法，上面用的是ali的druid连接池，关于Druid连接池：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chy18883701161/p/12594889.html">https://www.cnblogs.com/chy18883701161/p/12594889.html</a></p>
<p>注解方式配置JdbcConfig中 PlatformTransactionManager 是事务管理，在spring-jdbc包下。<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/903c01cb2a77">https://www.jianshu.com/p/903c01cb2a77</a></p>
<p>@Mapper注解，难道是spring-boot才能用的？<br>mybatis支持的映射方式有基于xml的mapper.xml文件、基于java的使用Mapper接口class。<br>从mybatis3.4.0开始加入了@Mapper注解，目的就是为了不再写mapper映射文件。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46369022/article/details/122755858">https://blog.csdn.net/weixin_46369022/article/details/122755858</a><br>需要依赖包：mybatis-spring-boot-starter</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>✅ @Value里的字段报红</p>
<p>原因：自动导入了lombok里的@Value，要用的是SpringFramework下的@Value。</p>
<p>✅ xml配置文件加载不到properties属性问题</p>
<p>原因：spring中没有成功加载相应的配置文件</p>
<p>解决：进入File-Project Struccture，进入Facets中进行配置，.在右边的spring目录下，找到对应的爆红问题所在配置文件，选择xml文件，点击修改符合（下图中的小铅笔），在跳出来的弹框中，选择添加（加号），然后选择Additioonal properties files。然后找到需要加载进spring中的配置文件，点击OK，添加成功。</p>
<p>来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaogot/article/details/103224088">https://blog.csdn.net/zhaogot/article/details/103224088</a></p>
<p>✅ xml配置文件中的问题：根元素 “beans” 必须匹配 DOCTYPE 根 “null”</p>
<p>在<code>&lt;beans&gt;</code>标签那里报出来。</p>
<p>原因：mybatis在扫描Mapper.xml文件时，扫描到非mapper文件。比如本次报错扫描到了自己。spring.xml的根元素是<code>&lt;beans&gt;&lt;/beans&gt;</code>当然不会有DOCTYPE了。<br>所以当Mybatis扫描到了Spring.xml这个非Mapper.xml文件时，自然找不到DOCTYPE，所以会有“DOCTYPE 根 “null””这个错误。</p>
<p>粗心：应该扫的是mybatis-config.xml文件，结构写成了自己。</p>
<p>来自：<a target="_blank" rel="noopener" href="https://www.codeleading.com/article/7746743165/">https://www.codeleading.com/article/7746743165/</a></p>
<p>✅ org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)</p>
<p>原因：mapper接口和xml文件没匹配上，有可能是文件名方法名没匹配上，这里是在配置文件里没加扫描接口，加了就好了。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43570367/article/details/103147854">https://blog.csdn.net/weixin_43570367/article/details/103147854</a></p>
<p>✅ properties文件 java.lang.NumberFormatException</p>
<p>明明是数字类型，但是说我从String转为int发生异常。</p>
<p>需要在xml配置文件中加载properties配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载properties文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">ignore-unresolvable</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">location</span>=<span class="string">&#x27;classpath:dbconfig.properties&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring加载properties文件的几种方式：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/chuige2013/article/details/121759088">https://blog.csdn.net/chuige2013/article/details/121759088</a></p>
<p>✅ java.sql.SQLException: com.mysql.cj.jdbc.Driver</p>
<p>mysql连接驱动依赖的版本不匹配问题，一般出现在使用低版本连接驱动连接高版本mysql情况下，解决方法是在maven中央仓库中下载高版本的mysql连接驱动.</p>
<p>mysql-connector-java 换8.0.21的包，自动引入没成功，手动下载装到.m2的。</p>
<p>✅ init datasource error, url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8</p>
<p>db.url换成：<code>jdbc:mysql://localhost:3306/mysql?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</code></p>
<p>✅ Table ‘mysql.student’ doesn’t exist</p>
<p>上面mysql换成库名。</p>
<p>😄终于成功了，不容易。</p>
<h2 id="com-github-pagehelper"><a href="#com-github-pagehelper" class="headerlink" title="com.github.pagehelper"></a>com.github.pagehelper</h2><p>背景：使用Pige时，从数据库中获取到list之后，removeIf筛选，但是分页得到的效果不对，条目总数total是从数据库得到的list size。</p>
<p>原因：Page与Mybatis强耦合，不是先从数据库获取再分页，而是先获取某页要获取的条目，耦合到sql中查询。</p>
<p>难道只能是spring-boot用的？ pagehelper-spring-boot-starter 依赖包中。</p>
<p>PageHelper分页：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43958747/article/details/103822761">https://blog.csdn.net/weixin_43958747/article/details/103822761</a></p>
<p>其中有个参数为CallBack接口。</p>
<p>⚠️使用中的一个case：<br>Pageed中的list的元素得和数据库dao返回的数据结构一样，得是DO。获取了Paged之后再转为vo，因为分页Page和mybatis是强耦合的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/22/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/leeco%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/leeco%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">javaのleecode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-22 09:27:14" itemprop="dateCreated datePublished" datetime="2022-10-22T09:27:14+08:00">2022-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-29 20:58:34" itemprop="dateModified" datetime="2023-12-29T20:58:34+08:00">2023-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="int数组的排序"><a href="#int数组的排序" class="headerlink" title="int数组的排序"></a>int数组的排序</h2><p>int[]数组的排序<br>单纯从小到大排序，直接 <code>Arrays.sort(nums);</code><br>但是想要倒叙排列或者自定义排序，就需要先转换为Integer[]数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 首先将int[]转换为Integer[]，因为Comparator不适用于原始数据类型数组</span><br><span class="line">Integer[] numbersObj = Arrays.stream(numbers).boxed().toArray(Integer[]::new);</span><br><span class="line">变为Integer[]之后，就可以</span><br><span class="line">Arrays.sort(numbers, Collections.reverseOrder());</span><br><span class="line">或者：</span><br><span class="line">Arrays.sort(strings, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public int compare(String s1, String s2) &#123;</span><br><span class="line">		return s2.compareTo(s1); // 逆序</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 使用自定义Comparator按绝对值从大到小排序</span><br><span class="line">Arrays.sort(numbersObj, (a, b) -&gt; &#123;</span><br><span class="line">	// 比较绝对值，实现逆序排序</span><br><span class="line">	return Integer.compare(Math.abs(b), Math.abs(a));</span><br><span class="line">&#125;);</span><br><span class="line">或者转变为List&lt;Integer&gt;，使用 Collections.sort(list);   Collections.reverse(list);</span><br><span class="line">以及自定义排序：</span><br><span class="line">Collections.sort(list, new Comparator&lt;A&gt;()&#123;</span><br><span class="line">  @Oerride</span><br><span class="line">  public int compare(A a1, A a2)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="int-和List转换"><a href="#int-和List转换" class="headerlink" title="int[]和List转换"></a>int[]和List转换</h2><p>List转变为int[]：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在Java中，将List&lt;Integer&gt;转换为基本类型数组int[]需进行拆箱操作，</span><br><span class="line">因为List可以存储对象（例如Integer类型），而基本类型数组（如int[]）存储的是基本类型的值。</span><br><span class="line">除了遍历add，也可以用stream。</span><br><span class="line"></span><br><span class="line">// 将List&lt;Integer&gt;转换为int[]</span><br><span class="line">int[] array = list.stream()  // 将List转换为Stream</span><br><span class="line">		 .mapToInt(Integer::intValue)  // 将每个Integer拆箱成int</span><br><span class="line">		 .toArray();  // 从Stream创建数组</span><br></pre></td></tr></table></figure>

<p>int[]转变为List：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在Java中，将一个基本类型的数组 int[] 转换为 List&lt;Integer&gt; 相对来说更为直接，</span><br><span class="line">因为需要进行装箱操作。除了遍历add，也可以用stream。</span><br><span class="line"></span><br><span class="line">// 使用Stream API将int[]转换为List&lt;Integer&gt;</span><br><span class="line">List&lt;Integer&gt; list = IntStream.of(array) // 创建一个IntStream</span><br><span class="line">			.boxed()   // 将每个int装箱成Integer</span><br><span class="line">			.collect(Collectors.toList()); // 收集为List</span><br></pre></td></tr></table></figure>

<p>不是普通数据类型的转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[][] nums = list.toArray(new int[list.size()][]);  // toArray需要一个参数，即数组的类型和期望的大小</span><br><span class="line"> List&lt;int[]&gt; list = Arrays.stream(nums).collect(Collectors.toList());</span><br><span class="line">打印：list.forEach(m -&gt; System.out.println(Arrays.toString(m)));</span><br></pre></td></tr></table></figure>

<p>java中String和char[]的相互转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">要将一个 String 对象转换为 char[] 数组，可以使用 String 类提供的 toCharArray() 方法：</span><br><span class="line">String str = &quot;Hello World&quot;;</span><br><span class="line">char[] charArray = str.toCharArray();</span><br><span class="line"></span><br><span class="line">要将一个 char[] 数组转换为 String 对象，可以使用 String 类的构造函数之一：</span><br><span class="line">char[] charArray = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;;</span><br><span class="line">String str = new String(charArray);</span><br></pre></td></tr></table></figure>

<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>创建栈：</p>
<p>在Java中，创建栈可以通过使用 java.util.Stack 类，它是 Java 集合框架的一部分。但自从 Java 1.6 开始，通常建议使用 Deque 接口来实现栈的功能，因为它提供了更为一致和完整的栈操作。ArrayDeque 是 Deque 接口的一个常用实现，它比 Stack 类更快，因此通常是实现栈的首选。 Stack 类是基于 Vector 实现的，而 Vector 是一个同步的集合类，它的操作比 ArrayDeque 更慢且通常不是必需的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>✅ArrayDeque 和 LinkedList：</p>
<p>ArrayDeque 和 LinkedList 都是 Deque 接口的实现，都可以用来创建一个双端队列（deque）。尽管它们都提供了相似的操作，但是在内部数据结构和性能上有所不同。</p>
<p>ArrayDeque<br>•内部数据结构：ArrayDeque 是基于一个循环数组实现的，这意味着它的操作可以非常快速，并且具有较好的内存局部性。扩容时，涉及到数组复制，可能比 LinkedList 慢。</p>
<p>LinkedList<br>•内部数据结构：LinkedList 是基于双向链表实现的，为每个元素都分配了一个节点（包含数据和前后指针）。在列表中搜索特定元素的操作，它的时间复杂度是线性的（O(n)）。添加新元素不需要复制整个数据结构，也不需要预先分配内存。LinkedList 对于每个元素都有额外的内存开销，因为每个节点都需要额外存储两个指针（前一个和后一个节点的引用）。</p>
<p>在大多数情况下，ArrayDeque 是实现栈或队列的更好选择，因为它提供了更高的性能和更低的内存开销。然而，如果你需要一个可以包含 null 元素的双端队列，或者你确切知道你的应用场景中 LinkedList 的某些特性更有优势，那么选择 LinkedList 也是合理的。</p>
<p>✅Stack、Deque、Queue、ArrayDeque、LinkedList的关系：</p>
<p>1、Stack:<br>Stack 是一个类，它表示后进先出（LIFO）的栈数据结构。<br>它继承自 Vector 类，并提供了标准的栈操作，比如 push、pop、和 peek。<br>Stack 类是传统的栈实现，但自Java 1.6起不推荐使用，因为它是同步的（线程安全的），这在单线程环境下导致不必要的性能损耗。</p>
<p>2、Deque:<br>Deque 是一个接口，代表双端队列，它支持在两端插入和移除元素。<br>Deque 接口扩展了 Queue 接口，因此它有 Queue 的所有功能，加上额外的在队列头部和尾部进行操作的能力。<br>Deque 接口可以作为栈或队列使用。</p>
<p>3、Queue:<br>Queue 是一个接口，它表示先进先出（FIFO）的队列数据结构。<br>它定义了基本的队列操作，如 offer、poll、和 peek。</p>
<p>4、ArrayDeque:<br>ArrayDeque 是 Deque 接口的一个具体实现，它使用循环数组来支持双端队列的操作。<br>ArrayDeque 可以用作栈或队列，通常比 Stack 更高效，并且不允许插入 null 元素。<br>作为一个 Deque 实现，它提供了所有 Deque 接口的方法，也包括 Queue 接口的方法。</p>
<p>5、LinkedList:<br>LinkedList 是 List 和 Deque 接口的一个具体实现，它使用链表数据结构。<br>LinkedList 可以用作列表、栈或队列，并允许插入 null 元素。<br>作为 Deque 的实现，它提供了在双端队列的两端进行操作的方法，同时也支持 Queue 接口的所有操作。</p>
<p>总的来说，Stack、ArrayDeque、和 LinkedList 都可以用来实现栈的功能，而 ArrayDeque 和 LinkedList 也可以用来实现队列。Deque 是一个更通用的接口，涵盖了栈和队列的操作，而 Queue 是专注于队列操作的接口。在实际使用中，ArrayDeque 是推荐用来实现栈和队列的类，因为它通常比 Stack 和 LinkedList 提供更好的性能。</p>
<p>✅Queue、Deque、和Stack在Java中的常见方法的简单介绍：</p>
<p>1、Queue<br>Queue是一个先进先出（FIFO）的集合。它是一个接口，定义了以下基本操作：<br>offer(E e): 将指定元素添加到队列的尾部，如果成功返回true，如果由于容量限制无法添加则返回false。<br>poll(): 移除并返回队列的头部元素，如果队列为空，则返回null。<br>peek(): 返回队列的头部元素，但不移除，如果队列为空，则返回null。<br>add(E e): 将指定元素添加到队列的尾部，如果成功返回true，如果无法添加则抛出IllegalStateException。<br>remove(): 移除并返回队列的头部元素，如果队列为空，则抛出NoSuchElementException。<br>element(): 返回队列的头部元素，但不移除，如果队列为空，则抛出NoSuchElementException。</p>
<p>2、Deque<br>Deque是双端队列接口，继承自Queue接口，包括Queue的所有方法，以及支持从两端插入和删除元素的方法：<br>addFirst(E e)和offerFirst(E e): 在队列的头部插入一个元素。<br>addLast(E e)和offerLast(E e): 在队列的尾部插入一个元素。<br>removeFirst()和pollFirst(): 移除并返回队列的第一个元素。<br>removeLast()和pollLast(): 移除并返回队列的最后一个元素。<br>getFirst()和peekFirst(): 返回队列的第一个元素，但不移除。<br>getLast()和peekLast(): 返回队列的最后一个元素，但不移除。<br>push(E e): 将元素推入栈顶（等同于addFirst）。<br>pop(): 移除并返回栈顶元素（等同于removeFirst）。</p>
<p>3、Stack<br>Stack是一个类，实现了传统的后进先出（LIFO）的栈数据结构。它继承自Vector类，并提供了以下方法：<br>push(E item): 将项目压入栈顶。<br>pop(): 移除并返回栈顶元素，如果栈为空，则抛出EmptyStackException。<br>peek(): 返回栈顶元素但不移除，如果栈为空，则抛出EmptyStackException。<br>empty(): 测试堆栈是否为空，为空则返回true，否则返回false。<br>search(Object o): 返回对象在堆栈中的位置，以1为栈底的偏移量开始计数。如果对象不在堆栈中，返回-1。</p>
<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>题目：给个数组和目标值，给出数组中两个数之和等于目标值的数的索引。<br>思想：哈希映射，利用map的快速查找key特性（<code>map.containsKey(key)</code>）来实现遍历一次就够了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 两数之和</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-20 23:39</span><br><span class="line"> **/</span><br><span class="line">public class TwoNumSum &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = new int[]&#123;2,7,11,15&#125;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        int[] res = solution.twoSum(nums, 9);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">            HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">                if (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                    return new int[]&#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new IllegalArgumentException(&quot;no result&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        d = dict()  #字典，相当于map</span><br><span class="line">        for i, num in enumerate(nums):  #遍历获取索引和内容</span><br><span class="line">            if target - num in d:</span><br><span class="line">                return [i, d[target - num]]</span><br><span class="line">            else:</span><br><span class="line">                d[num] = i</span><br><span class="line">        return []</span><br></pre></td></tr></table></figure>

<h2 id="两链表表示的数相加"><a href="#两链表表示的数相加" class="headerlink" title="两链表表示的数相加"></a>两链表表示的数相加</h2><p>题目：两个链表表示的数，1-&gt;2-&gt;3 表示 123，相加得到和的链表。<br>思想：相加遍历进位即可，carry表示进位，要在while循环外定义，要先算和再算进位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计算两个琏表表示的数的和</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-22 10:18</span><br><span class="line"> **/</span><br><span class="line">public class TwoLinkNumSum &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 构造链表</span><br><span class="line">        ListNode listNode1 = ListNode.inputList(1, 2, 3);</span><br><span class="line">        ListNode.printList(listNode1);</span><br><span class="line">        ListNode.printList(ListNode.reverseList(listNode1));</span><br><span class="line">        ListNode l1 = ListNode.inputList(2, 4, 3);</span><br><span class="line">        ListNode l2 = ListNode.inputList(5, 6, 4);</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        ListNode sum = s.addTwoNumbers(l1, l2);</span><br><span class="line">        ListNode.printList(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">            // 定义pre节点，保证头节点也参与循环</span><br><span class="line">            ListNode pre = new ListNode(0);</span><br><span class="line">            ListNode cur = pre;</span><br><span class="line">            int carry = 0;</span><br><span class="line">            while (l1 != null || l2 != null) &#123;</span><br><span class="line">                int x = l1 == null ? 0 : l1.val;</span><br><span class="line">                int y = l2 == null ? 0 : l2.val;</span><br><span class="line">                int sum = (x y carry) % 10;</span><br><span class="line">                carry = (x y carry) / 10;</span><br><span class="line">                cur.next = new ListNode(sum);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                if (l1 != null) &#123;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if (l2 != null) &#123;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (carry != 0) &#123;</span><br><span class="line">                cur.next = new ListNode(carry);</span><br><span class="line">            &#125;</span><br><span class="line">            return pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ListNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;;</span><br><span class="line">        ListNode(int val) &#123;this.val = val;&#125;</span><br><span class="line">        ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"></span><br><span class="line">        /** 向队尾添加节点 */</span><br><span class="line">        private void addNode(ListNode newNode) &#123;</span><br><span class="line">            if (this.next == null) &#123;</span><br><span class="line">                this.next = newNode;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.next.addNode(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /** 使用方法可变参数把一串数字变成链表 */</span><br><span class="line">        public static ListNode inputList(int ...data) &#123;</span><br><span class="line">            ListNode listHead = null;</span><br><span class="line">            for (int temp : data) &#123;</span><br><span class="line">                ListNode newNode = new ListNode(temp);</span><br><span class="line">                if (listHead == null) &#123;</span><br><span class="line">                    listHead = newNode;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    listHead.addNode(newNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return listHead;</span><br><span class="line">        &#125;</span><br><span class="line">        /** 打印链表 */</span><br><span class="line">        public static void printList(ListNode head) &#123;</span><br><span class="line">            while (head != null) &#123;</span><br><span class="line">                System.out.print(head.val &quot;-&gt;&quot;);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        /** 翻转链表 */</span><br><span class="line">        public static ListNode reverseList(ListNode head) &#123;</span><br><span class="line">            ListNode pre = null;</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            while (cur != null) &#123;</span><br><span class="line">                ListNode next = cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            return pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串的最长无重复字符子串"><a href="#字符串的最长无重复字符子串" class="headerlink" title="字符串的最长无重复字符子串"></a>字符串的最长无重复字符子串</h2><p>题目：一个字符串，给出字符串的连续子串中其中无重复字符的子串的最大长度。<br>思想：滑动窗口，或者叫做双指针，两个指针的差+1表示窗口的长度，用一个map记录某字符最晚出现的位置的下一个位置。如果在start指针后面出现过就需要移动start到map该字符的value的位置了。如果要子串本身，还得记录开始位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 无重复字符的最长子串</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-22 12:29</span><br><span class="line"> **/</span><br><span class="line">public class MaxNoRepeatString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;abcabc&quot;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        System.out.println(solution.lengthOfLongestSubstring(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">            // 用map表示字符对应的下一个位置</span><br><span class="line">            Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            int res = 0;</span><br><span class="line">            String sub = null;</span><br><span class="line">            for (int start = 0, end = 0; end &lt; s.length(); end ++) &#123;</span><br><span class="line">                char c = s.charAt(end);</span><br><span class="line">                if (map.containsKey(c)) &#123;</span><br><span class="line">                    start = Math.max(start, map.get(c));</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果存在key，会更新</span><br><span class="line">                map.put(c, end 1);</span><br><span class="line">                //res = Math.max(res, end - start 1);</span><br><span class="line">                if (end - start 1 &gt; res) &#123;</span><br><span class="line">                    res = end - start 1;</span><br><span class="line">                    sub = s.substring(start, end 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;sub字符串：&quot; sub);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap();</span><br><span class="line">        int maxSize = 0;</span><br><span class="line">        int l = 0;</span><br><span class="line">        String res = null;</span><br><span class="line">        for (int r = 0; r &lt; s.length(); r ++) &#123;  //String是.length() 数组是.length</span><br><span class="line">            char c = s.charAt(r);  //不是.get，是.charAt</span><br><span class="line">            if (map.containsKey(c)) &#123;</span><br><span class="line">                l = Math.max(map.get(c) 1, l);  //需要取大的，不然会回退</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, r);</span><br><span class="line">            if (r - l 1 &gt; maxSize) &#123;</span><br><span class="line">                maxSize = r - l 1;</span><br><span class="line">                res = s.substring(l, r 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;res:&quot; res);</span><br><span class="line">        return maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s: str) -&gt; int:</span><br><span class="line">        dic, res, i = &#123;&#125;, 0, 0</span><br><span class="line">        for j in range(len(s)):</span><br><span class="line">            if s[j] in dic:</span><br><span class="line">                i = max(i, dic[s[j]] + 1)</span><br><span class="line">            dic[s[j]] = j</span><br><span class="line">            res = max(res, j - i + 1)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><p>题目：给两个正序排列的数组，返回这两个数组合起来的数组的中位数。<br>思路1：遍历，在两个数组间横跳，遍历(m+n)/2+1次就好了。时间复杂度是O(m+n)<br>思路2：遍历是挨个排除不可能的值，那么如果用二分法就可以一半一半地排除不可能的值。其实是找第K小的数，要比两个数组的K/2位置的数，小的那个数组K/2及前面的数就可以排除掉，这样递归查找。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 寻找两个正序数组的中位数</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-23 10:10</span><br><span class="line"> **/</span><br><span class="line">public class MedianOfTwoArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array1 = new int[]&#123;1, 2&#125;;</span><br><span class="line">        int[] array2 = new int[]&#123;3, 4&#125;;</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        System.out.println(s.findMedianSortedArrays(array1, array2));</span><br><span class="line">        System.out.println(s.findMedianSortedArrays2(array1, array2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        // 方法一：在两个数组间遍历，移动(m+n)/2+1步</span><br><span class="line">        public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">            int index1 = 0, index2 = 0, left = 0, right = 0;</span><br><span class="line">            int size = nums1.length nums2.length;</span><br><span class="line">            for (int i = 0; i &lt;= size / 2; i++) &#123;</span><br><span class="line">                // left慢一步</span><br><span class="line">                left = right;</span><br><span class="line">                if (index1 &lt; nums1.length &amp;&amp; (index2 == nums2.length || nums1[index1] &lt;= nums2[index2])) &#123;</span><br><span class="line">                    right = nums1[index1++];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right = nums2[index2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (size % 2 == 0) &#123;</span><br><span class="line">                return (left right) / 2.0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 方法二：二分法</span><br><span class="line">        public double findMedianSortedArrays2(int[] nums1, int[] nums2) &#123;</span><br><span class="line">            int n = nums1.length;</span><br><span class="line">            int m = nums2.length;</span><br><span class="line">            int left = (n m 1) / 2;</span><br><span class="line">            int right = (n m 2) / 2;</span><br><span class="line">            return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取两正序数组的第k大的值</span><br><span class="line">        private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) &#123;</span><br><span class="line">            // 要进行比较的数组的长度</span><br><span class="line">            int len1 = end1 - start1 1;</span><br><span class="line">            int len2 = end2 - start2 1;</span><br><span class="line">            if (len1 len2 &lt; k) &#123;throw new IllegalArgumentException(&quot;no result&quot;);&#125;</span><br><span class="line">            // 出递归条件</span><br><span class="line">            if (len1 == 0) return nums2[start2 k - 1];</span><br><span class="line">            if (len2 == 0) return nums1[start1 k - 1];</span><br><span class="line">            if (k == 1) return Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">            // 要比较的两个数组的索引</span><br><span class="line">            int i = start1 Math.min(len1, k / 2) - 1;</span><br><span class="line">            int j = start2 Math.min(len2, k / 2) - 1;</span><br><span class="line">            if (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 1));</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int size = nums1.length nums2.length;</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        int left = 0, right = 0;</span><br><span class="line">        for (int m = 0; m &lt;= size/2; m ++) &#123;</span><br><span class="line">            left = right;</span><br><span class="line">            if (i &lt; nums1.length &amp;&amp; (j == nums2.length || nums1[i] &lt;= nums2[j])) &#123;  //注意越界</span><br><span class="line">                right = nums1[i ++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right = nums2[j ++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (size % 2 == 0) &#123;</span><br><span class="line">            return (left right) / 2.0; //注意除以2.0</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 二分法的思想：在有序数组中查找，每次缩小一半的查找范围</span><br><span class="line">    // 就要看怎么淘汰：扩展一下，找第k大数，两个数组k/2位置，小的那个数组之前的就能淘汰</span><br><span class="line">    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int len = nums1.length nums2.length;</span><br><span class="line">        if (len % 2 == 0) &#123;</span><br><span class="line">            return (getK(nums1, 0, nums1.length - 1, nums2, 0, nums2.length - 1, len/2) getK(nums1, 0, nums1.length - 1, nums2, 0, nums2.length - 1, len/2 1)) / 2.0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return getK(nums1, 0, nums1.length - 1, nums2, 0, nums2.length - 1, len/2 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Integer getK(int[] nums1, int s1, int e1, int[] nums2, int s2, int e2, int k) &#123;</span><br><span class="line">        System.out.println(s1+&quot;.&quot;+e1+&quot;.&quot;+s2+&quot;.&quot;+e2+&quot;.&quot;+k);</span><br><span class="line">        // 递归第一步：出递归条件</span><br><span class="line">        if (s1 &gt; e1) return nums2[s2 k - 1]; // 注意这里得加s2</span><br><span class="line">        if (s2 &gt; e2) return nums1[s1 k - 1]; // 注意k是第k个，索引又是从0开始的</span><br><span class="line">        if (k == 1) return nums1[s1] &lt; nums2[s2] ? nums1[s1]:nums2[s2];</span><br><span class="line">        // 递归第二步：缩小范围</span><br><span class="line">        // 需要注意数组可能没k/2那么大了，没那么大只能选边界</span><br><span class="line">        int i = Math.min(s1 k/2 - 1, e1); // 注意-1</span><br><span class="line">        int j = Math.min(s2 k/2 - 1, e2);</span><br><span class="line">        if (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            // 应该找第几个了</span><br><span class="line">            int find = k - (i - s1 1);</span><br><span class="line">            return getK(nums1, i + 1, e1, nums2, s2, e2, find);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int find = k - (j - s2 1);</span><br><span class="line">            return getK(nums1, s1, e1, nums2, j + 1, e2, find);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>题目：给一个字符串，返回该字符串的最长回文子串，例如：aba，abba。<br>思想1：可以挨个遍历每个字符，从字符开始向左右散发，如果不相等了就停止，并且分两种散发：一个中心字符，两个一样的作为中心字符。记录开始位置和结束位置。<br>思想2：回文子串也是该字符串与它倒过来的字符串的最长公共子串，可以用动态规划维护一个二维数组来做。动态规划就是为了减少重复计算的问题。动态规划听起来很高大上。其实说白了就是空间换时间，将计算结果暂存起来，避免重复计算。作用和工程中用 redis 做缓存有异曲同工之妙。<br>求出最长公共子串后，并不一定是回文串，我们还需要判断该字符串倒置前的下标和当前的字符串下标是不是匹配</p>
<blockquote>
<p>整体思想就是，申请一个二维的数组初始化为 0，然后判断对应的字符是否相等，相等的话<br>arr [ i ][ j ] = arr [ i - 1 ][ j - 1] + 1 。<br>当 i = 0 或者 j = 0 的时候单独分析，字符相等的话 arr [ i ][ j ] 就赋为 1 。<br>arr [ i ][ j ] 保存的就是公共子串的长度，表示以i为结尾和以j为结尾的前arr[i][j]个字符是公共子串。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最长回文子串</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-29 20:43</span><br><span class="line"> **/</span><br><span class="line">public class HuiWenString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;aacabdkacaa&quot;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        System.out.println(solution.longestPalindrome(s));</span><br><span class="line">        System.out.println(solution.longestPalindrome1(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public String longestPalindrome(String s) &#123;</span><br><span class="line">            if (null == s || s.length() &lt; 2) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">            int max = 0;</span><br><span class="line">            String res = null;</span><br><span class="line">            for (int i = 0; i &lt; s.length() - 1; i ++) &#123;</span><br><span class="line">                int l = i, r = i;</span><br><span class="line">                while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                    l --;</span><br><span class="line">                    r ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (r - l 1 &gt; max) &#123;</span><br><span class="line">                    max = r - l 1;</span><br><span class="line">                    res = s.substring(l 1, r);</span><br><span class="line">                &#125;</span><br><span class="line">                l = i;</span><br><span class="line">                r = i + 1;</span><br><span class="line">                while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                    l --;</span><br><span class="line">                    r ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (r - l 1 &gt; max) &#123;</span><br><span class="line">                    max = r - l 1;</span><br><span class="line">                    res = s.substring(l 1, r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String longestPalindrome1(String s) &#123;</span><br><span class="line">            if (null == s || s.length() &lt; 2) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">            String res = null;</span><br><span class="line">            int max = 0;</span><br><span class="line">            int length = s.length();</span><br><span class="line">            int[][] arr = new int[length][length];</span><br><span class="line">            String rev = new StringBuffer(s).reverse().toString(); //字符串翻转</span><br><span class="line">            for (int i = 0; i &lt; length; i ++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; length; j ++) &#123;</span><br><span class="line">                    //如果不想等可以不赋值为0，表示以这个字符为公共最后字符没有公共字符，动态规划也用不上</span><br><span class="line">                    if (s.charAt(i) == rev.charAt(j)) &#123;</span><br><span class="line">                        //为0的边界</span><br><span class="line">                        if (i == 0 || j == 0) &#123;</span><br><span class="line">                            arr[i][j] = 1;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            arr[i][j] = arr[i - 1][j - 1] + 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (arr[i][j] &gt; max) &#123;</span><br><span class="line">                        int beforeRev = length - 1 - j; //倒置前的坐标</span><br><span class="line">                        if (beforeRev arr[i][j] - 1 == i) &#123; //判断下标是否对应</span><br><span class="line">                            max = arr[i][j];</span><br><span class="line">                            res = s.substring(i - arr[i][j] + 1, i + 1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        //遍历每个元素，用双指针前后拓展，直到不一样就停止</span><br><span class="line">        int maxSize = 0;</span><br><span class="line">        String res = &quot;&quot;;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            // 1.一个点为中心</span><br><span class="line">            int jump = 0;</span><br><span class="line">            while (i - jump &gt;= 0 &amp;&amp; i jump &lt; s.length() &amp;&amp; s.charAt(i - jump) == s.charAt(i jump)) &#123;</span><br><span class="line">                if (jump*2+1 &gt; maxSize) &#123;</span><br><span class="line">                    maxSize = jump*2+1;</span><br><span class="line">                    res = s.substring(i - jump, i jump +1);</span><br><span class="line">                &#125;</span><br><span class="line">                jump ++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 2.以两个点为中心</span><br><span class="line">            jump= 0; // 注意从0开始</span><br><span class="line">            while (i - jump &gt;= 0 &amp;&amp; i + 1 jump &lt; s.length() &amp;&amp; s.charAt(i - jump) == s.charAt(i + 1 jump)) &#123;</span><br><span class="line">                if (jump*2+2 &gt; maxSize) &#123;</span><br><span class="line">                    maxSize = jump*2+2;</span><br><span class="line">                    res = s.substring(i - jump, i jump +2);  //注意是substring</span><br><span class="line">                &#125;</span><br><span class="line">                jump ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        //动态规划的思想：以空间换时间，保存计算结果，避免重复计算</span><br><span class="line">        //需要明确[i][j]表示的含义，以及怎么传递下去，以及最开始怎么算</span><br><span class="line">        // 1.初始化动态规划矩阵</span><br><span class="line">        int length = s.length();</span><br><span class="line">        int[][] nums = new int[length][length]; //矩阵初始化方法</span><br><span class="line">        String res = &quot;&quot;;</span><br><span class="line">        int max = 0;</span><br><span class="line">        // 2.遍历方向要依据传递条件</span><br><span class="line">        for (int i = length - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">            int maxj = i;</span><br><span class="line">            for (int j = i; j &lt; length; j++) &#123;</span><br><span class="line">                if (i == j) &#123;</span><br><span class="line">                    // 3.代表的含义应该是：是否回文</span><br><span class="line">                    nums[i][j] = 1;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    if (j == i + 1) &#123;</span><br><span class="line">                        nums[i][j] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 4.上面是初始条件，下面是传递条件</span><br><span class="line">                        nums[i][j] = nums[i + 1][j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxj = nums[i][j] == 1 &amp;&amp; j &gt; maxj ? j: maxj;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    nums[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (maxj - i + 1 &gt; max) &#123;</span><br><span class="line">                max = maxj - i + 1;</span><br><span class="line">                res = s.substring(i, maxj + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Z字形变换"><a href="#Z字形变换" class="headerlink" title="Z字形变换"></a>Z字形变换</h2><p>题目：将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>思路：根据行数可以得出多少个循环一次半Z，然后第一行就是除以几余几的，看有咩用方法可以获取一个字符串中位置是/n余i的字符组成的字符串。String的split方法尽管可以按照正则表达式来分割，但是貌似无法实现隔位分割。<br>所以只能是新建一个<code>List&lt;StringBuilder&gt;</code>，然后遍历字符串来append进去。比取余更好的做法是用一个index标注，往下是+1，遇到拐角就-1.</p>
<p>遍历字符串中的字符：<code>char c : s.toCharArray()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package leeco.string;</span><br><span class="line"></span><br><span class="line">import com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-12 12:08</span><br><span class="line"> **/</span><br><span class="line">public class ZTransform &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;PAYPALISHIRING&quot;;</span><br><span class="line">        Solution so = new Solution();</span><br><span class="line">        String res = so.convert(s, 3);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public String convert(String s, int numRows) &#123;</span><br><span class="line">            if (numRows &lt; 2) return s;</span><br><span class="line">            List&lt;StringBuilder&gt; rows = Lists.newArrayList();</span><br><span class="line">            //List&lt;StringBuilder&gt; rows = new ArrayList&lt;StringBuilder&gt;();</span><br><span class="line">            //需要写入numRows个StringBuilder到List</span><br><span class="line">            for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                rows.add(sb);</span><br><span class="line">            &#125;</span><br><span class="line">            int index = 0;</span><br><span class="line">            int step = -1;</span><br><span class="line">            for (char c : s.toCharArray()) &#123;</span><br><span class="line">                rows.get(index).append(c);</span><br><span class="line">                //遇到拐点，方向就反</span><br><span class="line">                if (index == 0 || index == numRows - 1) &#123;</span><br><span class="line">                    step = -step;</span><br><span class="line">                &#125;</span><br><span class="line">                index += step;</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder res = new StringBuilder();</span><br><span class="line">            for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class="line">                res.append(rows.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            return res.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String convert(String s, int numRows) &#123;</span><br><span class="line">        //很简单，规律性的东西，两个方向：往上走和往下走</span><br><span class="line">        if (numRows == 1) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;StringBuilder&gt; sbList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i&lt; numRows; i++) &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            sbList.add(sb);</span><br><span class="line">        &#125;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i ++) &#123;</span><br><span class="line">            sbList.get(index).append(s.charAt(i));</span><br><span class="line">            if (i % (2 * numRows - 2) &lt; numRows - 1) &#123;</span><br><span class="line">                index ++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                index --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i&lt;numRows; i++) &#123;</span><br><span class="line">            sbList.get(0).append(sbList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return sbList.get(0).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h2><p>题目：给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。-123 变 -321<br>Integer整数区间：[−2^31,  2^31 − 1]<br>思路1：变成一个字符串，然后反转，然后加符号。<br>思路2：对int一步一步/10，然后拿到结果一步一步*10<br>思路3：用栈stack，也得先变字符串，本质上也是字符串反转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-12 22:38</span><br><span class="line"> **/</span><br><span class="line">public class IntegerReverse &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Integer.MAX_VALUE);</span><br><span class="line">        System.out.println(Math.pow(2, 31) - 1);</span><br><span class="line">        int i = -33;</span><br><span class="line">        System.out.println(~(i-1));  //和-i一样</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        System.out.println(s.reverse(-123));</span><br><span class="line">        System.out.println(s.reverse2(-123));</span><br><span class="line">        System.out.println(s.reverse2(-123));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int reverse(int x) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                if (x &lt; 0) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x = -x;</span><br><span class="line">                &#125;</span><br><span class="line">                String old = String.valueOf(x);</span><br><span class="line">                String newS = new StringBuilder(old).reverse().toString();</span><br><span class="line">                int res = Integer.parseInt(newS);</span><br><span class="line">                if (flag) res = -res;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int reverse2(int x) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                if (x &lt; 0) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x = -x;</span><br><span class="line">                &#125;</span><br><span class="line">                int res = 0;</span><br><span class="line">                while (x &gt; 0) &#123;</span><br><span class="line">                    res = res * 10 x % 10;</span><br><span class="line">                    x = x / 10;</span><br><span class="line">                &#125;</span><br><span class="line">                if (flag) res = - res;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int reverse3(int x) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                if (x &lt; 0) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x = -x;</span><br><span class="line">                &#125;</span><br><span class="line">                String old = String.valueOf(x);</span><br><span class="line">                Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">                for (char c : old.toCharArray()) stack.push(c);</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                while (!stack.empty()) sb.append(stack.pop());</span><br><span class="line">                int res = Integer.parseInt(sb.toString());</span><br><span class="line">                if (flag) res = -res;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int reverse(int x) &#123;</span><br><span class="line">        // 用String进行反转，java的幂运算用Math.pow(2,2)</span><br><span class="line">        boolean isFu = false;</span><br><span class="line">        if(x &lt; 0) &#123;</span><br><span class="line">            isFu = true;</span><br><span class="line">            // 如果是-2^31，负的接不住。</span><br><span class="line">            if (x == Integer.MIN_VALUE) return 0;</span><br><span class="line">            x = -x;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = new StringBuilder(String.valueOf(x)).reverse().toString();</span><br><span class="line">        long l = Long.valueOf(s);</span><br><span class="line">        // 原来正的，反过来正的，不能大于2^ 31-1</span><br><span class="line">        if ((isFu &amp;&amp; l &gt; Math.pow(2, 31)) || !isFu &amp;&amp; l &gt; Math.pow(2, 31)-1)</span><br><span class="line">            return 0;</span><br><span class="line">        return isFu? -Integer.valueOf(String.valueOf(l)) : Integer.valueOf(String.valueOf(l));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ErFen &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;输入有序数组，逗号分隔：&quot;);</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        str = str.replace(&quot; &quot;, &quot;&quot;);</span><br><span class="line">        String[] strArray = str.split(&quot;,&quot;);</span><br><span class="line">        int[] array = new int[strArray.length];</span><br><span class="line">        for(int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = Integer.parseInt(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;输入目标值：&quot;);</span><br><span class="line">        int target = sc.nextInt();</span><br><span class="line">        System.out.println(&quot;array:&quot; Arrays.toString(array));</span><br><span class="line">        int min = 0;</span><br><span class="line">        int max = array.length - 1;</span><br><span class="line">        int middle = min (max - min) / 2; //防止越界</span><br><span class="line">        while(min &lt;= max) &#123;</span><br><span class="line">            if (array[middle] == target) &#123;</span><br><span class="line">                System.out.println(middle);</span><br><span class="line">                return;</span><br><span class="line">            &#125; else if (array[middle] &lt; target) &#123;</span><br><span class="line">                min = middle 1;</span><br><span class="line">                middle = min (max - min) / 2;</span><br><span class="line">            &#125; else if (array[middle] &gt; target) &#123;</span><br><span class="line">                max = middle - 1;</span><br><span class="line">                middle = min (max - min) / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="字符串转换为整数"><a href="#字符串转换为整数" class="headerlink" title="字符串转换为整数"></a>字符串转换为整数</h2><p>“   -42” 变为-42.<br>“4193 with words” 变为4193。<br>遇到非数字的字符串就停止，如果超过int表示范围了就返回正负的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int myAtoi(String s) &#123;</span><br><span class="line">        // 去掉头尾空白符，中间的不去</span><br><span class="line">        char[] c = s.trim().toCharArray();</span><br><span class="line">        if (c.length == 0) return 0;</span><br><span class="line">        int res = 0, bndry = Integer.MAX_VALUE / 10; //最大是2147483647</span><br><span class="line">        int i = 1, sign = 1;</span><br><span class="line">        if (c[0] == &#x27;-&#x27;) sign = -1;</span><br><span class="line">        else if (c[0] != &#x27;+&#x27;) i = 0; //从0开始</span><br><span class="line">        for (int j = i; j &lt; c.length; j++) &#123;</span><br><span class="line">            if (c[j] &lt; &#x27;0&#x27; || c[j] &gt; &#x27;9&#x27;) break;</span><br><span class="line">            if (res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; &#x27;7&#x27;) &#123;</span><br><span class="line">                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * 10 (c[j] - &#x27;0&#x27;); //字符变数字</span><br><span class="line">        &#125;</span><br><span class="line">        return sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="到最近的人的最大距离"><a href="#到最近的人的最大距离" class="headerlink" title="到最近的人的最大距离"></a>到最近的人的最大距离</h2><p>给你一个数组 seats 表示一排座位，其中 seats[i] = 1 代表有人坐在第 i 个座位上，seats[i] = 0 代表座位 i 上是空的（下标从 0 开始）。</p>
<p>找一个距离两边人最近的一个位置，找坑位。返回他到离他最近的人的最大距离。</p>
<p>双指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistToClosest(int[] seats) &#123;</span><br><span class="line">        //双指针：左右指针为相邻的有人座位，则最大距离是r-l/2</span><br><span class="line">        //但是要考虑两边没座位的情况</span><br><span class="line">        int res = 0;</span><br><span class="line">        int l = 0;</span><br><span class="line">        while(seats[l] == 0) &#123;</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, l);</span><br><span class="line">        while(l &lt; seats.length - 1) &#123;</span><br><span class="line">            int r = l 1;</span><br><span class="line">            while(r &lt; seats.length &amp;&amp; seats[r] == 0) &#123;</span><br><span class="line">                r ++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (r == seats.length) &#123;</span><br><span class="line">                res = Math.max(res, r - l - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res = Math.max(res, (r - l)/2);</span><br><span class="line">            &#125;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><p>1.变成String之后反转比较是否跟之前的数相等，但是要注意Integer溢出。<br>2.变成String之后，双指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPalindrome(int x) &#123;</span><br><span class="line">        if (x &lt; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        long y = Long.valueOf(new StringBuilder(new Long(x).toString()).reverse().toString());</span><br><span class="line">        return x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        // 双指针：一个最前一个最后，谁小就移动谁</span><br><span class="line">        int l = 0, r = height.length-1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        while(l &lt; r) &#123;</span><br><span class="line">            // 选择小的移动</span><br><span class="line">            if (height[l] &lt; height[r]) &#123;</span><br><span class="line">                max = Math.max(max, (r - l) * height[l]);</span><br><span class="line">                l ++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                max = Math.max(max, (r - l) * height[r]);</span><br><span class="line">                r --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>1.5.10.50…有特定的符号，但是4.9.40.90…也比较特殊，所以把它们也作为特定的符号。从大到小遍历。不会出现80变为两个40的情况，因为之前一定会先拆出一个50.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int[] values = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">    String[] symbols = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    public String intToRoman(int num) &#123;</span><br><span class="line">        StringBuffer roman = new StringBuffer();</span><br><span class="line">        for (int i = 0; i &lt; values.length; ++i) &#123;</span><br><span class="line">            int value = values[i];</span><br><span class="line">            String symbol = symbols[i];</span><br><span class="line">            while (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman.append(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            if (num == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p>给两个递增的数组，其中nums1后面的nums2的长度是有的，填充的0.将nums2填充到nums1中，并且是排好序的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        //用双指针进行替换，如果是第二个队列的元素大，就替换</span><br><span class="line">        //替换出来的第一个队列的元素放在哪，放哪都不行，所以从后往前移动</span><br><span class="line">        // 方法一：先合并，直接Arrays.sort(nums1)</span><br><span class="line">        // 方法二：开一个新数组，从前往后双指针</span><br><span class="line">        // 方法三：不用重开，直接从后往前双指针</span><br><span class="line">        int tail = m n - 1;</span><br><span class="line">        int p1 = m - 1;</span><br><span class="line">        int p2 = n - 1;</span><br><span class="line">        while(p1 &gt;= 0 || p2 &gt;= 0) &#123;</span><br><span class="line">            if (p1 &lt; 0) &#123;</span><br><span class="line">                nums1[tail] = nums2[p2--];</span><br><span class="line">            &#125; else if (p2 &lt; 0) &#123;</span><br><span class="line">                nums1[tail] = nums1[p1--];</span><br><span class="line">            &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                nums1[tail] = nums1[p1--];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums1[tail] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不能使用额外的空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        //双指针，一前一后，前面的不是val，就往后走，如果是就替换，并前后都移动，其实不用替换</span><br><span class="line">        int l = 0;</span><br><span class="line">        int r = nums.length - 1;</span><br><span class="line">        while(l &lt;= r) &#123;</span><br><span class="line">            if (l == r) &#123;</span><br><span class="line">                if (nums[l] != val) l ++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[l] == val &amp;&amp; nums[r] != val) &#123;</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">                l ++;</span><br><span class="line">                r --;</span><br><span class="line">            &#125; else if (nums[l] == val &amp;&amp; nums[r] == val) &#123;</span><br><span class="line">                r --;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                l ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h2><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。nums 的其余元素与 nums 的大小不重要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        //双指针，移除重复的元素其实就是把不重复的元素移到最前面</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = 1;</span><br><span class="line">        while(j &lt; nums.length) &#123;</span><br><span class="line">            if (nums[i] == nums[j]) &#123;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除有序数组中的重复项-II"><a href="#删除有序数组中的重复项-II" class="headerlink" title="删除有序数组中的重复项 II"></a>删除有序数组中的重复项 II</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p>
<p>和上面的相比，多了保留两个重复的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        // 同样是相当于将元素向前移动，无非是加个标识位表示第一个</span><br><span class="line">        int i = 0, j = 1;</span><br><span class="line">        boolean isFirst = true;</span><br><span class="line">        while (j &lt; nums.length) &#123;</span><br><span class="line">            if (nums[i] == nums[j]) &#123;</span><br><span class="line">                if (isFirst) &#123;</span><br><span class="line">                    i ++;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    isFirst = false;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                j ++;</span><br><span class="line">                isFirst = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h2><p>摩尔投票法：<br>候选人(cand_num)初始化为 nums[0]，票数 count 初始化为 1。<br>当遇到与 cand_num 相同的数，则票数 count = count 1，否则票数 count = count - 1。当票数 count 为 0 时，更换候选人，并将票数 count 重置为 1。遍历完数组后，cand_num 即为最终答案。</p>
<p>投票法是遇到相同的则 票数 1，遇到不同的则 票数 - 1。<br>且“多数元素”的个数 &gt; ⌊ n/2 ⌋，其余元素的个数总和 &lt;= ⌊ n/2 ⌋。<br>因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 &gt;= 1。<br>这就相当于每个 “多数元素” 和其他元素 两两相互抵消，抵消到最后肯定还剩余 至少1个 “多数元素”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int majorityElement(int[] nums) &#123;</span><br><span class="line">        // 排序之后的nums.length/2元素一定是多数元素</span><br><span class="line">        // 摩尔投票法：先选一个，往后遍历，如果不一样就减一，直到0就换</span><br><span class="line">        int res = nums[0];</span><br><span class="line">        int score = 1;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            if (num == res) score ++;</span><br><span class="line">            else if (--score == 0) &#123;</span><br><span class="line">                res = num;</span><br><span class="line">                score = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h2><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。<br>使用空间复杂度为 O(1) 的 原地 算法解决这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[] nums, int k) &#123;</span><br><span class="line">        // 使用额外的数组很简单，问题是怎么用O1的空间</span><br><span class="line">        // 被替换的元素保存在变量temp中，从而避免了额外数组的开销</span><br><span class="line">        // 怎么遍历？跳跃式替换，回到原点时应该从下一个元素开始跳跃</span><br><span class="line">        // 什么时候结束？用一个元素记录遍历了多少次</span><br><span class="line">        if (k == 0 || nums.length &lt; 2) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = 0;</span><br><span class="line">        int index = 0;</span><br><span class="line">        int temp = nums[index];</span><br><span class="line">        int pre;</span><br><span class="line">        int start = 0;</span><br><span class="line">        while (count &lt; nums.length) &#123;</span><br><span class="line">            index = (index k) % nums.length;</span><br><span class="line">            pre = nums[index];</span><br><span class="line">            nums[index] = temp;</span><br><span class="line">            temp = pre;</span><br><span class="line">            count ++;</span><br><span class="line">            if (count &lt; nums.length &amp;&amp; index == start) &#123;</span><br><span class="line">                index = start 1;</span><br><span class="line">                start = index;</span><br><span class="line">                temp = nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        // 一次遍历便可得到，每次遍历得到之前最小的数，以及目前为止最大利润</span><br><span class="line">        int cost = Integer.MAX_VALUE, profile = 0;</span><br><span class="line">        for (int price : prices) &#123;</span><br><span class="line">            profile = Math.max(price - cost, profile);</span><br><span class="line">            cost = Math.min(cost, price);</span><br><span class="line">        &#125;</span><br><span class="line">        return profile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用动态规划：</p>
<p>状态定义：dp[i][j]：下标为 i 这一天结束的时候，手上持股状态为 j 时，我们持有的现金数。换种说法：dp[i][j] 表示天数 [0, i] 区间里，下标 i 这一天状态为 j 的时候能够获得的最大利润。</p>
<p>推导状态转移方程：<br>dp[i][0]：规定了今天不持股，有以下两种情况：<br>昨天不持股，今天什么都不做；<br>昨天持股，今天卖出股票（现金数增加）</p>
<p>dp[i][1]：规定了今天持股，有以下两种情况：<br>昨天持股，今天什么都不做（现金数与昨天一样）；<br>昨天不持股，今天买入股票（注意：只允许交易一次，因此手上的现金数就是当天的股价的相反数）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        // 特殊判断</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] dp = new int[len][2];</span><br><span class="line"></span><br><span class="line">        // dp[i][0] 下标为 i 这天结束的时候，不持股，手上拥有的现金数</span><br><span class="line">        // dp[i][1] 下标为 i 这天结束的时候，持股，手上拥有的现金数</span><br><span class="line"></span><br><span class="line">        // 初始化：不持股显然为 0，持股就需要减去第 1 天（下标为 0）的股价</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line">        dp[0][1] = -prices[0];</span><br><span class="line"></span><br><span class="line">        // 从第 2 天开始遍历</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] prices[i]);</span><br><span class="line">            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len - 1][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机2"><a href="#买卖股票的最佳时机2" class="headerlink" title="买卖股票的最佳时机2"></a>买卖股票的最佳时机2</h2><p>与第一题只能进行一次交易不同，这里可以进行多次交易。</p>
<p>方法一：在每一天都有操作/不操作（买入还是卖出）的选择。所以用树形结构进行回溯搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private int res;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        this.res = 0;</span><br><span class="line">        dfs(prices, 0, len, 0, res);</span><br><span class="line">        return this.res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param prices 股价数组</span><br><span class="line">     * @param index  当前是第几天，从 0 开始</span><br><span class="line">     * @param status 0 表示不持有股票，1表示持有股票，</span><br><span class="line">     * @param profit 当前收益</span><br><span class="line">     */</span><br><span class="line">    private void dfs(int[] prices, int index, int len, int status, int profit) &#123;</span><br><span class="line"></span><br><span class="line">        if (index == len) &#123;</span><br><span class="line">            this.res = Math.max(this.res, profit);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(prices, index 1, len, status, profit);</span><br><span class="line"></span><br><span class="line">        if (status == 0) &#123;</span><br><span class="line">            // 可以尝试转向 1</span><br><span class="line">            dfs(prices, index 1, len, 1, profit - prices[index]);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 此时 status == 1，可以尝试转向 0</span><br><span class="line">            dfs(prices, index 1, len, 0, profit prices[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：动态规划，与上一题在状态转移的时候会有所不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        // 特殊判断</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] dp = new int[len][2];</span><br><span class="line"></span><br><span class="line">        // dp[i][0] 下标为 i 这天结束的时候，不持股，手上拥有的现金数</span><br><span class="line">        // dp[i][1] 下标为 i 这天结束的时候，持股，手上拥有的现金数</span><br><span class="line"></span><br><span class="line">        // 初始化：不持股显然为 0，持股就需要减去第 1 天（下标为 0）的股价</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line">        dp[0][1] = -prices[0];</span><br><span class="line"></span><br><span class="line">        // 从第 2 天开始遍历</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] prices[i]);</span><br><span class="line">            // 这里持股，并不是这天持股的收益，与只买卖一次就这里的差别</span><br><span class="line">            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len - 1][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于当前行只参考上一行，每一行就 2 个值，因此可以考虑使用「滚动变量」</p>
<p>方法三：贪心算法</p>
<p>求解最优化问题的算法通常需要经过一系列的步骤，在每个步骤都面临生种选择。对于许多最优化问题，使用动态规划算法来求最优解有些杀鸡用牛力了，可以使用更简单、更高效的算法。贪心算法(greedy algorithm)就是这样的算法，它在每一步都做出当时看起来最佳的选择。也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。</p>
<p>贪心算法和动态规划相比，它既不看前面（也就是说它不需要从前面的状态转移过来），也不看后面（无后效性，后面的选择不会对前面的选择有影响），因此贪心算法时间复杂度一般是线性的，空间复杂度是常数级别的。</p>
<p>这道题 「贪心」 的地方在于，对于 「今天的股价 - 昨天的股价」，得到的结果有 3 种可能：① 正数，② 0，③负数。贪心算法的决策是： 只加正数 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            res += Math.max(prices[i] - prices[i - 1], 0);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机3"><a href="#买卖股票的最佳时机3" class="headerlink" title="买卖股票的最佳时机3"></a>买卖股票的最佳时机3</h2><p>与上面不同，这里只允许最多完成两笔交易，并且必须在再次购买前出售掉之前的股票。</p>
<p>结合上面两道题，第一题是交易一次就不交易，第二题是还可以交易。这里设定三维数组，增加一维表示交易次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第 2 维的 0 没有意义，1 表示交易进行了 1 次，2 表示交易进行了 2 次</span><br><span class="line">        // 为了使得第 2 维的数值 1 和 2 有意义，这里将第 2 维的长度设置为 3</span><br><span class="line">        int[][][] dp = new int[len][3][2];</span><br><span class="line"></span><br><span class="line">        // 理解如下初始化</span><br><span class="line">        // 第 3 维规定了必须持股，因此是 -prices[0]</span><br><span class="line">        dp[0][1][1] = -prices[0];</span><br><span class="line">        // 还没发生的交易，持股的时候应该初始化为负无穷</span><br><span class="line">        dp[0][2][1] = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            // 转移顺序先持股，再卖出</span><br><span class="line">            dp[i][1][1] = Math.max(dp[i - 1][1][1], -prices[i]) ;</span><br><span class="line">            dp[i][1][0] = Math.max(dp[i - 1][1][0], dp[i - 1][1][1] prices[i]);</span><br><span class="line">            dp[i][2][1] = Math.max(dp[i - 1][2][1], dp[i - 1][1][0] - prices[i]);</span><br><span class="line">            dp[i][2][0] = Math.max(dp[i - 1][2][0], dp[i - 1][2][1] prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[len - 1][1][0], dp[len - 1][2][0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机4"><a href="#买卖股票的最佳时机4" class="headerlink" title="买卖股票的最佳时机4"></a>买卖股票的最佳时机4</h2><p>最多可以完成 k 笔交易。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">         int len = prices.length;</span><br><span class="line">        if (k &gt;= len / 2) &#123;</span><br><span class="line">            int res = 0;</span><br><span class="line">            for (int i = 1; i &lt; len; i ++) &#123;</span><br><span class="line">                res += Math.max(0, prices[i] - prices[i - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dpHold = new int[k 1];</span><br><span class="line">        int[] dpNoHold = new int[k 1];</span><br><span class="line">        for (int i = 0; i &lt;= k; i++) &#123;</span><br><span class="line">            dpHold[i] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int price : prices) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= k; j++) &#123;</span><br><span class="line">                // 持有 = max(前一天持有，前一天不持有今天持有)</span><br><span class="line">                // 持有表示交易次数+1，需要考虑交易次数-1的情况</span><br><span class="line">                dpHold[j] = Math.max(dpHold[j], dpNoHold[j - 1] - price);</span><br><span class="line">                // 不持有 = max(前一天不持有， 今天卖掉)</span><br><span class="line">                // 不持有，卖掉，交易次数还是原来的</span><br><span class="line">                dpNoHold[j] = Math.max(dpNoHold[j], dpHold[j] price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dpNoHold[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="买卖股票含冷冻期"><a href="#买卖股票含冷冻期" class="headerlink" title="买卖股票含冷冻期"></a>买卖股票含冷冻期</h2><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        // 一维表示天，二维表示 不持有、持有、冷冻</span><br><span class="line">        int[][] dp = new int[len 1][3];</span><br><span class="line">        for (int i = 0; i &lt;= len; i++) &#123;</span><br><span class="line">            dp[i][1] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= len; i++) &#123;</span><br><span class="line">            // 不持有：前一天不持有/前一天持有今天卖掉</span><br><span class="line">            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] prices[i-1]);</span><br><span class="line">            // 持有：前一天持有/前一天冷冻今天持有</span><br><span class="line">            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][2] - prices[i-1]);</span><br><span class="line">            // 冷冻：前一天不持有/前一天冷冻</span><br><span class="line">            dp[i][2] = Math.max(dp[i-1][2], dp[i-1][0]);</span><br><span class="line">            System.out.println(dp[i][0] &quot;==&quot; dp[i][1] &quot;==&quot; dp[i][2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[len][0], dp[len][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票含手续费"><a href="#买卖股票含手续费" class="headerlink" title="买卖股票含手续费"></a>买卖股票含手续费</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices, int fee) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        int[][] dp = new int[len+1][2];</span><br><span class="line">        for (int i = 0; i&lt;=len; i++) &#123;</span><br><span class="line">            dp[i][1] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= len; i++) &#123;</span><br><span class="line">            // 不持有</span><br><span class="line">            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] prices[i-1]);</span><br><span class="line">            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i-1] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p>
<p>解法：从前往后遍历，在当前点时，可以知道当前点最远可以到达哪里，在遍历下一个的时候，对比能不能达到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canJump(int[] nums) &#123;</span><br><span class="line">        int reach = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (i &gt; reach) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            reach = Math.max(reach, i nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏2"><a href="#跳跃游戏2" class="headerlink" title="跳跃游戏2"></a>跳跃游戏2</h2><p>给一个数组，表示在该位置上的最大跳跃长度。现在要给出最少跳跃步数。</p>
<p>标签：贪心、动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 方法1：动态规划，正向遍历到达每一个位置需要的最少步数，时间复杂度On2</span><br><span class="line">    public static int jump(int[] nums) &#123;</span><br><span class="line">        int[] res = new int[nums.length];</span><br><span class="line">        for (int i = 1; i&lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt;= i nums[i] &amp;&amp; j &lt; nums.length; j++) &#123;</span><br><span class="line">                res[j] = Math.min(res[i] + 1, res[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[res.length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 方法2：贪心，反向查找出发位置，具体哪个位置跳最好需要从前往后遍历</span><br><span class="line">    // ps：因为不是固定步数跳，所以可行</span><br><span class="line">    public static int jump(int[] nums) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int pos = len - 1;</span><br><span class="line">        int step = 0;</span><br><span class="line">        while (pos &gt; 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                if (i nums[i] &gt;= pos) &#123;</span><br><span class="line">                    step += 1;</span><br><span class="line">                    pos = i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 方法3：贪心地正向查找，每次可到达的最远位置</span><br><span class="line">    public static int jump(int[] nums) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int end = 0; //边界</span><br><span class="line">        int maxPos = 0; //能到达的最远位置</span><br><span class="line">        int step = 0;</span><br><span class="line">        // 注意：遍历到最后元素的前一个就好</span><br><span class="line">        for (int i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            maxPos = Math.max(maxPos, nums[i] i);</span><br><span class="line">            // 到达边界了就需要走一步了，并且更新边界</span><br><span class="line">            if (i == end) &#123;</span><br><span class="line">                end = maxPos;</span><br><span class="line">                step ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="跳跃游戏3"><a href="#跳跃游戏3" class="headerlink" title="跳跃游戏3"></a>跳跃游戏3</h2><p>这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i arr[i] 或者 i - arr[i]。判断自己是否能够跳到对应元素值为 0 的 任一 下标处。</p>
<p>标签：深度优先搜索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 跳跃游戏3：可以左右跳跃，只能跳跃固定值，从给定开始位置，能不能跳到元素值为0的地方</span><br><span class="line">    // 深度优先搜索：DFS，可以用递归实现，也可以用栈实现</span><br><span class="line">    // 比如二叉树，向下遍历直到叶子节点，然后向上回溯，再向下遍历。用栈就是出栈和入栈。</span><br><span class="line">    public static boolean canReach(int[] nums, int start) &#123;</span><br><span class="line">        // 用一个数组表示是否访问过</span><br><span class="line">        boolean[] visit = new boolean[nums.length];</span><br><span class="line">        return dfs(nums, start, visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean dfs(int[] nums, int start, boolean[] visit) &#123;</span><br><span class="line">        if (start &lt; 0 || start &gt;= nums.length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果之前访问过，一定到不了</span><br><span class="line">        if (visit[start]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 出递归条件</span><br><span class="line">        if (nums[start] == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[start] = true;</span><br><span class="line">        return dfs(nums, start - nums[start], visit) || dfs(nums, start nums[start], visit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>这个题目要求打印出来。</p>
<p>标签：深度优先搜索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = new ArrayList();</span><br><span class="line">        int[] place = new int[n];</span><br><span class="line">        List&lt;int[]&gt; resList = new ArrayList();</span><br><span class="line">        int resNum = queueDfs(0, place, n, res);</span><br><span class="line">        for (int[] resPlace : resList) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(resPlace));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; print(int[] place) &#123;</span><br><span class="line">        List&lt;String&gt; ss = new ArrayList();</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int j = 0; j &lt; place.length; j++) &#123;</span><br><span class="line">            sb.append(&#x27;.&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int column : place) &#123;</span><br><span class="line">            // 这里也得新建一个</span><br><span class="line">            StringBuilder pre = new StringBuilder(sb);</span><br><span class="line">            pre.setCharAt(column, &#x27;Q&#x27;);</span><br><span class="line">            ss.add(pre.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // row代表第row行皇后的放置</span><br><span class="line">    private int queueDfs(int row, int[] place, int n, List&lt;List&lt;String&gt;&gt; resList) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if (row == n) &#123;</span><br><span class="line">            // 注意这里加入的是数组的引用，之后会变</span><br><span class="line">            resList.add(print(place));</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第row行可以放到第0到n-1列</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            if (isValid(row, place, i)) &#123;</span><br><span class="line">                place[row] = i;</span><br><span class="line">                res += queueDfs(row 1, place, n, resList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查第row行皇后放在column列有没有问题</span><br><span class="line">    private static boolean isValid(int row, int[] place, int column) &#123;</span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            if (place[i] == column || row - i == Math.abs(column - place[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(row &quot;:&quot; column &quot;:&quot; Arrays.toString(place));</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还有一种构建”…Q”字符串的方法，更优雅，用char数组创建String：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char[] row = new char[n];</span><br><span class="line">Arrays.fill(row, &#x27;.&#x27;);</span><br><span class="line">row[queens[i]] = &#x27;Q&#x27;;</span><br><span class="line">board.add(new String(row));</span><br></pre></td></tr></table></figure>

<h2 id="N皇后2"><a href="#N皇后2" class="headerlink" title="N皇后2"></a>N皇后2</h2><p>这个N皇后之需要给出有几种解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public static int totalNQueens(int n) &#123;</span><br><span class="line">        // 皇后问题，在于DFS，表现形式：int[] 表示每列上皇后的位置</span><br><span class="line">        int[] place = new int[n];</span><br><span class="line">        return queueDfs(0, place, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // column代表第row列的放置</span><br><span class="line">    private static int queueDfs(int column, int[] place, int n) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if (column == n) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第row列可以放到第0到n-1行</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            if (isValid(column, place, i)) &#123;</span><br><span class="line">                place[column] = i;</span><br><span class="line">                res += queueDfs(column 1, place, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查第column列皇后放在row行有没有问题</span><br><span class="line">    private static boolean isValid(int column, int[] place, int row) &#123;</span><br><span class="line">        for (int i = 0; i &lt; column; i++) &#123;</span><br><span class="line">            if (place[i] == row || column - i == Math.abs(row - place[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
<p>标签：DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class BracketAlgo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(generateBracket(3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 给出一个n，返回可能的括号组合</span><br><span class="line">    public static List&lt;String&gt; generateBracket(int n) &#123;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList();</span><br><span class="line">        String s = &quot;&quot;;</span><br><span class="line">        dfs(n, n, s, res);</span><br><span class="line">        return  res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 入参：剩余左括号数、剩余右括号数、当前String、结果</span><br><span class="line">    private static void dfs(int left, int right, String curStr, List&lt;String&gt; res) &#123;</span><br><span class="line">        // 出递归条件</span><br><span class="line">        if (left == 0 &amp;&amp; right == 0) &#123;</span><br><span class="line">            res.add(curStr);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 左括号还有就可以继续放左括号，剩余右括号大于剩余左括号，就可以放右括号</span><br><span class="line">        // 这里没有感觉有回溯呢，就感觉不需要回溯</span><br><span class="line">        if (left &gt; 0) &#123;</span><br><span class="line">            dfs(left - 1, right, curStr &quot;(&quot;, res);</span><br><span class="line">        &#125;</span><br><span class="line">        if (right &gt; left) &#123;</span><br><span class="line">            dfs(left, right - 1, curStr &quot;)&quot;, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
<p>标签：DFS、并查集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan.lee;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class IslandAlgo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char[][] lands = new char[][]&#123;&#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;&#125;;</span><br><span class="line">        System.out.println(islandNum(lands));</span><br><span class="line">        lands = new char[][]&#123;&#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;&#125;;</span><br><span class="line">        System.out.println(islandNum2(lands));</span><br><span class="line">        lands = new char[][]&#123;&#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;&#125;;</span><br><span class="line">        System.out.println(islandNum3(lands));</span><br><span class="line">        lands = new char[][]&#123;&#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;&#125;;</span><br><span class="line">        System.out.println(maxIsland(lands));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1表示陆地，0表示水，四周也是水，斜线相接的不是一座岛屿，返回总共有几个岛屿</span><br><span class="line">    // 方法一：DFS解法：</span><br><span class="line">    //遍历整个二维网格，当遇到一个岛屿（值为1）时，计数器加1，然后调用DFS函数，将相邻的岛屿都标记为已遍历（可以将其值置为0）。</span><br><span class="line">    //在DFS函数中，首先判断当前位置是否越界或者已经遍历过，如果是，直接返回。</span><br><span class="line">    //如果当前位置是岛屿，则将其值置为0，并递归调用DFS函数，分别向上、向下、向左、向右四个方向进行搜索。</span><br><span class="line">    //最后，返回计数器的值即为岛屿的数量。</span><br><span class="line">    public static int islandNum(char[][] lands) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; lands.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; lands[0].length; j++) &#123;</span><br><span class="line">                // 有一块陆地就表示一定是一个岛屿，只需要把周围的都变成水</span><br><span class="line">                // 递归的目的是将周围的陆地变为水，并且是在遍历下一块儿地之前</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    dfs(i, j, lands);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void dfs(int i, int j, char[][] lands) &#123;</span><br><span class="line">        // 越界则出递归</span><br><span class="line">        if (i &lt; 0 || i &gt;= lands.length || j &lt; 0 || j &gt;= lands[0].length) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 是水则出递归</span><br><span class="line">        if (lands[i][j] == &#x27;0&#x27;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 这里将陆地变为水，所以下面即使递归回到该位置也直接return了</span><br><span class="line">        lands[i][j] = &#x27;0&#x27;;</span><br><span class="line">        dfs(i - 1, j, lands);</span><br><span class="line">        dfs(i + 1, j, lands);</span><br><span class="line">        dfs(i, j - 1, lands);</span><br><span class="line">        dfs(i, j + 1, lands);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并查集，有点问题：不一定都是往左上角靠拢的，比如工字型，所以使用完整的并查集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public static int numIslands(char[][] lands) &#123;</span><br><span class="line">        // 1.首先初始化，用一个数组表示每个节点的根结点</span><br><span class="line">        int n = lands.length;</span><br><span class="line">        int m = lands[0].length;</span><br><span class="line">        int[] roots = new int[n * m];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    roots[i * m j] = i * m j;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.合并，往四个方向走，如果也是1的话就合并节点（将当前节点的根结点变为相邻节点的根结点），在合并的过程中就完成计数</span><br><span class="line">        int[][] directs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j ++) &#123;</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    for (int[] direct : directs) &#123;</span><br><span class="line">                        // 如果相邻也是1，且根结点不相同则进行合并：将相邻节点的根节点变为当前节点的根结点，这样向下向右遍历的时候，就不会再变原来的根结点了</span><br><span class="line">                        // 正常合并需要考虑节点深度，如果两个集合的深度不同，为了保持并查集的平衡性，应该将深度较小的集合合并到深度较大的集合上</span><br><span class="line">                        // 但是这里由于遍历的有序性，所以先遍历的深度大</span><br><span class="line">                        int newRow = i direct[0];</span><br><span class="line">                        int newColumn = j direct[1];</span><br><span class="line">                        if (newRow &lt; 0 || newRow &gt;= n || newColumn &lt; 0 || newColumn &gt;= m) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 这里还是由于遍历的有序性，找root，根结点一定是左上角的1</span><br><span class="line">                        if (lands[newRow][newColumn] == &#x27;1&#x27; &amp;&amp; roots[i * m j] != roots[newRow * m newColumn]) &#123;</span><br><span class="line">                            roots[newRow * m newColumn] = roots[i * m j];</span><br><span class="line">                            res --;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 并查集-规范完整版</span><br><span class="line">    public static int numIslands(char[][] lands) &#123;</span><br><span class="line">        // 1.首先初始化，用一个数组表示每个节点的根结点</span><br><span class="line">        int n = lands.length;</span><br><span class="line">        int m = lands[0].length;</span><br><span class="line">        // 记录节点的父节点</span><br><span class="line">        int[] parents = new int[n * m];</span><br><span class="line">        // 记录节点深度</span><br><span class="line">        int[] ranks = new int[n * m];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    parents[i * m j] = i * m j;</span><br><span class="line">                    ranks[i * m j] = 0;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.合并，往四个方向走，如果也是1的话就合并节点（将当前节点的根结点变为相邻节点的根结点），在合并的过程中就完成计数</span><br><span class="line">        int[][] directs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j ++) &#123;</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    int curRoot = find(parents, i * m j);</span><br><span class="line">                    for (int[] direct : directs) &#123;</span><br><span class="line">                        int newRow = i direct[0];</span><br><span class="line">                        int newColumn = j direct[1];</span><br><span class="line">                        if (newRow &lt; 0 || newRow &gt;= n || newColumn &lt; 0 || newColumn &gt;= m || lands[newRow][newColumn] == &#x27;0&#x27;) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        int newRoot = find(parents, newRow * m newColumn);</span><br><span class="line">                        if (curRoot != newRoot) &#123;</span><br><span class="line">                            System.out.println(&quot;cur:&quot; i &quot;-&quot; j &quot;:&quot; curRoot &quot;===&quot; &quot;new:&quot; newRow &quot;-&quot; newColumn &quot;:&quot; newRoot);</span><br><span class="line">//                            System.out.println(&quot;curRanks:&quot; ranks[i * m j] &quot;===&quot; &quot;newRanks:&quot; ranks[newRow * m newColumn]);</span><br><span class="line">                            // 深度小的往深度大的合并，提高查找根结点的效率</span><br><span class="line">                            // 将rank较小的根节点指向rank较大的根节点，以保持树的平衡。如果两个根节点的rank相同，则可以将其中一个根节点作为另一个根节点的子节点，并将rank增加1。</span><br><span class="line">                            if (ranks[i * m j] &lt; ranks[newRow * m newColumn]) &#123;</span><br><span class="line">                                // 当前节点深度小：将深度较小的根节点合并到深度较大的根节点上</span><br><span class="line">                                parents[curRoot] = newRoot;</span><br><span class="line">                            &#125; else if (ranks[i * m j] &gt; ranks[newRow * m newColumn])&#123;</span><br><span class="line">                                parents[newRoot] = curRoot;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                parents[newRoot] = curRoot;</span><br><span class="line">                                ranks[i * m j] ++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            res --;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int find(int[] parents, int k) &#123;</span><br><span class="line">        // 根结点的父节点是自己</span><br><span class="line">        if (parents[k] == k) &#123;</span><br><span class="line">            return k;</span><br><span class="line">        &#125;</span><br><span class="line">        return find(parents, parents[k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 岛屿的最大面积</span><br><span class="line">    // ps：将area作为参数传递时，int不行、Integer也不行、返回出去需要在连续四个dfs上加上返回再传入下一个</span><br><span class="line">    // 用一个全局变量表示area比较好</span><br><span class="line">    public static int maxAreaOfIsland(int[][] lands) &#123;</span><br><span class="line">        // 和获取数量一样，递归，但是同时记录岛屿最大面积</span><br><span class="line">        int maxArea = 0;</span><br><span class="line">        for (int i = 0; i &lt; lands.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; lands[0].length; j++) &#123;</span><br><span class="line">                if (lands[i][j] == 1) &#123;</span><br><span class="line">                    int area = dfs(lands, i , j, 0);</span><br><span class="line">                    maxArea = Math.max(area, maxArea);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int dfs(int[][] lands, int i, int j, int area) &#123;</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;= lands.length || j &gt;= lands[0].length) &#123;</span><br><span class="line">            return area;</span><br><span class="line">        &#125;</span><br><span class="line">        if (lands[i][j] == 0) &#123;</span><br><span class="line">            return area;</span><br><span class="line">        &#125;</span><br><span class="line">        lands[i][j] = 0;</span><br><span class="line">        area += 1;</span><br><span class="line">        area = dfs(lands, i - 1, j, area);</span><br><span class="line">        area = dfs(lands, i + 1, j, area);</span><br><span class="line">        area = dfs(lands, i, j - 1, area);</span><br><span class="line">        area = dfs(lands, i, j + 1, area);</span><br><span class="line">        return area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h2><p>有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p>
<p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p>输入：nums = [1,5]<br>输出：10</p>
<p>标签：深度优先搜索、动态规划</p>
<p>超出时间限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 戳气球：一组数代表气球的值，戳一个气球收益是左气球*自己*右气球，戳破后左右两个变为相邻的，求最大收益</span><br><span class="line">    // 方法一：深度优先搜索，到最后一个气球时记录收益记录下来，最后对比最大值</span><br><span class="line">    public static int maxCoins(int[] nums) &#123;</span><br><span class="line">        // 注意：List是一个对象类型的集合，需要用Integer</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return dfs(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int dfs(List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (list.size() == 0) return 0;</span><br><span class="line">        // 在哪里取最大值：在这里取，因为这里就是最终的最大值</span><br><span class="line">        int max = 0;</span><br><span class="line">        int left, cur, right;</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            left = i == 0 ? 1 : list.get(i - 1);</span><br><span class="line">            right = i == list.size() - 1 ? 1 : list.get(i + 1);</span><br><span class="line">            cur = list.get(i);</span><br><span class="line">            // 这里会报warning：再循环中修改List，可以使用一个临时List，每次传入临时List</span><br><span class="line">            list.remove(i);</span><br><span class="line">            max = Math.max(left * cur * right dfs(list), max);</span><br><span class="line">            list.add(i, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个不对的DFS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 方法二：另一个深度优先搜索，上一个是先戳破再递归计算剩下的，这里可以先拆开计算左右的再加起来</span><br><span class="line">    // 这样的好处是：List没有被破坏，只需给个边界</span><br><span class="line">    // !!! 这个方法不对，忽略了气球戳破后两边气球就变成相邻气球的事实</span><br><span class="line">    private static int maxProfit2(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return dfs2(list, 0, nums.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int dfs2(List&lt;Integer&gt; list, int left, int right) &#123;</span><br><span class="line">        if (left == right) return 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        int l, r, cur;</span><br><span class="line">        for (int i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            l = i == 0 ? 1 : list.get(i - 1);</span><br><span class="line">            r = i == list.size() - 1 ? 1 : list.get(i + 1);</span><br><span class="line">            cur = list.get(i);</span><br><span class="line">            int profit = l * cur * r dfs2(list, left, i - 1) dfs2(list, i + 1, right);</span><br><span class="line">            max = Math.max(max, profit);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正确的动态规划：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 方法三：动态规划</span><br><span class="line">    // 1.定义数据 2.初始化 3.状态转移</span><br><span class="line">    // 两边各加一个辅助气球，是1，用k表示最后戳破的气球</span><br><span class="line">    // dp[i][j]表示戳破i-j区间内气球获得的收益，两边是包含辅助气球的，辅助气球不戳破</span><br><span class="line">    // 因此：状态转移：dp[i][j] = Math.max(dp[i][j], dp[i][k] dp[k][j] list[k] * list[i] * [j])</span><br><span class="line">    // 注意：k是最后戳破的，所以乘以最两边的辅助气球</span><br><span class="line">    // 辅助气球不戳破，所以这样拆分之后k是辅助气球，为两边算收益用，但本身不被戳破</span><br><span class="line">    // Max的过程是在选最后戳破哪个气球的过程中选择的</span><br><span class="line">    // 因为该状态方程，所以长度短的应该先算好，所以最外层循环为长度</span><br><span class="line">    public static int maxCoins(int[] nums) &#123;</span><br><span class="line">        // 定义数据</span><br><span class="line">        int len =nums.length 2;</span><br><span class="line">        int[][] dp = new int[len][len];</span><br><span class="line">        int[] arr = new int[len];</span><br><span class="line">        arr[0] = 1;</span><br><span class="line">        arr[len - 1] = 1;</span><br><span class="line">        System.arraycopy(nums, 0, arr, 1, len - 2);</span><br><span class="line">        // 初始化，因为在状态转移过程中会取值，所以为0就好</span><br><span class="line">        // 一层循环为长度，最小长度为3，两边是辅助气球</span><br><span class="line">        for (int l = 3; l &lt;= len; l ++) &#123;</span><br><span class="line">            // 二层循环为开始位置</span><br><span class="line">            for (int i = 0; i &lt;= len - l; i ++) &#123;</span><br><span class="line">                // 结束位置</span><br><span class="line">                int j = i l - 1;</span><br><span class="line">                // 最后戳破气球的位置k</span><br><span class="line">                for (int k = i + 1; k &lt; j; k ++) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], arr[i] * arr[k] * arr[j] dp[i][k] dp[k][j]);</span><br><span class="line">                    // 为什么不能正向先戳破k？</span><br><span class="line">                    // 因为戳破之后k就不存在了，所以不能在算两边时加k而是加k左右两边的，是一个k断开的状态</span><br><span class="line">                    // 最后戳破k就可以用k算两边，因为算完两边最后才戳破k</span><br><span class="line">//                    dp[i][j] = Math.max(dp[i][j], arr[k] * arr[k - 1] * arr[k 1] dp[i][k] dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][len - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a>省份数量</h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>
<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<p>标签：并查集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private static int num;</span><br><span class="line">    </span><br><span class="line">    // 省份数量</span><br><span class="line">    // 输入n*n，nums[i][j]表示i和j相连</span><br><span class="line">    // 返回有多少不相连的城市群</span><br><span class="line">    public static int findCircleNum(int[][] nums) &#123;</span><br><span class="line">        // 1.初始化</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int[] parents = new int[len];</span><br><span class="line">        int[] ranks = new int[len];</span><br><span class="line">        num = len;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">            ranks[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.合并</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">                if (nums[i][j] == 0) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                union(parents, ranks, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void union(int[] parents, int[] ranks, int i, int j) &#123;</span><br><span class="line">        int iRoot = find(parents, i);</span><br><span class="line">        int jRoot = find(parents, j);</span><br><span class="line">        if (iRoot == jRoot) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ranks[i] &gt; ranks[j]) &#123;</span><br><span class="line">            parents[jRoot] = iRoot;</span><br><span class="line">        &#125; else if (ranks[i] &lt; ranks[j]) &#123;</span><br><span class="line">            parents[iRoot] = jRoot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parents[iRoot] = jRoot;</span><br><span class="line">            ranks[j] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        num --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int find(int[] parents, int k) &#123;</span><br><span class="line">        if (parents[k] == k) &#123;</span><br><span class="line">            return k;</span><br><span class="line">        &#125;</span><br><span class="line">        return find(parents, parents[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统计无向图中无法互相到达点数量"><a href="#统计无向图中无法互相到达点数量" class="headerlink" title="统计无向图中无法互相到达点数量"></a>统计无向图中无法互相到达点数量</h2><p>给你一个整数 n ，表示一张 无向图 中有 n 个节点，编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。</p>
<p>请你返回 无法互相到达 的不同 点对数目 。</p>
<p>标签：并查集、DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 统计无向图中无法互相到达的点对数</span><br><span class="line">    // 输入：总共多少个点、点与点间无向边</span><br><span class="line">    // 输出：总共多少不连接的点组合</span><br><span class="line">    // 超出时间限制：因为获取结果双层循环，可以简化</span><br><span class="line">    public static long countPairs(int n, int[][] edges) &#123;</span><br><span class="line">        // 1.初始化</span><br><span class="line">        int[] parents = new int[n];</span><br><span class="line">        // 这里不用ranks表示深度，而是用sizes表示以x为根结点所在树的顶点数</span><br><span class="line">        int[] sizes = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">            sizes[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.合并</span><br><span class="line">        for (int[] edge : edges) &#123;</span><br><span class="line">            union(parents, sizes, edge[0], edge[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 3.获取结果</span><br><span class="line">        long res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            res += n - sizes[find(parents, i)];</span><br><span class="line">        &#125;</span><br><span class="line">        // 注意：上面是每个节点与几个节点不相连，算两遍了</span><br><span class="line">        return res / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void union(int[] parents, int[] sizes, int i, int j) &#123;</span><br><span class="line">        int iRoot = find(parents, i);</span><br><span class="line">        int jRoot = find(parents, j);</span><br><span class="line">        if (iRoot == jRoot) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sizes[i] &gt; sizes[j]) &#123;</span><br><span class="line">            // j应该往i合并，j的节点数给到i</span><br><span class="line">            parents[jRoot] = iRoot;</span><br><span class="line">            sizes[iRoot] += sizes[jRoot];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // i应该往j合并，i的节点数给到j</span><br><span class="line">            parents[iRoot] = jRoot;</span><br><span class="line">            sizes[jRoot] += sizes[iRoot];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int find(int[] parents, int k) &#123;</span><br><span class="line">        if (parents[k] == k) &#123;</span><br><span class="line">            return k;</span><br><span class="line">        &#125;</span><br><span class="line">        return find(parents, parents[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DFS:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public static int countPairs(int n, int[][] edges) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            graph.add(new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        // 构建图的邻接表，存储直接连接的节点</span><br><span class="line">        for (int[] edge : edges) &#123;</span><br><span class="line">            graph.get(edge[0]).add(edge[1]);</span><br><span class="line">            graph.get(edge[1]).add(edge[0]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean[] visited = new boolean[n];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (!visited[i]) &#123;</span><br><span class="line">                int count = dfs(graph, i, visited);</span><br><span class="line">                // 结果要不连通的节点对数，对于该簇，count个点相互联通，这样算会算两次</span><br><span class="line">                res += count * (n - count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 通过DFS得到该节点联通的节点数（一个簇的节点数）</span><br><span class="line">    private static int dfs(List&lt;List&lt;Integer&gt;&gt; graph, int node, boolean[] visited) &#123;</span><br><span class="line">        visited[node] = true;</span><br><span class="line">        int count = 1;</span><br><span class="line">        for (int neighbor : graph.get(node)) &#123;</span><br><span class="line">            if (!visited[neighbor]) &#123;</span><br><span class="line">                count += dfs(graph, neighbor, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿的周长"><a href="#岛屿的周长" class="headerlink" title="岛屿的周长"></a>岛屿的周长</h2><p>标签：DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 岛屿的周长：只有一个岛屿，并且岛屿内部没有湖</span><br><span class="line">    // 使用DFS的方法，for循环遍历到第一个陆地，然后开始DFS，将lands元素置为2表示遍历过了</span><br><span class="line">    public static int islandPerimeter(int[][] lands) &#123;</span><br><span class="line">        for (int i = 0; i &lt; lands.length; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; lands[0].length; j ++) &#123;</span><br><span class="line">                if (lands[i][j] == 1) &#123;</span><br><span class="line">                    return lengthDfs(lands, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int lengthDfs(int[][] lands, int i, int j) &#123;</span><br><span class="line">        // 边界或遇到水周长+1</span><br><span class="line">        if (i &lt; 0 || i &gt;= lands.length || j &lt; 0 || j &gt;= lands[0].length || lands[i][j] == 0) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (lands[i][j] == 2) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        lands[i][j] = 2;</span><br><span class="line">        return lengthDfs(lands, i-1, j) lengthDfs(lands, i+1, j) lengthDfs(lands, i, j-1) lengthDfs(lands, i, j+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="衣橱整理-机器人的运动范围"><a href="#衣橱整理-机器人的运动范围" class="headerlink" title="衣橱整理/机器人的运动范围"></a>衣橱整理/机器人的运动范围</h2><p>家居整理师将待整理衣橱划分为 m x n 的二维矩阵 grid，其中 grid[i][j] 代表一个需要整理的格子。整理师自 grid[0][0] 开始 逐行逐列 地整理每个格子。</p>
<p>整理规则为：在整理过程中，可以选择 向右移动一格 或 向下移动一格，但不能移动到衣柜之外。同时，不需要整理 digit(i) digit(j) &gt; cnt 的格子，其中 digit(x) 表示数字 x 的各数位之和。</p>
<p>请返回整理师 总共需要整理多少个格子。</p>
<p>输入：m = 4, n = 7, cnt = 5<br>输出：18</p>
<p>标签：DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 机器人的运动范围</span><br><span class="line">    // 输入：m行、n列的格子，机器人从[0][0]开始移动，每次只能移动一格，但是不能到格子数位之和为k的格子。</span><br><span class="line">    // 返回：能到几个格子</span><br><span class="line">    public static int wardrobeFinishing(int m, int n, int k) &#123;</span><br><span class="line">        int[][] lands = new int[m][n];</span><br><span class="line">        dfs(lands, 0 , 0, k);</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (lands[i][j] == 1) res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不能直接返回？因为初次到达的应该返回1，但是还得往下遍历不能return</span><br><span class="line">    private static void dfs(int[][] lands, int i, int j, int k) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= lands.length || j &lt; 0 || j &gt;= lands[0].length || lands[i][j] == 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!checkValid(i, j, k)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 可以到达置为1</span><br><span class="line">        lands[i][j] = 1;</span><br><span class="line">        dfs(lands, i+1, j, k);</span><br><span class="line">        dfs(lands, i-1, j, k);</span><br><span class="line">        dfs(lands, i, j-1, k);</span><br><span class="line">        dfs(lands, i, j+1, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean checkValid(int i, int j, int k) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while (i &gt; 0) &#123;</span><br><span class="line">            sum += i % 10;</span><br><span class="line">            i = i / 10;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &gt; 0) &#123;</span><br><span class="line">            sum += j % 10;</span><br><span class="line">            j = j / 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>标签：DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 单词搜索</span><br><span class="line">    // 输入：一个字符矩阵，一个单词</span><br><span class="line">    // 输出：水平两连和垂直相连，可以拐弯，能否找到这个单词</span><br><span class="line">    // 解法：DFS，dfs起点：每个点；dfs需要携带的：匹配上的字符长度；dfs出口：字符不一样/字符长度达到</span><br><span class="line">    // 已经用过的字母不能再用：向下一个递归之前变为其他字符，递归完之后再变回来</span><br><span class="line">    public static boolean exist(char[][] words, String s) &#123;</span><br><span class="line">        for (int i = 0; i &lt; words.length; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; words[0].length; j ++) &#123;</span><br><span class="line">                if (dfs(words, i, j, 0, s)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean dfs(char[][] words, int i, int j, int k, String s) &#123;</span><br><span class="line">        if (s.length() == k) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;= words.length || j &lt; 0 || j &gt;= words[0].length || words[i][j] != s.charAt(k)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        k ++;</span><br><span class="line">        char pre = words[i][j];</span><br><span class="line">        words[i][j] = &#x27; &#x27;;</span><br><span class="line">        boolean one = dfs(words, i + 1, j, k, s);</span><br><span class="line">        boolean two = dfs(words, i - 1, j, k, s);</span><br><span class="line">        boolean three = dfs(words, i, j + 1, k, s);</span><br><span class="line">        boolean four = dfs(words, i, j - 1, k, s);</span><br><span class="line">        words[i][j] = pre;</span><br><span class="line">        return one || two || three || four;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h2><p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：</p>
<p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。</p>
<p>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p>
<p>标签：BFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 腐烂的橘子</span><br><span class="line">    // 输入：0空 1新鲜 2腐烂，每一分钟腐烂橘子向四周扩散</span><br><span class="line">    // 输出：几分钟可以全部腐烂</span><br><span class="line">    // 广度优先搜索：使用一个队列Queue或者双向队列Deque，先将第一层节点放到队列里，然后while循环中poll出来，每poll一个就把它的下一层节点offer进去</span><br><span class="line">    public static int orangesRotting(int[][] oranges) &#123;</span><br><span class="line">        // 1.将第一层烂橘子加入队列，统计好橘子个数</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        int freshNum = 0;</span><br><span class="line">        for (int i = 0; i &lt; oranges.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; oranges[0].length; j++) &#123;</span><br><span class="line">                if (oranges[i][j] == 2) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                &#125; else if (oranges[i][j] == 1) &#123;</span><br><span class="line">                    freshNum ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] directs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">        int res = 0;</span><br><span class="line">        // 2.一层一层BFS</span><br><span class="line">        // 需要增加freshNum &gt; 0，不然最后一层之后还会遍历一下</span><br><span class="line">        while (!queue.isEmpty() &amp;&amp; freshNum &gt; 0) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">                int[] cur = queue.poll();</span><br><span class="line">                int row = cur[0];</span><br><span class="line">                int column = cur[1];</span><br><span class="line">                for (int[] direct : directs) &#123;</span><br><span class="line">                    int newRow = row direct[0];</span><br><span class="line">                    int newColumn = column direct[1];</span><br><span class="line">                    if (newRow &gt;= 0 &amp;&amp; newRow &lt; oranges.length &amp;&amp; newColumn &gt;= 0 &amp;&amp; newColumn &lt; oranges[0].length &amp;&amp; oranges[newRow][newColumn] == 1) &#123;</span><br><span class="line">                        queue.offer(new int[]&#123;newRow, newColumn&#125;);</span><br><span class="line">                        freshNum --;</span><br><span class="line">                        oranges[newRow][newColumn] = 2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return freshNum == 0 ? res : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小基因变化"><a href="#最小基因变化" class="headerlink" title="最小基因变化"></a>最小基因变化</h2><p>基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 ‘A’、’C’、’G’ 和 ‘T’ 之一。</p>
<p>假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p>
<p>另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 bank 中）</p>
<p>给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。</p>
<p>注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。</p>
<p>标签：BFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 最小基因变化</span><br><span class="line">    // 八个字符的字符串，并且字符只能是ACGT，每次基因变化只能改变一个字符，并且必须得是基因库里的</span><br><span class="line">    // 问最少需要几次基因变化，有的字符不能直接变过去，需要bank里的中转一下 123-145，123-163-165-145</span><br><span class="line">    // 最少需要几次这种问题，就是几层，自然是广度优先遍历</span><br><span class="line">    // 深度优先遍历行不行？我认为也行，类似与单词搜索，但是需要遍历完所有符合要求的end，然后求最少次数，时间复杂度高了</span><br><span class="line">    public int minMutation(String startGene, String endGene, String[] bank) &#123;</span><br><span class="line">        // 1.将第一个放入队列</span><br><span class="line">        char[] chars = new char[]&#123;&#x27;A&#x27;, &#x27;C&#x27;, &#x27;G&#x27;, &#x27;T&#x27;&#125;;</span><br><span class="line">        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(startGene);</span><br><span class="line">        int res = 0;</span><br><span class="line">        // 如果将char数组（char[]）作为HashSet或HashMap的键（key），那么只有当两个char数组是相同的对象引用时，才会被视为相同的键。两个具有相同元素的char数组，即使它们的元素内容相同，但是不是同一个对象引用，仍然被视为不同的键。</span><br><span class="line">        // 这里注意，需要使用String</span><br><span class="line">        Set&lt;String&gt; bankSet = new HashSet&lt;&gt;(Arrays.asList(bank));</span><br><span class="line">        // 以及遍历过的不能再遍历，Set记录</span><br><span class="line">        Set&lt;String&gt; visitedSet = new HashSet&lt;&gt;();</span><br><span class="line">        visitedSet.add(startGene);</span><br><span class="line">        // 2.开始while广度遍历</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">                String gene = queue.poll();</span><br><span class="line">                if (gene.equals(endGene)) &#123;</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;</span><br><span class="line">                // 遍历下层节点</span><br><span class="line">                char[] geneChars = gene.toCharArray();</span><br><span class="line">                for (int index = 0; index &lt; geneChars.length; index ++) &#123;</span><br><span class="line">                    char originChar = geneChars[index];</span><br><span class="line">                    for (char c : chars) &#123;</span><br><span class="line">                        if (c == originChar) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        geneChars[index] = c;</span><br><span class="line">                        String pre = new String(geneChars);</span><br><span class="line">                        //拷贝char[] : System.arraycopy(gene, 0, pre, 0, gene.length);</span><br><span class="line">                        if (bankSet.contains(pre) &amp;&amp; !visitedSet.contains(pre)) &#123;</span><br><span class="line">                            queue.offer(pre);</span><br><span class="line">                            visitedSet.add(pre);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    geneChars[index] = originChar;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙</h2><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk：</p>
<p>每一对相邻的单词只差一个字母。<br> 对于 1 &lt;= i &lt;= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。<br>sk == endWord<br>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。</p>
<p>标签：BFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 单词接龙</span><br><span class="line">    // wordList是从startWord到endWord的转换序列，每次只能变一个字母，endWord需要在转换序列里</span><br><span class="line">    // 返回：最短转换序列中的单词数目</span><br><span class="line">    // 怎么从wordList中获取可以变的word？</span><br><span class="line">    public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        if (!wordList.contains(endWord)) return 0;</span><br><span class="line">        // 1.定义队列，放入第一个</span><br><span class="line">        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line">        int res = 1;</span><br><span class="line">        // 2.遍历队列</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">                String word = queue.poll();</span><br><span class="line">                if (word.equals(endWord)) return res;</span><br><span class="line">                for (String other : wordList) &#123;</span><br><span class="line">                    if (!visited.contains(other) &amp;&amp; checkWord(word, other)) &#123;</span><br><span class="line">                        queue.offer(other);</span><br><span class="line">                        visited.add(other);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean checkWord(String s1, String s2) &#123;</span><br><span class="line">        if (s1.length() != s2. length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int diffNum = 0;</span><br><span class="line">        for (int i = 0; i &lt; s1.length(); i ++) &#123;</span><br><span class="line">            if (s1.charAt(i) != s2.charAt(i)) diffNum ++;</span><br><span class="line">            if (diffNum &gt; 1) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏4"><a href="#跳跃游戏4" class="headerlink" title="跳跃游戏4"></a>跳跃游戏4</h2><p>给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。</p>
<p>每一步，你可以从下标 i 跳到下标 i + 1 、i - 1 或者 j ：</p>
<p>i + 1 需满足：i + 1 &lt; arr.length<br>i - 1 需满足：i - 1 &gt;= 0<br>j 需满足：arr[i] == arr[j] 且 i != j<br>请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。</p>
<p>注意：任何时候你都不能跳到数组外面。</p>
<p>标签：BFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 跳跃游戏4</span><br><span class="line">    // 从index=0开始，每次能前后跳一步，或者跳到arr[i] == arr[j]的位置</span><br><span class="line">    // 返回到达数组最后一个元素的下标处所需的最少操作次数</span><br><span class="line">    public int minJumps(int[] arr) &#123;</span><br><span class="line">        // 1.初始化，第一个点加入队列</span><br><span class="line">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(0);</span><br><span class="line">        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();</span><br><span class="line">        visited.add(0);</span><br><span class="line">        int res = 0;</span><br><span class="line">        // 2.while循环</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">                Integer index = queue.poll();</span><br><span class="line">                if (index == arr.length - 1) return res;</span><br><span class="line">                for (int j = 0; j &lt; arr.length; j ++) &#123;</span><br><span class="line">                    if (visited.contains(j)) continue;</span><br><span class="line">                    if (arr[j] == arr[index] || j == index - 1 || j == index 1) &#123;</span><br><span class="line">                        queue.offer(j);</span><br><span class="line">                        visited.add(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合总和1（元素无重复可重选）"><a href="#组合总和1（元素无重复可重选）" class="headerlink" title="组合总和1（元素无重复可重选）"></a>组合总和1（元素无重复可重选）</h2><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>标签：DFS回溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    </span><br><span class="line">    // 组合总和</span><br><span class="line">    // 输入：无重复元素的整数数组、目标整数</span><br><span class="line">    // 输出：所有组合，数组中的数可重复使用</span><br><span class="line">    // 常规DFS回溯</span><br><span class="line">    // 注意：1.每次add nums时，需要add副本；2.需要传start索引，因为找到后面的就不需要再往前找了。</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        // 1.初始化，排个序（实际上这个例子中不需要排序）</span><br><span class="line">        // Arrays.sort(candidates);</span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(candidates, target, 0, new ArrayList&lt;&gt;(), 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[] candidates, int target, int sum, List&lt;Integer&gt; nums, int start) &#123;</span><br><span class="line">        if (sum &gt; target) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(nums)); // 需要添加nums的副本</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            nums.add(candidates[i]);</span><br><span class="line">            dfs(candidates, target, sum candidates[i], nums, i); // 传递当前索引i作为下一次递归的start</span><br><span class="line">            nums.remove(nums.size() - 1); // 回溯移除最后一个元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合总和2（元素重复不可重选）"><a href="#组合总和2（元素重复不可重选）" class="headerlink" title="组合总和2（元素重复不可重选）"></a>组合总和2（元素重复不可重选）</h2><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用 一次 。</p>
<p>注意：解集不能包含重复的组合。 </p>
<p>标签：DFS回溯 剪枝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res2;</span><br><span class="line">    // 组合总和2</span><br><span class="line">    // 输入：可重复元素的整数数组、目标整数</span><br><span class="line">    // 输出：所有组合，数组中的数不可重复使用</span><br><span class="line">    // 常规DFS回溯</span><br><span class="line">    // 注意：1.每次add nums时，需要add副本；2.需要传start索引，因为找到后面的就不需要再往前找了。</span><br><span class="line">    // 返回的结果里不能包含重复的组合，元素值重复，但是元素不能重复使用，一样值的不同元素可以用</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">        // 1.初始化，排序也行，不排序也行。排序可以在横向循环遍历时发现大了就break，而不往下DFS，上面那个例子也是</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        System.out.println(Arrays.toString(candidates));</span><br><span class="line">        res2 = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs2(candidates, target, 0, 0, new ArrayList&lt;&gt;());</span><br><span class="line">        return res2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs2(int[] candidates, int target, int sum, int start, List&lt;Integer&gt; nums) &#123;</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            res2.add(new ArrayList&lt;&gt;(nums));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            if (sum candidates[i] &gt; target) break; //剪枝</span><br><span class="line">            // 关键：后面元素一样的话，就continue，这是横向的，因为比如111，target为2，用前面两个11就行，后面就不用遍历了</span><br><span class="line">            if (i &gt; start &amp;&amp; candidates[i] == candidates[i- 1]) &#123;</span><br><span class="line">                System.out.println(candidates[i]);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            nums.add(candidates[i]);</span><br><span class="line">            dfs2(candidates, target, sum candidates[i], i + 1, nums);</span><br><span class="line">            nums.remove(nums.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合总和3（k个数和为n）"><a href="#组合总和3（k个数和为n）" class="headerlink" title="组合总和3（k个数和为n）"></a>组合总和3（k个数和为n）</h2><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>
<p>标签：DFS回溯 只传leftNum</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 组合总和3</span><br><span class="line">    // 找出所有相加之和为n的k个数的组合，数字1-9，每个数字最多只用一次</span><br><span class="line">    // 技巧：迭代中只传剩下的n、剩下的k就好了。</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; res3;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        res3 = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs3(n, k, 1, new ArrayList&lt;&gt;());</span><br><span class="line">        return res3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs3(int leftNum, int leftK, int start, List&lt;Integer&gt; nums) &#123;</span><br><span class="line">        if (leftNum &lt; 0 || leftK &lt; 0) return;</span><br><span class="line">        if (leftNum == 0 &amp;&amp; leftK == 0) &#123;</span><br><span class="line">            res3.add(new ArrayList&lt;&gt;(nums));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt;= 9; i ++) &#123;</span><br><span class="line">            nums.add(i);</span><br><span class="line">            dfs3(leftNum - i, leftK - 1, i + 1, nums);</span><br><span class="line">            nums.remove(nums.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>标签：DFS+回溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 手机号码的组合</span><br><span class="line">    // 手机九宫格键盘 2-9分别对应几个字符，返回一串数字的所有字母组合</span><br><span class="line">    private List&lt;String&gt; res4;</span><br><span class="line">    private String[] letters = new String[]&#123;&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    // 手机号码的组合</span><br><span class="line">    // 手机九宫格键盘 2-9分别对应几个字符，返回一串数字的所有字母组合</span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        res4 = new ArrayList&lt;&gt;();</span><br><span class="line">        if (digits.equals(&quot;&quot;)) return res4;</span><br><span class="line">        dfs4(0, digits, new ArrayList&lt;&gt;());</span><br><span class="line">        return res4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs4(int index, String digits, List&lt;Character&gt; chars) &#123;</span><br><span class="line">        if (index == digits.length()) &#123;</span><br><span class="line">            String s = chars.stream().map(String :: valueOf).collect(Collectors.joining());</span><br><span class="line">            res4.add(s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String letter = letters[digits.charAt(index) - &#x27;2&#x27;];</span><br><span class="line">        for (int i = 0; i &lt; letter.length(); i ++) &#123;</span><br><span class="line">            chars.add(letter.charAt(i));</span><br><span class="line">            dfs4(index 1, digits, chars);</span><br><span class="line">            chars.remove(chars.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p>
<p>输入：s = “aab”<br>输出：[[“a”,”a”,”b”],[“aa”,”b”]]</p>
<p>标签：分割问题 DFS+回溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    // 分割回文串</span><br><span class="line">    // 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案</span><br><span class="line">    // 解法：DFS+回溯，要传start记录切割位置，for横向遍历，dfs纵向遍历</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(s, 0, new ArrayList&lt;&gt;());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(String s, int start, List&lt;String&gt; track) &#123;</span><br><span class="line">        if (start == s.length()) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt; s. length(); i ++) &#123;</span><br><span class="line">            if (isHuiWen(s, start, i)) &#123;</span><br><span class="line">                track.add(s.substring(start, i + 1));</span><br><span class="line">                dfs(s, i + 1, track);</span><br><span class="line">                track.remove(track.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isHuiWen(String s, int start, int end) &#123;</span><br><span class="line">        while(start &lt; end) &#123;</span><br><span class="line">            if (s.charAt(start) != s.charAt(end)) return false;</span><br><span class="line">            start ++;</span><br><span class="line">            end --;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复原-IP-地址"><a href="#复原-IP-地址" class="headerlink" title="复原 IP 地址"></a>复原 IP 地址</h2><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#x39;&#50;&#46;&#49;&#x36;&#56;&#64;&#x31;&#46;&#x31;">&#x31;&#x39;&#50;&#46;&#49;&#x36;&#56;&#64;&#x31;&#46;&#x31;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>
<p>标签：切割问题 DFS+回溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 复原IP地址</span><br><span class="line">    // 输入一串数字，返回可能的IP地址，如0.1.255.23</span><br><span class="line">    private List&lt;String&gt; ipList;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        ipList = new ArrayList&lt;&gt;();</span><br><span class="line">        if (s.length() &gt; 12) return ipList;</span><br><span class="line">        dfs2(s, 0, new ArrayList&lt;&gt;());</span><br><span class="line">        return ipList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs2(String s, int start, List&lt;String&gt; track) &#123;</span><br><span class="line">        if (track.size() == 4 &amp;&amp; start == s. length()) &#123;</span><br><span class="line">            String ip = String.join(&quot;.&quot;, track);</span><br><span class="line">            ipList.add(ip);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (track.size() == 4) return;</span><br><span class="line">        for (int i = start; i &lt; s. length(); i ++) &#123;</span><br><span class="line">            String ss = s.substring(start, i + 1);</span><br><span class="line">            if (isRightIp(ss)) &#123;</span><br><span class="line">                track.add(ss);</span><br><span class="line">                dfs2(s, i + 1, track);</span><br><span class="line">                track.remove(track.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isRightIp(String s) &#123;</span><br><span class="line">        if (s.length() == 1) return true;</span><br><span class="line">        if (s.charAt(0) == &#x27;0&#x27;) return false;</span><br><span class="line">        long num = Long.parseLong(s);</span><br><span class="line">        return num &lt; 256;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p>输入：nums = [1,2,3]<br>输出：<code>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></p>
<p>标签：DFS+回溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 子集</span><br><span class="line">    // 给定一个int[]，返回它的子集，包括[]，不能重复.</span><br><span class="line">    // 给定的数组中，就没重复的，没重复的就不用排序</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">        //Arrays.sort(nums);</span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums, 0, new ArrayList&lt;&gt;());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int[] nums, int start, List&lt;Integer&gt; track) &#123;</span><br><span class="line">        res.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">        for (int i = start; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            dfs(nums, i + 1, track);</span><br><span class="line">            track.remove(track.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子集2"><a href="#子集2" class="headerlink" title="子集2"></a>子集2</h2><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p>
<p>输入：nums = [1,2,2]<br>输出：<code>[[],[1],[1,2],[1,2,2],[2],[2,2]]</code></p>
<p>标签：DFS+回溯+剪枝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 子集2：输入可能包含重复元素了</span><br><span class="line">    // 只需要增加一个横向的去重</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; res2;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        res2 = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs2(nums, 0, new ArrayList&lt;&gt;());</span><br><span class="line">        return res2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs2(int[] nums, int start, List&lt;Integer&gt; track) &#123;</span><br><span class="line">        res2.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">        for (int i = start; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            dfs2(nums, i + 1, track);</span><br><span class="line">            track.remove(track.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<p>输入：nums = [4,6,7,7]<br>输出：<code>[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</code></p>
<p>标签：DFS+回溯+剪枝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 递增子序列</span><br><span class="line">    // 输入一个整数数组，返回所有的递增子序列，相同也算递增，子序列不需要连续元素，可以间隔取用</span><br><span class="line">    // 注意：序列本身并不一定是递增的，子序列不能不是原序列的顺序，所以不能排序</span><br><span class="line">    // 注意：序列不是递增的，剪枝就不能前后对比剪枝了</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; sequenceList;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;</span><br><span class="line">        sequenceList = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs3(nums, 0, new ArrayList&lt;&gt;());</span><br><span class="line">        return sequenceList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs3(int[] nums, int start, List&lt;Integer&gt; track) &#123;</span><br><span class="line">        // 判断是否递增</span><br><span class="line">        if (track.size() &gt;= 2 &amp;&amp; track.get(track.size() - 1) &lt; track.get(track.size() - 2)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 长度至少是2</span><br><span class="line">        if (track.size() &gt;= 2) &#123;</span><br><span class="line">            // 这里不应该return</span><br><span class="line">            sequenceList.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; jianzhiSet = new HashSet&lt;&gt;();</span><br><span class="line">        for (int i = start; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            // 横向去重，剪枝</span><br><span class="line">//            if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; //这样不行</span><br><span class="line">            if(jianzhiSet.contains(nums[i])) continue;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            jianzhiSet.add(nums[i]);</span><br><span class="line">            dfs3(nums, i + 1, track);</span><br><span class="line">            track.remove(track.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全排列（元素无重，不可重选）"><a href="#全排列（元素无重，不可重选）" class="headerlink" title="全排列（元素无重，不可重选）"></a>全排列（元素无重，不可重选）</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p>输入：nums = [1,2,3]<br>输出：<code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></p>
<p>标签：DFS+回溯+记录数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 全排列(元素无重，不可重选)</span><br><span class="line">    // [1,2] 输出: [1,2][2,1]</span><br><span class="line">    // 元素无重复，一个位置的元素不能重选</span><br><span class="line">    // 实现：不需要start来记录遍历到哪，但是需要记录哪些位置遍历过了（前提是元素无重复，要是有重复的话，不同位置但是值一样就会重选）</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        if (nums.length == 0) return res;</span><br><span class="line">        dfs(nums, new ArrayList&lt;&gt;(), new HashSet&lt;&gt;());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int[] nums, List&lt;Integer&gt; track, Set&lt;Integer&gt; usedIndex) &#123;</span><br><span class="line">        if (track.size() == nums.length) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (usedIndex.contains(i)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            usedIndex.add(i);</span><br><span class="line">            dfs(nums, track, usedIndex);</span><br><span class="line">            track.remove(track.size() - 1);</span><br><span class="line">            usedIndex.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全排列2（元素可重，不可重选）"><a href="#全排列2（元素可重，不可重选）" class="headerlink" title="全排列2（元素可重，不可重选）"></a>全排列2（元素可重，不可重选）</h2><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<p>输入：nums = [1,1,2]<br>输出：<code>[[1,1,2], [1,2,1], [2,1,1]]</code></p>
<p>标签：DFS+回溯+记录数组+剪枝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 全排列(元素重复，不可重选)</span><br><span class="line">    // 输入：[1,1,2] 输出：[1,1,2][1,2,1][2,1,1]</span><br><span class="line">    // 不光要记录深度方向哪些索引已经用过，还要横向剪枝，但是这里剪枝比较特殊，需要是横向之前确定用过的，用临时数记录</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; res2;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">        res2 = new ArrayList&lt;&gt;();</span><br><span class="line">        if (nums.length == 0) return res2;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs2(nums, new ArrayList&lt;&gt;(), new HashSet&lt;&gt;());</span><br><span class="line">        return res2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs2(int[] nums, List&lt;Integer&gt; track, Set&lt;Integer&gt; usedIndex) &#123;</span><br><span class="line">        System.out.println(track);</span><br><span class="line">        if (track.size() == nums.length) &#123;</span><br><span class="line">            res2.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int used = -11;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (usedIndex.contains(i)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == used) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            used = nums[i];</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            usedIndex.add(i);</span><br><span class="line">            dfs2(nums, track, usedIndex);</span><br><span class="line">            track.remove(track.size() - 1);</span><br><span class="line">            usedIndex.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p>标签：DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 解数独</span><br><span class="line">    // 输入9*9的矩阵，未知数用.表示，每行每列每个左中右3*3，都是1-9不能重复</span><br><span class="line">    // 输出填好的数独</span><br><span class="line">    // 解法：和n皇后问题类似，n皇后是只填一个，数独要1-9。n皇后用一个int[]表示皇后的位置。</span><br><span class="line">    // 遍历还有没有没填的数，如果没有了就return了。得返回boolean记录一下。</span><br><span class="line">    // 思想其实都是尝试，n皇后尝试在每行的哪个位置放置皇后，然后校验。填数独在没填的位置尝试，然后校验。</span><br><span class="line">    // n皇后要返回几种答案，所以dfs返回几种。</span><br><span class="line">    public void solveSudoku(char[][] board) &#123;</span><br><span class="line">        dfs(board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean dfs(char[][] board) &#123;</span><br><span class="line">        for (int i = 0; i &lt; board.length; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; board[0].length; j ++) &#123;</span><br><span class="line">                if (board[i][j] != &#x27;.&#x27;) continue;</span><br><span class="line">                for (int tryNum = 1; tryNum &lt;= 9; tryNum ++) &#123;</span><br><span class="line">                    char tryChar = (char) (&#x27;0&#x27; tryNum);</span><br><span class="line">                    if (isValid(board, i, j, tryChar)) &#123;</span><br><span class="line">                        board[i][j] = tryChar;</span><br><span class="line">                        if (dfs(board)) return true;</span><br><span class="line">                        else board[i][j] = &#x27;.&#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 注意：所有数都不行，证明前面填错了，因此需要回溯。不然还会遍历下一个位置</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isValid(char[][] board, int row, int column, char num) &#123;</span><br><span class="line">        // 同行是否已有</span><br><span class="line">        for (int i = 0; i &lt; board[0].length; i++) &#123;</span><br><span class="line">            if (board[row][i] == num)  return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同列是否已有</span><br><span class="line">        for (int i = 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            if (board[i][column] == num)  return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同方块儿是否已有</span><br><span class="line">        int startRow = (row / 3) * 3;</span><br><span class="line">        int startColumn = (column / 3) * 3;</span><br><span class="line">        for (int i = startRow; i &lt; startRow 3; i ++) &#123;</span><br><span class="line">            for (int j = startColumn; j &lt; startColumn 3; j ++) &#123;</span><br><span class="line">                if (board[i][j] == num)  return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同构字符串"><a href="#同构字符串" class="headerlink" title="同构字符串"></a>同构字符串</h2><p>给定两个字符串 s 和 t ，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。</p>
<p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<p>输入：s = “egg”, t = “add”<br>输出：true</p>
<p>标签：Map indexOf charAt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 同构字符串</span><br><span class="line">    // 输入两个字符串，判断是否是同构字符串，如：aabc、oody，映射只能是一对一的</span><br><span class="line">    // 思路：</span><br><span class="line">    // 1.可以用String的indexOf()方法：找到元素的第一个索引下标</span><br><span class="line">    // 2.可以用map记录字符映射</span><br><span class="line">    public boolean isIsomorphic(String s1, String s2) &#123;</span><br><span class="line">        if (s1.length() != s2.length()) return false;</span><br><span class="line">        for (int i = 0; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            if (s1.indexOf(s1.charAt(i)) != s2.indexOf(s2.charAt(i))) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isIsomorphic2(String s1, String s2) &#123;</span><br><span class="line">        if (s1.length() != s2.length()) return false;</span><br><span class="line">        Map&lt;Character, Character&gt; map = new HashMap();</span><br><span class="line">        for (int i = 0; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            if (map.containsKey(s1.charAt(i)) &amp;&amp; s2.charAt(i) != map.get(s1.charAt(i))) return false;</span><br><span class="line">            map.put(s1.charAt(i), s2.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="贪心专栏"><a href="#贪心专栏" class="headerlink" title="贪心专栏"></a>贪心专栏</h2><p>贪心专栏：贪心算法就是找当下的最优解，每一个状态都找到最优解，从而希望结果是全局最优的。<br>解题思路一般是：<br>    •    问题分解为若干子问题<br>    •    找出适合的贪心策略<br>    •    求解每个子问题的最优解<br>    •    将局部最优解堆叠成全局最优</p>
<h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>标签：贪心算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 分发饼干</span><br><span class="line">    // 输入：g数组表示孩子的胃口值，数组大小表示有多少个孩子，s数组表示饼干的尺寸，数组大小表示有多少个饼干</span><br><span class="line">    // 输出：最多能满足多少个孩子</span><br><span class="line">    // 贪心思想：从局部最优到全局最优，大的饼干尽可能满足胃口大的孩子</span><br><span class="line">    public int findContentChildren(int[] g, int[] s) &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        int i = g.length - 1, j = s.length - 1;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123;</span><br><span class="line">            // 胃口大了</span><br><span class="line">            if (g[i] &gt; s[j]) &#123;</span><br><span class="line">                i --;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">            i --;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h2><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p>
<p>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。<br>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p>
<p>以这种方式修改数组后，返回数组 可能的最大和 。</p>
<p>标签：贪心算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // k次取反后最大化的数组和</span><br><span class="line">    // 输入：一个整数数组nums、一个整数k，每次选择一个元素取反，重复k次，可以重复选择同一元素</span><br><span class="line">    // 输出：操作后最大的数组和</span><br><span class="line">    // 贪心思想：局部最优是每次取反的数字是最小的</span><br><span class="line">    // 方法一：每次都重排序，取最小的反转。时间复杂度高</span><br><span class="line">    public int largestSumAfterKNegations1(int[] nums, int k) &#123;</span><br><span class="line">        for (int i = 0; i &lt; k; i ++) &#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            nums[0] = -nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            res += num;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法二：优化一下，首先将数组按照绝对值从大到小排列，然后从前往后遍历遇到负数就反转，最后如果k没用完就将放最后的数组来回反转。</span><br><span class="line">    // 优点：只需要排序一次，需要自定义排序</span><br><span class="line">    public int largestSumAfterKNegations(int[] nums, int k) &#123;</span><br><span class="line">        // 首先将int[]转换为Integer[]，因为Comparator不适用于原始数据类型数组</span><br><span class="line">        Integer[] numbersObj = Arrays.stream(nums).boxed().toArray(Integer[]::new);</span><br><span class="line">        Arrays.sort(numbersObj, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">                // 比较绝对值，实现逆序排序</span><br><span class="line">                return Integer.compare(Math.abs(o2), Math.abs(o1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (k &gt; 0 &amp;&amp; i &lt; numbersObj.length) &#123;</span><br><span class="line">            if (numbersObj[i] &lt; 0) &#123;</span><br><span class="line">                numbersObj[i] *= -1;</span><br><span class="line">                k --;</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (k -- &gt; 0) &#123;</span><br><span class="line">            numbersObj[numbersObj.length - 1] *= -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int num : numbersObj) &#123;</span><br><span class="line">            res += num;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
<p>标签：贪心算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 柠檬水找零</span><br><span class="line">    // 一个柠檬5块，输入一个整数数组，表示顾客付的钱(5、10、20)，需要考虑顺序</span><br><span class="line">    // 返回是否成功找零</span><br><span class="line">    // 贪心思想：顺序遍历有多少5块10块，找20优先使用10+5</span><br><span class="line">    public boolean lemonadeChange(int[] bills) &#123;</span><br><span class="line">        int fiveNum = 0;</span><br><span class="line">        int tenNum = 0;</span><br><span class="line">        for (int bill : bills) &#123;</span><br><span class="line">            if (bill == 5) fiveNum ++;</span><br><span class="line">            else if (bill == 10) &#123;</span><br><span class="line">                fiveNum --;</span><br><span class="line">                tenNum ++;</span><br><span class="line">            &#125; else if (bill == 20) &#123;</span><br><span class="line">                if (tenNum &gt; 0) &#123;</span><br><span class="line">                    tenNum --;</span><br><span class="line">                    fiveNum --;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    fiveNum -= 3;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (fiveNum &lt; 0 || tenNum &lt; 0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。</p>
<p>返回 你可以获得的最大乘积 。</p>
<p>标签：贪心算法、动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 整数拆分</span><br><span class="line">    // 给一个正整数n，求将其拆分后的最大积</span><br><span class="line">    // 方法1：贪心，发现除了最后的4，将其拆分为尽可能多的3，最后积最大</span><br><span class="line">    public int integerBreak2(int n) &#123;</span><br><span class="line">        if (n &lt;= 2) return 1;</span><br><span class="line">        if (n == 3) return 2;</span><br><span class="line">        int res = 1;</span><br><span class="line">        while (n &gt; 4) &#123;</span><br><span class="line">            res *= 3;</span><br><span class="line">            n -= 3;</span><br><span class="line">        &#125;</span><br><span class="line">        return res * n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法2：动态规划，后一个状态与前一个状态有关，建立状态转移方程</span><br><span class="line">    public int integerBreak(int n) &#123;</span><br><span class="line">        if (n &lt;= 2) return 1;</span><br><span class="line">        // 1.定义dp</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        // 2.初始化，本来想每个都初始化自己n，但是只有1，2是需要赋予初值的</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        dp[2] = 1;</span><br><span class="line">        // 3.状态转移</span><br><span class="line">        for (int i = 3; i &lt;= n; i ++) &#123;</span><br><span class="line">            // 遍历拆到一半的数</span><br><span class="line">            for (int j = 1; j &lt;= i/2; j ++) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], j * Math.max(dp[i - j], i - j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 5 1</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 零钱兑换</span><br><span class="line">     * 输入：一个数组表示有哪些种零钱，每种的数量无限，给你一个整数表示总金额，返回所需最少的零钱个数</span><br><span class="line">     * 如果组合不成，就返回-1</span><br><span class="line">     */</span><br><span class="line">    // 思路：用动态规划</span><br><span class="line">    public static int coinChange(int[] changes, int total) &#123;</span><br><span class="line">        if (total == 0) return 0;</span><br><span class="line">        Arrays.sort(changes);</span><br><span class="line">        int[] dp = new int[total 1];</span><br><span class="line">        for (int num : changes) &#123;</span><br><span class="line">            if (num &lt;= total)  dp[num] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= total; i ++) &#123;</span><br><span class="line">            for (int num : changes) &#123;</span><br><span class="line">                if (i - num &lt; 1) break;</span><br><span class="line">                if (dp[i - num] == 0) continue;</span><br><span class="line">                dp[i] = dp[i] == 0 ? dp[i - num] + 1 : Math.min(dp[i], dp[i - num] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[total] == 0 ? -1 : dp[total];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
<p>输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</p>
<p>标签：贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">     /**</span><br><span class="line">     * 摆动序列</span><br><span class="line">     * 什么是摆动序列：序列相邻元素的差值是正数负数摆动的，仅含有一个/两个元素的序列也是摆动序列</span><br><span class="line">     * 输入一个序列，返回这个序列的最长摆动子序列（只能删除元素）</span><br><span class="line">     * 思考：不管怎么样，最优答案一定是可以从最开头开始遍历的，就算是：1 2 3 2 3..，也可以 1 3 2 3</span><br><span class="line">     * 所以从头开始遍历，贪心地往后走就好</span><br><span class="line">     */</span><br><span class="line">    public static int wiggleMaxLength(int[] nums) &#123;</span><br><span class="line">        if (nums.length == 1) return 1;</span><br><span class="line">        if (nums.length == 2) return nums[0] == nums[1]? 1:2;</span><br><span class="line">        int res = nums[0] == nums[1] ? 1 : 2;</span><br><span class="line">        int preDiff = nums[1] - nums[0];</span><br><span class="line">        for (int i = 2; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            int curDiff = nums[i] - nums[i - 1];</span><br><span class="line">            if ((preDiff &gt;= 0  &amp;&amp; curDiff &lt; 0) || (preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0)) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">                preDiff = curDiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="峰与谷"><a href="#峰与谷" class="headerlink" title="峰与谷"></a>峰与谷</h2><p>在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。</p>
<p>输入: [5, 3, 1, 2, 3]<br>输出: [5, 1, 3, 2, 3]</p>
<p>标签：贪心，注意贪心算法，从局部最优到全局最优的前提是：局部最优不影响全局最优。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   </span><br><span class="line">    /**</span><br><span class="line">     * 峰与谷</span><br><span class="line">     * 输入：一个整数数组，峰是大于等于两边数的，谷是小于等于两边数的。在最边只有一个相邻元素也算</span><br><span class="line">     * 输出：将该数组按照峰与谷的顺序交替顺序排序</span><br><span class="line">     * [5,3,1,2,3] 输出：[5,1,3,2,3]  应该输出不止有一种可能</span><br><span class="line">     * 贪心的思想：挨个遍历，挨个满足要求。重点是峰与谷交替，所以每个位置是峰还是谷是确定的，每次遍历保证和上一个位置的关系。</span><br><span class="line">     * 从第二个数开始遍历，保证和前一个数的关系，不满足就交换。可是交换了影响前面的怎么办？不会，后面交换只会换来更小或更大的</span><br><span class="line">     * 比如，在应该峰的位置，比前面小，换来前面的大值，在下一个应该谷的位置，发现比前一个大，所以换来前面的小值，那么最开始峰的位置变得更大了，不影响</span><br><span class="line">     */</span><br><span class="line">    public static int[] wiggleSort(int[] nums) &#123;</span><br><span class="line">        if(nums.length == 1) &#123;</span><br><span class="line">            return nums;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            if (i % 2 == 0) &#123;</span><br><span class="line">                //峰，应该比上一个大</span><br><span class="line">                if (nums[i] &lt; nums[i - 1]) &#123;</span><br><span class="line">                    swap(nums, i, i - 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //谷，应该比上一个小</span><br><span class="line">                if (nums[i] &gt; nums[i - 1]) &#123;</span><br><span class="line">                    swap(nums, i, i - 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] nums, int index1, int index2) &#123;</span><br><span class="line">        int pre = nums[index2];</span><br><span class="line">        nums[index2] = nums[index1];</span><br><span class="line">        nums[index1] = pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。</p>
<p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</p>
<p>标签：贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  </span><br><span class="line">    /**</span><br><span class="line">     * 单调递增的数字</span><br><span class="line">     * 单调数字是各位数字都是单调递增的，比如：123、122。121就不是  213 199; 9213 8999；192 189</span><br><span class="line">     * 输入n，返回小于等于n的最大单调数字</span><br><span class="line">     * 思路：从前往后遍历，如果前&gt;后，前-1，后面就都变9</span><br><span class="line">     * 错误：332，应该是299。这种情况怎么处理。在发现前数大于后数时，需要先向前遍历，-1是否会比前一位小（这样麻烦）</span><br><span class="line">     * 修正：从后（个位）往前遍历，如果前面比后面大，前面位-1，并记录flag，决定从哪位开始后面都变为9</span><br><span class="line">     */</span><br><span class="line">    public static int monotoneIncreasingDigits(int n) &#123;</span><br><span class="line">        // 存数的各个位，前面是个位</span><br><span class="line">        List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();</span><br><span class="line">        while(n &gt; 0) &#123;</span><br><span class="line">            nums.add(n % 10);</span><br><span class="line">            n /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        int flag = -1;</span><br><span class="line">        for (int i = 0; i &lt; nums.size() - 1; i++) &#123;</span><br><span class="line">            if (nums.get(i) &lt; nums.get(i + 1)) &#123;</span><br><span class="line">                nums.set(i + 1, nums.get(i + 1) - 1);</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt;= flag; i ++) &#123;</span><br><span class="line">            nums.set(i, 9);</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = nums.size() - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">            res = res * 10 nums.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p>
<p>标签：动态规划，动态规划和贪心的关系：都是局部到全局，贪心不需要状态转移，也就是不需要dp。动态规划需要状态转移dp。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  </span><br><span class="line">    // 最大子数组和</span><br><span class="line">    // 给你一个数组，返回一个最大连续子数组和</span><br><span class="line">    //动态规划，dp表示的应该是连续的到某位置的最大值</span><br><span class="line">    public static int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        int res = dp[0];</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - 1] nums[i], nums[i]);</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><p>标签：动态规划</p>
<p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p>
<p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 最长连续递增子序列</span><br><span class="line">    // 输入一个未经排序的整数数组，返回最长连续递增子序列的长度，等于不算递增</span><br><span class="line">    public static int findLengthOfLCIS(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        int res = 1;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            if (nums[i] &gt; nums[i - 1]) dp[i] = dp[i - 1] + 1;</span><br><span class="line">            else dp[i] = 1;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p>
<p>标签：贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 分发糖果</span><br><span class="line">    // 输入一个数组，表示n个孩子站成一排的评分</span><br><span class="line">    // 分发糖果规则：每个孩子都需要分到至少一个，相邻孩子评分高的需要分到更多糖果，如果相等则无所谓，可以少</span><br><span class="line">    // 输出：需要的最少糖果数</span><br><span class="line">    // 贪心，从头遍历分糖果，第一个给1，往后遍历如果出现了需要分0的情况，往前遍历，连续变大的+1，例如5-4-3-2-1</span><br><span class="line">    // 出错，注意：往前遍历不能无脑加1，需要是后面值的加一，而且需要比较一下取大的</span><br><span class="line">    public static int candy(int[] nums) &#123;</span><br><span class="line">        int[] candies = new int[nums.length];</span><br><span class="line">        candies[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            if (nums[i] &gt; nums[i - 1]) &#123;</span><br><span class="line">                candies[i] = candies[i - 1] + 1;</span><br><span class="line">            &#125; else if (nums[i] == nums[i - 1]) &#123;</span><br><span class="line">                candies[i] = 1; //相等就给最少的</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (candies[i - 1] == 1) &#123;</span><br><span class="line">                    candies[i] = 1;</span><br><span class="line">                    int j = i - 1;</span><br><span class="line">                    while(j &gt;= 0 &amp;&amp; nums[j] &gt; nums[j + 1]) &#123;</span><br><span class="line">                        candies[j] = Math.max(candies[j + 1] + 1, candies[j]);</span><br><span class="line">                        j --;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    candies[i] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int num : candies) &#123;</span><br><span class="line">            res += num;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(candies));</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
<p>标签：贪心，难点在于怎么总结出规律</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 根据身高重建队列</span><br><span class="line">    // 给定一个数组的数组[[5,1],[6,2],[7,3]]表示一些人，[5,1]中5表示身高，1表示前面有一个大于等于身高5的人</span><br><span class="line">    // 输入的数组是乱序的，输出排好序的数组</span><br><span class="line">    // 思路：关键在于先按照身高从高到低排序，如果身高相同，则按照前面的人数值从小到大排序。然后，使用一个列表（或数组）来依次放置每个人。对于每个人，我们根据前面人数值将其插入到结果列表中的正确位置。</span><br><span class="line">    // 输入：&#123;&#123;7, 0&#125;, &#123;4, 4&#125;, &#123;7, 1&#125;, &#123;5, 0&#125;, &#123;6, 1&#125;, &#123;5, 2&#125;&#125;</span><br><span class="line">    // 排序后：[[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]</span><br><span class="line">    // 一个一个插入：[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]</span><br><span class="line">    public int[][] reconstructQueue(int[][] people) &#123;</span><br><span class="line">        // 按照身高降序排列，身高相同的则按照前面人数升序排列</span><br><span class="line">        // 这里排的是int[]，不是int，所以可以。</span><br><span class="line">        // Comparator排序，a-b表示正序，b-a表示倒叙</span><br><span class="line">        Arrays.sort(people, (a, b) -&gt; &#123;</span><br><span class="line">            if (a[0] == b[0]) &#123;</span><br><span class="line">                return a[1] - b[1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return b[0] - a[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;int[]&gt; peopleList = new ArrayList&lt;&gt;();</span><br><span class="line">        // 遍历排序后的数组，根据前面人数插入到队列中的适当位置</span><br><span class="line">        for (int[] person : people) &#123;</span><br><span class="line">            peopleList.add(person[1], person);</span><br><span class="line">        &#125;</span><br><span class="line">        return peopleList.toArray(new int[peopleList.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p>标签：贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 合并区间</span><br><span class="line">    // 输入：int[][]，每个int[]表示一个区间，这些区间有重叠</span><br><span class="line">    // 返回：重叠区间合并后的不重叠的区间数组，边界相同也可合并</span><br><span class="line">    // 例如：输入：[1,3],[2,6],[8,10]  输出：[1,6],[8,10]</span><br><span class="line">    // 注意：排序之后，前一个的右边界可能比后一个右边界大</span><br><span class="line">    public int[][] merge(int[][] nums) &#123;</span><br><span class="line">        // 首先根据第一个数正序排序，如果相同根据第二个数正序排序</span><br><span class="line">        Arrays.sort(nums, (a, b) -&gt; &#123;</span><br><span class="line">            if (a[0] == b[0]) &#123;</span><br><span class="line">                return a[1] - b[1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return a[0] - b[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        int[] lastSec = nums[0];</span><br><span class="line">        List&lt;int[]&gt; secList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            // 不合并条件</span><br><span class="line">            if (lastSec[1] &lt; nums[i][0]) &#123;</span><br><span class="line">                secList.add(lastSec);</span><br><span class="line">                lastSec = nums[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 合并</span><br><span class="line">                lastSec[1] = Math.max(lastSec[1], nums[i][1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        secList.add(lastSec);</span><br><span class="line">        int[][] res = secList.toArray(new int[secList.size()][]);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p>
<p>输入：points = [[10,16],[2,8],[1,6],[7,12]]<br>输出：2</p>
<p>标签：贪心 区间问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 用最少数量的箭引爆气球</span><br><span class="line">    // 气球在平面上，一个气球有x轴的坐标，箭从x轴某个位置射出。求最少需要射多少箭</span><br><span class="line">    // 输入：int[][]表示气球的坐标</span><br><span class="line">    // 思路：其实和合并区间是一个问题，最后合并完变成几个区间，就是几个箭 ? 并不是，应该是有几个相交区域，就是几个箭。</span><br><span class="line">    public static int findMinArrowShots(int[][] nums) &#123;</span><br><span class="line">        // 1.首先排序</span><br><span class="line">        Arrays.sort(nums, (a, b) -&gt; &#123;</span><br><span class="line">            // 下面这样会越界</span><br><span class="line">            // if (a[0] == b[0]) return a[1] - b[1];</span><br><span class="line">            // else return a[0] - b[0];</span><br><span class="line">            // 只根据end排序就行</span><br><span class="line">            if (a[1] &gt; b[1]) &#123;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125; else if (a[1] &lt; b[1]) &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 2.遍历寻找合并契机</span><br><span class="line">        // 上一个重合区间，可以合并的条件变严格，只有和这个重合区间重合，才能同一根箭射爆</span><br><span class="line">        int[] lastSec = nums[0];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            if (lastSec[1] &gt;= nums[i][0]) &#123;</span><br><span class="line">                // 可以合并</span><br><span class="line">                lastSec[0] = Math.max(lastSec[0], nums[i][0]);</span><br><span class="line">                lastSec[1] = Math.min(lastSec[1], nums[i][1]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 不能合并</span><br><span class="line">                res ++;</span><br><span class="line">                lastSec = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p>
<p>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<p>标签：贪心、区间问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 无重叠区间</span><br><span class="line">    // 输入一组区间，返回最少需要移除几个区间才能使剩余区间互不重叠，区间边界相同也不算重叠</span><br><span class="line">    // 思路：其实没那么复杂，就是射箭问题的反面，思考几个case就能明白，但你需要注意气球是边界相同可以射破，这里不行。</span><br><span class="line">    public static int eraseOverlapIntervals(int[][] nums) &#123;</span><br><span class="line">        // 1.首先排序</span><br><span class="line">        Arrays.sort(nums, (a, b) -&gt; &#123;</span><br><span class="line">            if (a[0] == b[0]) return a[1] - b[1];</span><br><span class="line">            else return a[0] - b[0];</span><br><span class="line">        &#125;);</span><br><span class="line">        // 2.遍历寻找合并契机</span><br><span class="line">        // 上一个重合区间，可以合并的条件变严格，只有和这个重合区间重合，才能同一根箭射爆</span><br><span class="line">        int[] lastSec = nums[0];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            if (lastSec[1] &gt; nums[i][0]) &#123;</span><br><span class="line">                // 可以合并</span><br><span class="line">                lastSec[0] = Math.max(lastSec[0], nums[i][0]);</span><br><span class="line">                lastSec[1] = Math.min(lastSec[1], nums[i][1]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 不能合并</span><br><span class="line">                res ++;</span><br><span class="line">                lastSec = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums.length - res - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<p>输入：s = “ababcbacadefegdehijhklij”<br>输出：[9,7,8]<br>解释：<br>划分结果为 “ababcbaca”、”defegde”、”hijhklij” 。</p>
<p>标签：贪心、区间问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 划分字母区间</span><br><span class="line">    // 输入一个字符串，表示单词。要将这个单词划分为尽可能多的片段，同一个字母最多出现在一个片段中。</span><br><span class="line">    // 并且，所有片段按顺序连接之后，还是这个单词</span><br><span class="line">    // 返回表示每个字符串片段长度的列表</span><br><span class="line">    // 思路：indexOf只能获取字符的第一个位置索引。还是遍历用map记录一下字符的最大索引。然后遍历，并更新边界，如果和边界相等则成一个片段。</span><br><span class="line">    public static List&lt;Integer&gt; partitionLabels(String s) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            map.put(s.charAt(i), i);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; resList = new ArrayList&lt;&gt;();</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i ++) &#123;</span><br><span class="line">            end = Math.max(map.get(s.charAt(i)), end);</span><br><span class="line">            // 等于边界，表示可以分割</span><br><span class="line">            if (i == end) &#123;</span><br><span class="line">                resList.add(end - start 1);</span><br><span class="line">                start = end 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模拟行走机器人"><a href="#模拟行走机器人" class="headerlink" title="模拟行走机器人"></a>模拟行走机器人</h2><p>机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：</p>
<p>-2 ：向左转 90 度<br>-1 ：向右转 90 度<br>1 &lt;= x &lt;= 9 ：向前移动 x 个单位长度<br>在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点  obstacles[i] = (xi, yi) 。</p>
<p>机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，并继续执行下一个命令。</p>
<p>返回机器人距离原点的 最大欧式距离 的 平方 。（即，如果距离为 5 ，则返回 25 ）</p>
<p>标签：贪心模拟</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 模拟行走机器人</span><br><span class="line">    // 机器人在无限大平面行走，初始位置在(0,0)，初始朝向是向北，接收指令：-2向左转90度 -1向右转90度 1-9表示走多少步。</span><br><span class="line">    // 有障碍物，机器人走不上去，需要原地踏步直到转向，求达到点点最大欧式距离(x平方+y平方)</span><br><span class="line">    // obstacles表示障碍物位置</span><br><span class="line">    // 思路：其实不难，就是遍历指令，只是需要控制好方向</span><br><span class="line">    public int robotSim(int[] commands, int[][] obstacles) &#123;</span><br><span class="line">        // 定义转向 东南西北</span><br><span class="line">        int[][] directs = new int[][]&#123;&#123;1, 0&#125;,&#123;0, -1&#125;,&#123;-1, 0&#125;,&#123;0, 1&#125;&#125;;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int curX = 0;</span><br><span class="line">        int curY = 0;</span><br><span class="line">        int dir = 3; //初始朝向北</span><br><span class="line">        // 定义障碍物位置set</span><br><span class="line">        Set&lt;String&gt; obstacleSet = new HashSet&lt;&gt;();</span><br><span class="line">        for (int[] obs : obstacles) &#123;</span><br><span class="line">            obstacleSet.add(obs[0] &quot;:&quot; obs[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int command : commands) &#123;</span><br><span class="line">            if (command == -2) &#123;</span><br><span class="line">                dir = dir - 1 == -1? 3 : dir - 1;</span><br><span class="line">            &#125; else if (command == -1) &#123;</span><br><span class="line">                dir = dir 1 == 4? 0 : dir 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while (command -- &gt; 0) &#123;</span><br><span class="line">                    int nextX = curX directs[dir][0];</span><br><span class="line">                    int nextY = curY directs[dir][1];</span><br><span class="line">                    String nextPos = nextX &quot;:&quot; nextY;</span><br><span class="line">                    if (obstacleSet.contains(nextPos)) break;</span><br><span class="line">                    curX = nextX;</span><br><span class="line">                    curY = nextY;</span><br><span class="line">                    res = (int)Math.max(res, Math.pow(curX, 2) Math.pow(curY, 2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p>
<p>输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]<br>输出: 3</p>
<p>标签：贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 加油站</span><br><span class="line">    // 输入：cost数组表示第i个加油站到i+1个加油站需要的汽油，gas表示第i个加油站的汽油</span><br><span class="line">    // 加油站是个环，油箱无限，开始时邮箱为空，返回从哪个加油站出发能绕一圈，答案唯一，不能返回-1</span><br><span class="line">    // 输入：1,2,3,4,5 和 3,4,5,1,2，返回3</span><br><span class="line">    // 思路：remain数组表示只用这个加油站的油到下一个可以剩下多少，找到负的，向前遍历，到哪可以满足</span><br><span class="line">    // 应该先找到一个应该开始遍历的负点：这个点是从0点开始累计油量最少的地方。画个累计油量曲线就好了，从0开始和从其他地方开始曲线形状都是一样的，无非是上下平移</span><br><span class="line">    // 因为有解也只有一个解，所以一定是累计邮箱最少的点的下一个点开始才行。无解情况：cost总共比gas还多，从结余曲线来看就是固定出发点纵坐标为出发点结余量是，曲线还在x轴下</span><br><span class="line">    // [2,0,0,0] [0,1,0,0]  开始点是0则哪都去不了，违背上面的规律。</span><br><span class="line">    // 还是得用这种。累计油量新低不代表行不通。</span><br><span class="line">    public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        // 为了适配[0,2,0,0,0] [0,0,1,0,0]情况，将res设定为gas最多的点。不行，去掉</span><br><span class="line">        int res = 0;</span><br><span class="line">        int maxGas = Integer.MIN_VALUE;</span><br><span class="line">        // for (int i = 0; i &lt; gas.length; i ++) &#123;</span><br><span class="line">        //     if (gas[i] &gt; maxGas) &#123;</span><br><span class="line">        //         res = i;</span><br><span class="line">        //         maxGas= gas[i];</span><br><span class="line">        //     &#125;</span><br><span class="line">        // &#125;</span><br><span class="line">        int totalSum = 0;</span><br><span class="line">        int currentSum = 0;</span><br><span class="line">        for (int i = 0; i &lt; gas.length; i++) &#123;</span><br><span class="line">            int netGas = gas[i] - cost[i];</span><br><span class="line">            totalSum += netGas;</span><br><span class="line">            currentSum += netGas;</span><br><span class="line">            // 如果当前累计的净油量小于0，那么不能从之前的起点出发，需要将起点设置为下一个站点</span><br><span class="line">            if (currentSum &lt; 0) &#123;</span><br><span class="line">                res = i + 1;</span><br><span class="line">                currentSum = 0; // 重置当前累计油量</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果总油量小于总成本，无法绕环行驶</span><br><span class="line">        if (totalSum &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 由于加油站是环形的，如果可以绕行整个环路，返回计算出的起点</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p>给定一个二叉树，我们在树的节点上安装摄像头。<br>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>计算监控树的所有节点所需的最小摄像头数量。</p>
<p>标签：贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 监控二叉树</span><br><span class="line">    // 给定一个二叉树，要在二叉树上装摄像头，每个摄像头可以监控当前节点、父节点、直接子对象，返回最少需要几个摄像头</span><br><span class="line">    // 思路：局部最优到全局最优，就是摄像头尽量往头节点而不是叶子节点放，所以是后序遍历</span><br><span class="line">    // 为什么不是层序遍历：这里涉及到状态转移，父节点的状态依赖于叶子结点的状态，并且层序是从上到下，不合适。</span><br><span class="line">    // 状态转移：三种状态：有摄像头、无摄像头有覆盖、无摄像头无覆盖。空节点应该是无摄像头有覆盖</span><br><span class="line">    public int minCameraCover(TreeNode root) &#123;</span><br><span class="line">        // 注意：如果根节点是3，根节点需要装一个</span><br><span class="line">        if (dfs(root) == 3)  minCameraRes ++;</span><br><span class="line">        return minCameraRes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int minCameraRes;</span><br><span class="line"></span><br><span class="line">    // 返回：1.有摄像头 2.无摄像头有覆盖 3.无摄像头无覆盖</span><br><span class="line">    private int dfs(TreeNode node) &#123;</span><br><span class="line">        if (null == node) return 2;</span><br><span class="line">        int left = dfs(node.left);</span><br><span class="line">        int right = dfs(node.right);</span><br><span class="line">        if (left == 3 || right == 3) &#123;minCameraRes ++; return 1;&#125;</span><br><span class="line">        if (left == 1 || right == 1) return 2;</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p>
<p>标签：单调栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 每日温度</span><br><span class="line">    // 输入temperatures数组表示每天的温度</span><br><span class="line">    // 输出数组表示改天之后的下一个更高温天出现在几天后，如果没有用0代替</span><br><span class="line">    // 思路：单调栈，因为要找更高温，所以用单调不递增的单调栈</span><br><span class="line">    // 单调栈：</span><br><span class="line">    // 如果要加入的数大于栈顶元素，则应该弹出栈，直到栈顶元素&gt;=加入的数。表示弹出的数的右边第一高就是要加入的数</span><br><span class="line">    // 如果要加入的数小于等于栈顶元素，则加入</span><br><span class="line">    // peek返回栈顶元素不移除  pop移除栈顶元素  push向栈加入一个元素</span><br><span class="line">    // 输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">    // 输出: [1,1,4,2,1,1,0,0]</span><br><span class="line">    public int[] dailyTemperatures(int[] temperatures) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">        int[] res = new int[temperatures.length];</span><br><span class="line">        // 遍历入栈出栈</span><br><span class="line">        for (int i = 0; i &lt; temperatures.length; i ++) &#123;</span><br><span class="line">            // 如果栈顶元素小，就弹出</span><br><span class="line">            while (!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt; temperatures[i]) &#123;</span><br><span class="line">                int index = stack.pop();</span><br><span class="line">                res[index] = i - index;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        // 还在栈里的元素右边就没有比它更大的了</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            res[stack.pop()] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="移掉k位数字"><a href="#移掉k位数字" class="headerlink" title="移掉k位数字"></a>移掉k位数字</h2><p>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
<p>输入：num = “1432219”, k = 3<br>输出：”1219”<br>解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 移除k位数字</span><br><span class="line">    // 输入：一个字符串表示的非负整数num，和一个整数k，表示需要从num中移除k位</span><br><span class="line">    // 输出：移除k位后的最小数</span><br><span class="line">    // 例如：10200 和 1  输出200。1432219 和 3 输出1219</span><br><span class="line">    // 思路：从前往后遍历，如果前&gt;后，就移除。不行，会漏掉前面的大数。除非每次只删除一个数。</span><br><span class="line">    // 单调栈：每日温度是要获取后面大的数的位置，弹出前面小的位置，用单调递减的。这里要弹出前面大的，所以用单调递增</span><br><span class="line">    // 总结：要弹出小的，单调递减。要弹出大的，单调递增。(从栈底到栈顶)</span><br><span class="line">    public String removeKdigits(String num, int k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">        for (char ch : num.toCharArray()) &#123;</span><br><span class="line">            int n = ch - &#x27;0&#x27;;</span><br><span class="line">            // 如果栈顶元素更大，就弹出</span><br><span class="line">            while (!stack.isEmpty() &amp;&amp; k &gt; 0 &amp;&amp; stack.peek() &gt; n) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                k --;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(n);</span><br><span class="line">        &#125;</span><br><span class="line">        // 没删完，就删后面大的，也就是出栈</span><br><span class="line">        while (k -- &gt; 0) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        // 开始计算，栈顶是个位。用int记录结果会导致数据溢出，所以用StringBuilder</span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            // 从栈底加数据</span><br><span class="line">            builder.append(stack.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        // 移除前导零</span><br><span class="line">        while (builder.length() &gt; 1 &amp;&amp; builder.charAt(0) == &#x27;0&#x27;) &#123;</span><br><span class="line">            builder.deleteCharAt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果移除所有数字，返回 &quot;0&quot;</span><br><span class="line">        if (builder.length() == 0) &#123;</span><br><span class="line">            return &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下一个更大元素"><a href="#下一个更大元素" class="headerlink" title="下一个更大元素"></a>下一个更大元素</h2><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</p>
<p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。</p>
<p>对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</p>
<p>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。</p>
<p>输入：nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出：[-1,3,-1]</p>
<p>标签：单调栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 下一个更大元素1</span><br><span class="line">    // 输入两个数组，两个数组都没重复，数组1是数组2的子集</span><br><span class="line">    // 返回数组1的数字在数组2中位置右边第一个比它大的数，没有就返回-1</span><br><span class="line">    // 例子：[4,1,2] [1,3,4,2] 返回[-1,3,-1]</span><br><span class="line">    // 思路：和每日温度类似，只不过每日温度就一个当前数组。这个问题就需要遍历过程记录数字对应的右边第一个大的数</span><br><span class="line">    // 使用单调不递增的单调栈，弹出小的</span><br><span class="line">    public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">        // map记录nums1的 数-index 映射</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums1.length; i ++) &#123;</span><br><span class="line">            map.put(nums1[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res = new int[nums1.length];</span><br><span class="line">        Arrays.fill(res, -1);</span><br><span class="line">        for (int value : nums2) &#123;</span><br><span class="line">            // 栈顶小的话就弹出</span><br><span class="line">            while (!stack.isEmpty() &amp;&amp; stack.peek() &lt; value) &#123;</span><br><span class="line">                int num2 = stack.pop();</span><br><span class="line">                if (map.containsKey(num2)) &#123;</span><br><span class="line">                    res[map.get(num2)] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下一个更大元素-II"><a href="#下一个更大元素-II" class="headerlink" title="下一个更大元素 II"></a>下一个更大元素 II</h2><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。</p>
<p>数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。</p>
<p>输入: nums = [1,2,1]<br>输出: [2,-1,2]</p>
<p>标签：单调栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 下一个更大元素2</span><br><span class="line">    // 输入一个数组，把它当作循环数组。返回数组元素下一个更大元素，如果不存在则输出-1</span><br><span class="line">    // 思路：直接把数组copy一份放后面就ok。但是倒也不用真的复制一份，遍历2size就行</span><br><span class="line">    // 使用单调不递增单调栈，弹出小的</span><br><span class="line">    public int[] nextGreaterElements(int[] nums) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">        int[] res = new int[nums.length];</span><br><span class="line">        Arrays.fill(res, -1);</span><br><span class="line">        for (int i = 0; i &lt; nums.length * 2; i ++) &#123;</span><br><span class="line">            int index = i % nums.length;</span><br><span class="line">            while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[index]) &#123;</span><br><span class="line">                int topIndex = stack.pop();</span><br><span class="line">                res[topIndex] = nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(index);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 01背包问题</span><br><span class="line">// 输入：重量数组、价值数组、背包最大容量。每个物品仅能用一次。</span><br><span class="line">// 输出：背包能容纳的最大价值</span><br><span class="line">// 动态规划步骤：</span><br><span class="line">// 1.确定dp数组以及下标的含义</span><br><span class="line">// 2.确定递推公式</span><br><span class="line">// 3.dp数组如何初始化</span><br><span class="line">// 4.确定遍历顺序</span><br><span class="line">// 5.举例推导dp数组</span><br><span class="line">public static int maxPackage(int[] weight, int[] value, int size) &#123;</span><br><span class="line">    // 1.确定dp数组：二维dp[i][j]，i表示购买到第i个物品，j表示用了j背包容量</span><br><span class="line">    int[][] dp = new int[weight.length][size + 1];</span><br><span class="line">    // 2.确定递推公式：要i和不要i: dp[i][j] = Math.max(dp[i-1][j-weight[i]] + value[i], dp[i-1][j]);</span><br><span class="line">    // 遍历顺序：先物品再size</span><br><span class="line">    // 3.初始化:i=0时，只有j大于等于了weight[0]才可以有value[0]的价值</span><br><span class="line">    for (int j = weight[0]; j &lt;= size; j ++) &#123;</span><br><span class="line">        dp[0][j] = value[0];</span><br><span class="line">    &#125;</span><br><span class="line">    // 4.开始遍历 外层是物品 内层是大小size</span><br><span class="line">    for (int i = 1; i &lt; weight.length; i ++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= size; j ++) &#123;</span><br><span class="line">            // 放不下当前物品</span><br><span class="line">            if (j &lt; weight[i]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - 1][j - weight[i]] + value[i], dp[i-1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[weight.length - 1][size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 01背包问题使用一维数组，表示容量为j时的最大价值</span><br><span class="line">// 其实也可以不用对i=0初始化，一维的不用加判断，但是二维的就得加了</span><br><span class="line">public static int maxPackage1(int[] weight, int[] value, int size) &#123;</span><br><span class="line">    int[] dp = new int[size + 1];</span><br><span class="line">//        for (int i = weight[0]; i &lt;= size; i ++) &#123;</span><br><span class="line">//            dp[i] = value[0];</span><br><span class="line">//        &#125;</span><br><span class="line">    for (int i = 0; i &lt; weight.length; i ++) &#123;</span><br><span class="line">        // 注意：遍历顺序应该从右往左了，确保取数相当于还是从上一层取</span><br><span class="line">        // 如果还是从左到右，后面的元素就可能因为前边元素的变化而变化，不是由上一层的元素推出来的了</span><br><span class="line">        // 现实意义表示一个物品用了多次</span><br><span class="line">        for (int j = size; j &gt; 0; j --) &#123;</span><br><span class="line">            if (j &gt;= weight[i])  dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 完全背包问题</span><br><span class="line">// 输入：重量数组、价值数组、背包最大容量。每个物品能用无限次</span><br><span class="line">// 输出：背包能容纳的最大价值</span><br><span class="line">// 一维数组遍历顺序从左到右</span><br><span class="line">// weight和value内元素的顺序不会有影响：因为遍历到物件，都会从容量1开始遍历</span><br><span class="line">public static int maxPackageTotal(int[] weight, int[] value, int size) &#123;</span><br><span class="line">    int[] dp = new int[size + 1];</span><br><span class="line">    for (int i = 0; i &lt; weight.length; i ++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= size; j ++) &#123;</span><br><span class="line">            if (j &gt;= weight[i])  dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p>标签：背包问题 动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 完全平方数</span><br><span class="line">    // 输入：一个整数n，返回这个整数n最少可以是几个完全平方数的和，可重复用</span><br><span class="line">    // 完全背包问题，一维数组从前往后遍历</span><br><span class="line">    public static int numSquares(int num) &#123;</span><br><span class="line">        // 1比较独特</span><br><span class="line">        if (num == 1) return 1;</span><br><span class="line">        int[] dp = new int[num + 1];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE - 1);</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        // 物品表示1-num/2</span><br><span class="line">        for (int i = 0; i &lt;= num / 2; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= num; j ++) &#123;</span><br><span class="line">                int square = (int) Math.pow(i, 2);</span><br><span class="line">                if (j &gt;= square) &#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j - square] + 1, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true</p>
<p>标签：背包问题(有顺序) 动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 单词拆分</span><br><span class="line">    // 输入一个字符串word，和一个String数组表示可以使用的单词，单词不一定全部使用，单词可以重复使用</span><br><span class="line">    // 完全背包问题，一维数组从前往后遍历</span><br><span class="line">    // 这个不同于上面的背包问题，上面的对于物品没有顺序要求，但是这里需要，如果按照上面的步骤，就会导致aba的情况无法遍历到</span><br><span class="line">    // 解决办法：先遍历size，再遍历物品。遍历顺序要先遍历背包，不能先遍历物品，因为物品得是有序的</span><br><span class="line">    public static boolean wordBreak(String word, List&lt;String&gt; words) &#123;</span><br><span class="line">        // 得初始化 word.length() + 1，因为需要dp[0]</span><br><span class="line">        boolean[] dp = new boolean[word.length() + 1];</span><br><span class="line">        // 初始化：dp[0]就行</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        // 因为需要有序，遍历先遍历背包再遍历物品</span><br><span class="line">        for (int j = 1; j &lt;= word.length(); j ++) &#123;</span><br><span class="line">            for (int i = 0; i &lt; words.size(); i ++) &#123;</span><br><span class="line">                if (j &lt; words.get(i).length())  continue;</span><br><span class="line">                // 判断该单词能否与字符尾部匹配</span><br><span class="line">                String sub = word.substring(j - words.get(i).length(), j);</span><br><span class="line">                if (sub.equals(words.get(i))) &#123;</span><br><span class="line">                    dp[j] = dp[j] || dp[j - words.get(i).length()];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">        return dp[word.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子序列（不连续）"><a href="#最长公共子序列（不连续）" class="headerlink" title="最长公共子序列（不连续）"></a>最长公共子序列（不连续）</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   </span><br><span class="line">    // 最长公共子序列</span><br><span class="line">    // 输入：两个字符串，求最长公共子序列，可以不连续，但是顺序得正确</span><br><span class="line">    // 思想：动态规划</span><br><span class="line">    public static int longestCommonSubsequence(String s1, String s2) &#123;</span><br><span class="line">        int len1 = s1.length();</span><br><span class="line">        int len2 = s2.length();</span><br><span class="line">        // 定义dp[i][j]表示s1前i个字符和s2前j个字符的最长公共子序列长度</span><br><span class="line">        int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">        // 初始化看状态转移方程依赖于哪些状态，这里是上和左</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">                if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子串（连续）"><a href="#最长公共子串（连续）" class="headerlink" title="最长公共子串（连续）"></a>最长公共子串（连续）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 最长公共子串</span><br><span class="line">// 输入：两个字符串，求最长公共子串，要求连续</span><br><span class="line">// 思想：动态规划</span><br><span class="line">public static String maxCommonString(String s1, String s2) &#123;</span><br><span class="line">    int len1  = s1.length();</span><br><span class="line">    int len2 = s2.length();</span><br><span class="line">    int maxSize = 0;</span><br><span class="line">    // 用于记录子串String</span><br><span class="line">    int endIndex = 0;</span><br><span class="line">    // dp[i][j]表示以s1[i-1]结尾的s1和以s2[j-1]结尾的s2，并且公共子串需要包括这两个结尾字符的最长公共子串长度</span><br><span class="line">    int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">    // 需要的初始化是0，所以忽略初始化</span><br><span class="line">    for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">            if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                dp[i][j] = dp[i -1][j -1] + 1;</span><br><span class="line">                // 记录结果</span><br><span class="line">                if (dp[i][j] &gt; maxSize) &#123;</span><br><span class="line">                    maxSize = dp[i][j];</span><br><span class="line">                    endIndex = i - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxSize &gt; 0 ? s1.substring(endIndex - maxSize + 1, endIndex + 1) : &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="最长回文子串-1"><a href="#最长回文子串-1" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<p>标签：动态规划</p>
<p>方法一：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  </span><br><span class="line">    // 最长回文子串</span><br><span class="line">    // 给定一个字符串，返回它的最长回文子串，这个子串需要是连续的子串</span><br><span class="line">    // 思路：和本字符串反转的用最长公共子串，就是回文子串。需要增加一个判断条件：索引位置是否镜像。</span><br><span class="line">    // 如果不判断，abaxab和baxaba就会把ab、ba当作回文串</span><br><span class="line">    public static String longestPalindrome(String s) &#123;</span><br><span class="line">        String s2 = new StringBuilder(s).reverse().toString();</span><br><span class="line">        int len = s.length();</span><br><span class="line">        int maxSize = 0;</span><br><span class="line">        // 用于记录子串String</span><br><span class="line">        int endIndex = 0;</span><br><span class="line">        // dp[i][j]表示以s1[i-1]结尾的s1和以s2[j-1]结尾的s2，并且公共子串需要包括这两个结尾字符的最长公共子串长度</span><br><span class="line">        int[][] dp = new int[len + 1][len + 1];</span><br><span class="line">        // 需要的初始化是0，所以忽略初始化</span><br><span class="line">        for (int i = 1; i &lt;= len; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len; j ++) &#123;</span><br><span class="line">                if (s.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i -1][j -1] + 1;</span><br><span class="line">                    // 记录结果，并检查子串的索引是否镜像，以确保它是回文. 1213 3121 i=3 dp=3 len=4 j=4</span><br><span class="line">                    if (dp[i][j] &gt; maxSize &amp;&amp; i - dp[i][j] == len - j) &#123;</span><br><span class="line">                        maxSize = dp[i][j];</span><br><span class="line">                        endIndex = i - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(endIndex - maxSize + 1, endIndex + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：另一个dp含义的动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  </span><br><span class="line">    public static String longestPalindrome(String s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        // dp[i][j]表示下标i-j的字符串是否是回文字符串，j&gt;=i</span><br><span class="line">        boolean[][] dp = new boolean[len][len];</span><br><span class="line">        int maxLen = 0;</span><br><span class="line">        String res = &quot;&quot;;</span><br><span class="line">        // 遍历顺序：左下到右上，因为用到[i+1][j-1]</span><br><span class="line">        for (int i = len - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">            for (int j = i; j &lt; len; j ++) &#123;</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    // 相差&lt;=1肯定回文，不是就要看中间是不是</span><br><span class="line">                    if (j -i &lt;= 1 || dp[i + 1][j - 1]) &#123;</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                        if (j - i + 1 &gt; maxLen) &#123;</span><br><span class="line">                            maxLen = j - i + 1;</span><br><span class="line">                            res = s.substring(i, j + 1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p>
<p>回文字符串 是正着读和倒过来读一样的字符串。</p>
<p>子字符串 是字符串中的由连续字符组成的一个序列。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>输入：s = “aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 回文子串</span><br><span class="line">    // 输入一个字符串返回有多少个回文子串。子串：连续的字符组成的。字符串相等，但是位置不同也算不同的子串</span><br><span class="line">    // 思路：动态规划，不用反转字符串，直接动态规划</span><br><span class="line">    //01 dp[i][j]的定义 是在 i-j这个区间内的 是不是回文</span><br><span class="line">    //02 更新方法: 这里是如果 ij的char相等 且 gap &lt;= 1那一定就是回文；要是gap &gt; 1那就要看 dp[i+1][j-1]是不是回文；</span><br><span class="line">    //03 更新顺序， 是从左下到右上，因为需要i+1 和 j-1 所以是从左下开始</span><br><span class="line">    // 注：最长回文子串也可以使用该方法</span><br><span class="line">    public static int countSubstrings(String s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        // dp[i][j]表示下标i-j的字符串是否是回文字符串，j&gt;=i</span><br><span class="line">        boolean[][] dp = new boolean[len][len];</span><br><span class="line">        int res = 0;</span><br><span class="line">        // 遍历顺序：左下到右上，因为用到[i+1][j-1]</span><br><span class="line">        for (int i = len - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">            for (int j = i; j &lt; len; j ++) &#123;</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    // 相差&lt;=1肯定回文，不是就要看中间是不是</span><br><span class="line">                    if (j -i &lt;= 1 || dp[i + 1][j - 1]) &#123;</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                        res ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p>输入：s = “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” 。</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 最长回文子序列</span><br><span class="line">    //01 dp[i][j] 表示 i-j区间内的最长回文子序列的长度；</span><br><span class="line">    //02 更新方法是 如果 s[i] = s[j] 那就在 s[i-1][j-1]的基础上+2；要是不相等的话，那就取 [i+1,j] 和 [i, j-1]区间内比较大的那个回文子串数目，也就是max(dp[i+1][j], dp[i][j-1])；</span><br><span class="line">    //03 遍历顺序 还是从左下到右上；</span><br><span class="line">    //04 初始化对角线</span><br><span class="line">    public static int longestPalindromeSubseq(String s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        // dp表示字符串i-j的最长回文子序列长度</span><br><span class="line">        int[][] dp = new int[len][len];</span><br><span class="line">        // 初始化对角线</span><br><span class="line">        for (int i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">            dp[i][i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从左下开始遍历</span><br><span class="line">        for (int i = len - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; len; j ++) &#123;</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + 1][j -1] + 2;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][len - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>输入：s = “abc”, t = “ahbgdc”<br>输出：true</p>
<p>标签：双指针、动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 判断子序列</span><br><span class="line">    // 输入字符串s和字符串t，判断s是否是t的子序列  abc是ajisbshc的子序列，出现顺序得一样</span><br><span class="line">    // 思路：1.双指针</span><br><span class="line">    public static boolean isSubsequence(String s, String t) &#123;</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        while (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;</span><br><span class="line">            if (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return i == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 思路2：动态规划</span><br><span class="line">    // 1.可以用最长公共子序列，得到的结果为s的长度，就是子序列。dp表示公共子序列长度</span><br><span class="line">    // 2.dp也可以表示是否是子序列boolean，但是状态转移要注意：dp[i][j] = dp[i][j-1]; 不能有dp[i-1][j]，因为可能去掉s的一个字符，可能就是子序列了，但是加上不行</span><br><span class="line">    public static boolean isSubsequence(String s, String t) &#123;</span><br><span class="line">        int len1 = s.length();</span><br><span class="line">        int len2 = t.length();</span><br><span class="line">        // 定义dp[i][j]表示s1前i个字符和s2前j个字符的最长公共子序列长度</span><br><span class="line">        int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">        // 初始化看状态转移方程依赖于哪些状态，这里是上和左</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">                if (s.charAt(i - 1) == t.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len1][len2] == len1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，结果需要对 109 + 7 取模。</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 不同的子序列</span><br><span class="line">    // 输入s1，s2，求s1的子序列中s2出现的次数</span><br><span class="line">    // 例如：rabbbit中rabbit出现了3次</span><br><span class="line">    // 两个字符串谁对应i谁对应j，无所谓。状态转移对了就行</span><br><span class="line">    // babgbag bag 返回5</span><br><span class="line">    public static int numDistinct(String s1, String s2) &#123;</span><br><span class="line">        int len1 = s1.length();</span><br><span class="line">        int len2 = s2.length();</span><br><span class="line">        // dp[i][j]表示字符串s1的前i个字符的子序列中s2的前j个字符出现的次数</span><br><span class="line">        int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">        // 初始化 其实dp[0][j] 和 dp[i][0] 没什么实际意义，但是看状态转移需要确定初始化</span><br><span class="line">        // 注意初始化，dp[i][0] 都需要初始化为1</span><br><span class="line">        for (int i = 0; i &lt; len1; i ++) &#123;</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">                if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                    // 相等的情况 j是要匹配的字符串，不能动</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 不相等的情况</span><br><span class="line">                    // 注意：不是 dp[i][j] = dp[i - 1][j] + dp[i - 2][j] + ....; 这种是重复计算的</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h2><p>给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。</p>
<p>每步 可以删除任意一个字符串中的一个字符。</p>
<p>输入: word1 = “sea”, word2 = “eat”<br>输出: 2</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   </span><br><span class="line">    // 两个字符串的互相删除操作</span><br><span class="line">    // 输入两个字符串，返回使得两个字符串相等的最小步数，每一步可以删除任意一个字符串中的任意一个字符</span><br><span class="line">    // 例如：sea、eat 两步</span><br><span class="line">    // 思路：直接动态规划</span><br><span class="line">    public static int minDistance(String s1, String s2) &#123;</span><br><span class="line">        int len1 = s1.length();</span><br><span class="line">        int len2 = s2.length();</span><br><span class="line">        // dp[i][j]表示s1的前i个字符和s2的前j个字符的删除距离，</span><br><span class="line">        int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">        // 根据下面的状态转移推断如何初始化：</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">            dp[0][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">                if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 不相等，不用考虑dp[i-1][j-1]，因为这俩已经考虑了</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<p>输入：word1 = “horse”, word2 = “ros”<br>输出：3</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 编辑距离</span><br><span class="line">    // 输入两个字符串，求编辑距离：可以删除、插入、替换。使得相等的最少操作数。</span><br><span class="line">    // intention、execution 5</span><br><span class="line">    public static int minDistance(String s1, String s2) &#123;</span><br><span class="line">        int len1 = s1.length();</span><br><span class="line">        int len2 = s2.length();</span><br><span class="line">        // dp[i][j]表示s1前i个字符和s2的前j个字符的最小编辑距离</span><br><span class="line">        int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">        // 和删除距离一样的初始化</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">            dp[0][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">                if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 删一个/加一个/修改一个</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>输入：”abbaca”<br>输出：”ca”</p>
<p>标签：栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public static String removeDuplicates(String s) &#123;</span><br><span class="line">        Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            if (stack.isEmpty()) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                char top = stack.peek();</span><br><span class="line">                if (c == top) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(stack.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/mysql%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/mysql%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Mysql技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-25 16:25:11" itemprop="dateCreated datePublished" datetime="2022-09-25T16:25:11+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-04 15:12:40" itemprop="dateModified" datetime="2023-06-04T15:12:40+08:00">2023-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="mysql日期函数"><a href="#mysql日期函数" class="headerlink" title="mysql日期函数"></a>mysql日期函数</h2><p>✅datepart()</p>
<p>获取日期中的年月日<br>datepart(‘2022-11-11 12:12:12’, ‘yyyy’)<br>得到：2022，也可以是mm、dd</p>
<p>✅datetrunc()</p>
<p>获取日期的指定起始日期，比如一天的开始<br>datetrunc(‘2022-11-11 12:12:12’, ‘yyyy‘)<br>得到：2022-01-01 00:00:00</p>
<p>✅quarter()</p>
<p>获取日期的季度<br>quarter(‘2022-11-11 00:00:00’)<br>得到：4</p>
<p>✅subdate函数</p>
<p>MySQL中的SUBDATE()函数用于从给定日期减去某间隔时间。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SUBDATE(date, INTERVAL expr, unit)</span><br><span class="line"></span><br><span class="line">此函数接受以下三个参数：</span><br><span class="line">日期：第一个指定的日期。</span><br><span class="line">expr：要减去的时间/日期间隔的值。负的表示该时间之后</span><br><span class="line">单位：间隔的类型。MICROSECOND\SECOND\MINUTE\HOUR\DAY\WEEK\MONTH\QUARTER\YEAR</span><br></pre></td></tr></table></figure>

<p>例子：<br><code>select subdate(&quot;2020-11-25&quot;, INTERVAL 30 DAY)</code></p>
<p>今天的日期：<br><code>select curdate();  2022-10-30</code><br>现在的时间：<br><code>select curtime();   13:13:54</code></p>
<p>✅mysql计算时间差函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.timestampdiff(interval, datetime1,datetime2)</span><br><span class="line">返回（时间2-时间1）的时间差，结果单位由interval参数给出</span><br><span class="line">select timestampdiff(MINUTE,&#x27;2012-10-01&#x27;,&#x27;2013-01-13&#x27;); # 149760</span><br><span class="line">不是四舍五入时间差，而是直接取整数部分，1.9天算1天。</span><br><span class="line">如果前面加avg想求平均值，注意如果两个时间字段中有一个为null，则timestampdiff函数会返回null，而avg函数会忽略null值并计算剩余时间差的平均值（为null的那一行忽略）。</span><br><span class="line">为了避免这种情况，coalesce(timediff,0) 或者 ifnull(timediff, 0)</span><br><span class="line">但是要注意timestampdiff(second, &quot;2023-04-30 00:00:00&quot;, 0) 返回的将是很大的负数。</span><br><span class="line"></span><br><span class="line">2.天数差函数 datediff</span><br><span class="line">语法：传入两个日期参数，比较DAY天数，第一个参数减去第二个参数的天数值。</span><br><span class="line">select datediff(‘2013-01-13’,‘2012-10-01’); # 104</span><br><span class="line"></span><br><span class="line">3.时间差函数：timediff</span><br><span class="line">语法：timediff(time1,time2)</span><br><span class="line">结果：返回两个时间相减得到的差值，time1-time2，如果其中一个是null，返回也是null。</span><br><span class="line">select timediff(‘2018-05-21 14:51:43’,‘2018-05-19 12:54:43’);</span><br><span class="line"></span><br><span class="line">4.其他求时间的函数</span><br><span class="line">select now(); //2022-11-26 16:18:45</span><br><span class="line">select curdate(); //2022-11-26</span><br><span class="line">select curtime();</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_53370274/article/details/122122628">https://blog.csdn.net/weixin_53370274/article/details/122122628</a></p>
<p>✅日期转换为时间戳</p>
<p>10位的时间戳精确到s<br>13位的时间戳精确到ms毫秒</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNIX_TIMESTAMP函数:日期转时间戳(10位)</span><br><span class="line">select unix_timestamp(now()); //1669452093</span><br><span class="line"></span><br><span class="line">FROM_UNIXTIME函数：时间戳转日期（第二个参数非必填，默认：%Y-%m-%d %H:%i:%s）</span><br><span class="line">select from_unixtime(unix_timestamp(now()));</span><br><span class="line">select from_unixtime(unix_timestamp(now()), &#x27;%Y~%m~%d %H:%i:%S&#x27;);  //2022~11~26 16:48:38</span><br></pre></td></tr></table></figure>

<p>✅日期和字符串相互转化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">日期转化为指定格式字符串：</span><br><span class="line">select date_format(now(),&#x27;%Y-%m-%d %H:%i:%S&#x27;); //2022-11-26 16:45:59</span><br><span class="line"></span><br><span class="line">指定格式字符串转化为日期：</span><br><span class="line">select str_to_date(&#x27;2022-11-29&#x27;, &#x27;%Y-%m-%d %H:%i:%S&#x27;); //2022-11-29 00:00:00</span><br></pre></td></tr></table></figure>

<h2 id="mySQL-with-as用法"><a href="#mySQL-with-as用法" class="headerlink" title="mySQL - with as用法"></a>mySQL - with as用法</h2><p>如果一整句查询中多个子查询都需要使用同一个子查询的结果，那么就可以用with as，将共用的子查询提取出来，加个别名。后面查询语句可以直接用，对于大量复杂的SQL语句起到了很好的优化作用。</p>
<p>构造数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 分类表</span><br><span class="line">CREATE TABLE category ( cid VARCHAR ( 32 ) PRIMARY KEY, cname VARCHAR ( 50 ) );</span><br><span class="line"></span><br><span class="line">-- 商品表</span><br><span class="line">CREATE TABLE products (</span><br><span class="line">	pid VARCHAR ( 32 ) PRIMARY KEY,</span><br><span class="line">	pname VARCHAR ( 50 ),</span><br><span class="line">	price INT,</span><br><span class="line">	flag VARCHAR ( 2 ),-- 是否上架标记为：1表示上架、0表示下架</span><br><span class="line">	category_id VARCHAR ( 32 ),</span><br><span class="line">	FOREIGN KEY ( category_id ) REFERENCES category ( cid ) </span><br><span class="line">);</span><br><span class="line">-- 分类数据</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c001&#x27;,&#x27;家电&#x27;);</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c002&#x27;,&#x27;鞋服&#x27;);</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c003&#x27;,&#x27;化妆品&#x27;);</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c004&#x27;,&#x27;汽车&#x27;);</span><br><span class="line"></span><br><span class="line">-- 商品数据</span><br><span class="line">INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#x27;p001&#x27;,&#x27;小米电视机&#x27;,5000,&#x27;1&#x27;,&#x27;c001&#x27;);</span><br><span class="line">INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#x27;p002&#x27;,&#x27;格力空调&#x27;,3000,&#x27;1&#x27;,&#x27;c001&#x27;);</span><br><span class="line">INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#x27;p003&#x27;,&#x27;美的冰箱&#x27;,4500,&#x27;1&#x27;,&#x27;c001&#x27;);</span><br></pre></td></tr></table></figure>

<p>查询两个商品的平均价格：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WITH xm_gl AS ( SELECT * FROM products WHERE pname IN ( &#x27;小米电视机&#x27;, &#x27;格力空调&#x27; ) ) </span><br><span class="line">SELECT avg( price ) FROM xm_gl;</span><br></pre></td></tr></table></figure>

<p>使用with as还可以创建多个临时表，但是要注意同一个查询语句前写一个with就够了，另外子查询需要逗号隔开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WITH a AS ( SELECT * FROM category WHERE cname = &#x27;家电&#x27; ),</span><br><span class="line">b AS ( SELECT * FROM products WHERE pname IN ( &#x27;小米电视机&#x27;, &#x27;格力空调&#x27; ) ) </span><br><span class="line">SELECT * FROM	a	LEFT JOIN b ON a.cid = b.category_id;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、with as 相当于一个临时表，但是不同于视图（create table as），不会存储起来，要与select配合使用。<br>2、同一个select前可以有多个临时表，写一个with就可以，用逗号隔开，最后一个with语句不要用逗号。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/397195826">https://zhuanlan.zhihu.com/p/397195826</a></p>
<p>实战总结：<br><code>with as</code>不能单独加<code>;</code>一句单独使用，需要后面跟select一起使用。第一个<code>with as</code>得到的临时表可以在第二个临时表里用。好处是可以分步骤生成表，不用嵌套很多层。</p>
<p>如果<code>create table as</code> ，是要加在<code>with as</code>之前的。</p>
<h2 id="mysql-case-when-用法"><a href="#mysql-case-when-用法" class="headerlink" title="mysql case when 用法"></a>mysql case when 用法</h2><p>MySQL 的 case when 的语法有两种：</p>
<p>简单函数<br><code>CASE [col_name] WHEN [value1] THEN [result1]…ELSE [default] END</code></p>
<p>搜索函数<br><code>CASE WHEN [expr] THEN [result1]…ELSE [default] END</code></p>
<p>简单函数用法：根据case字段when已知可能值，then列出已知装备（也可以是表的某个字段）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    NAME &#x27;英雄&#x27;,</span><br><span class="line">    CASE NAME</span><br><span class="line">        WHEN &#x27;德莱文&#x27; THEN</span><br><span class="line">            &#x27;斧子&#x27;</span><br><span class="line">        WHEN &#x27;德玛西亚-盖伦&#x27; THEN</span><br><span class="line">            &#x27;大宝剑&#x27;</span><br><span class="line">        WHEN &#x27;暗夜猎手-VN&#x27; THEN</span><br><span class="line">            &#x27;弩&#x27;</span><br><span class="line">        ELSE</span><br><span class="line">            &#x27;无&#x27;</span><br><span class="line">    END &#x27;装备&#x27;</span><br><span class="line">FROM</span><br><span class="line">    user_info;</span><br></pre></td></tr></table></figure>

<p>搜索函数用法：case when 某个字段的函数 then某值（也可以是表的字段）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># when 表达式中可以使用 and 连接条件</span><br><span class="line">SELECT</span><br><span class="line">    NAME &#x27;英雄&#x27;,</span><br><span class="line">    age &#x27;年龄&#x27;,</span><br><span class="line">    CASE</span><br><span class="line">        WHEN age &lt; 18 THEN</span><br><span class="line">            &#x27;少年&#x27;</span><br><span class="line">        WHEN age &lt; 30 THEN</span><br><span class="line">            &#x27;青年&#x27;</span><br><span class="line">        WHEN age &gt;= 30</span><br><span class="line">        AND age &lt; 50 THEN</span><br><span class="line">            &#x27;中年&#x27;</span><br><span class="line">        ELSE</span><br><span class="line">            &#x27;老年&#x27;</span><br><span class="line">    END &#x27;状态&#x27;</span><br><span class="line">FROM</span><br><span class="line">    user_info;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenduzizhong/p/9590741.html">https://www.cnblogs.com/chenduzizhong/p/9590741.html</a></p>
<h2 id="mysql批量删除大量数据"><a href="#mysql批量删除大量数据" class="headerlink" title="mysql批量删除大量数据"></a>mysql批量删除大量数据</h2><p>假设有一个表(syslogs)有1000万条记录，需要在业务不停止的情况下删除其中statusid=1的所有记录，差不多有600万条， 直接执行 DELETE FROM syslogs WHERE statusid=1 会发现删除失败，因为lock wait timeout exceed的错误。</p>
<p>因为这条语句所涉及的记录数太多，因此我们通过LIMIT参数分批删除，比如每10000条进行一次删除，那么我们可以利用 MySQL这样的语句来完成:<br><code>DELETE FROM syslogs WHERE status=1 ORDER BY statusid LIMIT 10000;</code></p>
<p>如果要用order by 必须要和 limit 联用，否则被优化掉。然后分多次执行就可以把这些记录成功删除。</p>
<p>注意：<br>执行大批量删除的时候注意要使用上limit。因为如果不用limit，删除大量数据很有可能造成死锁。<br><strong>如果delete的where语句不在索引上，可以先找主键，然后根据主键删除数据库。</strong><br>平时update和delete的时候最好也加上limit 1 来防止误操作。</p>
<p>mybatis中的delete语句可以有返回，返回结果int是删除的条数，如果没删除，返回0.</p>
<h2 id="delete和truncate，drop的区别"><a href="#delete和truncate，drop的区别" class="headerlink" title="delete和truncate，drop的区别"></a>delete和truncate，drop的区别</h2><p>1、delete删除数据的原理:(delete属于DML语句)</p>
<p>表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放。<br>这种删除表的优点是：支持回滚，后悔了可以恢复数据，可以带where条件删除部分数据，灵活性强。<br>缺点：删除效率比较低</p>
<p><code>delete from user;  //删除user表中的数据，但是这种删除数据的方式有点慢。</code></p>
<p>2、truncate删除数据的原理:(DDL)</p>
<p>可以理解为，drop table然后再create table。<br>效率比较高，表被一次截断，物理删除<br>优点：快速，不走事务，不会锁表，也不会产生大量日志写入日志文件<br>缺点：不支持回滚，只能删除表中所有数据，不能删单条数据<br>如果说公司项目里面有一张大表，数据非常多，几亿条记录：<br>删除的时候，使用delete，也许执行一个小时才能删除完，效率极其低；<br>可以选择使用truncate删除表中的数据。只需要不到1s的时间就能删除结束，效率较高。<br>但是使用truncate之前，必须仔细询问客户是否真的需要删除，并警告删除之后不可恢复。</p>
<p><code>truncate table user; //删除user表中的数据，快速。</code></p>
<p><strong>truncate和delete的差异</strong></p>
<blockquote>
<p>1、truncate是DDL语句，它不存在所谓的“事务回滚”；<br>delete是DML语句，它执行完是可以rollback的。<br>2、truncate table返回值是0；<br>delete from table返回值是被删除的行数。<br>3、InnoDB支持一个表一个文件时：<br>truncate会一次性把表干掉，且不会激活触发器，速度非常快；<br>delete from table则会一行一行删除，会激活触发器，速度比较慢。<br>delete数据，是要记录日志的，truncate表不需要记录日志。<br>4、当表中有列被其它表作为外键(foreign key)时：<br>truncate会是失败； delete则会成功。<br>5、当表中有自增列时：<br>truncate会使得自增列计数复原；<br>delete所有数据后，自增列计数并不会复原，而是保持原来的顺序自增。</p>
</blockquote>
<p>3、drop删除表操作</p>
<p>truncate和delete是删除表中的数据，表还在。</p>
<p><code>drop table 表名；// 删除表，不是删除表中的数据</code></p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jike11231/article/details/126551510">https://blog.csdn.net/jike11231/article/details/126551510</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jkzyx123/article/details/127223589">https://blog.csdn.net/jkzyx123/article/details/127223589</a></p>
<h2 id="mysql的空间"><a href="#mysql的空间" class="headerlink" title="mysql的空间"></a>mysql的空间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类型	    占用空间	  取值范围</span><br><span class="line">tinyint	      1个字节	    -128~127</span><br><span class="line">smallint	2个字节	    -32768~32767</span><br><span class="line">mediumint	3个字节	    -223~ 223 - 1</span><br><span class="line">int	        4个字节	    -231~ 231- 1</span><br><span class="line">bigint	    8个字节	    -263~ 263- 1</span><br></pre></td></tr></table></figure>

<p>mysql数据类型及占用空间：<a target="_blank" rel="noopener" href="https://blog.csdn.net/why_still_confused/article/details/125945285">https://blog.csdn.net/why_still_confused/article/details/125945285</a></p>
<h2 id="分库分表的表怎么查询"><a href="#分库分表的表怎么查询" class="headerlink" title="分库分表的表怎么查询"></a>分库分表的表怎么查询</h2><p>逻辑库查询暂不支持join查询。</p>
<h2 id="Lindorm云原生多模数据库"><a href="#Lindorm云原生多模数据库" class="headerlink" title="Lindorm云原生多模数据库"></a>Lindorm云原生多模数据库</h2><p>Lindorm是面向物联网、互联网、车联网等设计和优化的云原生多模超融合数据库，支持宽表、时序、文本、对象、流、空间等多种数据的统一访问和融合处理，并兼容SQL、HBase/Cassandra/S3、TSDB、HDFS、Solr、Kafka等多种标准接口和无缝集成三方生态工具，适用于日志、监控、账单、广告、社交、出行、风控等场景，Lindorm也是为阿里巴巴核心业务提供支撑的数据库之一。</p>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/174640.html">https://help.aliyun.com/document_detail/174640.html</a></p>
<h2 id="mysql查出来的数据转换为json格式-用ResultSet"><a href="#mysql查出来的数据转换为json格式-用ResultSet" class="headerlink" title="mysql查出来的数据转换为json格式 用ResultSet"></a>mysql查出来的数据转换为json格式 用ResultSet</h2><p>单纯mysql语句没得办法。<br>只能在java里操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.ResultSetMetaData;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">import org.json.JSONArray;</span><br><span class="line">import org.json.JSONObject;</span><br><span class="line"></span><br><span class="line">public class MysqlToJSON &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String driver = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/ontology&quot;;</span><br><span class="line">        String user = &quot;root&quot;;</span><br><span class="line">        String pwd = &quot;123456&quot;;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            Connection con =DriverManager.getConnection(url,user,pwd);</span><br><span class="line">            Statement stet = con.createStatement();</span><br><span class="line"></span><br><span class="line">            String sql = &quot;select * from class_tab&quot;;</span><br><span class="line">            ResultSet rs = stet.executeQuery(sql);</span><br><span class="line">            ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line">            int columnCount= metaData.getColumnCount();</span><br><span class="line">            JSONArray array = new JSONArray();</span><br><span class="line">            while(rs.next())&#123;</span><br><span class="line">                JSONObject jsonObj = new JSONObject();</span><br><span class="line">                for(int i = 1; i &lt;= columnCount;i++)&#123;</span><br><span class="line">                    String columnName = metaData.getColumnLabel(i);</span><br><span class="line">                    String value =rs.getString(columnName);</span><br><span class="line">                    jsonObj.put(columnName, value);</span><br><span class="line">                &#125;</span><br><span class="line">                array.put(jsonObj);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;转换JSON数据：&quot;);</span><br><span class="line">            System.out.println(array.toString());</span><br><span class="line">            </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mysql的json数据格式"><a href="#mysql的json数据格式" class="headerlink" title="mysql的json数据格式"></a>mysql的json数据格式</h2><p>mysql5.7以上提供了一种新的字段格式json，大概是mysql想把非关系型和关系型数据库一口通吃，所以推出了这种非常好用的格式，这样，我们的很多基于mongoDB的业务都可以用mysql去实现了。当然了，5.7的版本只是最基础的版本，对于海量数据的效率是远远不够的，不过这些都在mysql8.0解决了。</p>
<p>✅创建表，插入数据</p>
<p>先创建一个简单的含json格式的数据库表，其中json_value就为json格式的字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `dept` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `dept` varchar(255) DEFAULT NULL,</span><br><span class="line">  `json_value` json DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">insert into dept VALUES(1,&#x27;部门1&#x27;,&#x27;&#123;&quot;deptName&quot;: &quot;部门1&quot;, &quot;deptId&quot;: &quot;1&quot;, &quot;deptLeaderId&quot;: &quot;3&quot;&#125;&#x27;);</span><br><span class="line">insert into dept VALUES(2,&#x27;部门2&#x27;,&#x27;&#123;&quot;deptName&quot;: &quot;部门2&quot;, &quot;deptId&quot;: &quot;2&quot;, &quot;deptLeaderId&quot;: &quot;4&quot;&#125;&#x27;);</span><br><span class="line">insert into dept VALUES(3,&#x27;部门3&#x27;,&#x27;&#123;&quot;deptName&quot;: &quot;部门3&quot;, &quot;deptId&quot;: &quot;3&quot;, &quot;deptLeaderId&quot;: &quot;5&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure>

<p>✅基础查询操作</p>
<p>如果json字符串不是数组，则直接使用<code>$.字段名</code><br>如果json字符串是数组<code>[Array]</code>，则直接使用<code>$[对应元素的索引id]</code></p>
<p>使用 <code>json字段名-&gt;’$.json属性’</code> 进行查询条件<br>举个例子：如果想查询deptLeaderId=5 的数据，那么sql语句如下：<br><code>SELECT * from dept WHERE json_value-&gt;&#39;$.deptLeaderId&#39;=&#39;5&#39;;</code></p>
<p>多条件查询，想查dept为“部门3”和deptLeaderId=5的数据，sql如下：<br><code>SELECT * from dept WHERE json_value-&gt;&#39;$.deptLeaderId&#39;=&#39;5&#39; and dept=&#39;部门3&#39;;</code></p>
<p>json中的多条件查询，想查询json格式中deptLeaderId=5和deptId=5的数据:<br><code>SELECT * from dept WHERE json_value-&gt;&#39;$.deptLeaderId&#39;=&#39;5&#39; and json_value-&gt;&#39;$.deptId&#39;=&#39;5&#39;;</code></p>
<p>两个有json字段的表关联查询，一样的：<br><code>SELECT * from dept,dept_leader  WHERE dept.json_value-&gt;&#39;$.deptLeaderId&#39;=dept_leader.json_value-&gt;&#39;$.id&#39; ;</code></p>
<p>转自：mysql之json操作以及一些json函数：<br><a target="_blank" rel="noopener" href="http://events.jianshu.io/p/40b153000fb2">http://events.jianshu.io/p/40b153000fb2</a></p>
<h2 id="mysql表数据迁移"><a href="#mysql表数据迁移" class="headerlink" title="mysql表数据迁移"></a>mysql表数据迁移</h2><p>不是一个库只能先select出来，然后构造insert</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从一个表复制数据，然后把数据插入到另一个新表中：</span><br><span class="line">create  table 新表  as select * from 旧表</span><br><span class="line"></span><br><span class="line">INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中：</span><br><span class="line">insert into 新表 (select * from 旧表)</span><br><span class="line"></span><br><span class="line">只复制希望的列插入到另一个已存在的表中：</span><br><span class="line">insert into 新表(字段1, 字段2, 字段n)  select  字段1, 字段2, 字段n from 旧表</span><br></pre></td></tr></table></figure>


<h2 id="mysql中geometry类型的插入"><a href="#mysql中geometry类型的插入" class="headerlink" title="mysql中geometry类型的插入"></a>mysql中geometry类型的插入</h2><p>得加个<code>geoFromText(‘lineString(...)’)</code></p>
<p>geometry那篇博客里也有。</p>
<p>MySQL中地理位置数据扩展geometry的使用心得：<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2074765">https://cloud.tencent.com/developer/article/2074765</a></p>
<h2 id="mysql的mediumtext和text"><a href="#mysql的mediumtext和text" class="headerlink" title="mysql的mediumtext和text"></a>mysql的mediumtext和text</h2><p>MysQL中的mediumtext是一种文本数据类型，可以存储最长16777215个字符的文本数据。它是longtext和text类型之间的中间类型，比text类型更大，但比longtext类型更小。mediumtext 通常用于存储大量文本数据，例如文章、博客站子和评论等。</p>
<p>在msQL中，text是一种文本类型，可以存健最长 65535个字符的文本数据。 text类型通常用于存储的大量文本的数据。例如短信、邮件内容、简短的评论等。如果需要存储更长的文本数据，可以使用 longtext类型或 mediumtext类型。</p>
<h2 id="mysql的tinyint-unsigned能存多大"><a href="#mysql的tinyint-unsigned能存多大" class="headerlink" title="mysql的tinyint unsigned能存多大"></a>mysql的tinyint unsigned能存多大</h2><p>mysql的 tinyint unsigned能存多大：<br>MySQL的tinyint unsigned 数据类型可以存储0到255之间的整数。它使用8位(1字节）存储数据。由于它是无符号的，因此它不能存储负数，但可以存储比有符号的tinyint（-128 - 127）更大的正数值。</p>
<h2 id="NOT-NULL-DEFAULT-quot-quot"><a href="#NOT-NULL-DEFAULT-quot-quot" class="headerlink" title="NOT NULL DEFAULT &quot;&quot;"></a><code>NOT NULL DEFAULT &quot;&quot;</code></h2><p>在数据库表中，<code>NOT NULL DEFAULT &quot;&quot;</code> 表示该字段不能为空且如果没有指定值，将使用默认值””(空宇符串)。当使用MyBatis 插入数据时，如果该字段传递了null值，它将尝试将其插入数据库。由于该字段被指定为 NOT NULL，因此数据库会拒绝插入null 值，并返回错误消息。因此，建议在插入数据之前检查每个字段是否具有有效值，特别注意传的对象，如果没赋值为null，将报错。</p>
<p>总之：<code>NOT NULL DEFAULT &quot;&quot;</code>，要么不传，要么传非null。传null会报错，而不是传null给默认值。</p>
<h2 id="插入之后想获取id"><a href="#插入之后想获取id" class="headerlink" title="插入之后想获取id"></a>插入之后想获取id</h2><p>useGeneratedkeys 获取id，不是从insert返回，而是插入实体类的id。</p>
<p>Long insertNum = myDao.insert(myDO);<br>Long id = myDO.getId();</p>
<h2 id="关联表分条件关联"><a href="#关联表分条件关联" class="headerlink" title="关联表分条件关联"></a>关联表分条件关联</h2><p>例如a关联b表，a表status=1时用task_id关联，否则用flow_id<br>关联。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from a left join b on </span><br><span class="line">case</span><br><span class="line">    when a.status=1 then a.task_id = b.task_id</span><br><span class="line">    else a.flow_id = b.flow_id</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这样貌似运行时间长，看一下是否用<code>from a, b where (条件1) or (条件2)</code></p>
<h2 id="分组计数"><a href="#分组计数" class="headerlink" title="分组计数"></a>分组计数</h2><p>有一张表，有city、status字段，相统计各个城市不同status的数量和比例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">已知各status的情况下，分列显示：</span><br><span class="line">select city, count(1) as total, sum(status=0) as status_0, sum(status=1) as status_1</span><br><span class="line">from table</span><br><span class="line">group by city;</span><br><span class="line"></span><br><span class="line">不明status是什么，分行显示：</span><br><span class="line">select city, status, count(1) as count</span><br><span class="line">group by city, status;</span><br><span class="line"></span><br><span class="line">求两个数的商，并保留两位小数：</span><br><span class="line">rount(num1 / num2, 2)</span><br></pre></td></tr></table></figure>

<h2 id="想将另一张表的数据按照映射更新到另一张表："><a href="#想将另一张表的数据按照映射更新到另一张表：" class="headerlink" title="想将另一张表的数据按照映射更新到另一张表："></a>想将另一张表的数据按照映射更新到另一张表：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update table_a</span><br><span class="line">left join table_b</span><br><span class="line">on table_a.task_id = table_b.task_id</span><br><span class="line">set table_a.status = table_b.status</span><br><span class="line">where table_a.task_id in ()</span><br></pre></td></tr></table></figure>
<p>仅更新table_a的数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/11/myblog/JAVA/java%20web/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/11/myblog/JAVA/java%20web/" class="post-title-link" itemprop="url">java web相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-11 14:46:24" itemprop="dateCreated datePublished" datetime="2022-09-11T14:46:24+08:00">2022-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 15:33:03" itemprop="dateModified" datetime="2023-08-20T15:33:03+08:00">2023-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网页502"><a href="#网页502" class="headerlink" title="网页502"></a>网页502</h2><p>502 Bad Gateway是指错误网关，无效网关；在互联网中表示一种网络错误。表现在WEB浏览器中给出的页面反馈。</p>
<p>服务端代码下掉，重新部署的间隙，访问接口会502.</p>
<h2 id="504错误"><a href="#504错误" class="headerlink" title="504错误"></a>504错误</h2><p>504错误代表网关超时 （Gateway timeout），是指服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p>
<p>接口504超时，是服务端这边超时断开请求了，需要看一下nginx配置。如果是tomcat，看一下conf中配置的请求超时时间。</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="✅nginx是什么？"><a href="#✅nginx是什么？" class="headerlink" title="✅nginx是什么？"></a>✅nginx是什么？</h3><blockquote>
<p>Nginx是十分轻量级的HTTP服务器。Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器。</p>
<p>Ngnix 是互联网企业使用最为广泛的代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。</p>
<p>Nginx是lgor Sysoev为俄罗斯访问量第二的rambler.ru站点设计开发的。从2004年发布至今，凭借开源的力量，已经接近成熟与完善。<br>Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。<br>Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p>
</blockquote>
<p>nginx是服务器，代理服务器，负载均衡，反向代理，服务器架构。</p>
<p>Nginx凭借其稳定性、低资源消耗、简单配置和丰富的功能，从十多年前名不见经传的Web服务器软件，发展到如今能够跟Apache匹敌的地位。</p>
<p>1、作为Web服务器，Nginx处理静态文件、索引文件，自动索引的效率非常高</p>
<p>2、作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度</p>
<p>3、作为负载均衡服务器，Nginx既可以在内部直接支持Rails和PHP，也可以支持HTTP代理服务器对外进行服务，同时还支持简单的容错和利用算法进行负载均衡</p>
<p>4、在性能方面，Nginx是专门为性能优化而开发的，实现上非常注重效率。它采用内核Poll模型，可以支持更多的并发连接，最大可以支持对5万个并发连接数的响应，而且只占用很低的内存资源</p>
<p>5、在稳定性方面，Nginx采取了分阶段资源分配技术，使得CPU与内存的占用率非常低。Nginx官方表示，Nginx保持1万个没有活动的连接，而这些连接只占用2.5MB内存，因此，类似DOS这样的攻击对Nginx来说基本上是没有任何作用的</p>
<p>6、在高可用性方面，Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到7x24小时不间断地运行<br>————————————————<br>解读nginx：<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_60274825/article/details/122101640">https://blog.csdn.net/weixin_60274825/article/details/122101640</a></p>
<h3 id="✅什么是代理服务器？"><a href="#✅什么是代理服务器？" class="headerlink" title="✅什么是代理服务器？"></a>✅什么是代理服务器？</h3><p>代理服务器是介于客户端和Web服务器之间的另一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页，而是通过向代理服务器发送请求，信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p>
<p><img src="/images/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p>
<p>代理位于Web客户端和Web服务器之间，扮演“中间人”的角色。<br>HTTP的代理服务器既是Web服务器又是Web客户端。</p>
<h3 id="✅什么是正反向代理"><a href="#✅什么是正反向代理" class="headerlink" title="✅什么是正反向代理"></a>✅什么是正反向代理</h3><p>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取的内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端，客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p>正向代理代理的对象是客户端，正向代理中，proxy和client同属一个LAN，对server透明 （客户端服务端多对一？）</p>
<p>反向代理服务器：在服务器端接收客户端的请求，然后把请求分发给具体的服务器进行处理，然后再将服务器的响应结果反馈给客户端。Nginx就是其中的一种反向代理服务器软件。</p>
<p>反向代理代理的对象是服务端，反向代理中，proxy和server同属一个LAN，对client透明  （客户端服务端多对多）</p>
<p>正向代理客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。<br>反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间中的内容发送普通请求，接着反向代理将判断向哪个原始服务器转交请求，并将获得的内容返回给客户端。<br>————————————————<br>解读nginx：<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_60274825/article/details/122101640">https://blog.csdn.net/weixin_60274825/article/details/122101640</a></p>
<h3 id="✅nginx与tomcat什么关系"><a href="#✅nginx与tomcat什么关系" class="headerlink" title="✅nginx与tomcat什么关系"></a>✅nginx与tomcat什么关系</h3><p>nginx是上面做web代理服务器的，而tomcat是上面做真正web服务器的。</p>
<p>nginx常用做静态内容服务和代理服务器，直面外来请求转发给后面的应用服务（tomcat，django什么的），tomcat更多用来做做一个应用容器，让java web app跑在里面的东西，对应同级别的有jboss,jetty等东西。</p>
<p>但是事无绝对，nginx也可以通过模块开发来提供应用功能，tomcat也可以直接提供http服务，通常用在内网和不需要流控等小型服务的场景。</p>
<p>严格的来说，Apache/Nginx 应该叫做「HTTP Server」；而 Tomcat 则是一个「Application Server」，或者更准确的来说，是一个「Servlet/JSP」应用的容器（Ruby/Python 等其他语言开发的应用也无法直接运行在 Tomcat 上）。</p>
<p>一个 HTTP Server 关心的是 HTTP 协议层面的传输和访问控制，所以在 Apache/Nginx 上你可以看到代理、负载均衡等功能。客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。通过 CGI 技术，也可以将处理过的内容通过 HTTP Server 分发，但是一个 HTTP Server 始终只是把服务器上的文件如实的通过 HTTP 协议传输给客户端。</p>
<p>而应用服务器，则是一个应用执行的容器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。对于 Tomcat 来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44517990/article/details/100712182">https://blog.csdn.net/weixin_44517990/article/details/100712182</a></p>
<h3 id="✅-springboot内置tomcat-和-tomcat"><a href="#✅-springboot内置tomcat-和-tomcat" class="headerlink" title="✅ springboot内置tomcat 和 tomcat"></a>✅ springboot内置tomcat 和 tomcat</h3><p>1.内置的tomcat没有tomcat的主页页面<a target="_blank" rel="noopener" href="http://localhost:9999/%EF%BC%8C%E8%80%8C%E6%88%91%E4%BB%AC%E5%B9%B3%E6%97%B6%E7%94%A8%E7%9A%84%E5%A4%96%E7%BD%AE%E7%9A%84tomcat%E6%98%AF%E6%9C%89%E7%9A%84">http://localhost:9999/，而我们平时用的外置的tomcat是有的</a></p>
<p>2.内置的tomcat可以用main跑项目，而如果要用外置的tomcat就需要把项目打成war包，然后拷贝到webapp下进行运行</p>
<p>Tomcat：<br>Tomcat是一个Web应用服务器，也是Servlet容器。它的作用是，解析客户端client发起的request，并组装出HttpRequest、创建HttpResponse，将二者交于内部的HttpServlet处理和填充</p>
<p>Tomcat映射处理请求的Servlet是通过web.xml做的。</p>
<p>SpringMVC使用一个DispatcherServlet来接收所有的请求，并把它们分发到不同的controller中来做进一步处理。</p>
<p>SpringMVC = Spring + Web框架，Spring这部分主要是AOP/IOC容器。</p>
<p>SpringBoot是Spring的扩展，简化了Spring的配置，通过starter的方式简化了常用组件依赖的引入，使其更加易用。</p>
<p>SpringBoot内置了tomcat。</p>
<h3 id="✅tomcat和spring-mvc"><a href="#✅tomcat和spring-mvc" class="headerlink" title="✅tomcat和spring mvc"></a>✅tomcat和spring mvc</h3><p>tomcat既是Http服务器（不用代理的话，其实是应用服务器），Http服务器与Servlet容器的功能界限是：可以把HTTP服务器想象成前台的接待，负责网络通信和解析请求，Servlet容器是业务部门，负责处理业务请求。</p>
<p>Tomcat和Servlet作为Web服务器和Servlet容器的结合，可以接受网络http请求解析为Servlet规范的请求对象和响应对象。比如，HttpServletRequest对象是Tomcat提供的，Servlet是规范，Tomcat是实现规范的Servlet容器。tomcat监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理;然后调用那个servlet的service方法，service方法返回一个response对象;<br>tomcat再把这个response返回给客户端。</p>
<p>SpringMVC是处理Servlet请求的应用，其中DispatcherServlet实现了Servlet接口，Tomcat负责加载和调用DispatcherServlet。同时，DispatcherServlet有自己的容器（SpringMVC）容器，这个容器负责管理SpringMVC相关的bean，比如Controler和ViewResolver等。同时，Spring中还有其他的Bean比如Service和DAO等，这些由全局的Spring IOC容器管理，因此，Spring有两个IOC容器。</p>
<p>如果只是使用spring(不包含springmvc)，那么是tomcat容器解析xml文件，通过反射实例化对应的类，根据这些servlet规范实现类，触发对应的代码处理逻辑，这个时候tomcat负责http报文的解析和servlet调度的工作。</p>
<p>如果使用spring mvc，那么tomcat只是解析http报文，然后将其转发给dispatchsetvlet，然后由springmvc根据其配置，实例对应的类，执行对应的逻辑，然后返回结果给dispatchservlet，最后由它转发给tomcat,由tomcat负责构建http报文数据。</p>
<p>DispatcherServlet：是Spring MVC中的一个类，实现了Servlet接口。所以部署在Tomcat中的Spring项目，对Tomcat来说，都是一个servlet。</p>
<p>————————————————<br>spring mvc还需要tomcat吗？<br>版权声明：本文为CSDN博主「黄泥川水猴子」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40277163/article/details/124730530">https://blog.csdn.net/qq_40277163/article/details/124730530</a></p>
<h3 id="✅nginx与域名解析DNS什么关系"><a href="#✅nginx与域名解析DNS什么关系" class="headerlink" title="✅nginx与域名解析DNS什么关系"></a>✅nginx与域名解析DNS什么关系</h3><p>首先，nginx是web服务器和反向代理服务器。 dns是域名解析服务器。nginx不带dns。</p>
<p>作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。访问域名，dns帮忙解析到ip，然后访问这个地址的资源呈现给你。hosts和nginx在后面用到。</p>
<p>hosts文件：<br>hosts文件是个本地域名解析文件，不管你是windwos还是linux，那都是有的，他里面的有效内容，就是一个个的ip和域名映射关系。<br>windows一般在：C:/Windows/System32/drivers/etc/hosts<br>Linux的hosts文件路径一般：/etc/hosts<br>比如：127.0.0.1 localhost<br>这个文件其实也是配置了ip和域名之间的映射关系的数据库，本地要是有这个文件，就优先用这个文件中的配置去解析，如果没有，那就通过dns解析。<br>注意：hosts文件只能配置ip和域名的映射关系，但是不能配置端口号，默认访问80端口</p>
<p>因为要解决端口问题，这里就得使用反向代理软件nginx，nginx中的每个server就是一个反向代理配置，可以有多个server。</p>
<p>理解：<em><strong>客户端请求 - dns解析域名 - 解析到nginx服务器的ip - nginx代理到tomcat服务器+端口 - tomcat将请求给servlet - servlet的service处理请求。</strong></em></p>
<h3 id="✅nginx与CDN内容分发网络什么关系"><a href="#✅nginx与CDN内容分发网络什么关系" class="headerlink" title="✅nginx与CDN内容分发网络什么关系"></a>✅nginx与CDN内容分发网络什么关系</h3><p>cdn是网络，nginx是服务器也是负载均衡。</p>
<p>cdn：<br>1、CDN的全称是Content Delivery Network，即内容分发网络。<br>2、其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。<br>3、通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。<br>4、其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度**。<br>5、内容分发网络是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。</p>
<p>cdn的工作原理：<br>CDN这个技术其实说起来并不复杂，最初的核心理念，就是将内容缓存在终端用户附近。</p>
<p>内容源不是远么？那么，我们就在靠近用户的地方，建一个缓存服务器，把远端的内容，复制一份，放在这里，不就OK了？</p>
<p>具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓吧？）</p>
<p>大家可能觉得，这个不就是“镜像服务器”嘛？其实不一样。镜像服务器是源内容服务器的完整复制。而CDN，是部分内容的缓存，智能程度更高。</p>
<p><img src="/images/CDN.png"></p>
<p>借用阿里云官网的例子，来简单介绍CDN的工作原理。</p>
<p>假设通过CDN加速的域名为 <a href="http://www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：">www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：</a></p>
<p>1、当终端用户（北京）向<a target="_blank" rel="noopener" href="http://www.a.com下的指定资源发起请求时,首先向ldns(本地dns)发起域名解析请求./">www.a.com下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。</a></p>
<p>2、LDNS检查缓存中是否有<a target="_blank" rel="noopener" href="http://www.a.com的ip地址记录.如果有,则直接返回给终端用户;如果没有,则向授权dns查询./">www.a.com的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。</a></p>
<p>3、当授权DNS解析<a target="_blank" rel="noopener" href="http://www.a.com时,返回域名cname/">www.a.com时，返回域名CNAME</a> <a target="_blank" rel="noopener" href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></p>
<p>4、域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</p>
<p>5、LDNS获取DNS返回的解析IP地址。</p>
<p>6、用户获取解析IP地址。</p>
<p>7、用户向获取的IP地址发起对该资源的访问请求。</p>
<p>8、如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</p>
<p>9、如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。</p>
<p>所以：<br>（1）CDN的加速资源是跟域名绑定的。<br>（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP<br>（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。</p>
<hr>
<p>nginx负载均衡：负载均衡实际上就是将大量请求进行分布式处理的策略</p>
<p>Nginx 作为一个基于 C 实现的高性能 Web 服务器，可以通过系列算法解决上述的负载均衡问题。并且由于它具有高并发、高可靠性、高扩展性、开源等特点，成为开发人员常用的反向代理工具</p>
<p>1、正向代理</p>
<p>正向代理（Forward Proxy）最大的特点是，客户端非常明确要访问的服务器地址，它代理客户端，替客户端发出请求。比如：科学上网。</p>
<p>假设客户端想要访问 Google，它明确知道待访问的服务器地址是 <a target="_blank" rel="noopener" href="https://www.google.com/%EF%BC%8C%E4%BD%86%E7%94%B1%E4%BA%8E%E6%9D%A1%E4%BB%B6%E9%99%90%E5%88%B6%EF%BC%8C%E5%AE%83%E6%89%BE%E6%9D%A5%E4%BA%86%E4%B8%80%E4%B8%AA%E8%83%BD%E5%A4%9F%E8%AE%BF%E9%97%AE%E5%88%B0">https://www.google.com/，但由于条件限制，它找来了一个能够访问到</a> Google 的”朋友”：代理服务器。客户端把请求发给代理服务器，由代理服务器代替它请求 Google，最终再将响应返回给客户端。这便是一次正向代理的过程，该过程中服务器并不知道真正发出请求的是谁。<br>（客户端 - 正向代理 - 服务器）</p>
<p>2、反向代理</p>
<p>随着请求量的爆发式增长，服务器觉得自己一个人始终是应付不过来，需要兄弟服务器们帮忙，于是它喊来了自己的兄弟以及代理服务器朋友。此时，来自不同客户端的所有请求实际上都发到了代理服务器处，再由代理服务器按照一定的规则将请求分发给各个服务器。这就是反向代理（Reverse Proxy），反向代理隐藏了服务器的信息，它代理的是服务器端，代其接收请求。换句话说，反向代理的过程中，客户端并不知道具体是哪台服务器处理了自己的请求。如此一来，既提高了访问速度，又为安全性提供了保证<br>（一堆客户端 - 反向代理 - 一堆服务器）</p>
<p>在这之中，反向代理需要考虑的问题是，如何进行均衡分工，控制流量，避免出现局部节点负载过大的问题。通俗的讲，就是如何为每台服务器合理的分配请求，使其整体具有更高的工作效率和资源利用率。</p>
<p>3、负载均衡常用算法</p>
<p>轮询 （round-robin）<br>轮询为负载均衡中较为基础也较为简单的算法，它不需要配置额外参数。假设配置文件中共有 台服务器，该算法遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。特点：由于该算法中每个请求按时间顺序逐一分配到不同的服务器处理，因此适用于服务器性能相近的集群情况，其中每个服务器承载相同的负载。但对于服务器性能不同的集群而言，该算法容易引发资源分配不合理等问题。</p>
<p>加权轮询<br>为了避免普通轮询带来的弊端，加权轮询应运而生。在加权轮询中，每个服务器会有各自的 weight。一般情况下，weight 的值越大意味着该服务器的性能越好，可以承载更多的请求。该算法中，客户端的请求按权值比例分配，当一个请求到达时，优先为其分配权值最大的服务器。特点：加权轮询可以应用于服务器性能不等的集群中，使资源分配更加合理化。</p>
<p>IP 哈希（IP hash）<br>ip_hash 依据发出请求的客户端 IP 的 hash 值来分配服务器，该算法可以保证同 IP 发出的请求映射到同一服务器，或者具有相同 hash 值的不同 IP 映射到同一服务器。特点：该算法在一定程度上解决了集群部署环境下 Session 不共享的问题。</p>
<p>所以：<br>Nginx 作为一款优秀的反向代理服务器，可以通过不同的负载均衡算法来解决请求量过大情况下的服务器资源分配问题。较为常见的负载均衡算法有轮询、加权轮询、IP 哈希等等，可分别应对不同的请求场景。</p>
<p>————————————————<br>好文章：从对CDN的理解到Nginx负载均衡<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40409143/article/details/118330238">https://blog.csdn.net/qq_40409143/article/details/118330238</a></p>
<h3 id="✅nginx与RPC远程过程调用什么关系？"><a href="#✅nginx与RPC远程过程调用什么关系？" class="headerlink" title="✅nginx与RPC远程过程调用什么关系？"></a>✅nginx与RPC远程过程调用什么关系？</h3><p>RPC是远程过程调用，是一种计算机通信思想。</p>
<p>nginx是代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。</p>
<p>Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互。也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</p>
<p>讲RPC、RPC与nginx、RPC与HTTP间的关系的好文章：<br><a target="_blank" rel="noopener" href="https://www.kancloud.cn/machh03/server/2096716">https://www.kancloud.cn/machh03/server/2096716</a></p>
<h3 id="✅与gateway有什么关系？"><a href="#✅与gateway有什么关系？" class="headerlink" title="✅与gateway有什么关系？"></a>✅与gateway有什么关系？</h3><p>网关(Gateway)就是一个网络连接到另一个网络的“关口”。</p>
<p><img src="/images/gateway.png"></p>
<p>1、nginx也可以做网关，是用户访问的总入口，也就是前端页面的容器，流量网关。</p>
<p>流量网关是定义全局性的、跟具体的后端业务应用和服务完全无关的策略网关。<br>流量网关通常只专注于全局的Api管理策略，比如全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等，有点类似防火墙。</p>
<p>2、gateway的定义是针对每一个业务微服务来得，属于业务网关。是介于nignx以及业务应用之间的中间层，主要负责将请求路由到不同的微服务中以及对请求的合法性进行校验。</p>
<p>业务网关针对具体的业务需要提供特定的流控策略、缓存策略、鉴权认证策略等等。<br>业务网关一般部署在流量网关之后、业务系统之前，比流量网关更靠近业务系统。通常API网指的是业务网关。 有时候我们也会模糊流量网关和业务网关，让一个网关承担所有的工作,所以这两者之间并没有严格的界线。</p>
<hr>
<p>网关可以看做系统与外界联通的入口，我们可以在网关进行处理一些非业务逻辑的逻辑，比如权限验证，监控，缓存，请求路由等等。</p>
<p>1、nginx是用户到 前端工程 的网关，对外网关<br>nginx是用C语言写的<br>nginx做网关，更多的是做总流量入口，反向代理，负载均衡等，还可以用来做web服务器。<br>Nginx在其中扮演的角色是什么？<br>反向代理<br>负载均衡</p>
<p>2、gateway 是前端工程 到 后台服务器之间的一个 对内网关<br>gateway是java语言的一个框架，可以在框架上进行代码的扩展与控制，例如：安全控制，统一异常处理，XXS,SQL注入等；权限控制，黑白名单，性能监控，日志打印等<br>gateway的主要功能有，路由，断言，过滤器，利用它的这些特性，可以做流控。<br>SpringGateway在其中扮演的角色是什么？<br>统一鉴权</p>
<p>nginx与gateway：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yangbindxj/article/details/125040773">https://blog.csdn.net/yangbindxj/article/details/125040773</a></p>
<hr>
<p>网关服务的端口号默认是80或者443.<br>相同点：都是可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等，可以实现和网关一样的效果。<br>Nginx实现负载均衡的原理属于服务器端负载均衡器。<br>Gateway实现负载均衡原理采用本地负载均衡器的形式。</p>
<h3 id="✅nginx与统一接入有什么关系？"><a href="#✅nginx与统一接入有什么关系？" class="headerlink" title="✅nginx与统一接入有什么关系？"></a>✅nginx与统一接入有什么关系？</h3><p>统一接入层是：指的是设置专属一层，统一接入所有流量，包括 PC 流量、无线流量、IoT 流量。在应用层之上的一层。</p>
<p>如果没有统一接入层，之前的业务方，例如购物车、商品等都要自己维护一个网关，这就涉及到维护成本和机器成本。例如卸载 HTTPS，如果所有业务方都要申请证书，那造成的应用成本是非常高的。可如果将所有功能全放在这一层进行，好处非常明显：一方面是机器集中管理节省成本；另外一方面，如果遇到新的瓶颈可以在统一接入层集中优化，如请求响应 Body 统一在这一层进行压缩减少带宽消耗，压缩会消耗 CPU，可以在这一层通过硬件加速的方式集中优化等。</p>
<p>阿里统一接入层：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96510277?hmsr=toutiao.io">https://zhuanlan.zhihu.com/p/96510277?hmsr=toutiao.io</a></p>
<p>统一接入层方案：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Leo_wl/archive/2012/10/17/2728541.html">https://www.cnblogs.com/Leo_wl/archive/2012/10/17/2728541.html</a></p>
<p>统一接入层是网关中最前端的服务，统一接入到集群中。<br>所以，统一接入层应该是在web代理服务器nginx前的。</p>
<h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><h3 id="nginx配置文件结构"><a href="#nginx配置文件结构" class="headerlink" title="nginx配置文件结构"></a>nginx配置文件结构</h3><p>Main 位于 nginx.conf 配置文件的最高层；<br>Main 层下可以有 Event、HTTP 层；<br>Http 层下面允许有多个 Server 层，用于对不同的网站做不同的配置；<br>Server 层下面允许有多个 Location，用于对不同的路径进行不同模块的配置。</p>
<p>1、main（最上面）<br>全局配置部分用来配置对整个 server 都有效的参数。主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等<br>全局Main配置<br>user nginx;<br>worker_processes 1; #设置值和CPU核心数一致</p>
<p>error_log /var/log/nginx/error.log warn; #日志位置和日志级别<br>pid       /var/run/nginx.pid;</p>
<p>2.event<br>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 worker process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 worker process 可以同时支持的最大连接数等。<br>Event配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、http<br>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。<br>http配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  include       /etc/nginx/mime.types;</span><br><span class="line">  default_type application/octet-stream;</span><br><span class="line">  log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                    &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                    &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">  access_log /var/log/nginx/access.log main;</span><br><span class="line">  sendfile       on;</span><br><span class="line">  #tcp_nopush     on;</span><br><span class="line">  keepalive_timeout 65;</span><br><span class="line">  #gzip on;</span><br><span class="line">  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、server<br>Server 块也被叫做“虚拟主机”部分，它描述的是一组根据不同 server_name 指令逻辑分割的资源，这些虚拟服务器响应 HTTP 请求，因此都包含在 http 部分。最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。一个 server 块可以配置多个 location 块。<br>server配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  location / &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">      index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">  error_page   500 502 503 504 /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nginx配置结构：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1729793004418584302&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1729793004418584302&amp;wfr=spider&amp;for=pc</a></p>
<p>菜鸟nginx配置：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">https://www.runoob.com/w3cnote/nginx-setup-intro.html</a></p>
<p>nginx配置详细介绍：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_12218973/2457715">https://blog.51cto.com/u_12218973/2457715</a></p>
<h3 id="nginx超时配置"><a href="#nginx超时配置" class="headerlink" title="nginx超时配置"></a>nginx超时配置</h3><p>Nginx主要有四类超时设置：客户端超时设置、DNS解析超时设置、代理超时设置，如果使用ngx_lua，则还有lua相关的超时设置。</p>
<p>1、客户端超时</p>
<p>客户端超时主要设置有读取请求头超时时间、读取请求体超时时间、发送响应超时时间、长连接超时时间。通过客户端超时设置避免客户端恶意或者网络状况不佳造成连接长期占用，影响服务端的可处理的能力。</p>
<p><strong>client_header_timeout time</strong>：设置读取客户端请求头超时时间，默认为60s，如果在此超时时间内客户端没有发送完请求头，则响应408（RequestTime-out）状态码给客户端。</p>
<p><strong>client_body_timeout time</strong>：设置读取客户端内容体超时时间，默认为60s，此超时时间指的是两次成功读操作间隔时间，而不是发送整个请求体的超时时间，如果在此超时时间内客户端没有发送任何请求体，则响应408（RequestTime-out）状态码给客户端。</p>
<p><strong>send_timeout time</strong>：设置发送响应到客户端的超时时间，默认为60s，此超时时间指的也是两次成功写操作间隔时间，而不是发送整个响应的超时时间。如果在此超时时间内客户端没有接收任何响应，则Nginx关闭此连接。</p>
<p>**keepalive_timeout timeout [header_timeout]**：设置HTTP长连接超时时间，其中，第一个参数timeout是告诉Nginx长连接超时时间是多少，默认为75s。第二个参数header_timeout是用于设置响应头“Keep-Alive: timeout=time”，即告知客户端长连接超时时间。如果timeout设置为0，则表示禁用长连接。</p>
<p>2、DNS解析超时</p>
<p><strong>resolver_timeout 30s</strong>：设置DNS解析超时时间，默认为30s</p>
<p>3、代理超时</p>
<p>主要有三组配置：网络连接/读/写超时设置、失败重试机制设置、upstream存活超时设置</p>
<p><strong>proxy_connect_timeout time</strong>：与后端/上游服务器建立连接的超时时间，默认为60s，此时间不超过75s。</p>
<p><strong>proxy_read_timeout time</strong>：设置从后端/上游服务器读取响应的超时时间，默认为60s，此超时时间指的是两次成功读操作间隔时间，而不是读取整个响应体的超时时间，如果在此超时时间内上游服务器没有发送任何响应，则Nginx关闭此连接。</p>
<p><strong>proxy_send_timeout time</strong>：设置往后端/上游服务器发送请求的超时时间，默认为60s，此超时时间指的是两次成功写操作间隔时间，而不是发送整个请求的超时时间，如果在此超时时间内上游服务器没有接收任何响应，则Nginx关闭此连接。</p>
<p><strong>proxy_next_upstream_tries number</strong>：设置重试次数，默认0表示不限制，注意此重试次数指的是所有请求次数（包括第一次和之后的重试次数之和）。</p>
<p><strong>proxy_next_upstream_timeout time</strong>：设置重试最大超时时间，默认0表示不限制。</p>
<p>Nginx超时配置：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiao__jia__jia/article/details/124075274">https://blog.csdn.net/xiao__jia__jia/article/details/124075274</a></p>
<h2 id="PoolingHttpClientConnectionManager"><a href="#PoolingHttpClientConnectionManager" class="headerlink" title="PoolingHttpClientConnectionManager"></a>PoolingHttpClientConnectionManager</h2><p>HttpClien高并发请求连接池 - PoolingHttpClientConnectionManager</p>
<p>连接池：<br>连接池技术作为创建和管理连接的缓冲池技术，目前已广泛用于诸如数据库连接等长连接的维护和管理中，能够有效减少系统的响应时间，节省服务器资源开销。其优势主要有两个：其一是减少创建连接的资源开销，其二是资源的访问控制。连接池管理的对象是长连接。</p>
<p>PoolingHttpClientConnectionManager是通过租用连接和收回链接的方式来实现的。解决了http请求的多线程问题。</p>
<p>依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>实现http连接池：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34484062/article/details/109470135">https://blog.csdn.net/qq_34484062/article/details/109470135</a></p>
<h2 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h2><p>远程过程调用（Remote Procedure Call，缩写为 RPC）允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，比如 Java RMI。</p>
<p>远程过程调用是一个分布式计算的客户端-服务器（Client/Server）的例子，它简单而又广受欢迎。 远程过程调用总是由客户端对服务器发出一个执行若干过程请求，并用客户端提供的参数。执行结果将返回给客户端。 由于存在各式各样的变体和细节差异，对应地派生了各式远程过程调用协议，而且它们并不互相兼容。</p>
<p>为了允许不同的客户端均能访问服务器，许多标准化的 RPC 系统应运而生了。其中大部分采用接口描述语言（Interface Description Language，IDL），方便跨平台的远程过程调用。<br>有些实现扩展了远程调用的模型，实现了双向的服务调用，但是不管怎样，调用过程还是由一个客户端发起，服务器端提供响应，基本模型没有变化。</p>
<p>服务的调用过程为：<br>1、client调用client stub，这是一次本地过程调用<br>2、client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做 marshalling<br>3、client所在的系统将消息发送给server<br>4、server的的系统将收到的包传给server stub<br>5、server stub解包得到参数。 解包也被称作 unmarshalling<br>6、最后server stub调用服务过程. 返回结果按照相反的步骤传给client</p>
<hr>
<p>RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存。</p>
<p>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。<strong>HTTP 调用其实也可以看成是一种特殊的 RPC，只不过传统意义上的 RPC 是指长连接数据交互，而 HTTP 一般是指即用即走的短链接。</strong></p>
<p>RPC 在我们熟知的各种中间件中都有它的身影。Nginx/Redis/MySQL/Dubbo/Hadoop/Spark/Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的，我们<strong>这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术</strong>。RPC 在技术中的地位好比我们身边的空气，它无处不在，但是又有很多人根本不知道它的存在。</p>
<p>例如数据库：<br>子系统和数据库之间的交互也是通过 RPC 进行的，只不过这里是三个子系统之间复杂的组合消息交互罢了。如果再深入进去，你会发现，这里的数据库不是那种单机数据库，而是具备主从复制功能的数据库，比如 MySQL。在互联网企业里一般都会使用这种主从读写分离的数据库。一个业务子系统将数据写往主库，主库再将数据同步到从库，然后另一个业务子系统又从从库里将数据取出来。这时又可以进一步将它们看成是四个子系统之间进行的更加复杂的 RPC 数据交互。</p>
<hr>
<p>一些分布式场景中RPC的使用：（广义上的RPC）</p>
<p>✅nginx<br>Ngnix 是互联网企业使用最为广泛的代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互。也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。不过 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</p>
<p>✅Hadoop<br>在大数据技术领域，RPC 也占据了非常重要的地位。大数据领域广泛应用了非常多的分布式技术，分布式意味着节点的物理隔离，隔离意味着需要通信，通信意味着 RPC 的存在。大数据需要通信的量比业务系统更加庞大，所以在数据通信优化上做的更深。比如最常见的 Hadoop 文件系统 hdfs，一般包括一个 NameNode 和多个 DataNode，NameNode 和 DataNode 之间就是通过一种称为 Hadoop RPC 的二进制协议进行通讯。</p>
<p>✅TensorFlow<br>在人工智能领域，RPC 也很重要，著名的 TensorFlow 框架如果需要处理上亿的数据，就需要依靠分布式计算力，需要集群化，当多个分布式节点需要集体智慧时，就必须引入 RPC 技术进行通讯。Tensorflow Cluster 的 RPC 通讯框架使用了 Google 内部自研的 gRPC 框架。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/machh03/server/2096716">https://www.kancloud.cn/machh03/server/2096716</a><br>里面还有实现rpc</p>
<h2 id="理解http和rpc"><a href="#理解http和rpc" class="headerlink" title="理解http和rpc"></a>理解http和rpc</h2><p>HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 KeepAlive 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</p>
<p>当 HTTP 协议进化到 2.0 之后，Google 开源了一个建立在 HTTP2.0 协议之上的通信框架直接取名为 gRPC，也就是 Google RPC，这时 HTTP 和 RPC 之间已经没有非常明显的界限了。</p>
<p>HTTP 与 RPC 的关系就好比普通话与方言的关系。要进行跨企业服务调用时，往往都是通过 HTTP API，也就是普通话，虽然效率不高，但是通用，没有太多沟通的学习成本。但是在企业内部还是 RPC 更加高效，同一个企业公用一套方言进行高效率的交流，要比通用的 HTTP 协议来交流更加节省资源。整个中国有非常多的方言，正如有很多的企业内部服务各有自己的一套交互协议一样。好比开源 RPC 协议中 Protobuf 和 Thrift 一样，它们两应该是 RPC 协议中使用最为广泛的两个。</p>
<p>rpc基于什么实现网络传输？<br>1.rpc可以基于tcp直接开发自己的协议，这个是可以保持长连接的，tcp的传输效率高，并且可以一直维持链接</p>
<p>2.自定义协议可以优化数据的传输，例如更大的压缩比。分布式系统中非常有用。</p>
<p>3.http协议1.x一般情况下一个来回就关闭连接，虽然提供了keep-alive可以保持长连接，但是依然不方便，所以就出现了http2.0， http2.0基本上可以当做tcp协议使用了。所以grpc就会使用http2.0开发。</p>
<h2 id="rest和restful"><a href="#rest和restful" class="headerlink" title="rest和restful"></a>rest和restful</h2><p>REST，英文全称Representational State Transfer（表述性状态转移），是一组架构约束条件和原则（注意，REST是设计风格而不是标准）。满足这些约束条件和原则的应用程序或设计就是RESTful。可以降低开发的复杂性，提高系统的可伸缩性。体现在Web开发中就是通过HTTP方法中的POST、DELETE、PUT、GET来对资源进行操作。</p>
<p>一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>在 REST 样式的 Web 服务中，每个资源都有一个地址。资源本身都是方法调用的目标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 HTTP GET、POST、PUT、DELETE，还可能包括 HEADER 和 OPTIONS。</p>
<p>Representation（表现层）<br>资源的信息载体形式。它可以是文本、XML、JSON或者是一个二进制文件。它的表现形式应该在HTTP请求的头信息中用Accept和Content-Type字段指定描述。</p>
<p>State Transfer（状态转移）<br>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转移”。</p>
<p>在 HTTP 中，我们一般通过四种 HTTP 动词来对应资源的变化：<br>POST（新建资源，也可用于更新资源）<br>DELETE（删除资源）<br>PUT（更新资源）<br>GET（获取资源）</p>
<p>REST架构原则：<br>对网络上所有资源都有一个资源标识符<br>对资源的操作不会改变标识符<br>同一资源有多种表现形式，如XML、JSON…<br>所有操作都是无状态的（Stateless）</p>
<p>RESTful，是一种网络应用程序的设计风格和开发方式。RESTful可以通过一套统一的接口为Web，iOS和Android提供服务。比如微博开放平台，微信开放平台等，它们不需要有显式的前端，只需要一套提供服务的接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">在使用RESTful风格之前，我们通常是这样操作用户数据:</span><br><span class="line">//创建用户信息</span><br><span class="line">http://localhost:8080/user/createUser</span><br><span class="line">//删除id为1的用户信息</span><br><span class="line">http://localhost:8080/user/deleteUser/1</span><br><span class="line">//修改id为2的用户信息</span><br><span class="line">http://localhost:8080/user/updateUser/2</span><br><span class="line">//获取所有用户信息</span><br><span class="line">http://localhost:8080/user/getUsers</span><br><span class="line"></span><br><span class="line">使用RESTful风格之后:</span><br><span class="line">//创建用户信息</span><br><span class="line">POST http://localhost:8080/user</span><br><span class="line">//删除id为1的用户信息</span><br><span class="line">DELETE http://localhost:8080/user/1</span><br><span class="line">//修改id为2的用户信息</span><br><span class="line">PUT http://localhost:8080/user/2</span><br><span class="line">//获取所有用户信息</span><br><span class="line">GET http://localhost:8080/user获取所有用户信息</span><br><span class="line">通过约定不同的HTTP方法来实现不同的业务，有一个更加直观的了解。</span><br><span class="line">1、看URL就知道要操作什么</span><br><span class="line">2、看HTTP方法就知道要如何操作</span><br><span class="line">3、看HTTP状态码就知道返回结果如何</span><br></pre></td></tr></table></figure>

<p>参考：<br>rest与restful：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44316527/article/details/106276655">https://blog.csdn.net/weixin_44316527/article/details/106276655</a></p>
<hr>
<p>rpc与restful：</p>
<p>RPC（Remote Procedure Call Protocol）就是远程调用。最简单的想法，应该就是把HTTP协议当做RPC来用。比如我们把网址作为一个借口，传入的参数作为函数参数，response的数据作为返回信息。这其实就是一个调用。</p>
<p>RESTful和RPC最大的区别应该就是面向对象了。<br>从设计上来看，RPC，所谓的远程过程调用 ，是面向方法的 ；<br>REST：所谓的 Representational state transfer ，是面向资源的；<br>除此之外，还有一种叫做 SOA，所谓的面向服务的架构，它是面向消息的。<br>很多人只知道GET和POST，因为现在最常用的就是GET和POST了。虽说这应该是违背了HTTP设计的初衷。</p>
<p>序列化协议的区别：<br>接口调用通常包含两个部分，序列化和通信协议。<br>通信协议，上面已经提及了，REST 是 基于 HTTP 协议，而 RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输的。<br>常见的序列化协议，有：json、xml、hession、protobuf、thrift、text、bytes等，REST 通常使用的是 JSON或者XML，而 RPC 使用的是 JSON-RPC，或者 XML-RPC。</p>
<p>什么时候用？<br>REST 接口更加规范，通用适配性要求高，建议对外的接口都统一成 REST。而组件内部的各个模块，可以选择 RPC，一个是不用耗费太多精力去开发和维护多套的HTTP接口，一个RPC的调用性能更高。从性能角度看，由于HTTP本身提供了丰富的状态功能与扩展功能，但也正由于HTTP提供的功能过多，导致在网络传输时，需要携带的信息更多，从性能角度上讲，较为低效。而RPC服务网络传输上仅传输与业务内容相关的数据，传输数据更小，性能更高。</p>
<p>转自：<br><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/53677">https://developer.aliyun.com/article/53677</a></p>
<hr>
<p>restful和http：</p>
<p>REST 是一种软件架构风格。这种风格的典型应用，就是HTTP。其因为简单、扩展性强的特点而广受开发者的青睐。</p>
<p>某种意义下，我们说 REST 可以其实就是指代 HTTP 协议。</p>
<hr>
<p>总结：rpc、http、rest</p>
<p>rpc是一种协议还是，还是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想？更是后者<br>rpc包含：服务发现、负载、容器、网络传输、序列化等组件。<br>rpc指明了程序如何进行网络传输和序列化。</p>
<p>关于rpc和http的比较：<br>rpc的网络传输是如何实现的，rpc是连接，http是短连接。<br>http是一种rpc（广义上），还是rpc可以基于http实现？<br>RPC可以基于TCP协议也可以基于HTTP协议。<br>HTTP需要携带的信息更多，低效，RPC仅传输与业务相关的数据，传输数据更小，性能更高</p>
<p>关于rpc和restful的比较：<br>rpc面向方法，restful面向资源。<br>日常写的接口，更多基于rpc面向方法的，虽然有的是rpc接口，有的是http接口。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jade liu"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Jade liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">104</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jadeliuliu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jadeliuliu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jadeliu1998@163.com" title="E-Mail → mailto:jadeliu1998@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jadeliu1998" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;jadeliu1998" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5823044646" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5823044646" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jade liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
