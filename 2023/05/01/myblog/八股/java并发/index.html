<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="八股文 - java并发 ✅synchronized的使用及原理1.修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁。2.修饰静态方法：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。3.修饰代码">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发">
<meta property="og:url" content="http://example.com/2023/05/01/myblog/%E5%85%AB%E8%82%A1/java%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="Jadeliu&#39;s blog">
<meta property="og:description" content="八股文 - java并发 ✅synchronized的使用及原理1.修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁。2.修饰静态方法：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。3.修饰代码">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-05-01T10:23:05.885Z">
<meta property="article:modified_time" content="2023-05-01T10:24:00.995Z">
<meta property="article:author" content="Jade liu">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/05/01/myblog/%E5%85%AB%E8%82%A1/java%E5%B9%B6%E5%8F%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>java并发 | Jadeliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jadeliu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/01/myblog/%E5%85%AB%E8%82%A1/java%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java并发
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-01 18:23:05 / Modified: 18:24:00" itemprop="dateCreated datePublished" datetime="2023-05-01T18:23:05+08:00">2023-05-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>八股文 - java并发</p>
<h3 id="✅synchronized的使用及原理"><a href="#✅synchronized的使用及原理" class="headerlink" title="✅synchronized的使用及原理"></a>✅synchronized的使用及原理</h3><p>1.修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁。<br>2.修饰静态方法：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。<br>3.修饰代码块 ：指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。 synchronized(类.class) 表示进⼊同步代码前要获得 当前 class 的锁</p>
<p>实现原理：<br>1.jvm基于进入和退出Monitor对象来实现方法同步和代码块同步，monitor是一个对象的监视器。<br>2.synchronized修饰代码块时，JVM采用monitorenter、monitorexit两个字节码指令来实现同步，monitorenter 指令指向同步代码块的开始位置，尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁。 monitorexit 指令则指向同步代码块的结束位置。要从对象监视器中退出，也就是释放锁。<br>3.synchronized修饰同步方法时，JVM采用ACC_SYNCHRONIZED标记符来实现同步，这个标识指明了该方法是一个同步方法。<br>4.monitorenter、monitorexit或者ACC_SYNCHRONIZED都是基于Monitor实现的。<br>5.实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，这部分主要存储对象自身的运行数据，如Hashcode、gc分代年龄、对象锁，锁状态标志，偏向锁（线程）ID，偏向时间等等。64 位虚拟机 Mark Word 是 64bit。<br>6.所谓的Monitor其实是一种同步工具，也可以说是一种同步机制。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，可以叫做内部锁，或者Monitor锁。<br>7.其中有一个锁的计数器，如果对象没有锁定或者当前线程再次进入，锁的计数器+1，退出时-1.</p>
<h3 id="✅synchronized锁的升级"><a href="#✅synchronized锁的升级" class="headerlink" title="✅synchronized锁的升级"></a>✅synchronized锁的升级</h3><p>1.可见性</p>
<ul>
<li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li>
<li>线程加锁后，其它线程无法获取主内存中的共享变量。</li>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li>
</ul>
<p>2.有序性<br>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。<br>因为as-if-serial语义（不管怎么重排序，单线程的程序的执行结果不能被改变）的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。<br>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<p>3.可重入性<br>synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。<br>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。</p>
<p>4.非公平性<br>并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，这样做的目的是提高执行性能，缺点时可能会产生线程饥饿现象。</p>
<h3 id="✅synchronized锁的升级-1"><a href="#✅synchronized锁的升级-1" class="headerlink" title="✅synchronized锁的升级"></a>✅synchronized锁的升级</h3><p>Java对象头里，有一块结构，叫Mark Word标记字段，这块结构会随着锁的状态变化而变化。<br>在JDK6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁。依赖底层操作系统的互斥锁来实现，对线程阻塞和唤醒都需要操作系统的协助，需要从用户态切换到内核态来执行，代价昂贵。<br>从JDK6开始，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状 态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。</p>
<ol>
<li>偏向锁：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。</li>
<li>轻量级锁：如果有另一个线程试图锁定某个被偏斜过的对象，JVM会撤销偏向锁。线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁。自旋会消耗CPU。但是竞争的线程不会阻塞，提高了程序的响应速度。</li>
<li>重量级锁：当锁处于这个状态下，其他线程试图获取锁时， 都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。线程不使用自旋，不会消耗CPU，但是线程阻塞，响应时间缓慢。</li>
</ol>
<p>自旋锁：在线程进入阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，线程就无需执行阻塞操作，避免了用户态到内核态的切换。</p>
<p>锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。因为频繁地进行互斥同步操作会导致不必要的性能损耗，所以增大锁的作用域。</p>
<p>锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p>
<h3 id="✅volatile可见性的原理"><a href="#✅volatile可见性的原理" class="headerlink" title="✅volatile可见性的原理"></a>✅volatile可见性的原理</h3><p>volatile是轻量级的synchronized，在多处理器开发中保证了共享变量的可见性（所有线程看到的这个变量的值是一致的）。比synchronized执行成本低，不会引起线程上下文的切换和调度。<br>原理：<br>1.cpu不直接与内存进行通信，而是先将内存的数据读到自己的内存缓存（以缓存行为单位）中。<br>2.存储大体上分两种, 主存是堆内存, 工作内存是栈内存, 属于线程私有。volatile修饰的变量, 等于在堆中这个变量的内存区域上打了个标, 所有操作都必须从主存中读取, 由MESI&lt;缓存一致性协议&gt;实现。<br>3.jvm向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回系统内存。lock指令执行期间会锁住总线/缓存，保证不会同时多个cpu修改共享变量。<br>4.多处理下，实现缓存一致性协议，每个处理器使用嗅探技术，保证它的内部缓存和系统内存的数据在总线上保持一致（发现自己缓存行对应的内存地址被修改，首先将缓存行置为无效，重新从系统内存中将数据读到缓存）。<br>所以：volatile可以确保对某个变量的更新对其他线程马上可见：一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p>
<h3 id="✅volatile和static的可见性"><a href="#✅volatile和static的可见性" class="headerlink" title="✅volatile和static的可见性"></a>✅volatile和static的可见性</h3><p>volatile的可见性：是多个线程间的共享变量，当一个线程修改时，其他的线程能够知道这个修改。static不能知道变化，它的可见性：可访问。<br>volatile修饰的共享变量对其他线程具有可见性，可以保证原子性操作的线程安全。static修饰的变量为全局变量, 对所有线程可访问, 可用于线程间的通信，但是不能保证线程安全。</p>
<h3 id="✅volatile为什么是非原子的"><a href="#✅volatile为什么是非原子的" class="headerlink" title="✅volatile为什么是非原子的"></a>✅volatile为什么是非原子的</h3><p>count++ 就是非原子操作，读改写，分三步：从主存读取、在寄存器中自增操作、将计算后的值刷回主存。<br>t1线程与t2线程同时从主存中读取了count = 1,自增, 这时候两个线程的寄存器中存的计算后的值都是 2, 然后要写回count的主存, 假设这时 t1成功了, 那么主存中的count就是2, 然后根据MESI协议, t2需要重新从主存读取count值, 得到的是2, 再将寄存器中的计算结果2 赋值给count, 刷回主存, 此时主存中的count值还是2, 而不是期望中的3。</p>
<h3 id="✅volatile的有序性"><a href="#✅volatile的有序性" class="headerlink" title="✅volatile的有序性"></a>✅volatile的有序性</h3><p>volatile变量读写可以实现线程之间通信：A写，B读，实质就是A通过主内存向B发送消息，实现线程之间通信。<br>但是前提是：volatile禁止指令重排<br>为了实现volatile的内存语义，JMM会限制重排序类型。<br>1、当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到写之后。<br>2、当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到读之前。<br>3、当第一个操作是volatile写时，第二个操作是volatile读时，不能重排序。</p>
<p>Volatile实现限制指令重排的原理：<br>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。尽管内存屏障会降低效率，但是JMM（java内存模型）在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<h3 id="✅指令重排和as-if-serial语义和happens-before"><a href="#✅指令重排和as-if-serial语义和happens-before" class="headerlink" title="✅指令重排和as-if-serial语义和happens-before"></a>✅指令重排和as-if-serial语义和happens-before</h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<p>as-if-serial语义：不管怎么重排序，单线程的程序的执行结果不能被改变，为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。会对没有依赖关系的操作重排序，但是不影响结果和可见性。</p>
<p>happens - before：向程序员提供跨线程的内存可见性保证。<br>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见。<br>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。</p>
<p>happens-before的六大规则：<br>1、程序顺序规则：一个线程中的每个操作，happens - before 于该程序的任意后续操作。<br>2、监视器规则：对一个锁的解锁，happens - before 于随后对这个锁的加锁。<br>3、volatile 变量规则：对一个 volatile 域的写，happens - before 于任意后续对这个 volatile 域的读。<br>4、传递性，如果 A happens - before B， B happens - before C，那么 A happens - before C<br>5、start() 规则：如果线程 A 执行操作 ThreadB.start()（启动线程B），那么线程 A 的 ThreadB.start() 操作 happens - before 线程 B 中的任意操作。<br>6、join() 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens- before 于线程 A 从 Thread.join() 操作成功返回。</p>
<h3 id="✅Synchronized是悲观锁-CAS是乐观锁"><a href="#✅Synchronized是悲观锁-CAS是乐观锁" class="headerlink" title="✅Synchronized是悲观锁 CAS是乐观锁"></a>✅Synchronized是悲观锁 CAS是乐观锁</h3><p>Synchronized的并发策略是悲观的，不管是否会发生竞争，任何的数据操作都要加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。</p>
<p>随着硬件指令集的发展。可以使用基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程征用数据，就操作成功；如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略不需要线程挂起，所以被称为非阻塞同步。</p>
<p>乐观锁的核心算法是CAS(Compareand Swap，比较并交换)，它涉及到三个操作数;内存值、预期值、新值。当且仅当预期值和内存值相等时才将内存值修改为新值。（像改密码需要先验证旧密码一样）<br>这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样。如不一样则表示期问此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。<br>CAS 具有原子性，它的原子性由 CPU 硬件指令实现保证，即使用 JNI调用 Native 方法调用由 C++编写的硬件级别指令，JDK 中提供了 Unsafe类执行这些操作。</p>
<h3 id="✅CAS缺点"><a href="#✅CAS缺点" class="headerlink" title="✅CAS缺点"></a>✅CAS缺点</h3><p>乐观锁避免了悲观锁独占对象的现象，同时也提高了并发性能，但它也有缺点</p>
<ol>
<li>乐观锁只能保证一个共享变量的原子操作。如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解決，不管对象数量多少及对象颗粒度大小。</li>
<li>长时间自旋可能导致开销大。假如 CAS 长时间不成功而一直自旋，会给CPU 带来很大的开销。</li>
<li> ABA 问题。CAS 的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是 A，后来被一条线程改为 B，最后又被改成了 A，则CAS 认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情況对依赖过程值的情景的运算结果影响很大。解决思路是引入版本号，每次变量更新都把版本号加一。</li>
</ol>
<h3 id="✅Atomic原子类"><a href="#✅Atomic原子类" class="headerlink" title="✅Atomic原子类"></a>✅Atomic原子类</h3><p>在并发包 java.util.concurrent 的原子类。<br>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类：<br>基本类型：AtomicInteger、AtomicLong、AtomicLong<br>数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray<br>引用类型：AtomicReference、<br>AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来、<br>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。<br>对象的属性修改类型：<br>AtomicIntegerFieldUpdater:原子更新整型字段的更新器<br>AtomicLongFieldUpdater：原子更新长整型字段的更新器<br>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</p>
<p>使用方法：<br>public final int get() //获取当前的值<br>public final int getAndSet(int newValue)//获取当前的值，并设置新的值<br>publicfinal int getAndIncrement()//获取当前的值，并自增<br>public final int getAndDecrement() //获取当前的值，并自减<br>public final int getAndAdd(int delta) //获取当前的值，并加上预期的值<br>boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）<br>public final void lazySet(intnewValue) //最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</p>
<h3 id="✅AtomicInteger线程安全原理"><a href="#✅AtomicInteger线程安全原理" class="headerlink" title="✅AtomicInteger线程安全原理"></a>✅AtomicInteger线程安全原理</h3><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。<br>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset()方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h3 id="✅Lock接口和Synchronized"><a href="#✅Lock接口和Synchronized" class="headerlink" title="✅Lock接口和Synchronized"></a>✅Lock接口和Synchronized</h3><p>在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。</p>
<p>Lock具备的sychronized关键字不具备的特点：1、非阻塞地获取锁2、能被中断地获取锁（获取到锁的线程能响应中断，中断异常被抛出，同时锁释放）3、超时获取锁（截止时间无法获取锁，则返回）</p>
<h3 id="✅AQS"><a href="#✅AQS" class="headerlink" title="✅AQS"></a>✅AQS</h3><p>AQS(AbstractQvevedSvnchronizer 类)队列同步器是一个用来构建锁和同步器的框架，各种Lock 包中的锁(常用的有 PeentrantLock ReaaWrtelock)，以及其他如 Semaphore、CountDownLatcn，甚至是早期的 Futurerask等，都是基于 AQS 来构建。</p>
<ol>
<li>AQS 在内部定义了一个 volatile int state 变量，表示同步状态;当线程调用 lock 方法时，如果 state=0，说明没有任何线程占有共享资源的锁，可以获得锁并将 state=1;如果 state=1，则说明有线程目前正在 使用共享变量，其他线程必须加入同步队列进行等待。</li>
<li>AQS 通过 Node 内部类构成的一个双向链表结构的同步队列，来完成线程获取锁的排队工作，当有线程获取锁失败后，就被添加到队列未尾。这个加入队列的过程用CAS保证线程安全。被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。节点进入同步队列之后，就进入了一个自旋的过程。获取到了同步状态，就可以从这个自旋过程中退出，代表获取了锁。<br>•Node 类是对要访问同步代码的线程的封装，包含了线程本身及其状态WaitStatus(有五种不同取值，分别表示是否被阻塞，是否等待唤醒，是香已经被取消等)，每个 Node 结点关联其 prev 结点和 next 结点，方便线程释放锁后快速唤醒下一个在等待的线程，是一个FIFO 的过程。<br>•Node 类有两个常量，SHARED 和 EXCLUSIVE， 分别代表共享模式和独占模式。所谓共享模式是一个锁允许多条线程同时操作(信号量Semaphore 就是基子 AQS 的共享模式实现的)，独占模式是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待（如 ReentranLock)。</li>
<li>AQS 通过内部类 ConditionObject 构建等待队列（可有多个)，当Condition 调用 wait()方法后，线程将会加入等待队列中，而当Condition 调用 signal() 方法后，线程将从等待队列转移动同步队列中进行锁竞争。</li>
<li>AQS 和Condition 各自维护了不同的队列，在使用 Lock 和 Condition的时候，其实就是两个队列的互相移动。</li>
</ol>
<h3 id="✅AQS与Lock"><a href="#✅AQS与Lock" class="headerlink" title="✅AQS与Lock"></a>✅AQS与Lock</h3><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。锁是面向使用者的，它定义了使用者与锁交互的接口。同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。<br>同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法（tryAcquire独占式获取 非阻塞、tryAcquireShared共享式获取），随后将同步器作为静态内部类组合在自定义同步组件的实现中，并调用同步器提供的模板方法（acquire独占式获取同步状态 获取失败会进入同步队列等待、acquireShared共享式获取）。</p>
<p>lock和tryLock的区别：<br>lock是非阻塞的，会一直尝试或锁，用acquire方法（内部用tryAcquire方法）线程调用该方法获取同步状态失败后会被加入到同步队列中等待；<br>tryLock是阻塞的，获取一次，所以直接用tryAcquire方法。</p>
<h3 id="✅等待通知机制"><a href="#✅等待通知机制" class="headerlink" title="✅等待通知机制"></a>✅等待通知机制</h3><p>用的是Object对象的监视器方法，Synchronized、wait、notify、notifyAll。<br>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。（两个notify都是通知等待队列里的，不是阻塞状态的同步队列，notify通知一个，notifyAll通知所有）。</p>
<p>经典范式：<br>等待方：<br>synchronized(对象) {<br>    while(条件不满足) {<br>        对象.wait();<br>    }<br>    对应的处理逻辑;<br>}<br>通知方：<br>synchronized(对象) {<br>    改变条件(flag)<br>    对象.notifyAll();<br>}</p>
<p>等待/通知机制依托于同步机制<br>同步的目的：获取了锁才能wait和notify，同步的目的是把修改变量和notify包在一起，让wait出来的时候能感知到变量的变化。</p>
<p>1、wait线程首先获取锁，调用lock的wait方法，放弃了锁，进入等待队列，等待状态。（可以有很多个wait线程）<br>2、notify线程获取了锁，调用lock的notify方法，将wait线程从等待队列移动到了同步队列，是阻塞状态。（notify只能唤醒一个）<br>3、notify线程运行完了，释放锁，wait线程才有机会获取到锁，从wait方法返回并继续执行。</p>
<h3 id="✅Condition接口-等待通知机制"><a href="#✅Condition接口-等待通知机制" class="headerlink" title="✅Condition接口 等待通知机制"></a>✅Condition接口 等待通知机制</h3><p>Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。<br>Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。<br>调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前需要获取锁。</p>
<p>synchronized + Object监视器方法 - 实现等待通知 - 案例线程池（都可以）<br>Lock(队列同步器) + Condition接口 - 实现等待通知 - 案例有界队列</p>
<h3 id="✅ReentrantLock和Synchronized的区别"><a href="#✅ReentrantLock和Synchronized的区别" class="headerlink" title="✅ReentrantLock和Synchronized的区别"></a>✅ReentrantLock和Synchronized的区别</h3><p>ReentrantLock 实现了 Lock 接口，是一个可重入且独占式的锁，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。<br>ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。<br>￼<br>1.两者都是可重入锁<br>可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p>
<p>2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API<br>从锁释放角度， Synchronized 在JVM 层面上实现的，不但可以通过一些监控工具监控 Synchronized 的锁定，而旦在代码执行出现异常 时，JVM会自动释放锁定;但是使用 Lock 则不行，Lock 是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally()中。</p>
<p>3.ReentrantLock 比 synchronized 增加了一些高级功能<br>等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。<br>可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。<br>可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。synchronized关键字就相当于整个 Lock 对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而Condition实例的signalAll()方法，只会唤醒注册在该Condition实例中的所有等待线程。</p>
<p>4.性能<br>从性能角度，Synchronized 早期实现比较低效，对比ReentrantLock，大多数场景性能都相羞较大。<br>但是在 Java 6 中对其进行了非常多的改进，在竞争不激烈时，Synchronized 的性能要优于 ReetrantLock；在高竞争情况下，Synchronized 的性能会下降几十倍，但是ReetrantLock 的性能能维持常态。</p>
<h3 id="✅ReentrantLock如何实现可重入的"><a href="#✅ReentrantLock如何实现可重入的" class="headerlink" title="✅ReentrantLock如何实现可重入的"></a>✅ReentrantLock如何实现可重入的</h3><p>在于使用一个计数器来跟踪锁的持有次数，每次持有锁时计数器加一，释放锁时计数器减一，只有当计数器为0时，锁才能被完全释放。acquire方法获取锁时，如果当前线程已经拥有该锁，计数器加一并返回true，否则使用CAS原子操作来尝试获取锁。</p>
<h3 id="✅ReentrantReadWriteLock读写锁"><a href="#✅ReentrantReadWriteLock读写锁" class="headerlink" title="✅ReentrantReadWriteLock读写锁"></a>✅ReentrantReadWriteLock读写锁</h3><p>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升，提供写操作对读操作的可见性以及并发性的提升。</p>
<p>适用场景：在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。</p>
<p>static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();<br>static Lock r = rwl.readLock();<br>static Lock w = rwl.writeLock();</p>
<p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。<br>读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态。按位切割使用。</p>
<h3 id="✅读写锁的锁降级"><a href="#✅读写锁的锁降级" class="headerlink" title="✅读写锁的锁降级"></a>✅读写锁的锁降级</h3><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。</p>
<p>锁降级：先获取写锁，变更数据，再获取读锁，再释放写锁。此时还有读锁，还可以读数据，其他线程也可以获取读锁读数据。这样变更完数据之后，可以多个读线程一起读取数据。</p>
<h3 id="✅线程池"><a href="#✅线程池" class="headerlink" title="✅线程池"></a>✅线程池</h3><p>什么是线程池？<br>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>
<p>为什么要用线程池？<br>池化技术：线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。<br>线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p>￼<br>如何创建线程池？<br>方式一：通过ThreadPoolExecutor构造函数来创建（推荐）。<br>ThreadPoolExecutor(int corePoolSize,<br>int maximumPoolSize,<br>long keepAliveTime,<br>TimeUnit unit,<br>BlockingQueue workQueue,<br>RejectedExecutionHandler handler) </p>
<p>corePoolSize： 任务队列未达到队列容量时，最大可以同时运行的线程数量<br>maximumPoolSize：任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。<br>workQueue： 用于保存等待执行的任务的阻塞队列<br>keepAliveTime： 线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；<br>unit：keepAliveTime的单位<br>threadFactory： 设置创建线程的工厂，可以给线程命名<br>handler： 线程池对拒绝任务的处理策略 </p>
<p>ThreadPoolTaskExecutor定义的一些策略：<br>ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。（默认）<br>ThreadPoolExecutor.CallerRunsPolicy： 直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。<br>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。<br>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。</p>
<p>线程池常用的阻塞队列：<br>1、容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）：FixedThreadPool 和 SingleThreadExector。由于队列永远不会被放满，因此FixedThreadPool最多只能创建核心线程数的线程。<br>2、SynchronousQueue（同步队列） ：CachedThreadPool 。SynchronousQueue 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，CachedThreadPool 的最大线程数是 Integer.MAX_VALUE ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。<br>3、DelayedWorkQueue（延迟阻塞队列）：ScheduledThreadPool 和 SingleThreadScheduledExecutor。DelayedWorkQueue 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。DelayedWorkQueue 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 Integer.MAX_VALUE，所以最多只能创建核心线程数的线程。</p>
<p>方式二：通过 Executor 框架的工具类 Executors 来创建。<br>FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。<br>SingleThreadExecutor： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。<br>CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。<br>ScheduledThreadPool ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</p>
<p>为什么不推荐使用内置线程池？<br>Executors 返回线程池对象的弊端:<br>1、FixedThreadPool 和 SingleThreadExecutor ： 使用的是无界的 LinkedBlockingQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。<br>2、CachedThreadPool ：使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。<br>3、ScheduledThreadPool 和 SingleThreadScheduledExecutor : 使用的无界的延迟阻塞队列DelayedWorkQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</p>
<p>线程池处理任务的流程：<br>￼<br>1、如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。<br>2、如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。<br>3、如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。<br>4、如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用RejectedExecutionHandler.rejectedExecution()方法。</p>
<p>处理任务的优先级为：<br>核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。</p>
<h3 id="✅线程的生命周期和状态"><a href="#✅线程的生命周期和状态" class="headerlink" title="✅线程的生命周期和状态"></a>✅线程的生命周期和状态</h3><p>1、NEW: 初始状态，线程被创建出来但没有被调用 start() 。<br>2、RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。<br>3、BLOCKED ：阻塞状态，需要等待锁释放。当线程进入 synchronized 方法/块或者调用 wait 后（被 notify）重新进入 synchronized 方法/块，但是锁被其它线程占有，这个时候线程就会进入 BLOCKED（阻塞） 状态。<br>4、WAITING：等待状态，wait()方法之后进入，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。<br>5、TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。sleep（long millis）方法或 wait（long millis）方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。<br>6、TERMINATED：终止状态，表示该线程已经运行完毕。在执行完了 run()方法之后将会进入到 TERMINATED（终止） 状态。</p>
<p>￼</p>
<h3 id="✅线程相关的几个方法"><a href="#✅线程相关的几个方法" class="headerlink" title="✅线程相关的几个方法"></a>✅线程相关的几个方法</h3><p>thread.start 方法，启动线程<br>thread.suspend()、resume()和stop()方法，过时，终结一个线程时不会保证线程的资源正常释放。<br>thread.interrupt 中断线程<br>Object上的监视器方法：wait、notify、notifyAll<br>thread.join()：当前线程A等待thread线程终止之后才从thread.join()返回，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。<br>Thread.yield(): yield方法是Thread类的静态方法，重新分配。<br>会把当前线程从可运行状态变成就绪状态。<br>之后会cpu会从众多就绪状态的线程中选择一个来执行。<br>Thread.sleep(): 是Thread类的静态方法，</p>
<h3 id="✅thread的join方法原理"><a href="#✅thread的join方法原理" class="headerlink" title="✅thread的join方法原理"></a>✅thread的join方法原理</h3><p>【原理：等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）。加锁、循环和处理逻辑3个步骤。】<br>1、线程a执行线程b的join方法，相当于用线程b对象做同步，内部本线程wait进入等待，并用一个变量flag进行条件判断。<br>2、线程b终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。</p>
<h3 id="✅如何安全地终止线程"><a href="#✅如何安全地终止线程" class="headerlink" title="✅如何安全地终止线程"></a>✅如何安全地终止线程</h3><p>方法1：使用中断interrupt方法进行中断。<br>方法2：等待通知机制，使用一个volatile的boolean类型变量来控制，实际上是中断while方法，然后执行完run方法，终止。</p>
<h3 id="✅sleep-方法和-wait-方法对比"><a href="#✅sleep-方法和-wait-方法对比" class="headerlink" title="✅sleep() 方法和 wait() 方法对比"></a>✅sleep() 方法和 wait() 方法对比</h3><p>共同点 ：两者都可以暂停线程的执行。<br>区别 ：</p>
<ul>
<li>sleep() 方法没有释放锁，而 wait() 方法释放了锁 。</li>
<li>wait() 通常被用于线程间交互/通信，sleep()通常被用于暂停执行。</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll()方法，如果没获取锁进入阻塞状态。sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。</li>
<li>sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。</li>
</ul>
<h3 id="✅为什么-wait-方法不定义在-Thread-中？"><a href="#✅为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="✅为什么 wait() 方法不定义在 Thread 中？"></a>✅为什么 wait() 方法不定义在 Thread 中？</h3><p>wait() 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（Object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（Object）而非当前的线程（Thread）。<br>类似的问题：为什么 sleep() 方法定义在 Thread 中？<br>因为 sleep() 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
<h3 id="✅可以直接调用-Thread-类的-run-方法吗？"><a href="#✅可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="✅可以直接调用 Thread 类的 run 方法吗？"></a>✅可以直接调用 Thread 类的 run 方法吗？</h3><p>new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。<br>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</p>
<h3 id="✅Runnable和Thread的区别"><a href="#✅Runnable和Thread的区别" class="headerlink" title="✅Runnable和Thread的区别"></a>✅Runnable和Thread的区别</h3><p>Runnable是一个接口，它包含了一个run()方法，用来实现一个线程的具体操作。而Thread则是一个类，它实现了Runnable接口，并拥有其它一些方法，如start()、sleep()、yield()等。一个线程必须通过Thread类的构造函数来创建。因此，Runnable可以被认为是Thread的一个组成部分。在使用线程时，我们可以选择扩展Thread类或者实现Runnable接口来自定义线程类，这取决于具体的需求和设计。一般来说，实现Runnable接口的方式更为灵活。</p>
<p>Runnable更容易可以实现多个线程间的资源共享，提交给Thread同一个Runnable对象，共享其中的private对象。（只是共享，线程安全要加同步）。而Thread也是可以的，只不过是多个thread对象共享static变量，或者提交同一个Thread对象，并且static只是可见，还需要加同步才是线程安全的。</p>
<h3 id="✅Runnable和Callable区别"><a href="#✅Runnable和Callable区别" class="headerlink" title="✅Runnable和Callable区别"></a>✅Runnable和Callable区别</h3><p>Runnable接口和Callable接口都可以用来定义多线程的任务，它们都可以被线程执行，但是二者有几个区别。</p>
<ol>
<li>方法签名不同<br>Runnable接口定义了—个run()方法，该方法没有返回值，只能使用void类型来定义。<br>callable接口定 义了一个call()方法，该方法可以返回一个指定类型的结果，并旦可以抛出异常。</li>
<li>返回值类型不同<br>Rupnable接口的run()方法没有返回值，因此在执行任务后无法获得执行结果。<br>Callable接口的call()方法可以返回一个指定类型的结果对象，可以通过Future接口来获取执行结果。</li>
<li>异常处理不同<br>Runnable接口的run()方法无法抛出异常，只能在任务内部进行异常处理。<br>Callable接回的call()方法可以抛出异常，可以通过执行结果Future的get()方法来获取异常信息。<br>综上所述，Runnable接口适用于 不需要获取任务执行结果的情况，而Callable接口适用于需要获取任务执行结果并且可能会抛出异常的情况。</li>
</ol>
<p>1、Callable能接受一个泛型，然后在call方法中返回一个这个类型的值。而Runnable的run方法没有返回值<br>2、Callable的call方法可以抛出异常，而Runnable的run方法不会抛出异常。</p>
<h3 id="✅ThreadPoolExecutor的execute方法和submit方法"><a href="#✅ThreadPoolExecutor的execute方法和submit方法" class="headerlink" title="✅ThreadPoolExecutor的execute方法和submit方法"></a>✅ThreadPoolExecutor的execute方法和submit方法</h3><p>1、execute是Executor接口的方法，而submit是ExecutorService的方法，并且ExecutorService接口继承了Executor接口。<br>2、execute只接受Runnable参数，没有返回值；而submit可以接受Runnable参数和Callable参数，并且返回了Future对象，可以进行任务取消、获取任务结果、判断任务是否执行完毕/取消等操作。<br>3、submit会对Runnable或Callable入参封装成RunnableFuture对象（同时继承了Runnable接口和Future接口），调用execute方法并返回。FutureTask是实现了RunnableFuture接口<br>4、通过execute方法提交的任务如果出现异常则直接抛出原异常，是在线程池中的线程中；而submit方法是捕获了异常的，只有当调用Future的get方法时，才会抛出ExecutionException异常，且是在调用get方法的线程。</p>
<p>submit方法的异常可以在主线程中catch到。而使用execute方法执行任务是捕捉不到异常的。</p>
<p><T> Future<T> submit(Callable<T> task);<br><T> Future<T> submit(Runnable task, T result);<br>Future&lt;?&gt; submit(Runnable task);</T></T></T></T></T></p>
<h3 id="✅Future-类"><a href="#✅Future-类" class="headerlink" title="✅Future 类"></a>✅Future 类</h3><p>Future 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>
<p>这其实就是多线程中经典的 Future 模式，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。<br>在 Java 中，Future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>
<ul>
<li>取消任务；  cancel</li>
<li>判断任务是否被取消;  isCancelled</li>
<li>判断任务是否已经执行完成;  isDone</li>
<li>获取任务执行结果。  get</li>
</ul>
<p>简单理解就是：我有一个任务，提交给了 Future 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 Future 那里直接取出任务执行结果。</p>
<p>Future future = executor.submit(myCallable);<br>System.out.println(“获取返回值: “+future.get());</p>
<h3 id="✅Callable-和-Future-有什么关系？"><a href="#✅Callable-和-Future-有什么关系？" class="headerlink" title="✅Callable 和 Future 有什么关系？"></a>✅Callable 和 Future 有什么关系？</h3><p>可以通过 FutureTask 来理解 Callable 和 Future 之间的关系。<br>FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。ExecutorService.submit() 方法返回的其实就是 Future 的实现类 FutureTask 。<br>￼<br>FutureTask 不光实现了 Future接口，还实现了Runnable 接口，因此可以作为任务直接被线程执行。<br>FutureTask 有两个构造函数，可传入 Callable 或者 Runnable 对象。实际上，传入 Runnable 对象也会在方法内部转换为Callable 对象。<br>FutureTask相当于对Callable 进行了封装，管理着任务执行的情况，存储了 Callable 的 call 方法的任务执行结果。</p>
<h3 id="✅CompletableFuture-类"><a href="#✅CompletableFuture-类" class="headerlink" title="✅CompletableFuture 类"></a>✅CompletableFuture 类</h3><p>Future 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。<br>Java 8 才被引入CompletableFuture 类可以解决Future 的这些缺陷。CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。<br>￼<br>可以看到，CompletableFuture 同时实现了 Future 和 CompletionStage 接口。<br>CompletionStage 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。<br>CompletionStage 接口中的方法比较多，CompletableFuture 的函数式能力就是这个接口赋予的。</p>
<h3 id="✅ThreadLocal干嘛的"><a href="#✅ThreadLocal干嘛的" class="headerlink" title="✅ThreadLocal干嘛的"></a>✅ThreadLocal干嘛的</h3><p>成员变量：如果使用一个Runnable对象创建多个线程，多个线程共享成员变量，多个线程对该变量进行操作是彼此影响的，是线程不安全的。需要加锁，达到线程安全。</p>
<p>局部变量（方法块里的）：每个线程都会有局部变量的拷贝，一个线程对局部变量的操作不会影响其他线程。</p>
<p>ThreadLocal类：让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<p>使用：<br>public static class MyRunnable implements Runnable {<br>        private ThreadLocal<Integer> threadLocal = new ThreadLocal<Integer>();<br>        int local = 1;</Integer></Integer></p>
<pre><code>    @Override
    public void run() &#123;
        threadLocal.set((int) (Math.random() * 100D));
        local = (int) (Math.random() * 100D);
        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
        &#125;
        System.out.println(&quot;threadLocal:&quot; +threadLocal.get());
        System.out.println(&quot;local:&quot; +local);
    &#125;
&#125;
</code></pre>
<h3 id="✅ThreadLocal-原理"><a href="#✅ThreadLocal-原理" class="headerlink" title="✅ThreadLocal 原理"></a>✅ThreadLocal 原理</h3><p>从 Thread类源代码入手。<br>public class Thread implements Runnable {<br>     //与此线程有关的ThreadLocal值。由ThreadLocal类维护<br>    ThreadLocal.ThreadLocalMap threadLocals = null; </p>
<pre><code>//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护 
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; 
</code></pre>
<p>}</p>
<p>从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是 null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。</p>
<p>ThreadLocal类的set()方法：<br>public void set(T value) {<br>    //获取当前请求的线程<br>    Thread t = Thread.currentThread();<br>    //取出 Thread 类内部的 threadLocals 变量(哈希表结构)<br>    ThreadLocalMap map = getMap(t);<br>    if (map != null)<br>        // 将需要存储的值放入到这个哈希表中<br>        map.set(this, value);<br>    else<br>        createMap(t, value);<br>     }<br>ThreadLocalMap getMap(Thread t) { return t.threadLocals; }</p>
<p>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。 ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。<br>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。所以可以有多个ThreadLocal。</p>
<h3 id="✅ThreadLocal-内存泄露问题是怎么导致的？"><a href="#✅ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="✅ThreadLocal 内存泄露问题是怎么导致的？"></a>✅ThreadLocal 内存泄露问题是怎么导致的？</h3><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。<br>这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法</p>
<h3 id="✅强引用、软引用用、弱引用"><a href="#✅强引用、软引用用、弱引用" class="headerlink" title="✅强引用、软引用用、弱引用"></a>✅强引用、软引用用、弱引用</h3><p>是Jave中用来管理对象生命周期的三种引用方式。<br>1、强引用：是最普通的对象引用方式，只要一个对象被强引用引用，就不会被回收。例如：Object obj = new object().<br>2、软引用：是一种比强引用弱一些的引用方式，如果内存足够时，软引用不会被回收，如果内存不足时，就会被回收。可以通过SoftReference类来实现软引用。例如：SoftReterence<br>sra new SoftReference&lt;&gt; (new Object())。<br>3、弱引用：是一种比软引用更弱的引用方方式，只要被弱引用引用，没有被强引用或软引用所引用，就会被回收。<br>可以通过WeakReference类来实现弱引用。例如：WeakReference wr = new WeakPeference&lt;&gt; (new Object())。</p>
<p>总的来说，弱引用、软引用是为了解决内存泄漏问题而产生的技术手段，通过合理地使用它们可以更好地管理内存，提高程序的性能和稳定性。</p>
<h3 id="✅什么是Java-的内存模型，Java-中各个线程是怎么彼此看到-对方的变量的？"><a href="#✅什么是Java-的内存模型，Java-中各个线程是怎么彼此看到-对方的变量的？" class="headerlink" title="✅什么是Java 的内存模型，Java 中各个线程是怎么彼此看到 对方的变量的？"></a>✅什么是Java 的内存模型，Java 中各个线程是怎么彼此看到 对方的变量的？</h3><p>Java 的内存模型定义了程序中各个变量的访问规则，即在虛拟机中将 变量存储到内存和从内存中取出这样的底层细节。此处的变量包括实例字段、静态宇段和构成数组对象的元素，但是不包括局部变量和方法参数，因为这些是线程私有的，不会被共享，所以不存在竞争问题。</p>
<p>java 中各个线程是怎么彼此看到对方的变量的呢?<br>Java 中定义了主内存与工作内存的概念：<br>所有的变量都存储在主内存，每条线程还有自己的工作内存，保存了被该线程使用到的变量的主内存副本拷贝。</p>
<p>线程对变量的所有操作(读取、赋值)都必须在工作内存中进行，不能直接读写主内存的变量。不同的线程之间也无法直接访问对方工作内存的变量，线程间变量值的传递需要通过主内存。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%85%AB%E8%82%A1/" rel="tag"># 八股</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/05/01/myblog/%E5%85%AB%E8%82%A1/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="prev" title="java虚拟机">
      <i class="fa fa-chevron-left"></i> java虚拟机
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/28/myblog/%E5%85%AB%E8%82%A1/java%E9%A2%98%E7%9B%AE/" rel="next" title="java题目">
      java题目 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">✅synchronized的使用及原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85synchronized%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="nav-number">2.</span> <span class="nav-text">✅synchronized锁的升级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85synchronized%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7-1"><span class="nav-number">3.</span> <span class="nav-text">✅synchronized锁的升级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85volatile%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">✅volatile可见性的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85volatile%E5%92%8Cstatic%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">✅volatile和static的可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%8E%9F%E5%AD%90%E7%9A%84"><span class="nav-number">6.</span> <span class="nav-text">✅volatile为什么是非原子的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85volatile%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-number">7.</span> <span class="nav-text">✅volatile的有序性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%92%8Cas-if-serial%E8%AF%AD%E4%B9%89%E5%92%8Chappens-before"><span class="nav-number">8.</span> <span class="nav-text">✅指令重排和as-if-serial语义和happens-before</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85Synchronized%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81-CAS%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">9.</span> <span class="nav-text">✅Synchronized是悲观锁 CAS是乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85CAS%E7%BC%BA%E7%82%B9"><span class="nav-number">10.</span> <span class="nav-text">✅CAS缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">11.</span> <span class="nav-text">✅Atomic原子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85AtomicInteger%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86"><span class="nav-number">12.</span> <span class="nav-text">✅AtomicInteger线程安全原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85Lock%E6%8E%A5%E5%8F%A3%E5%92%8CSynchronized"><span class="nav-number">13.</span> <span class="nav-text">✅Lock接口和Synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85AQS"><span class="nav-number">14.</span> <span class="nav-text">✅AQS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85AQS%E4%B8%8ELock"><span class="nav-number">15.</span> <span class="nav-text">✅AQS与Lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">16.</span> <span class="nav-text">✅等待通知机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85Condition%E6%8E%A5%E5%8F%A3-%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">17.</span> <span class="nav-text">✅Condition接口 等待通知机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85ReentrantLock%E5%92%8CSynchronized%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">18.</span> <span class="nav-text">✅ReentrantLock和Synchronized的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85ReentrantLock%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84"><span class="nav-number">19.</span> <span class="nav-text">✅ReentrantLock如何实现可重入的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85ReentrantReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">20.</span> <span class="nav-text">✅ReentrantReadWriteLock读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E9%94%81%E9%99%8D%E7%BA%A7"><span class="nav-number">21.</span> <span class="nav-text">✅读写锁的锁降级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">22.</span> <span class="nav-text">✅线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="nav-number">23.</span> <span class="nav-text">✅线程的生命周期和状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">24.</span> <span class="nav-text">✅线程相关的几个方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85thread%E7%9A%84join%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-number">25.</span> <span class="nav-text">✅thread的join方法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%9C%B0%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="nav-number">26.</span> <span class="nav-text">✅如何安全地终止线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85sleep-%E6%96%B9%E6%B3%95%E5%92%8C-wait-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="nav-number">27.</span> <span class="nav-text">✅sleep() 方法和 wait() 方法对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%9C%A8-Thread-%E4%B8%AD%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">✅为什么 wait() 方法不定义在 Thread 中？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-Thread-%E7%B1%BB%E7%9A%84-run-%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">✅可以直接调用 Thread 类的 run 方法吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85Runnable%E5%92%8CThread%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">30.</span> <span class="nav-text">✅Runnable和Thread的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85Runnable%E5%92%8CCallable%E5%8C%BA%E5%88%AB"><span class="nav-number">31.</span> <span class="nav-text">✅Runnable和Callable区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85ThreadPoolExecutor%E7%9A%84execute%E6%96%B9%E6%B3%95%E5%92%8Csubmit%E6%96%B9%E6%B3%95"><span class="nav-number">32.</span> <span class="nav-text">✅ThreadPoolExecutor的execute方法和submit方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85Future-%E7%B1%BB"><span class="nav-number">33.</span> <span class="nav-text">✅Future 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85Callable-%E5%92%8C-Future-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">✅Callable 和 Future 有什么关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85CompletableFuture-%E7%B1%BB"><span class="nav-number">35.</span> <span class="nav-text">✅CompletableFuture 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85ThreadLocal%E5%B9%B2%E5%98%9B%E7%9A%84"><span class="nav-number">36.</span> <span class="nav-text">✅ThreadLocal干嘛的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85ThreadLocal-%E5%8E%9F%E7%90%86"><span class="nav-number">37.</span> <span class="nav-text">✅ThreadLocal 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%BC%E8%87%B4%E7%9A%84%EF%BC%9F"><span class="nav-number">38.</span> <span class="nav-text">✅ThreadLocal 内存泄露问题是怎么导致的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">39.</span> <span class="nav-text">✅强引用、软引用用、弱引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E4%BB%80%E4%B9%88%E6%98%AFJava-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%8CJava-%E4%B8%AD%E5%90%84%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%BD%BC%E6%AD%A4%E7%9C%8B%E5%88%B0-%E5%AF%B9%E6%96%B9%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">✅什么是Java 的内存模型，Java 中各个线程是怎么彼此看到 对方的变量的？</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jade liu"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Jade liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jadeliuliu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jadeliuliu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jadeliu1998@163.com" title="E-Mail → mailto:jadeliu1998@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jadeliu1998" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;jadeliu1998" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5823044646" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5823044646" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jade liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
