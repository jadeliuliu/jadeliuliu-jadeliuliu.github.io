<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jadeliu&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Jadeliu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jade liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jadeliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jadeliu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/04/myblog/JAVA/war%E5%8C%85jar%E5%8C%85%E6%89%93%E5%8C%85tomcat%E9%83%A8%E7%BD%B2servlet%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/04/myblog/JAVA/war%E5%8C%85jar%E5%8C%85%E6%89%93%E5%8C%85tomcat%E9%83%A8%E7%BD%B2servlet%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">jar、war、tomcat、servlet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-04 14:47:55" itemprop="dateCreated datePublished" datetime="2022-06-04T14:47:55+08:00">2022-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-05 23:59:59" itemprop="dateModified" datetime="2022-06-05T23:59:59+08:00">2022-06-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="tomcat与servlet"><a href="#tomcat与servlet" class="headerlink" title="tomcat与servlet"></a>tomcat与servlet</h3><p>1.tomcat就是一个web应用服务器，相当于市存放java程序的容器。以便服务被访问。<br>2.servlet实际上是java类，java语言编写的服务器端程序，它用来处理http协议相关的所有内容，没有main方法，需要在servlet容器中进行管理，可以是tomact。如何使用：继承HttpServlet（tomcat里的jar包支持），它帮助我们完成通信的规则。<br>3.tomcat与servlet关系：tomcat是servlet/jsp容器，servlet时web应用开发的组件，tomcat负责处理客户请求，把请求传送给servlet，再将servlet的响应传送回给客户。<br>4.新建web工程时，如果不用maven，java enterprise - web application，再引入jdk、tomcat（tomcat的lib下有servlet包）。如果用maven，就选archetype-webapp。</p>
<h3 id="war包与jar包"><a href="#war包与jar包" class="headerlink" title="war包与jar包"></a>war包与jar包</h3><p>1.Jar文件（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等。<br>2.jar包是java打的包，一般只是包括一些编译后class文件和一些部署文件，在声明了Main_class之后是可以用java命令运行的。<br>3.jar包通常是开发时要引用通用类，打成包便于存放管理。<br>————————————————<br>1.War文件（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对war文件进行封装，并把它作为小型服务程序（servlet）来访问。<br>2.war包可以理解为javaweb打的包，是一个web模块，包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。<br>3.war包需要发布到一个容器里面，拿Tomcat来说,将war文件包放置它的\webapps\目录下，启动Tomcat,这个包可以自动进行解压，也就是你的web目录，相当于发布了。<br>4.WAR是Sun提出的一种Web应用程序格式，与JAR类似，也是许多文件的一个压缩包。这个包中的文件按一定目录结构来组织：通常其根目录下包含有Html和Jsp文件或者包含这两种文件的目录，另外还会有一个WEB-INF目录，这个目录很重要。通常在WEB-INF目录下有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的Servlet类和Jsp或Servlet所依赖的其它类（JavaBean）。另外还有META-INF目录，里面有MANIFEST.MF文件。存储了项目的元信息。其中文件manifest.mf仅此一份，描述了程序的基本信息、Main-Class的入口、jar依赖路径Class-Path。<br>————————————————</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Sunny5319/article/details/90933532">https://blog.csdn.net/Sunny5319/article/details/90933532</a></p>
<p>jar包和war包都是为了项目的部署和发布，通常在打包部署的时候，会在里面加上部署的相关信息。这个打包实际上就是把代码和依赖的东西压缩在一起，变成后缀名为.jar和.war的文件</p>
<hr>
<p>什么时候用jar、war?<br>当你的项目在没有完全完成的时候，不适合使用war文件，因为你的类会由于调试之类的经常改，这样来回删除、创建war文件很不方便，来回修改，来回打包，最好是你的项目已经完成了，不做修改的时候，那就打个war包，这个时候一个war文件就相当于一个web应用程序；而jar文件就是把类和一些相关的资源封装到一个包中，便于程序中引用。</p>
<h3 id="jar包打包"><a href="#jar包打包" class="headerlink" title="jar包打包"></a>jar包打包</h3><p>安装好JDK之后,jar.exe就已经安装好了。在命令行中键入jar命令之后，会有详细的用法介绍。</p>
<h4 id="✅单个文件打包"><a href="#✅单个文件打包" class="headerlink" title="✅单个文件打包"></a>✅单个文件打包</h4><p>将一个单独的java文件打包：<br><code>jar cvf /Users/liuxuan/MyProject/java/test.jar /Users/liuxuan/MyProject/java/jartest/hello.java</code><br>使用<code>java -jar test.jar</code> 提示没有主清单属性。</p>
<p>所以增加清单配置文件：MANIFEST.MF</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: hello</span><br><span class="line"></span><br><span class="line">//注意：1. 冒号后面加一个空格，2. 最后必须回车到新的空行</span><br></pre></td></tr></table></figure>
<p>再打包：<code>jar cvfm test.jar ./*</code><br>java -jar运行，找不到或无法加载主类 hello。</p>
<p>所以在打包前先编译：<code>javac hello.java</code>，生成class文件，然后再打包，运行，可以执行。</p>
<blockquote>
<p>META-INF文件夹相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务。这个文件夹和其中的 MANIFEST.MF文件，在用jar打包时自动生成。<br>执行jar文件的时候，这个jar里是需要具备 META-INF/MANIFEST.MF的，否则java -jar就找不到main class。</p>
</blockquote>
<p>多个文件也可以如此打包，首先应该javac编译，然后增加主清单配置文件，其中可以指示默认入口函数（其中有main方法）。如果打的包中有其他类，java -jar jar包 是运行默认类，运行其他类方法：<code>java -cp test.jar com.test.sum 3 9</code>。<br>main函数可以有输入参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">public class sum&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        if(args.length &lt; 2)&#123;</span><br><span class="line">            System.out.println(&quot;Paras: num1 num2&quot;);</span><br><span class="line">            System.exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        final int num1 = Integer.valueOf(args[0]);</span><br><span class="line">        System.out.println(&quot;Num1: &quot; + num1);</span><br><span class="line">        final int num2 = Integer.valueOf(args[1]);</span><br><span class="line">        System.out.println(&quot;Num2: &quot; + num2);</span><br><span class="line"></span><br><span class="line">        final int sum = num1 + num2;</span><br><span class="line">        System.out.println(num1 + &quot; + &quot; + num2 + &quot; = &quot; + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Xminyang/article/details/108059776">https://blog.csdn.net/Xminyang/article/details/108059776</a></p>
<h4 id="✅使用idea打包"><a href="#✅使用idea打包" class="headerlink" title="✅使用idea打包"></a>✅使用idea打包</h4><p>🤔不可以java -jar的打包：<br>1.点击intellij idea左上角的“File”菜单 -&gt; Project Structure<br>2.点击”Artifacts” -&gt; 绿色的”+” -&gt; “JAR” -&gt; Empty<br>3. Name栏填入自定义的名字，Output ditectory选择jar包目标目录，Available Elements里双击需要添加到jar包的文件（添加java工程编译文件）<br>4. OK之后，点击菜单中“Build” -&gt; “Build Artifacts”<br>5. 点击弹出框中待生成jar包下面的build即可</p>
<p>生成了jar包，直接java -jar执行，报<code>Error: Invalid or corrupt jarfile testjar.jar</code>.<br>需要用 -cp 指定类来执行，例如：<code>java -cp testjar.jar leecode.JianPanHang500</code></p>
<p>🤔可以直接java -jar的打包：<br>如果需要直接java -jar 执行的jar包：<br>1.点击”Artifacts” -&gt; 绿色的”+” -&gt; “JAR” -&gt; from modules…<br>2.选择主类，选择META-INF位置<br>3.OK之后，点击菜单中“Build” -&gt; “Build Artifacts”<br>4.点击弹出框中待生成jar包下面的build即可</p>
<p>注意：在选择主类时需要全路径，rebuild之后可以重新编译，<code>java -jar lee.jar</code>直接运行主类。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42239765/article/details/123236019">https://blog.csdn.net/qq_42239765/article/details/123236019</a></p>
<h4 id="✅使用maven打包"><a href="#✅使用maven打包" class="headerlink" title="✅使用maven打包"></a>✅使用maven打包</h4><p>🤔不包含依赖包，也不指定入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;!-- 项目最终打包成的名字 --&gt;</span><br><span class="line">    &lt;finalName&gt;mylogmavenpackage&lt;/finalName&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>🤔指定入口，将依赖的jar包输出到指定目录<br>指定了入口类，可以直接使用java -jar project.jar执行，但是第三方依赖存在一个指定的外部目录下，迁移时需将jar和依赖目录一起迁移。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">          &lt;manifest&gt;</span><br><span class="line">            &lt;mainClass&gt;com.netty.client.SignalClient&lt;/mainClass&gt; &lt;!-- 指定入口类 --&gt;</span><br><span class="line">            &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;!-- 在jar的MF文件中生成classpath属性 --&gt;</span><br><span class="line">            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;!-- classpath前缀,即依赖jar包的路径 --&gt;</span><br><span class="line">          &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.1&lt;/version&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;copy&lt;/id&gt;</span><br><span class="line">          &lt;phase&gt;install&lt;/phase&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">          &lt;configuration&gt;</span><br><span class="line">            &lt;!-- 指定依赖包的输出路径，需与上方的classpathPrefix保持一致 --&gt;</span><br><span class="line">            &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt;</span><br><span class="line">          &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>🤔将项目依赖和项目打成一个jar包（胖包）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">          &lt;manifest&gt;</span><br><span class="line">            &lt;mainClass&gt;com.netty.client.SignalClient&lt;/mainClass&gt; &lt;!-- 指定入口类路径 --&gt;</span><br><span class="line">          &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">        &lt;descriptorRefs&gt;</span><br><span class="line">          &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;!-- jar包后缀，生成的jar包形式为：project-1.0-SNAPSHOT-jar-with-dependencies.jar --&gt;</span><br><span class="line">        &lt;/descriptorRefs&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">      &lt;!-- 添加此项后，可直接使用mvn package | mvn install --&gt;</span><br><span class="line">      &lt;!-- 不添加此项，需直接使用mvn package assembly:single --&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">          &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="打war包"><a href="#打war包" class="headerlink" title="打war包"></a>打war包</h3><p>上面打jar包，其实都有对应的打war包的方法：</p>
<p>✅手动打war包<br><code>jar cvf test.war ./*</code></p>
<p>✅idea打war包<br>artifact中选择web application，explode对于war explode，archive对应war。</p>
<p>✅maven打war包<br>pom.xml中指示<br><code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>maven有多种打包方式。</p>
<h3 id="war包和war-explode包"><a href="#war包和war-explode包" class="headerlink" title="war包和war explode包"></a>war包和war explode包</h3><p>1.war模式<br>这种可以称之为是发布模式，就是先将WEB工程打成war包，然后再将其上传到服务器进行发布 。</p>
<p>2.war exploded模式<br>是将WEB工程以当前文件夹的位置关系上传到服务器，即直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。<br>在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来。<br>（热部署，对于Java应用程序来说，热部署就是在运行时更新Java类文件。）</p>
<p>问题：<br>idea进行部署，会将war包移到tomcat webapp文件夹下吗？</p>
<h3 id="java-web工程目录结构"><a href="#java-web工程目录结构" class="headerlink" title="java web工程目录结构"></a>java web工程目录结构</h3><p>1.src文件夹：这是用来存放Java源文件。下面有main文件夹和test文件夹。<br>1.1.src/main/java：存放相应的Java代码，并根据对应的Java项目继续分层<br>1.2.src/main/resource：存放一些配置文件，例如application.properties、logback.xml<br>1.3.src/main/webapp：Web应用的网页，用来放静态资源比如HTML、CSS、图片等文件。WEB-INF目录所在。WEB-INF中存放网站配置文件目录，web.xml等配置信息。</p>
<p>2..idea文件夹：是存储IntelliJ IDEA项目的配置信息，主要内容有IntelliJ IDEA项目本身的一些编译配置、文件编码信息、jar包的数据源和相关的插件配置信息。一般用git做版本控制的时候会把.idea文件夹排除，因为这个文件下保存的都是个人本地Idea编译器的配置。</p>
<p>3.target文件夹：是用来存放项目构建后的文件和目录、jar包、war包、编译的class文件，都是maven构建时生成的。存放的是单个module的编译结果。</p>
<p>4.out文件夹：存放该项目下所有module的编译结果。</p>
<p>5.pom.xml：项目对象模型</p>
<h3 id="新建个web工程并部署"><a href="#新建个web工程并部署" class="headerlink" title="新建个web工程并部署"></a>新建个web工程并部署</h3><p>1.new project，选maven，选archetype maven<br>2.选择maven setting，新建工程<br>3.简单写个index.jsp，在webapp目录下（主页）<br>4.通过idea部署，生成war_explode包，热部署<br>5.lsof -i:8080 查看端口占用<br>6.target文件夹下有war包了，但是在tomcat-webapp文件夹下并没有该项目。<br>7.关闭idea，web也无法访问了，所以要想一直运行，得打jar包放在webapp目录下？<br>8.并且发现，没用servlet，不用导入servlet包。</p>
<h3 id="pom-xml结构"><a href="#pom-xml结构" class="headerlink" title="pom.xml结构"></a>pom.xml结构</h3><p>pom.xml 就是 maven 的配置文件，用以描述项目的各种信息。</p>
<p><code>&lt;project </code>  是 pom.xml 中描述符的根。</p>
<p><code>&lt;modelVersion&gt;</code> 指定 pom.xml 符合哪个版本的描述符。maven 2 和 3 只能为 4.0.0。</p>
<p>在 maven 中，根据 groupId、artifactId、version 组合来唯一识别一个 jar 包。<br><code>&lt;groupId&gt;</code> - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 java 的包结构。<br><code>&lt;artifactId&gt;</code> - 单独项目的唯一标识符。例如junit。不要在 artifactId 中包含点号(.)。<br><code>&lt;version&gt;</code> - 一个项目的特定版本。</p>
<blockquote>
<p>maven 在版本管理时候可以使用几个特殊的字符串 SNAPSHOT、LATEST、RELEASE。比如 1.0-SNAPSHOT。各个部分的含义和处理逻辑如下说明：<br>SNAPSHOT - 这个版本一般用于开发过程中，表示不稳定的版本。<br>LATEST - 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。<br>RELEASE ：指最后一个发布版。</p>
</blockquote>
<p><code>&lt;packaging&gt;</code> - 项目的类型，描述了项目打包后的输出，默认是 jar。常见的输出类型为：pom, jar, maven-plugin, ejb, war, ear, rar, par。</p>
<p><code>&lt;name&gt;</code> - 项目名字</p>
<p><code>&lt;url&gt;</code> - 项目网站</p>
<p><code>&lt;description&gt;</code> - 项目描述</p>
<p><code>&lt;parent&gt;</code> - maven 支持继承功能。子 POM 可以使用 parent 指定父 POM ，然后继承其配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;my-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0&lt;/version&gt;</span><br><span class="line">    &lt;relativePath&gt;../my-parent&lt;/relativePath&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">relativePath ： 在搜索本地和远程存储库之前，它不是必需的，但可以用作 maven 的指示符，以首先搜索给定该项目父级的路径。</span><br></pre></td></tr></table></figure>

<p><code>&lt;modules&gt;</code> - 子模块列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;my-project-api&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;my-project-repository&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;properties&gt;</code> - 属性列表。定义的属性可以在 pom.xml 文件中任意处使用。使用方式为 ${propertie} 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;!-- Test --&gt;</span><br><span class="line">		&lt;junit.version&gt;1.16.1&lt;/junit.version&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;dependencies&gt;</code> - 依赖配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">groupId, artifactId, version - 和基本配置中的 groupId、artifactId、version 意义相同。</span><br><span class="line"></span><br><span class="line">type - 对应 packaging 的类型，如果不使用 type 标签，maven 默认为 jar。</span><br><span class="line"></span><br><span class="line">scope - 此元素指的是任务的类路径（编译和运行时，测试等）以及如何限制依赖关系的传递性。有 5 种可用的限定范围：</span><br><span class="line">compile : 如果没有指定 scope 标签，maven 默认为这个范围。编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目。</span><br><span class="line">provided : 与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它。它只适用于编译和测试 classpath，不可传递。</span><br><span class="line">runtime : 此范围表示编译不需要依赖关系，而是用于执行。它是在运行时和测试 classpath，但不是编译 classpath。</span><br><span class="line">test : 此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。它不是传递的。</span><br><span class="line">system : 此范围与 provided 类似，除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。</span><br><span class="line"></span><br><span class="line">systemPath - 仅当依赖范围是系统时才使用。否则，如果设置此元素，构建将失败。该路径必须是绝对路径，因此建议使用 propertie 来指定特定的路径，如\$ &#123;java.home&#125; / lib。由于假定先前安装了系统范围依赖关系，maven 将不会检查项目的仓库，而是检查库文件是否存在。如果没有，maven 将会失败，并建议您手动下载安装。</span><br><span class="line"></span><br><span class="line">optional - optional 让其他项目知道，当您使用此项目时，您不需要这种依赖性才能正常工作。</span><br><span class="line"></span><br><span class="line">exclusions - 包含一个或多个排除元素，每个排除元素都包含一个表示要排除的依赖关系的 groupId 和 artifactId。与可选项不同，可能或可能不会安装和使用，排除主动从依赖关系树中删除自己。</span><br></pre></td></tr></table></figure>

<p><code>&lt;dependencyManagement&gt;</code> - 是在<code>&lt;dependencies&gt;</code>外用的。表示依赖 jar 包的声明。即你在项目中的 dependencyManagement 下声明了依赖，maven 不会加载该依赖，dependencyManagement 声明可以被子 POM 继承。<br>它的一个使用案例是当有父子项目的时候，父项目中可以利用 <code>&lt;dependencyManagement&gt;</code> 声明子项目中需要用到的依赖 jar 包，之后，当某个或者某几个子项目需要加载该依赖的时候，就可以在子项目中 dependencies 节点只配置 groupId 和 artifactId 就可以完成依赖的引用。<br><code>&lt;dependencyManagement&gt;</code> 主要是为了统一管理依赖包的版本，确保所有子项目使用的版本一致，类似的还有plugins和pluginManagement。</p>
<p><code>&lt;build&gt;</code> - 构建配置。<br><code>&lt;plugins&gt;</code> - 配置插件，在<code>&lt;build&gt;</code>下。<br><code>pluginManagement</code> - 与 dependencyManagement 很相似，在当前 POM 中仅声明插件，而不是实际引入插件。子 POM 中只配置 groupId 和 artifactId 就可以完成插件的引用，且子 POM 有权重写 pluginManagement 定义。<br>它的目的在于统一所有子 POM 的插件版本。<br><code>&lt;extensions&gt;</code> - 扩展配置，扩展是在构建期间激活的 artifacts。扩展不需要实际执行任何操作，也不包含 Mojo。因此，扩展对于指定普通插件接口的多个实现中的一个是非常好的。</p>
<p>pom.xml解析：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/76874769">https://zhuanlan.zhihu.com/p/76874769</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/02/myblog/JAVA/mybatis%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/02/myblog/JAVA/mybatis%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">mybatis实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-02 21:45:44" itemprop="dateCreated datePublished" datetime="2022-06-02T21:45:44+08:00">2022-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-05 21:43:37" itemprop="dateModified" datetime="2022-06-05T21:43:37+08:00">2022-06-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="resultMap和resultType"><a href="#resultMap和resultType" class="headerlink" title="resultMap和resultType"></a>resultMap和resultType</h3><p>ResultType和ResultMap都是执行查询语句时返回的结果集。<br>ResultType相对与ResultMap而言更简单一点。只有满足ORM（Object Relational Mapping，对象关系映射）时，即数据库表中的字段名和实体类中的属性完全一致时，才能使用，否则会出现数据不显示的情况。<br>ResultMap和ResultType的功能类似，但是ResultMap更强大一点，ResultMap可以实现将查询结果映射为复杂类型的pojo。</p>
<h4 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h4><p>1.java的基础类型及其包装类int,double和java.lang.Integer,java.lang.Double等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值为int，resultType为int ,java.lang.Integer也可以--&gt;</span><br><span class="line">&lt;select id=&quot;countUser&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">    select count(*) from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>2.自己定义的实体类,实体类和数据库字段需要一致，如果不一致需要使用resulMap自定义map，也可以直接使用map。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值为实体类，resultType为User--&gt;</span><br><span class="line">&lt;select id=&quot;getUser&quot; resultType=&quot;com.entity.User&quot;&gt;</span><br><span class="line">   select * from User where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>3.map类型，Dao层的返回类型为<code>Map&lt;String, Object&gt;</code>，key是对应的column值，value是数据中的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 返回值为Map&lt;String,Object&gt;，resultType为map--&gt;</span><br><span class="line">&lt;select id=&quot;getUserSelective&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">    select name,address,salary from User where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>4.List集合，其中该集合的类型可以为1,2,3中提到的类型。Dao层的返回类型为<code>List&lt;User&gt;</code>，这里只展示了实体类集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值为List&lt;User&gt;，resultType为User--&gt;</span><br><span class="line">&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>结果集的映射是 MyBatis 最强大的特性,通过使用resultMap或resultType可以解决复杂映射问题。基础简单的使用resultType就可以了，但是如果出现table中列和实体类中的属性不一致或者多表级联。那么这时resultMap就可以发挥作用了。</p>
<p>TestDao.xml:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.repository.TestDao&quot;&gt;</span><br><span class="line">    //定义映射</span><br><span class="line">    &lt;resultMap id=&quot;TestResultMap&quot; type=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">        &lt;result column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">        &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    //定义返回栏目</span><br><span class="line">    &lt;sql id=&quot;all_colum_without_id&quot;&gt;</span><br><span class="line">        name</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id=&quot;all_colum&quot;&gt;</span><br><span class="line">        name,&lt;include refid=&quot;all_colum_without_id&quot;/&gt;</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    //插入语句</span><br><span class="line">    &lt;insert id=&quot;insertOne&quot; parameterType=&quot;com.entity.TestDO&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">        insert into table (&lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">        values (#&#123;name&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    //查询</span><br><span class="line">    &lt;select id=&quot;findById&quot; resultMap=&quot;TestResultMap&quot;&gt;</span><br><span class="line">        select &lt;include refid=&quot;all_colum&quot;/&gt; from table where id=#&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>TestDao.java接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface TestDao &#123;</span><br><span class="line">    //插入</span><br><span class="line">    Integer insertOne(TestDO testDO);</span><br><span class="line">    //查询</span><br><span class="line">    TestDO findById(Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdbcType告诉框架如何解析这个属性（对应数据库中的类型），column是数据库中table的列名，property是实体类中对应的属性名字，type是对应的实体类，id=”TestResultMap”是这个resultMap的一个引用标志。</p>
<p>这样使用resultMap就像用resultType对应实体类，在select出来的语句中直接对字段就行as，as为实体类属性名，或驼峰形式就行。</p>
<p>resultMap更复杂的用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wobuaizhi/article/details/83104464">https://blog.csdn.net/wobuaizhi/article/details/83104464</a></p>
<h3 id="返回映射下划线转驼峰"><a href="#返回映射下划线转驼峰" class="headerlink" title="返回映射下划线转驼峰"></a>返回映射下划线转驼峰</h3><p>意思是返回值对应到对象，mysql返回的字段名（app_id），直接映射到对象属性名（appId）。</p>
<p>第一种 Spring Boot</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br></pre></td></tr></table></figure>

<p>第二种 mybatis-config.xml配置中加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 全局配置 --&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">    </span><br><span class="line">       &lt;!-- 是否开启自动驼峰命名规则映射</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt; </span><br></pre></td></tr></table></figure>

<h3 id="mybatis-useGeneratedKeys-keyProperty"><a href="#mybatis-useGeneratedKeys-keyProperty" class="headerlink" title="mybatis useGeneratedKeys keyProperty"></a>mybatis useGeneratedKeys keyProperty</h3><p>useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</p>
<p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置为目标属性就 OK 了。</p>
<p>作用：在inset时，可以不用管主键插入多少，而且插入后，还能直接用对象里的主，因为自动返回了。建表时必须设置主键自增。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;</span><br><span class="line">    keyProperty=&quot;id&quot;&gt;</span><br><span class="line">  insert into Author (username,password,email,bio)</span><br><span class="line">  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/01/myblog/JAVA/maven%E5%92%8Cnuxus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/01/myblog/JAVA/maven%E5%92%8Cnuxus/" class="post-title-link" itemprop="url">maven与nexus</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-01 22:34:23 / Modified: 23:10:09" itemprop="dateCreated datePublished" datetime="2022-06-01T22:34:23+08:00">2022-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><ol>
<li><p>优秀的构建工具<br>通过简单的命令，能够完成清理、编译、测试、打包、部署等一系列过程。同时，不得不提的是，Maven是跨平台的，无论是在Windows、还是在Linux或Mac上，都可以使用同样的命令。</p>
</li>
<li><p>依赖管理工具<br>项目依赖的第三方的开源类库，都可以通过依赖的方式引入到项目中来。代替了原来需要首先下载第三方jar，再加入到项目中的方式。从而更好的解决了合作开发中依赖增多、版本不一致、版本冲突、依赖臃肿等问题。<br>具体是怎么实现的呢？Maven通过坐标系统准确的定位每一个构件，即通过坐标找到对应的java类库。</p>
</li>
<li><p>项目信息管理工具<br>能够管理项目描述、开发者列表、版本控制系统地址、许可证等一些比较零散的项目信息。除了直接的项目信息，通过Maven自动生成的站点，以及一些已有的插件，还能够轻松获得项目文档、测试报告、静态分析报告、源码版本、日志报告等非常具有价值的项目信息。</p>
</li>
</ol>
<h3 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h3><p>maven的依赖管理功能，通过在Pom中指定坐标的形式将jar引入到项目中。jar包就存放在仓库中。</p>
<p>Maven的仓库分为本地仓库和远程仓库。远程仓库分为：中央仓库、私服、其他远程仓库。</p>
<p>当Maven根据坐标寻找构件时，它首先会查看本地仓库，如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要查看是否有更新的构件版本，Maven会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。</p>
<p>为什么需要私服？</p>
<p>1.一些无法从外部仓库下载的构件，例如内部的项目，可以部署到私服上，以便供其他依赖项目使用。</p>
<p>2.为了节省带宽和时间，在局域网内架设一个私有的仓库服务器，用其代理所有外部的远程仓库。当本地Maven项目需要下载构件时，先去私服请求，如果私服没有，则再去远程仓库请求，从远程仓库下载构件后，把构件缓存在私服上。这样，即使暂时没有Internet链接，由于私服已经缓存了大量构件，整个项目还是可以正常使用的。同时，也降低了中央仓库的负荷。</p>
<p>如果没有私服，我们所需的所有构件都需要通过maven的中央仓库和第三方的Maven仓库下载到本地，而一个团队中的所有人都重复的从maven仓库下载构件无疑加大了仓库的负载和浪费了外网带宽，如果网速慢的话，还会影响项目的进程。很多情况下项目的开发都是在内网进行的，连接不到maven仓库怎么办呢？开发的公共构件怎么让其它项目使用？这个时候我们不得不为自己的团队搭建属于自己的maven私服，这样既节省了网络带宽也会加速项目搭建的进程，当然前提条件就是你的私服中拥有项目所需的所有构件。<br>————————————————</p>
<p>总而言之：私服在用户局域网内的特殊远程仓库，私服起到了maven用户与中央仓库的中间作用，私服从中央仓库缓存构件，maven用户从私服下载构件。</p>
<h3 id="nexus"><a href="#nexus" class="headerlink" title="nexus"></a>nexus</h3><p>nexus就是私服的一种。</p>
<p>nexus是一个强大的maven仓库管理器,它极大的简化了本地内部仓库的维护和外部仓库的访问.</p>
<p>nexus提供了强大的仓库管理功能,构件搜索功能,它基于REST,友好的UI是一个extjs的REST客户端,占用较少的内存,基于简单文件系统而非数据库.</p>
<p>节省外网带宽；加速Maven构建；部署第三方构件；提高稳定性，增强控制；降低中央仓库的负荷；控制和审计；建立本地内部公用仓库。</p>
<p>转载自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/youngdeng/p/15098442.html">https://www.cnblogs.com/youngdeng/p/15098442.html</a></p>
<p>如何配置：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5b06b2541336">https://www.jianshu.com/p/5b06b2541336</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/21/myblog/JAVA/Geometry%E5%92%8CCoordinate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/21/myblog/JAVA/Geometry%E5%92%8CCoordinate/" class="post-title-link" itemprop="url">Geometry和Coordinate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-21 13:25:10" itemprop="dateCreated datePublished" datetime="2022-05-21T13:25:10+08:00">2022-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-28 17:46:03" itemprop="dateModified" datetime="2022-05-28T17:46:03+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="LineString与Coordinate"><a href="#LineString与Coordinate" class="headerlink" title="LineString与Coordinate"></a>LineString与Coordinate</h3><p>Geometry对象转换为LineString对象，前面加(LineString)强转。</p>
<p>Coordinate coor = new Coordinate(lng, lat);<br>//lng、lat是Double类型经度纬度</p>
<h3 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h3><p>com.vividsolutions.jts.geom下<br>Geometry可以是一系列的点组成的线。<br>数据库中查看需要加：select st_astext(geo) from table;</p>
<p>Geometry里的点：<br>Coordinate[] coordinates = geo.getCoordinates();</p>
<h3 id="GeometryUtils工具类"><a href="#GeometryUtils工具类" class="headerlink" title="GeometryUtils工具类"></a>GeometryUtils工具类</h3><p>GeometryUtils类属于mil.nga.giat.geowave.core.geotime包。</p>
<p><a target="_blank" rel="noopener" href="https://vimsky.com/examples/detail/java-class-mil.nga.giat.geowave.core.geotime.GeometryUtils.html">https://vimsky.com/examples/detail/java-class-mil.nga.giat.geowave.core.geotime.GeometryUtils.html</a></p>
<h3 id="redisTemplate的GEO-API："><a href="#redisTemplate的GEO-API：" class="headerlink" title="redisTemplate的GEO API："></a>redisTemplate的GEO API：</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39274753/article/details/107783674">https://blog.csdn.net/weixin_39274753/article/details/107783674</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/21/myblog/JAVA/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/21/myblog/JAVA/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">java多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-21 10:52:08 / Modified: 13:15:15" itemprop="dateCreated datePublished" datetime="2022-05-21T10:52:08+08:00">2022-05-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="线程池Executor、ExecutorService、Executors三者关系"><a href="#线程池Executor、ExecutorService、Executors三者关系" class="headerlink" title="线程池Executor、ExecutorService、Executors三者关系"></a>线程池Executor、ExecutorService、Executors三者关系</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/6f13f22d0f1e6bc6930273b38666f8cc.png"></p>
<p>层次关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;&#125;</span><br><span class="line">public abstract class AbstractExecutorService implements ExecutorService &#123;&#125;</span><br><span class="line">public interface ScheduledExecutorService extends ExecutorService &#123;&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;&#125;</span><br><span class="line">public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>区别：<br>1.ExecutorService 接口继承了Executor 接口，是Executor 的子接口。</p>
<p>2.Executor接口中定义了execute()方法，用来接收一个Runnable接口的对象，而ExecutorService接口中定义的submit()方法可以接收Runnable和Callable接口对象。</p>
<p>3.Executor接口中execute()方法不返回任何结果，而ExecutorService接口中submit()方法可以通过一个 Future 对象返回运算结果。</p>
<p>4.Executor和ExecutorService除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。<br>比如：调用 shutDown() 方法终止线程池。</p>
<p>5.Executors 是一个工具类，类似于 Collections。Executors 类提供工厂方法用来创建不同类型的线程池。比如:<br>　　 Executors.newSingleThreadExecutor() 创建一个只有一个线程的线程池，<br>　　 Executors.newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，<br>　　 Executors.newCachedThreadPool()创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>　　 Executors.newScheduledThreadPool(int corePoolSize) 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/whx20100101/p/9862392.html">https://www.cnblogs.com/whx20100101/p/9862392.html</a></p>
<p>使用Executor还是ExecutorService？<br>当线程池中的线程均处于工作状态，并且线程数已达线程池允许的最大线程数时，就会采取指定的饱和策略来处理新提交的任务。总共有四种策略：<br>AbortPolicy: 直接抛异常<br>CallerRunsPolicy: 用调用者的线程来运行任务<br>DiscardOldestPolicy: 丢弃线程队列里最近的一个任务，执行新提交的任务<br>DiscardPolicy 直接将新任务丢弃</p>
<p>如果使用 Executors 的工厂方法创建的线程池，那么饱和策略都是采用默认的 AbortPolicy，所以如果我们想当线程池已满的情况，使用调用者的线程来运行任务，就要自己创建线程池，指定想要的饱和策略，而不是使用 Executors 了。</p>
<p>所以我们可以根据需要创建 ThreadPoolExecutor(ExecutorService接口的实现类) 对象，自定义一些参数，而不是调用 Executors 的工厂方法创建。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43921491/article/details/115717604">https://blog.csdn.net/weixin_43921491/article/details/115717604</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = new ThreadPoolExecutor(...);</span><br><span class="line">executor.submit(()-&gt;单条语句);</span><br><span class="line"></span><br><span class="line">executor.submit(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        dosomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(1000);  //休息1s，以毫秒为单位。</span><br><span class="line"></span><br><span class="line">新建Thread线程：</span><br><span class="line">Thread thread = new Thread(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        dosomething();</span><br><span class="line">    &#125;, &quot;name&quot;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/myblog/JAVA/java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/myblog/JAVA/java/" class="post-title-link" itemprop="url">java常规</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-30 12:00:26" itemprop="dateCreated datePublished" datetime="2022-04-30T12:00:26+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-19 23:26:25" itemprop="dateModified" datetime="2022-06-19T23:26:25+08:00">2022-06-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>1、sql（dao层）返回的，尽量不要用VO，而使用DO。除非联表查询？</p>
<p>2、service里面不要调不想干的dao层方法，而是调dao所在service的方法。</p>
<p>3、mybatis <code>&lt;if&gt;</code> 标签得在<code>&lt;where&gt;</code>标签下。</p>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>forEach() 方法用于遍历动态数组中每一个元素并执行特定操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testArray()&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 往数组中添加元素</span><br><span class="line">        numbers.add(1);</span><br><span class="line">        numbers.add(2);</span><br><span class="line">        numbers.add(3);</span><br><span class="line">        numbers.add(4);</span><br><span class="line">        System.out.println(&quot;ArrayList: &quot; + numbers);</span><br><span class="line"></span><br><span class="line">        // 将 lambda 表达式传递给 forEach</span><br><span class="line">        numbers.forEach((e) -&gt; &#123;</span><br><span class="line">            System.out.print(e + &quot; &quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="Error-java-Compilation-failed"><a href="#Error-java-Compilation-failed" class="headerlink" title="Error:java: Compilation failed:"></a>Error:java: Compilation failed:</h3><p>报错原因：<br>项目中Java版本不一致，可以查看项目中的jdk配置.<br>1、查看项目的jdk<br>File -&gt;Project Structure-&gt;Project Settings -&gt;Project </p>
<p>2、查看工程的jdk<br>File -&gt;Project Structure-&gt;Project Settings -&gt; Modules -&gt; （需要修改的工程名称） -&gt; Sources -&gt;</p>
<p>3、查看idea中Java配置<br>compile 的 java compile中。</p>
<h3 id="Void-与-void-与-null"><a href="#Void-与-void-与-null" class="headerlink" title="Void 与 void 与 null"></a>Void 与 void 与 null</h3><p>void 是一种基本数据类型。而 Void 是 void 封装类型。<br>Void 之于 void 类似于 Integer 之于 int。但并非如此，Void 比较特别：<br>它不可实例化<br>它没有内置的类型实例，也没有可用的字面值。</p>
<p>声明一个 Void 变量通常是没有什么意义的，因为没有可为其赋值的实例。Void 变量唯一能持有的是 null。Void 一个可用的地方是反射判断方法的返回值时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(m.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">	// 处理返回值为 void 的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但也不是必需使用Void.TYPE，也可以用void.class。<br>总结来说，几乎很少会用到 Void 。</p>
<p>null是所有引用类型的默认值，但是我要澄清一些误解，null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将其赋予任何引用类型，你也可以将null转化成任何类型。</p>
<p>访问一个类里的方法，如果用null赋予的对象访问普通方法，会NullPointerException，而访问static方法，没事，因为访问静态方法不需要实例对象。因此，静态方法的访问，不建议用实例调用，用类调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Main m = (Main) null;</span><br><span class="line">System.out.println(m instanceof Main); //返回false</span><br><span class="line">System.out.println(m.getClass()); //空指针</span><br></pre></td></tr></table></figure>

<p>void不是函数，是方法的修饰符，void的意思是该方法没有返回值，意思就是方法只会运行方法中的语句，但是不返回任何东西。 java.lang.Void是一种类型。例如给Void引用赋值null。通过Void类的源代码可以看到，Void类型不可以继承与实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class Main &#123;</span><br><span class="line"></span><br><span class="line">    public void do1() &#123;</span><br><span class="line">        return; //返回void，return可写可不写</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Void do2() &#123;</span><br><span class="line">        return null; //此处必须返回null 返回其余类型都不好使</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Void.class); //class java.lang.Void</span><br><span class="line">        System.out.println(void.class); //void</span><br><span class="line">        //类似于下面的</span><br><span class="line">        System.out.println(Integer.class); //class java.lang.Integer</span><br><span class="line">        System.out.println(int.class); //int</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Void我们到底有什么用呢？其实在泛型出现之前，Void一般用于反射之中。判断方法返回是否为void。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">  public void print(String v) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">    for(Method method : Test.class.getMethods()) &#123;</span><br><span class="line">      //判断返回值类型 用到了Void类</span><br><span class="line">      if(method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有有的时候，并不需要返回值的抽像性设计，比如我设计的分布式锁：RedisLock.</p>
<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/f641385712/article/details/80409211?utm_source=blogxgwz0">https://blog.csdn.net/f641385712/article/details/80409211?utm_source=blogxgwz0</a></p>
<h3 id="int变String"><a href="#int变String" class="headerlink" title="int变String"></a>int变String</h3><p>第一种方式：使用int的封装类Integer，在Integer里面用他的toString方法。（性能最好）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i=3；</span><br><span class="line">String s=Integer.toString(i);</span><br></pre></td></tr></table></figure>

<p>第二种方式：String的valueOf方法，传参是Object（性能第二）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i=1;</span><br><span class="line">String s=String.valueOf(i);</span><br></pre></td></tr></table></figure>

<p>第三种方式，直接在int后面加一个空的字符串，因为在java里面，默认任务int类型和字符串类型相加，为字符串类型。（性能最差）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i=2；</span><br><span class="line">String s=i+&quot;&quot;;</span><br></pre></td></tr></table></figure>

<p>string变int：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(s)</span><br></pre></td></tr></table></figure>

<h3 id="java位运算"><a href="#java位运算" class="headerlink" title="java位运算"></a>java位运算</h3><p>1、左移( &lt;&lt; )  向左移动，低位补0<br>2、右移( &gt;&gt; )  向右移动，高位补0<br>3、无符号右移( &gt;&gt;&gt; )   正数右移，高位补0，负数右移，高位补1，当负数使用无符号右移时，用0进行补位(自然而然的，就由负数变成了正数了)<br>4、与( &amp; )  都为1，结果为1，否则为0<br>5、或( | )  一个是1，结果为1，否则为0<br>6、异或( ^ )  两个相反，结果为1，否则为0<br>7、非( ~ ) 一元操作符   取相反。</p>
<h3 id="Autowired接口还是现实类？"><a href="#Autowired接口还是现实类？" class="headerlink" title="Autowired接口还是现实类？"></a>Autowired接口还是现实类？</h3><p>答案：接口好</p>
<p>当实现类唯一时，表面上注入接口，其实注入实现类<br>当实现类多个时，通过@Service(“menuService1”)指定实现类</p>
<p>解析：<br>这个其实是创建了实现类的对象但引用了接口类型，<br>即 “InjectionDao injectionDao = new InjectionDaoImpl ()”, 是 Java 多态性（向上转型）的一种应用。<br>在实现类处加 @Repository 注解，意思就是 new InjectionDaoImpl (),</p>
<p>而在 InjectionServiceImpl 中定义属性 InjectionDAO injectionDAO 就是将 new 出来的这个 InjectionDaoImpl 对象向上转型为 InjectionDao 类型。</p>
<p>注意：<br>若一个接口被多个实现类，实现的时候，@Autowired，Spring 会按 byType 的方式寻找接口的实现类，将其注入。存在多个实现类，应该指定名字，可以通过 byName 注入的方式。可以使用 @Resource 或 @Qualifier 注解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//实现类1</span><br><span class="line">@Service(&quot;menuService1&quot;)</span><br><span class="line">public class MenuServiceImpl implements IMenuService</span><br><span class="line"> </span><br><span class="line">//实现类2</span><br><span class="line">@Service(&quot;menuService2&quot;)</span><br><span class="line">public class MenuServiceImpl implements IMenuService</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//注入接口，相当于new一个实现类，指定名称menuService1实现类</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;menuService1&quot;)</span><br><span class="line">private IMenuService menuService;</span><br><span class="line"></span><br><span class="line">//注入接口，相当于new一个实现类，指定名称menuService2实现类  </span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;menuService2&quot;)</span><br><span class="line">private IMenuService menuService;</span><br></pre></td></tr></table></figure>

<p>链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/huangkechen/article/details/122475824">https://blog.csdn.net/huangkechen/article/details/122475824</a></p>
<p>总结：就是Java 多态性（向上转型）的一种应用，但是这样做的好处并没有说啊。</p>
<h3 id="String-format"><a href="#String-format" class="headerlink" title="String.format"></a>String.format</h3><p>String.format(String format, Object… args)<br>字符串格式化方法</p>
<p><code>String str=String.format(&quot;Hi,%s %s %s&quot;, &quot;小超&quot;,&quot;是个&quot;,&quot;大帅哥&quot;);  </code></p>
<p>%s    字符串类型    “hello”<br>%c    字符类型    ‘m’<br>%b    布尔类型    true<br>%d    整数类型（十进制）    88<br>%x    整数类型（十六进制）    FF<br>%o    整数类型（八进制）    77<br>%f    浮点类型    8.888<br>%a    十六进制浮点类型    FF.35AE<br>%e    指数类型    9.38e+5<br>%g    通用浮点类型（f和e类型中较短的）    不举例(基本用不到)<br>%h    散列码    不举例(基本用不到)<br>%%    百分比类型    ％(%特殊字符%%才能显示%)<br>%n    换行符    不举例(基本用不到)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    String str=null;  </span><br><span class="line">    str=String.format(&quot;Hi,%s&quot;, &quot;小超&quot;);  </span><br><span class="line">    System.out.println(str);  </span><br><span class="line">    str=String.format(&quot;Hi,%s %s %s&quot;, &quot;小超&quot;,&quot;是个&quot;,&quot;大帅哥&quot;);            </span><br><span class="line">    System.out.println(str);                           </span><br><span class="line">    System.out.printf(&quot;字母c的大写是：%c %n&quot;, &#x27;C&#x27;);  </span><br><span class="line">    System.out.printf(&quot;布尔结果是：%b %n&quot;, &quot;小超&quot;.equal(&quot;帅哥&quot;));  </span><br><span class="line">    System.out.printf(&quot;100的一半是：%d %n&quot;, 100/2);  </span><br><span class="line">    System.out.printf(&quot;100的16进制数是：%x %n&quot;, 100);  </span><br><span class="line">    System.out.printf(&quot;100的8进制数是：%o %n&quot;, 100);  </span><br><span class="line">    System.out.printf(&quot;50元的书打8.5折扣是：%f 元%n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的16进制数是：%a %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的指数表示：%e %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的指数和浮点数结果的长度较短的是：%g %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面的折扣是%d%% %n&quot;, 85);  </span><br><span class="line">    System.out.printf(&quot;字母A的散列码是：%h %n&quot;, &#x27;A&#x27;);  </span><br><span class="line"></span><br><span class="line">日期格式：%tx x代表日期转换符</span><br><span class="line">c	包括全部日期和时间信息	星期六 十月 27 14:21:20 CST 2007</span><br><span class="line">F	“年-月-日”格式	2007-10-27</span><br><span class="line">D	“月/日/年”格式	10/27/07</span><br><span class="line">r	“HH:MM:SS PM”格式（12时制）	02:25:51 下午</span><br><span class="line">T	“HH:MM:SS”格式（24时制）	14:28:16</span><br><span class="line">R	“HH:MM”格式（24时制）	14:28</span><br><span class="line"></span><br><span class="line">Date date=new Date();                                  </span><br><span class="line">    //c的使用  </span><br><span class="line">    System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date);          </span><br><span class="line">    //f的使用  </span><br><span class="line">    System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date);  </span><br><span class="line">    //d的使用  </span><br><span class="line">    System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date);  </span><br><span class="line">    //r的使用  </span><br><span class="line">    System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date);  </span><br><span class="line">    //t的使用  </span><br><span class="line">    System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date);  </span><br><span class="line">    //R的使用  </span><br><span class="line">    System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date);  </span><br></pre></td></tr></table></figure>

<h3 id="list的一些操作"><a href="#list的一些操作" class="headerlink" title="list的一些操作"></a>list的一些操作</h3><p>一、Lists.newArrayList() 和 new ArrayList() ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; list = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">Lists和Maps是谷歌的两个工具类,</span><br><span class="line"></span><br><span class="line">Lists.newArrayList()其实和new ArrayList()几乎一模一样,</span><br><span class="line"></span><br><span class="line">唯一它帮你做的(其实是javac帮你做的),就是自动推导尖括号里的数据类型.</span><br><span class="line"></span><br><span class="line">在 Java 7 之后，都允许类型推断 - 在运行时没有区别。</span><br><span class="line"></span><br><span class="line">java8 的new ArrayList&lt;&gt;()的&lt;&gt;里面可以不写类型，java回帮你自动推导类型</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>同样，还有Sets：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; sets = Sets.newHashSet(&quot;ww&quot;); //可直接定义</span><br><span class="line">Set&lt;String&gt; sets = new HashSet&lt;&gt;(Lists.newArrayList(&quot;11&quot;,&quot;22&quot;));</span><br><span class="line">//还得用list转换</span><br></pre></td></tr></table></figure>

<p>二、对list排序：Comparator-java工具类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Comparator.comparing(A::getB));</span><br><span class="line"></span><br><span class="line">List&lt;类&gt; list; 代表某集合</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一升序排序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一));</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一降序排序 注意两种写法</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed());//先以属性一升序,结果进行属性一降序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()));//以属性一降序</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一升序 属性二升序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一降序 属性二升序 注意两种写法</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二));//先以属性一升序,升序结果进行属性一降序,再进行属性二升序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二));//先以属性一降序,再进行属性二升序</span><br><span class="line"></span><br><span class="line">//含Null数据排序,nullsLast空的放后面，距离Date类型属性</span><br><span class="line">list.stream().sorted(Comparator.comparing(item -&gt; item.属性, Comparator.nullsLast(Date::compareTo))).collect(Collectors.toList());</span><br><span class="line">// nullLast或nullFirst里面带类型，可以用Comparator.nullsLast(Comparator.naturalOrder()))</span><br><span class="line"></span><br><span class="line">//空/Null数据分组</span><br><span class="line">Map&lt;String, List&lt;类&gt;&gt; map = list.stream().collect(Collectors.groupingBy(item -&gt; &#123;</span><br><span class="line">  if (item.属性一 == null || item.属性一.equals(&quot;&quot;)) &#123;</span><br><span class="line">  　　return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return DateFormat.getDateInstance().format(item.属性一);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>list可以直接使用sort。<br>用sorted就需要先.stream()，再.collect(Collectors.toList())<br>::都得是get属性</p>
<p>自定义排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, new Comparator&lt;list中元素&gt;()&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public int compare(元素 o1, 元素 o2) &#123;</span><br><span class="line">    if(..)  return 1;  //表示o1在前</span><br><span class="line">    if(..)  return 0;  //表示一样</span><br><span class="line">    return -1；  //表示o2在前</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>三、list移除： removeIf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">removeIf() 方法用于删除所有满足特定条件的数组元素。</span><br><span class="line">ArrayList&lt;String&gt; sites = new ArrayList&lt;&gt;();</span><br><span class="line">sites.add(&quot;Taobao&quot;);</span><br><span class="line">sites.removeIf(e -&gt; e.contains(&quot;Tao&quot;));</span><br><span class="line">用了String的contains方法</span><br></pre></td></tr></table></figure>
<p>list元素可以先设置，再更改。</p>
<p>四、判断list为空<br>if(CollectionUtils.isEmpty(list)){}</p>
<p>五、indexOf方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">indexOf() 方法返回动态数组中元素的索引值。</span><br><span class="line">int i = arraylist.indexOf(Object obj)</span><br></pre></td></tr></table></figure>

<p>六、list、set转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//list直接变set：</span><br><span class="line">Set&lt;Long&gt; set2 = new HashSet&lt;&gt;(list);</span><br><span class="line">Set&lt;Long&gt; set1 = Sets.newHashSet(list);</span><br><span class="line">//set变list：</span><br><span class="line">List&lt;Long&gt; list2 = new ArrayList&lt;&gt;(set1);</span><br><span class="line">List&lt;Long&gt; list3 = Lists.newArrayList(set1);</span><br></pre></td></tr></table></figure>

<h3 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo()方法"></a>compareTo()方法</h3><p>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小。当一个对象调用该方法与另一个对象进行比较时，例如obj1.compareTo(obj2)，如果该方法返回0，则表示两个对象相等，如果该方法返回一个正整数，则表明obj1大于obj2；如果该方法返回一个负整数，则表明obj1小于obj2。</p>
<p>一些已经实现了Comparable接口的常用类：<br>Character：按照字符的UNICODE值进行比较<br>String：按照字符的UNICODE值进行比较<br>Date\Time：外面比里面新，返回1<br>Long：a.compareTo(b)，a比b大返回1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//以特定格式返回日期格式化程序</span><br><span class="line">DateFormat dateFormat = DateFormat.getDateInstance();</span><br><span class="line">Date oldTime = dateFormat.parse(&quot;2019-04-07 19:50:11&quot;);</span><br><span class="line">Date newTime = new Date();</span><br><span class="line">int result = oldTime.compareTo(newTime);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">// 日期变为字符串</span><br><span class="line">String str = dateFormat.format(new Date());</span><br></pre></td></tr></table></figure>

<h3 id="stream流-parallelStream流"><a href="#stream流-parallelStream流" class="headerlink" title="stream流 parallelStream流"></a>stream流 parallelStream流</h3><p>stream(): 是串行执行，按照顺序执行</p>
<p>parallelStream()：是并行执行，异步执行，多线程，并且使用的线程池是ForkJoinPool.common，可能存在共享资源、线程安全等问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">过滤：</span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5, 6);</span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().filter(i -&gt; i &gt; 3);</span><br><span class="line">integerList = stream.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">排序：</span><br><span class="line">.stream().sorted((e1,e2)-&gt;e1.compareTo(e2)).</span><br><span class="line"></span><br><span class="line">去重：</span><br><span class="line">.stream().distinct().</span><br><span class="line"></span><br><span class="line">按照对象中某一元素去重：</span><br><span class="line">.stream().filter(LambdaUtils.distinctByKey(类::get属性))</span><br><span class="line"></span><br><span class="line">返回指定流个数：</span><br><span class="line">.limit(5)</span><br><span class="line"></span><br><span class="line">跳过流中元素：</span><br><span class="line">.skip(2)</span><br><span class="line"></span><br><span class="line">map流映射：将接收的元素映射成另外一个元素：</span><br><span class="line">.map(类::get属性).collect...</span><br><span class="line">.map(对象-&gt;&#123;</span><br><span class="line">  构造另一种对象;</span><br><span class="line">  return 另一对象;</span><br><span class="line">&#125;).</span><br><span class="line">.map(string-&gt;Long.valueOf(string)).  //String变为Long</span><br><span class="line"></span><br><span class="line">对象list根据某一个元素变为map：</span><br><span class="line">list.stream().collect(Collectors.groupingBy(类::get属性))</span><br><span class="line"></span><br><span class="line">//流的过程中对元素进行操作</span><br><span class="line">List&lt;Long&gt; list = Lists.newArrayList();</span><br><span class="line">list2.stream().forEach(s -&gt; list.add(Long.valueOf(s)));</span><br></pre></td></tr></table></figure>

<h3 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h3><p>✅now.after()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DateFormat dateformat = DateFormat.getDateInstance();</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line">Date now = new Date();</span><br><span class="line">if(now.after(oldTime))&#123;</span><br><span class="line">    System.out.println(&quot;now比after新&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅DateFormat类<br>DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期→文本）、解析（文本→日期）和标准化日期。</p>
<p>在创建 DateFormat 对象时不能使用 new 关键字，而应该使用 DateFormat 类中的静态方法 getDateInstance()：<br><code>DateFormat df = DateFormat.getDatelnstance();</code><br>在创建了一个 DateFormat 对象后，可以调用该对象中的方法来对日期/时间进行格式化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//定义对象，日期、时间，也有getDateTimeInstance</span><br><span class="line">SHORT：18-10-15 上午9:30</span><br><span class="line">FULL：2018年10月15日 星期一 上午09时30分43秒 CST</span><br><span class="line">MEDIUM：2018-10-15 9:30:43</span><br><span class="line">LONG：2018年10月15日 上午09时30分43秒</span><br><span class="line"></span><br><span class="line">DateFormat df1 = DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line">DateFormat df5 = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line"></span><br><span class="line">//字符串到Date</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line"></span><br><span class="line">//Date到字符串</span><br><span class="line">String str = dateFormat.format(new Date());</span><br><span class="line"></span><br><span class="line">Date newTime = new Date();</span><br><span class="line">int result = oldTime.compareTo(newTime);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">DateFormat dateformat = DateFormat.getDateInstance();</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line">Date now = new Date();</span><br><span class="line">if(now.after(old))&#123;</span><br><span class="line">    System.out.println(&quot;now比old新&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅SimpleDateFormat<br>SimpleDateFormat 使得可以选择任何用户定义的日期/时间格式的模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date now = new Date(); // 创建一个Date对象，获取当前时间</span><br><span class="line">// 指定格式化格式</span><br><span class="line">SimpleDateFormat f = new SimpleDateFormat(&quot;今天是 &quot; + &quot;yyyy 年 MM 月 dd 日 E HH 点 mm 分 ss 秒&quot;);</span><br><span class="line">System.out.println(f.format(now)); // 将当前时间袼式化为指定的格式</span><br><span class="line">// format方法输出的是string类型</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/878.html">http://c.biancheng.net/view/878.html</a></p>
<p>✅FastDataFormat<br>Apache commons-lang中的FastDateFormat。也可以做时间的格式化。<br>FastDateFormat是线程安全的，可以直接使用，不必考虑多线程的情况<br>JDK里自带的SimpleDateFormat存在线程不安全问题。<br>SimpleDateFormat在对时间进行格式化的方法format中，会先对calendar对象进行setTime的赋值，若是有多个线程同时操作一个SimpleDateFormat实例的话，就会对calendar的赋值进行覆盖，进而产生问题。</p>
<p>FastDateFormat用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FastDateFormat f = FastDateFormat.getInstance(&quot;yyyy-MM-dd HH:mm:ss&quot;);  </span><br><span class="line">String s = f.format(new Date());</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>


<p>✅当前时间的后几秒：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Data data = new Date(System.currentTiomMillis() + expiremilliSeconds);</span><br><span class="line">加的是毫秒</span><br></pre></td></tr></table></figure>

<p>获取当前时间的月份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mon = LocalDate.now().getMonthValue();</span><br></pre></td></tr></table></figure>

<p>✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】</p>
<p>为什么需要LocalDate、LocalTime、LocalDateTime</p>
<p>1.Date如果不格式化，打印出的日期可读性差<br>Tue Sep 10 09:34:04 CST 2019<br>Date对时间处理比较麻烦。<br>getYear、getMonth这些方法吗，获取年月日很Easy，但都被弃用了。</p>
<p>2.使用SimpleDateFormat对时间进行格式化，但SimpleDateFormat是线程不安全的。SimpleDateFormat的format方法中的calendar是共享变量，并且这个共享变量没有做线程安全控制。当多个线程同时使用相同的SimpleDateFormat对象【如用static修饰的SimpleDateFormat】调用format方法时，多个线程会同时调用calendar.setTime方法，可能一个线程刚设置好time值。另外的一个线程马上把设置的time值给修改了导致返回的格式化时间可能是错误的。在多并发情况下使用SimpleDateFormat需格外注意 SimpleDateFormat除了format是线程不安全以外，parse方法也是线程不安全的。</p>
<p>多线程并发如何保证线程安全 - 避免线程之间共享一个SimpleDateFormat对象，每个线程使用时都创建一次SimpleDateFormat对象 =&gt; 创建和销毁对象的开销大 - 对使用format和parse方法的地方进行加锁 =&gt; 线程阻塞性能差 - 使用ThreadLocal保证每个线程最多只创建一次SimpleDateFormat对象 =&gt; 较好的方法。</p>
<p>LocalDate用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">只会获取年月日</span><br><span class="line">//获取当前年月日</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">//构造指定的年月日</span><br><span class="line">LocalDate localDate1 = LocalDate.of(2019, 9, 10);</span><br><span class="line">获取年、月、日、星期几</span><br><span class="line">int year = localDate.getYear();</span><br><span class="line">int year1 = localDate.get(ChronoField.YEAR);</span><br><span class="line">Month month = localDate.getMonth();</span><br><span class="line">int month1 = localDate.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line">int day = localDate.getDayOfMonth();</span><br><span class="line">int day1 = localDate.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek();</span><br><span class="line">int dayOfWeek1 = localDate.get(ChronoField.DAY_OF_WEEK);</span><br></pre></td></tr></table></figure>

<p>LocalTime用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">只会获取几点几分几秒</span><br><span class="line">创建LocalTime</span><br><span class="line">LocalTime localTime = LocalTime.of(13, 51, 10);</span><br><span class="line">LocalTime localTime1 = LocalTime.now();</span><br><span class="line">获取时分秒</span><br><span class="line">//获取小时</span><br><span class="line">int hour = localTime.getHour();</span><br><span class="line">int hour1 = localTime.get(ChronoField.HOUR_OF_DAY);</span><br><span class="line">//获取分</span><br><span class="line">int minute = localTime.getMinute();</span><br><span class="line">int minute1 = localTime.get(ChronoField.MINUTE_OF_HOUR);</span><br><span class="line">//获取秒</span><br><span class="line">int second = localTime.getSecond();</span><br><span class="line">int second1 = localTime.get(ChronoField.SECOND_OF_MINUTE);</span><br></pre></td></tr></table></figure>

<p>LocalDateTime:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">获取年月日时分秒，等于LocalDate+LocalTime</span><br><span class="line">创建LocalDateTime</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(2019, Month.SEPTEMBER, 10, 14, 46, 56);</span><br><span class="line">LocalDateTime localDateTime2 = LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime3 = localDate.atTime(localTime);</span><br><span class="line">LocalDateTime localDateTime4 = localTime.atDate(localDate);</span><br><span class="line">获取LocalDate</span><br><span class="line">LocalDate localDate2 = localDateTime.toLocalDate();</span><br><span class="line">获取LocalTime</span><br><span class="line">LocalTime localTime2 = localDateTime.toLocalTime();</span><br></pre></td></tr></table></figure>

<p>Instant:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">获取秒数</span><br><span class="line">创建Instant对象</span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">获取秒数</span><br><span class="line">long currentSecond = instant.getEpochSecond();</span><br><span class="line">获取毫秒数</span><br><span class="line">long currentMilli = instant.toEpochMilli();</span><br><span class="line">如果只是为了获取秒数或者毫秒数，使用System.currentTimeMillis()来得更为方便</span><br></pre></td></tr></table></figure>

<p>时间变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LocalDate、LocalTime、LocalDateTime、Instant为不可变对象，修改这些对象对象会返回一个副本</span><br><span class="line">增加、减少年数、月数、天数等 以LocalDateTime为例</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.of(2019, Month.SEPTEMBER, 10,</span><br><span class="line">14, 46, 56);</span><br><span class="line">//增加一年</span><br><span class="line">localDateTime = localDateTime.plusYears(1);</span><br><span class="line">localDateTime = localDateTime.plus(1, ChronoUnit.YEARS);</span><br><span class="line">//减少一个月</span><br><span class="line">localDateTime = localDateTime.minusMonths(1);</span><br><span class="line">localDateTime = localDateTime.minus(1, ChronoUnit.MONTHS);</span><br><span class="line">通过with修改某些值</span><br><span class="line">//修改年为2019</span><br><span class="line">localDateTime = localDateTime.withYear(2020);</span><br><span class="line">//修改为2022</span><br><span class="line">localDateTime = localDateTime.with(ChronoField.YEAR, 2022);</span><br><span class="line">还可以修改月、日</span><br></pre></td></tr></table></figure>

<p>时间计算:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">比如有些时候想知道这个月的最后一天是几号、下个周末是几号，通过提供的时间和日期API可以很快得到答案</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalDate localDate1 = localDate.with(firstDayOfYear());</span><br><span class="line">比如通过firstDayOfYear()返回了当前日期的第一天日期，还有很多方法这里不在举例说明</span><br></pre></td></tr></table></figure>

<p>格式化时间:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(2019, 9, 10);</span><br><span class="line">String s1 = localDate.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = localDate.format(DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">//自定义格式化</span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;dd/MM/yyyy&quot;);</span><br><span class="line">String s3 = localDate.format(dateTimeFormatter);</span><br><span class="line">DateTimeFormatter默认提供了多种格式化方式，如果默认提供的不能满足要求，可以通过DateTimeFormatter的ofPattern方法创建自定义格式化方式</span><br></pre></td></tr></table></figure>

<p>解析时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate1 = LocalDate.parse(&quot;20190910&quot;, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate localDate2 = LocalDate.parse(&quot;2019-09-10&quot;, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">和SimpleDateFormat相比，DateTimeFormatter是线程安全的</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1685414035437236647&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1685414035437236647&amp;wfr=spider&amp;for=pc</a></p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DateUtilsTest &#123;</span><br><span class="line">    public static final String DATE_PATTERN = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        // 获取指定格式时间字符串</span><br><span class="line">        String date = LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_PATTERN));</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        // 获取当前月份</span><br><span class="line">        Integer month = LocalDateTime.now().getMonth().getValue();</span><br><span class="line">        System.out.println(month);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="map几种遍历方式"><a href="#map几种遍历方式" class="headerlink" title="map几种遍历方式"></a>map几种遍历方式</h3><p>一、Map.Entry遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;  </span><br><span class="line">  System.out.println(&quot;key= &quot; + entry.getKey());</span><br><span class="line">  System.out.println(&quot;value= &quot; + entry.getValue());</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p>二、通过Iterator迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**通过entrySet()方法将key和value存放到Set集合中，Set集合中有迭代器**/</span><br><span class="line">Set&lt;Entry&lt;String,String&gt;&gt; entry = map.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String,String&gt;&gt; iterators = entry.iterator();</span><br><span class="line">while(iterators.hasNext())&#123;</span><br><span class="line">  Entry&lt;String,String&gt; entrys  = iterators.next();</span><br><span class="line">  System.out.println(&quot;key=&quot;+entrys.getKey()+&quot;&amp;&amp;value=&quot;+entrys.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、通过keySet()遍历<br>keySet()：将Map中所有的key存放到Set集合中。因为Set集合有迭代器，可以通过迭代器循环key，再通过get()方法，得到每个key所对应的value；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**通过keySet()方法将所有的key值存放到Set集合中,Set集合中有迭代器**/</span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">  String key = iterator.next();</span><br><span class="line">  System.out.println(&quot;key=&quot;+key+&quot;  &quot;+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以不用迭代器，直接for循环</span><br><span class="line">for (String key: map.keySet()) &#123;</span><br><span class="line">  System.out.println(&quot;key:&quot; + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四、values()遍历<br>values()获取集合中的所有的value值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; collection = map.values();</span><br><span class="line">再for遍历得到value，同样也可以用迭代器</span><br><span class="line">Iterator var3 = values.iterator();</span><br><span class="line">while(var3.hasNext()) &#123;</span><br><span class="line">  String value = (String)var3.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、直接foreach map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">  System.out.println(&quot;第五种:&quot; + key + &quot; ：&quot; + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Strings-nullToEmpty"><a href="#Strings-nullToEmpty" class="headerlink" title="Strings.nullToEmpty"></a>Strings.nullToEmpty</h3><p>Strings、Lists、Maps 都是google提供的工具类。<br>使用之前导入包guava。</p>
<p>vo.setS(String.nullToEmpty(s));  一般用于给对象属性赋值，如果为null，就设空。</p>
<p>其他guava工具类使用：<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/article/17770773.html">https://www.w3cschool.cn/article/17770773.html</a></p>
<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>定义枚举类，定义在一个包中，和impl、service、vo包平级。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum SexEnum:int &#123;</span><br><span class="line">    male,female;</span><br><span class="line">&#125;</span><br><span class="line">多个枚举成员之间使用逗号分隔，</span><br><span class="line">如果没有显式地声明基础类型的枚举，那么意味着它所对应的基础类型是 int。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public enum DemoEnum &#123;</span><br><span class="line">  LIU(&quot;liu&quot;, 1),</span><br><span class="line">  WANG(&quot;wang&quot;, 2);</span><br><span class="line">  UN_KNOW(&quot;unknow&quot;, 99)</span><br><span class="line"></span><br><span class="line">  private final String name;</span><br><span class="line">  private final int age;</span><br><span class="line"></span><br><span class="line">  //构造函数</span><br><span class="line">  private DemoEnum(String name, int age)&#123; </span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //可以存一个map供外部使用，里面是直接的enum类</span><br><span class="line">  static Map&lt;String, DemoEnum&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">  static &#123;</span><br><span class="line">    for (DemoEnum enum : DemoEnum.values()) &#123;</span><br><span class="line">      map.put(enum.getName(), enum)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static DemoEnum getEnumByName(String name) &#123;</span><br><span class="line">    return map.get(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //根据属性获得enum，再获得另一属性</span><br><span class="line">  //可以使用上面构造个map，再从map获取的方法</span><br><span class="line">  //也可以加个方法，遍历获取，根据属性获取enum</span><br><span class="line">  public static DemoEnum nameOf(String name) &#123;</span><br><span class="line">    for (DemoEnum e : DemoEnum.values()) &#123;</span><br><span class="line">      if (e.name = name) &#123;</span><br><span class="line">        return e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return UN_KNOW;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类的values()方法，获取定义的成员数组：<br><code>DemoEnum[] values = DemoEnum.values();</code></p>
<p>Enum valueOf方法：<br>通过字符串来获取枚举enum：<br><code>DemoEnum e = DemoEnum.valueOf(&quot;LIU&quot;)</code></p>
<h3 id="map-getOrDefault-key-defaultvalue"><a href="#map-getOrDefault-key-defaultvalue" class="headerlink" title="map.getOrDefault(key, defaultvalue)"></a>map.getOrDefault(key, defaultvalue)</h3><p>用于map获取value，与.get(key)不同的是，如果得到的value是null的话，可以给一个默认值。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;StudentGrade&gt; gradeList = Lists.newArrayList();</span><br><span class="line">//把学生成绩list变为map：学生-成绩list</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; gradeMap = Maps.newHashMap();</span><br><span class="line">for(StudentGrade studentGrade : gradeList) &#123;</span><br><span class="line">  List&lt;String&gt; grades = gradeMap.getOrDefault(studentGrade.getName(), Lists.newArrayList());</span><br><span class="line">  grades.add(studentGrade.getGrade());</span><br><span class="line">  gradeMap.put(studentGrade.getName(), grades); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StringUtils工具类"><a href="#StringUtils工具类" class="headerlink" title="StringUtils工具类"></a>StringUtils工具类</h3><p>StringUtils工具类是org.apache.commons.lang3包下的工具类，对String类型的操作作了封装，是对Java自带的API的有效补充，可以帮助我们更高效快速地处理字符串。</p>
<p>导入commons-lang3包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String substringAfter(String str,String separator)：</span><br><span class="line">在第一次出现分隔符后获取子字符串。</span><br><span class="line"></span><br><span class="line">String substringAfterLast(String str,String separator)：</span><br><span class="line">在最后一次出现分隔符之后获取子字符串。</span><br></pre></td></tr></table></figure>

<p>工具类：一般是直接用它的静态方法，直接用类来调用，例如：Collections、Arrays等jaa自带的工具类；Lists、Maps等google工具类；CollectionUtils、StringUtils等apache工具类。</p>
<p>更多：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1662921">https://cloud.tencent.com/developer/article/1662921</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.EMPTY = &quot;&quot;</span><br><span class="line"></span><br><span class="line">// 只替换一次--&gt;结果是：phhhss</span><br><span class="line">StringUtils.replaceOnce(&quot;sshhhss&quot;, &quot;ss&quot;, &quot;p&quot;);</span><br><span class="line">// 全部替换</span><br><span class="line">StringUtils.replace(&quot;sshhhs&quot;, &quot;ss&quot;, &quot;p&quot;);</span><br><span class="line">// 定义替换次数</span><br><span class="line">StringUtils.replace(&quot;sshhhsshss&quot;, &quot;ss&quot;, &quot;7777&quot;,2);</span><br></pre></td></tr></table></figure>

<h3 id="MapUtils工具类"><a href="#MapUtils工具类" class="headerlink" title="MapUtils工具类"></a>MapUtils工具类</h3><p>MapUtils是 org.apache.commons.collections 工具包中常用的工具类<br>需要导入包：commons-collections4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int value = MapUtils.getInteger(map, key, 0)</span><br><span class="line">//将结果转换为Integer，如果转换失败则使用默认值</span><br></pre></td></tr></table></figure>

<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012894692/article/details/82557843">https://blog.csdn.net/u012894692/article/details/82557843</a></p>
<h3 id="Collections、Collections、CollectionUtils"><a href="#Collections、Collections、CollectionUtils" class="headerlink" title="Collections、Collections、CollectionUtils"></a>Collections、Collections、CollectionUtils</h3><p>Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Collection（单例集合  ） </span><br><span class="line">├-List（有序，可重复 ）  </span><br><span class="line">│  ├-LinkedList（查询速度慢，增删快）   </span><br><span class="line">│  ├-ArrayList（查询速度快，增删慢）  </span><br><span class="line">│  └-Vector（线程安全的，操作效率低 ）  </span><br><span class="line">│　    └-Stack   </span><br><span class="line">└-Set（无序，不可重复） </span><br><span class="line">      ├-HashSet（使用了哈希表存取）</span><br><span class="line">      │    └-LinkedHashSet</span><br><span class="line">      └-SortedSet</span><br><span class="line">               └-TreeSet（有序）</span><br><span class="line">Map（键值对）  </span><br><span class="line">├-Hashtable   </span><br><span class="line">├-HashMap   </span><br><span class="line">└-WeakHashMap</span><br></pre></td></tr></table></figure>
<p>set是在HashMap的基础上实现的，HashSet的存储方式是把HashMap中的Key作为Set的对应存储项。HashMap是非同步的，线程不安全的，Hashtable虽然是同步线程安全的，但是已经过期了。 现在使用ConcurrentHashMap，这个是线程安全同步的</p>
<p>Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
<p>例如：排序(Sort)、倒序(reverse)、最大(max)、最小(min)、替换(fill)</p>
<p>使用sort方法可以根据元素的自然顺序对指定列表按升序进行排列。列表中所有元素都必须实现Comparable接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list);//排序</span><br><span class="line">System.out.println(list);</span><br><span class="line">Collections.reverse(list);//倒序</span><br><span class="line">System.out.println(list);</span><br><span class="line">int max = Collections.max(list);//最大</span><br><span class="line">System.out.println(max);</span><br><span class="line">int min = Collections.min(list);//最小</span><br></pre></td></tr></table></figure>

<p>CollectionUtils是对Collection集合操作的类方法，这个类不是java自带的类方法，需要另外导入一个commons-collections.jar包才可以使用这个类中方法。</p>
<p>例如：CollectionUtils.isEmpty(list)</p>
<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chaoge321/article/details/83788667">https://blog.csdn.net/chaoge321/article/details/83788667</a></p>
<h3 id="Comparable、Comparator"><a href="#Comparable、Comparator" class="headerlink" title="Comparable、Comparator"></a>Comparable、Comparator</h3><p>要讲这个，就要讲list的排序，看上面，有几种办法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.list.sort(Comparator.comparing(A::getB))</span><br><span class="line">2.list.stream.sorted(Comparator.comparing(A::getB)).collect(Collectors.toList())</span><br><span class="line">3.list.stream.sorted((a1,a2)-&gt;a1.compareTo(a2))</span><br><span class="line">4.直接Collections.sort(list)  </span><br><span class="line">//这个需要list的元素实现Comparable接口，比如String就实现了</span><br><span class="line">5.Collections.sort(list, new Comparator&lt;A&gt;()&#123;</span><br><span class="line">  @Oerride</span><br><span class="line">  public int compare(A a1, A a2)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>他们都是java的一个接口, 并且是用来对自定义的实体类比较大小的.</p>
<p>Comparable接口需要进行比较的实体类在定义时实现它，重写compareTo方法。<br>Comparator接口是在集合外部实现的排序，重写compare接口。Comparator接口比Comparable接口要灵活。</p>
<h3 id="File相关"><a href="#File相关" class="headerlink" title="File相关"></a>File相关</h3><p>Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。<br>File对象代表磁盘中实际存在的文件和目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">新建文件：</span><br><span class="line">String dirname = &quot;/java&quot;;</span><br><span class="line">File f1 = new File(dirname);</span><br><span class="line"></span><br><span class="line">// 判断该文件是否是一个目录</span><br><span class="line">if (f1.isDirectory()) &#123; &#125;</span><br><span class="line">f1.isFile() 是否是文件</span><br><span class="line"></span><br><span class="line">// 返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。</span><br><span class="line">String s[] = f1.list();</span><br><span class="line">for (int i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  File f = new File(dirname + &quot;/&quot; + s[i]);</span><br><span class="line">  if (f.isDirectory()) &#123;</span><br><span class="line">    System.out.println(s[i] + &quot; is a directory&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    System.out.println(s[i] + &quot; is a file&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName()  返回此抽象路径名表示的文件或目录的名称。（文件名）</span><br><span class="line"></span><br><span class="line">public String getPath()  将此抽象路径名转换为一个路径名字符串。（路径名）</span><br><span class="line"></span><br><span class="line">public String getParent()  返回此抽象路径名的父路径名的路径名字符串（路径名）</span><br><span class="line"></span><br><span class="line">public File getParentFile()  返回父文件</span><br><span class="line"></span><br><span class="line">public boolean exists()  测试此抽象路径名表示的文件或目录是否存在。</span><br><span class="line"></span><br><span class="line">// 创建文件所在目录：</span><br><span class="line">File file = new File(&quot;E:\\java\\file04\\abc雪.jpg&quot;);</span><br><span class="line">File dirFile = file.getParentFile();</span><br><span class="line">if(dirFile != null &amp;&amp; !dirFile.exists())&#123;</span><br><span class="line">  dirFile.mkdirs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多方法：<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-file.html">https://www.runoob.com/java/java-file.html</a></p>
<h3 id="FileUtils-工具类"><a href="#FileUtils-工具类" class="headerlink" title="FileUtils 工具类"></a>FileUtils 工具类</h3><p>apache 的commons-io包下的FileUtils，导包：commons-io</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;E:\\java\\file04\\abc雪.jpg&quot;);</span><br><span class="line">//删除指定文件，从不引发异常。</span><br><span class="line">FileUtils.deleteQuietly(file);</span><br><span class="line"></span><br><span class="line">//将byte数组写为File</span><br><span class="line">byte[] bytes = IOUtils.toByteArray(inputStream);</span><br><span class="line">FileUtils.writeByteArrayToFile(new File(path), bytes)</span><br><span class="line"></span><br><span class="line">//删除掉指定目录的文件</span><br><span class="line">FileUtils.deleteExistFile(new File(localpath));</span><br></pre></td></tr></table></figure>
<p>更多方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42402854/article/details/83374559">https://blog.csdn.net/qq_42402854/article/details/83374559</a></p>
<h3 id="File流"><a href="#File流" class="headerlink" title="File流"></a>File流</h3><p>JAVA中针对文件的读写操作设置了一系列的流，其中主要有FileInputStream,FileOutputStream,FileReader,FileWriter四种最为常用的流</p>
<p>一、FileInputStream流</p>
<p>被称为文件字节输入流，意思指对文件数据以字节的形式进行读取操作如读取图片视频等</p>
<p>若File类对象的所代表的文件不存在;不是文件是目录;或者其他原因不能打开的话，则会抛出FileNotFoundException。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  File file=new File(&quot;xxxxxxxx&quot;); //根据路径创建File类对象--这里路径即使错误也不会报错，因为只是产生File对象，还并未与计算机文件读写有关联</span><br><span class="line">        </span><br><span class="line">  try&#123;</span><br><span class="line">    FileInputStream fileInputStream=new FileInputStream(file);//与根据File类对象的所代表的实际文件建立链接创建fileInputStream对象</span><br><span class="line">      &#125;catch (FileNotFoundException e)&#123;</span><br><span class="line">          System.out.println(&quot;文件不存在或者文件不可读或者文件是目录&quot;);</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 也可以根据文件路径名字符串进行建立</span><br><span class="line">FileInputStream fileInputStream=new FileInputStream(filepath);</span><br></pre></td></tr></table></figure>

<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ai_bao_zi/article/details/81097898">https://blog.csdn.net/ai_bao_zi/article/details/81097898</a></p>
<h3 id="IOUtils工具类"><a href="#IOUtils工具类" class="headerlink" title="IOUtils工具类"></a>IOUtils工具类</h3><p>它是 Apache Commons IO 的一部分 。该类的所有成员函数都被用来处理输入 - 输出流。这些方法基于InputStream,  OutputStream,  Reader 和 Writer工作。</p>
<p>所有成员字段和方法都是静态的，不需要创建对象，直接用类名调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将输入流转换成字符数组:</span><br><span class="line">byte[] bytes = IOUtils.toByteArray(inputStream);</span><br></pre></td></tr></table></figure>

<p>关闭流：<br>之前关闭流，往往在finally中，因为会抛出IOException，所以finally中需要try catch，并且close之前需要判断是否为null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">finally &#123;</span><br><span class="line">  if (in != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      in.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          LOGGER.warn(&quot;Fail to close stream : &quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候就可以使用 IOUtils.closeQuietly 来精简代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = new byte[1024];</span><br><span class="line">InputStream in = null;</span><br><span class="line">OutputStream out = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">      in = new FileInputStream(&quot;foo.txt&quot;);</span><br><span class="line">      in.read(data);</span><br><span class="line"></span><br><span class="line">      out = new FileOutputStream(&quot;foo.txt&quot;);</span><br><span class="line">      data = &quot;Hello, World&quot;.getBytes();</span><br><span class="line">      out.write(data);</span><br><span class="line"></span><br><span class="line">      IOUtils.copy(in, out);</span><br><span class="line"></span><br><span class="line">      in.close(); //close errors are handled</span><br><span class="line">      out.close();</span><br><span class="line">&#125; catch (IOException e) &#123; </span><br><span class="line">      // error handling</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">      IOUtils.closeQuietly(in);</span><br><span class="line">      IOUtils.closeQuietly(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sulia1234567890/article/details/120569718">https://blog.csdn.net/sulia1234567890/article/details/120569718</a></p>
<h3 id="Joiner"><a href="#Joiner" class="headerlink" title="Joiner"></a>Joiner</h3><p>google guava提供的用来连接字符串的类。需要导包：guava。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 连接字符串list</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;);</span><br><span class="line">String str = Joiner.on(&quot;:&quot;).join(list);</span><br><span class="line">System.out.println(str);</span><br><span class="line">// 输出：AA:BB:CC</span><br><span class="line"></span><br><span class="line">//过滤其中的null</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, null);</span><br><span class="line">String str = Joiner.on(&quot;:&quot;).skipNulls().join(list);</span><br><span class="line">System.out.println(str);</span><br><span class="line">// 输出：AA:BB</span><br><span class="line"></span><br><span class="line">// 可以先定义一个Join对象</span><br><span class="line">private static Joiner MY_JOINER = Joiner.on(&quot;/&quot;).skipNulls();</span><br><span class="line">String s = MY_JOINER.join(..);  里面的参数是Object类型，可以多个。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44143796/article/details/122998799">https://blog.csdn.net/qq_44143796/article/details/122998799</a></p>
<h3 id="string自己的方法"><a href="#string自己的方法" class="headerlink" title="string自己的方法"></a>string自己的方法</h3><p>✅str.trim()  用于删除字符串的头尾空白符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = new String(&quot;   hello   &quot;);</span><br><span class="line">System.out.println( str.trim() );</span><br></pre></td></tr></table></figure>

<p>✅str.replaceAll(正则表达式, 替换字符串)<br>使用给定的参数 replacement 替换字符串所有匹配给定的正则表达式的子字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String Str = new String(&quot;www.hello.com&quot;);</span><br><span class="line">System.out.println(Str.replaceAll(&quot;(.*)hello(.*)&quot;, &quot;hi&quot; ));</span><br></pre></td></tr></table></figure>

<p>✅str.replace(原字符/字符串, 替换成的新字符/字符串)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String replace(char oldChar, char newChar)</span><br><span class="line">用新字符newChar 替换所有的 旧字符oldChar 。</span><br><span class="line"></span><br><span class="line">String replace(CharSequence target, CharSequence replacement)</span><br><span class="line">用新字符串replacement替换所有的 旧字符串target。</span><br><span class="line"></span><br><span class="line">String replaceAll(String regex, String replacement)</span><br><span class="line">用新字符串replacement 替换所有的 正则模式匹配的串。——（替换的是模糊字串）</span><br><span class="line"></span><br><span class="line">String replaceFirst(String regex, String replacement)</span><br><span class="line">用新字符串replacement 替换第一个 正则模式匹配的串。——（替换的是模糊字串）</span><br><span class="line">————————————————</span><br><span class="line">另外，StringBuilder中也有该方法：</span><br><span class="line">replace(int start，int end，String str)</span><br><span class="line">用str 替换 start–end的子串。//不包括end</span><br></pre></td></tr></table></figure>

<p>✅str.indexof() 用于返回字符串中某部分的索引<br>1、 indexOf(String str): 返回指定字符str在字符串中（方法调用者）第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。<br>2、indexOf(String str, int index): 返回从 index 位置开始查找指定字符str在字符串中第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;01234567890123456789&quot;;</span><br><span class="line">System.out.println(str.indexOf(&quot;123&quot;));  //return 1</span><br><span class="line">System.out.println(str.indexOf(&quot;123&quot;,5));  //return 11</span><br></pre></td></tr></table></figure>

<p>✅String.join()静态方法<br>用于将list/set变为String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 2L);</span><br><span class="line">// 元素中类型变换</span><br><span class="line">List&lt;String&gt; ls = list.stream().distinct().map(String::valueOf).collect(Collectors.toList());</span><br><span class="line">// 里面的ls不能为空，必须是String元素类型</span><br><span class="line">String s = String.join(&quot;,&quot;, ls);</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">//用set也可以</span><br><span class="line">Set&lt;Long&gt; set = Sets.newHashSet(1L, 2L);</span><br><span class="line">Set&lt;String&gt; ss = set.stream().map(i-&gt;String.valueOf(i)).collect(Collectors.toSet());</span><br><span class="line">s = String.join(&quot;,&quot;, ss);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<h3 id="map的一些操作"><a href="#map的一些操作" class="headerlink" title="map的一些操作"></a>map的一些操作</h3><p>✅map的put和putIfAbsent<br>1.使用 put 方法添加键值对，如果 map 集合中没有该 key 对应的值，则直接添加，并返回 value；如果已经存在对应的值，则会<strong>覆盖旧值</strong>，value 为新的值，返回值为 value。<br><code>map.put(key, value)</code></p>
<p>2.使用 putIfAbsent 方法添加键值对，如果 map 集合中没有该 key 对应的值，则直接添加，并返回 null，如果已经存在对应的值，则依旧为原来的值，返回值为 value（旧的值）。<br><code>map.putIfAbsent(key, value)</code></p>
<h3 id="Splitter工具类（String拆分成list）"><a href="#Splitter工具类（String拆分成list）" class="headerlink" title="Splitter工具类（String拆分成list）"></a>Splitter工具类（String拆分成list）</h3><p>是google出品的，guava包下的工具类，用于对字符串分割处理。</p>
<p>首先，已有的对字符串进行分割的方法：</p>
<p>1.String自带的split()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;1,2,3&quot;;</span><br><span class="line">String[] split = s.split(&quot;,&quot;);</span><br></pre></td></tr></table></figure>
<p>不足之处：如果,后有空格的话，还需要做进一步处理，<br>并且分割后以数组接收，如果数据过多，还需要再转为集合。</p>
<p>2.使用Patter类的split静态方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String input = &quot;This!!unusual use!!hh!!points&quot;;</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input)));</span><br></pre></td></tr></table></figure>

<p>其次，Splitter来分割字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SplitterTest &#123;</span><br><span class="line"></span><br><span class="line">    //定义一个拆分器，“,”分隔，去空格</span><br><span class="line">    private static final Splitter splitter = Splitter.on(&quot;,&quot;).trimResults().omitEmptyStrings();</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        String s = &quot;1,2, 3&quot;;</span><br><span class="line">        List&lt;String&gt; list = splitter.splitToList(s);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        List&lt;Long&gt; list1 = list.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>看《java基础》<br>针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set.stream().map(i-&gt;String.valueOf(i)).</span><br><span class="line">括号内的i，表示流处理中的元素，也是lambda表达式的输入</span><br><span class="line">只有一句语句，省去了&#123;&#125;，省去了return</span><br><span class="line"></span><br><span class="line">使用现有的方法，比如上面的，可以变成lambda表达式的引用形式::</span><br><span class="line">.map(String::valueOf).</span><br><span class="line"></span><br><span class="line">上面的方法例如map()，内部的传参是只有一个函数式接口，</span><br><span class="line">有的方法穿参，除了一个函数式接口还有其他，所以会有其他参数。</span><br><span class="line">例如：</span><br><span class="line">方法：showSum(int x, int y, Calculate cu)</span><br><span class="line">使用：showSum(10, 20, (x,y)-&gt;x+y);</span><br></pre></td></tr></table></figure>

<h3 id="Calender类"><a href="#Calender类" class="headerlink" title="Calender类"></a>Calender类</h3><p>Calendar 是一个抽象类, 无法通过直接实例化得到对象. 因此, Calendar 提供了一个方法 getInstance（工厂方法）,来获得一个Calendar的子类对象, 得到的 Calendar 由当前时间初始化.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class CalenderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set (2013, 5, 4, 13, 44, 51);//年月日时分秒 (月份0代表1月)</span><br><span class="line">        cal.set (Calendar.YEAR, 2014); //年</span><br><span class="line">        cal.set (Calendar.MONTH, 7); //月 (月份0代表1月)</span><br><span class="line">        cal.set (Calendar.DATE, 11); //日</span><br><span class="line">        cal.set (Calendar.HOUR_OF_DAY, 15); //时</span><br><span class="line">        cal.set (Calendar.MINUTE, 33); //分</span><br><span class="line">        cal.set (Calendar.SECOND, 32); //秒</span><br><span class="line"></span><br><span class="line">        //同时还有get、add方法，使用类似</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Calendar是父类，GregorianCalendar是子类。<br>GregorianCalendar（公历）是Calendar的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。可以使用new关键字创建实例。</p>
<p>例子：返回当前时间加10分钟后的日期时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = new GregorianCalendar();</span><br><span class="line">Date date = new Date();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.add(GregorianCalendar.MINUTE, 10);</span><br><span class="line">Date after = calendar.getTime();</span><br><span class="line">System.out.println(after);</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a1439775520/article/details/98442556">https://blog.csdn.net/a1439775520/article/details/98442556</a></p>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>首先，浮点数为什么不准确？<br>码农在程序里写的10进制小数，计算机内部无法用二进制的小数来精确的表达。<br>对于二进制小数，小数点右边能表达的值是 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128 … 1/(2^n）</p>
<p>试一试如何表达十进制的 0.2 吧。</p>
<p>0.01 = 1/4 = 0.25 ,太大</p>
<p>0.001 =1/8 = 0.125 , 又太小</p>
<p>0.0011 = 1/8 + 1/16 = 0.1875 , 逼近0.2了</p>
<p>0.00111 = 1/8 + 1/16 + 1/32 = 0.21875 , 又大了</p>
<p>0.001101 = 1/8+ 1/16 + 1/64 = 0.203125 还是大</p>
<p>0.0011001 = 1/8 + 1/16 + 1/128 = 0.1953125 这结果不错</p>
<p>0.00110011 = 1/8+1/16+1/128+1/256 = 0.19921875<br>已经很逼近了， 就这样吧。</p>
<p>这就是用二进制小数没法精确表达10进制小数的含义。<br>根本原因是:十进制值通常没有完全相同的二进制表示形式;十进制数的二进制表示形式可能不精确。只能无限接近于那个值</p>
<p>《Effective Java》在第48条推荐“使用BigDecimal来做精确运算”。</p>
<hr>
<p>float和double类型的主要设计目标是为了科学计算和工程计算。他们执行二进制浮点运算，这是为了在广域数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们没有提供完全精确的结果，所以不应该被用于要求精确结果的场合。但是，商业计算往往要求结果精确，这时候BigDecimal就派上大用场啦。</p>
<p>Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。</p>
<hr>
<p>BigDecimal构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public BigDecimal(double val)    将double表示形式转换为BigDecimal *不建议使用</span><br><span class="line">public BigDecimal(int val)　　将int表示形式转换成BigDecimal</span><br><span class="line">public BigDecimal(long)    创建一个具有参数所指定长整数值的对象。 </span><br><span class="line">public BigDecimal(String val)　　将String表示形式转换成BigDecimal *推荐使用</span><br></pre></td></tr></table></figure>

<p>为什么不推荐使用Double入参？<br>BigDecimal bDouble = new BigDecimal(2.3);<br>最终输出的数是：2.29999999….</p>
<p>为什么会出现这种情况呢？</p>
<p>JDK的描述：<br>1、参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。</p>
<p>2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。</p>
<p>当double必须用作BigDecimal的源时，请使用Double.toString(double)转成String，然后使用String构造方法，或使用BigDecimal的静态方法valueOf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bDouble1 = BigDecimal.valueOf(2.3);</span><br><span class="line">BigDecimal bDouble2 = new BigDecimal(Double.toString(2.3));</span><br></pre></td></tr></table></figure>

<hr>
<p>BigDecimal用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5&quot;);</span><br><span class="line">        BigDecimal b = new BigDecimal(&quot;1.5&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a + b =&quot; + a.add(b));</span><br><span class="line">        System.out.println(&quot;a - b =&quot; + a.subtract(b));</span><br><span class="line">        System.out.println(&quot;a * b =&quot; + a.multiply(b));</span><br><span class="line">        System.out.println(&quot;a / b =&quot; + a.divide(b));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>BigDecimal除法可能出现不能整除的情况，比如 4.5/1.3，这时会报错java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</p>
<p>其实divide方法有可以传三个参数</p>
<p>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)<br>第一参数表示除数， 第二个参数表示小数点后保留位数，<br>第三个参数表示舍入模式，只有在作除法运算或四舍五入时才用到舍入模式，有下面这几种:</p>
<pre><code>ROUND_CEILING    //向正无穷方向舍入
ROUND_DOWN    //向零方向舍入
ROUND_FLOOR    //向负无穷方向舍入
ROUND_HALF_DOWN    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.55 保留一位小数结果为1.5
ROUND_HALF_EVEN    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，如果保留位数是奇数，使用ROUND_HALF_UP，如果是偶数，使用ROUND_HALF_DOWN
ROUND_HALF_UP    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向上舍入, 1.55保留一位小数结果为1.6
ROUND_UNNECESSARY    //计算结果是精确的，不需要舍入模式
ROUND_UP    //向远离0的方向舍入

四舍五入采用 ROUND_HALF_UP
</code></pre>
<p>对BigDecimal进行截断和四舍五入可用setScale方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5635&quot;);</span><br><span class="line"></span><br><span class="line">        a = a.setScale(3, RoundingMode.HALF_UP);    //保留3位小数，且四舍五入</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        Double d = a.doubleValue();  //转为double类型</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以在做加减乘除运算时千万要保存操作后的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5&quot;);</span><br><span class="line">        BigDecimal b = new BigDecimal(&quot;1.5&quot;);</span><br><span class="line">        a.add(b);</span><br><span class="line"></span><br><span class="line">        System.out.println(a);  //输出4.5. 加减乘除方法会返回一个新的BigDecimal对象，原来的a不变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/YangJavaer/p/6056394.html">https://www.cnblogs.com/YangJavaer/p/6056394.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/myblog/JAVA/java%E6%8E%A5%E5%8F%A3&%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/myblog/JAVA/java%E6%8E%A5%E5%8F%A3&%E7%B1%BB/" class="post-title-link" itemprop="url">java常规接口、类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-30 09:59:37" itemprop="dateCreated datePublished" datetime="2022-04-30T09:59:37+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-28 21:04:53" itemprop="dateModified" datetime="2022-05-28T21:04:53+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p>位于java.io.Serializable包中，一般在创建实体类的时候会去实现这个接口，目的是为了序列化。</p>
<p>序列化指的是把对象转化成字节序列的过程，就是把内存中的对象转换成一连串的字节bytes描述的过程。<br>反序列化就是将字节bytes数据恢复为对象的过程。</p>
<p>需要将内存中对象状态数据保存到文件或数据库中时，需要进行序列化。这个比较直观的就是通过ObjectOutputStream和FileOutputStream向文件中保存对象时，实现了Serializable接口的对象会以二进制数据的形式保存到文件中，而未实现Serializable接口的对象则会直接报错，无法保存。</p>
<p>serialVersionUID：<br>如果在进行反序列化前，将某个实体类原有的serialVersionUID改变，在进行反序列化时就会报InvalidClassException异常。<br>如果没有指定serialVersionUID，在进行序列化时，JVM会通过计算给该类一个默认的serialVersionUID值。<br>但是不建议不指定serialVersionUID，高度依赖于JVM默认生成serialVersionUID，可能会导致其与编译器的实现细节耦合，这样可能会导致在反序列化的过程中发生意外的InvalidClassException异常。个人认为应该是指不同编译器编译的不同类可能产生一个相同的默认serialVersionUID。<br>另外尽量用private来修饰serialVersionUID。</p>
<h3 id="MultipartFile接口"><a href="#MultipartFile接口" class="headerlink" title="MultipartFile接口"></a>MultipartFile接口</h3><p>用于http中获取前台传来的文件</p>
<p>位于：package org.springframework.web.multipart;包下<br>中文名：多组件文档<br>继承自：InputStreamSource,并封装了getInputStream()方法<br>此方法用法：<code>@RequesParam(&quot;file&quot;)MultipartFile file</code><br><code>InputStream is  = file.getInputStream();</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String getName():得到的是@RequesParam(value = &quot;file&quot;)中的value值，不会为空。</span><br><span class="line">String getOriginalFilename():获取的是文件的完整名称，包括文件名称+文件拓展名。</span><br><span class="line">String getContentType()：返回文件内容类型，不是文件扩展名（例如：jpeg图片：image/jpeg）</span><br><span class="line">boolean isEmpty()：返回上传的文件是否为空，即multipart形式中没有选择任何文件或者选择的文件没有内容</span><br><span class="line">long getSize()：以字节为单位返回文件大小</span><br><span class="line">byte[] getBytes()：以字节数组的形式返回文件内容</span><br><span class="line">InputStream getInputStream()：返回一个字节流</span><br><span class="line">void transferTo()：用来将接收文件传输到给定目标路径，会抛出IOException、IllegalStateException异常。该方法在实际项目开发中使用较少。</span><br></pre></td></tr></table></figure>


<h3 id="Pattern类-amp-Matcher类"><a href="#Pattern类-amp-Matcher类" class="headerlink" title="Pattern类&amp;Matcher类"></a>Pattern类&amp;Matcher类</h3><p>Pattern类是java.util.regex包中的final类。是正则表达式的编译表示形式，此类的实例是不可变的，可供多个并发线程安全使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">public final class Pattern extends Object implements Serializable</span><br><span class="line"></span><br><span class="line">//Pattern调用静态方法compile返回Pattern实例。</span><br><span class="line">// 将给定的正则表达式编译并赋予给Pattern类</span><br><span class="line">Pattern pattern = Pattern.compile(paternStr);</span><br><span class="line"></span><br><span class="line">// 增加flag参数的指定，可选的flag参数包括：CASE INSENSITIVE,MULTILINE,DOTALL,UNICODE CASE， CANON EQ </span><br><span class="line">static Pattern compile(String regex, int flags) </span><br><span class="line">//先不明白</span><br><span class="line"></span><br><span class="line">//Pattern.split()（静态方法）和string.split()用途一样，</span><br><span class="line">//是将字符串从正则表达式匹配的地方分开</span><br><span class="line">String input = &quot;This!!unusual use!!hh!!points&quot;;</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input)));</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input, 3)));</span><br><span class="line">// 第二种，第二个参数用来限制将输入分割成字符串的数量</span><br></pre></td></tr></table></figure>

<p>正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\\d 表示数字，前面多了第一个\，是转义的意思。</span><br><span class="line">+表示重复前面的</span><br><span class="line">\\d+ 表示多个数字</span><br></pre></td></tr></table></figure>

<p>Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查，此类的实例用于多个并发线程是不安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Pattern.matcher 静态方法：</span><br><span class="line">Pattern.matcher(String regex,CharSequence input)</span><br><span class="line">静态方法,用于快速匹配字符串,匹配全部字符串</span><br><span class="line"></span><br><span class="line">pattern.matcher(CharSequence input):</span><br><span class="line">返回一个Matcher对象。</span><br><span class="line">Matcher类的构造方法也是私有的,不能随意创建,</span><br><span class="line">只能通过pattern.matcher(CharSequence input)方法得到该类的实例</span><br><span class="line"></span><br><span class="line">Pattern p=Pattern.compile(&quot;\\d+&quot;); </span><br><span class="line">Matcher m=p.matcher(&quot;22bb23&quot;); </span><br><span class="line">m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的</span><br></pre></td></tr></table></figure>

<p>用Pattern以及Matcher匹配例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;aa11bb&quot;;</span><br><span class="line">String paternStr = &quot;\\d+&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(paternStr);</span><br><span class="line">Matcher matcher = pattern.matcher(str);</span><br><span class="line">if (matcher.find()) &#123;   //有匹配就行</span><br><span class="line">    System.out.println(matcher.group(0));  //输出11</span><br><span class="line">&#125;</span><br><span class="line">if (matcher.matches()) &#123;  //需要完全匹配</span><br><span class="line">    System.out.println(matcher.group(0));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>更多方法：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/woniu317/article/details/52186694">https://blog.csdn.net/woniu317/article/details/52186694</a><br><a target="_blank" rel="noopener" href="http://www.51gjie.com/java/759.html">http://www.51gjie.com/java/759.html</a></p>
<h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h3><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。 </p>
<p>java.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line">    R apply(T t);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：起到了转换类型的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FunctionTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        method(s -&gt; Integer.parseInt(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method(Function&lt;String, Integer&gt; function) &#123;</span><br><span class="line">        int num = function.apply(&quot;10&quot;);</span><br><span class="line">        System.out.println(num + 20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他方法：如andThen方法<br><a target="_blank" rel="noopener" href="http://t.zoukankan.com/liyihua-p-12286100.html">http://t.zoukankan.com/liyihua-p-12286100.html</a></p>
<p>和@FunctionalInterface作用一样？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/myblog/JAVA/fastjson/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/myblog/JAVA/fastjson/" class="post-title-link" itemprop="url">fastjson</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-30 09:44:44" itemprop="dateCreated datePublished" datetime="2022-04-30T09:44:44+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-17 22:33:46" itemprop="dateModified" datetime="2022-06-17T22:33:46+08:00">2022-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>fastjson是阿里出品的处理JSON字符串的Java类库，可以对JSON字符串、JSON对象、Java对象进行互相转换。需要导入fastjson包。</p>
<h3 id="String、JSONObject、Object转换"><a href="#String、JSONObject、Object转换" class="headerlink" title="String、JSONObject、Object转换"></a>String、JSONObject、Object转换</h3><p>一、字符串转成JSON对象/数组<br>字符串转成JSON对象<br>JSON.parseObject(String text)<br>JSON.parse(String text)</p>
<p>字符串转成JSON数组<br>JSON.parseArray(String text)<br>JSON.parse(String text)</p>
<p>二、字符串转成Java对象/列表<br>字符串转成Java对象<br>JSON.parseObject(String text, Class<T> clazz)</T></p>
<p>字符串转成Java对象列表<br>JSON.parseArray(String text, Class<T> clazz)</T></p>
<p>三、Java对象/列表转成JSON对象/数组<br>Java对象转成JSON对象<br>JSONObject.toJSON(Object javaObject)<br>JSON.toJSON(Object javaObject)</p>
<p>Java对象列表转成JSON数组<br>JSONArray.toJSON(Object javaObject)<br>JSON.toJSON(Object javaObject)</p>
<p>四、JSON对象/数组转成Java对象/列表<br>JSON对象转成Java对象<br>JSON.toJavaObject(JSON json, Class<T> clazz)<br>jsonObject.toJavaObject(JSON json) (非静态方法)</T></p>
<p>JSON数组转成Java对象列表<br>jsonArray.toJavaList(Class<T> clazz) (非静态方法)</T></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONArray;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class FastJSONLearning &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    String jsonObjectStr = &quot;&#123;\&quot;prop\&quot;:\&quot;code\&quot;,\&quot;label\&quot;:\&quot;代码\&quot;,\&quot;required\&quot;:true,\&quot;key\&quot;:true&#125;&quot;;</span><br><span class="line">    String jsonArrayStr = &quot;[&#123;\&quot;prop\&quot;:\&quot;code\&quot;,\&quot;label\&quot;:\&quot;代码\&quot;,\&quot;required\&quot;:true,\&quot;key\&quot;:true&#125;,&#123;\&quot;prop\&quot;:\&quot;explain\&quot;,\&quot;label\&quot;:\&quot;中文释义\&quot;,\&quot;required\&quot;:true&#125;]&quot;;</span><br><span class="line"> </span><br><span class="line">    // 字符串转成JSON对象/数组</span><br><span class="line">    // 字符串转成JSON对象</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONObject jsonObject1 = JSON.parseObject(jsonObjectStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON对象: &quot; + jsonObject1);</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONObject jsonObject2 = (JSONObject) JSON.parse(jsonObjectStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON对象: &quot; + jsonObject2);</span><br><span class="line"> </span><br><span class="line">    // 字符串转成JSON数组</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONArray jsonArray1 = JSON.parseArray(jsonArrayStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON数组: &quot; + jsonArray1);</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONArray jsonArray2 = (JSONArray) JSON.parse(jsonArrayStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON数组: &quot; + jsonArray2);</span><br><span class="line"> </span><br><span class="line">    // 字符串转成Java对象/列表</span><br><span class="line">    // 字符串转成Java对象</span><br><span class="line">    Dict dict = JSON.parseObject(jsonObjectStr, Dict.class);</span><br><span class="line">    System.out.println(&quot;字符串转成Java对象: &quot; + dict.toString());</span><br><span class="line"> </span><br><span class="line">    // 字符串转成Java对象列表</span><br><span class="line">    List&lt;Dict&gt; dictList = JSON.parseArray(jsonArrayStr, Dict.class);</span><br><span class="line">    System.out.println(&quot;字符串转成Java对象列表: &quot; + dictList.toString());</span><br><span class="line"> </span><br><span class="line">    // Java对象/列表转成JSON对象/数组</span><br><span class="line">    // Java对象转成JSON对象</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONObject jsonObject3 = (JSONObject) JSONObject.toJSON(dict);</span><br><span class="line">    System.out.println(&quot;Java对象转成JSON对象: &quot; + jsonObject3.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONObject jsonObject4 = (JSONObject) JSON.toJSON(dict);</span><br><span class="line">    System.out.println(&quot;Java对象转成JSON对象: &quot; + jsonObject4.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // Java对象列表转成JSON数组</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONArray jsonArray3 = (JSONArray) JSONArray.toJSON(dictList);</span><br><span class="line">    System.out.println(&quot;Java对象列表转成JSON数组: &quot; + jsonArray3.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONArray jsonArray4 = (JSONArray) JSON.toJSON(dictList);</span><br><span class="line">    System.out.println(&quot;Java对象列表转成JSON数组: &quot; + jsonArray4.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // JSON对象/数组转成Java对象/列表</span><br><span class="line">    // JSON对象转成Java对象</span><br><span class="line">    // 方法1</span><br><span class="line">    Dict dict1 = JSON.toJavaObject(jsonObject1, Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON对象转成Java对象: &quot; + dict1);</span><br><span class="line"> </span><br><span class="line">    // JSON对象转成Java对象</span><br><span class="line">    // 方法2</span><br><span class="line">    Dict dict2 = jsonObject1.toJavaObject(Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON对象转成Java对象: &quot; + dict2);</span><br><span class="line"> </span><br><span class="line">    // JSON数组转成Java对象列表</span><br><span class="line">    List&lt;Dict&gt; dictList1 = jsonArray1.toJavaList(Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON数组转成Java对象列表: &quot; + dictList1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lasdaybg/p/15144350.html">https://www.cnblogs.com/lasdaybg/p/15144350.html</a></p>
<h3 id="json文件中获取"><a href="#json文件中获取" class="headerlink" title="json文件中获取"></a>json文件中获取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class JsonTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void TestJ()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            File jsonFile = ResourceUtils.getFile(&quot;classpath:hello.json&quot;);</span><br><span class="line">            String s = FileUtils.readFileToString(jsonFile);</span><br><span class="line">            System.out.println(&quot;s:&quot;+s);</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;error:&quot;+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileUtils 需要导包：commons-io。<br>classpath表示项目中的resource文件夹。</p>
<h3 id="JSONObject、JSONArray"><a href="#JSONObject、JSONArray" class="headerlink" title="JSONObject、JSONArray"></a>JSONObject、JSONArray</h3><p>也是fastjson下的</p>
<p>JSON是互联网开发过程中应用最广泛的一种数据类型，不管是后端API接口中，还是在前端都能得到广泛应用。JSON 就是一种轻量级的数据交换格式，被广泛应用于 WEB 应用程序开发</p>
<p>在线解析：<a target="_blank" rel="noopener" href="https://c.runoob.com/front-end/53/">https://c.runoob.com/front-end/53/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;area&quot;: &quot;山东菏泽&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;马马马马马百万&quot;,</span><br><span class="line">  &quot;age&quot;: [1,2,3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON、JSON对象、JSON数组区别<br>JSON 呢只是一种宏观上的叫法，可以理解为是一种数据结构，就像 xml 结构一样，是一种规约性内容；而 JSON 对象则是对 JSON 的具体体现；JSON 数组则是将多个 JSON 对象进行存储的一个集合，可以想象成 Java 中的 List 和 Object 的关系</p>
<h4 id="JSONObject"><a href="#JSONObject" class="headerlink" title="JSONObject"></a>JSONObject</h4><p>JSONObject 是根据 JSON 形式在 Java 中存在的对象映射<br>各大 JSON 类库的 JSONObject 内部实现也是不太一样的。<br>例如fastjson：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class JSONObject extends JSON implements Map&lt;String, Object&gt;, Cloneable, Serializable, InvocationHandler &#123;</span><br><span class="line">&#125;</span><br><span class="line">对 HashMap 的一层封装，并提供了一些个性化方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSONObject json = new JSONObject();</span><br><span class="line">json.put(&quot;key&quot;,&quot;value&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="JSONArray"><a href="#JSONArray" class="headerlink" title="JSONArray"></a>JSONArray</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class JSONArray extends JSON implements List&lt;Object&gt;, Cloneable, RandomAccess, Serializable &#123;</span><br><span class="line">&#125;</span><br><span class="line">一个 List 中 套了个 Map 类结构</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSONObject person = new JSONObject();</span><br><span class="line">person.put(&quot;name&quot;, &quot;马马马马马百万&quot;);</span><br><span class="line">JSONObject drug = new JSONObject();</span><br><span class="line">drug.put(&quot;drugName&quot;, &quot;盐酸丁卡因注射液&quot;);</span><br><span class="line">JSONArray array = new JSONArray();</span><br><span class="line">array.add(person);</span><br><span class="line">array.add(drug);</span><br></pre></td></tr></table></figure>

<h4 id="各种转换"><a href="#各种转换" class="headerlink" title="各种转换"></a>各种转换</h4><p>普通对象、json字符串、jsonObject</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">将对象转换为json字符串</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">String jsonStr = JSON.toJSONString(person);</span><br><span class="line">将json字符串转换为JSONObject对象</span><br><span class="line">JSONObject jsonObject = JSON.parseObject(jsonStr);</span><br><span class="line">将JSONObject 转换为对象</span><br><span class="line">JSONObject person = new JSONObject();</span><br><span class="line">person.put(&quot;name&quot;, &quot;马马马马马百万&quot;);</span><br><span class="line">person.put(&quot;age&quot;, 25);</span><br><span class="line">Student stuObj = JSON.toJavaObject(person, Student.class);</span><br></pre></td></tr></table></figure>

<h3 id="一个对象转换为另一个对象"><a href="#一个对象转换为另一个对象" class="headerlink" title="一个对象转换为另一个对象"></a>一个对象转换为另一个对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B = JSON.parseObject(JSON.toString(a), b.class)</span><br></pre></td></tr></table></figure>


<h3 id="getJSONObject、getJSONArray"><a href="#getJSONObject、getJSONArray" class="headerlink" title="getJSONObject、getJSONArray"></a>getJSONObject、getJSONArray</h3><p>Fastjson中getJSONObject()与getJSONArray()，用于获取JSONObject里的JSONObject、JSONArray()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;    &quot;package&quot;: &#123;</span><br><span class="line">        &quot;List1&quot;: &#123;</span><br><span class="line">            &quot;errorCode&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;errorMsg&quot;: &quot;Success&quot;,</span><br><span class="line">            &quot;receiverTradeNum&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;List2&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;medicalNum&quot;: &quot;15XXXXXX&quot;,</span><br><span class="line">                &quot;queryDate&quot;: &quot;YYYYMMDD&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;XXX&quot;,</span><br><span class="line">                &quot;authorizationNum&quot;: &quot;xxxxx&quot;,</span><br><span class="line">                &quot;pageNum&quot;: &quot;1&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSONObject jsonObj = JSON.parseObject(jsonStr);</span><br><span class="line">JSONObject package = jsonObj.getJSONObject(&quot;package&quot;);     // 定位到package json对象</span><br><span class="line">JSONArray list = package.getJSONArray(&quot;List2&quot;);   //采用getJSONArray方法， 定位到json集合</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/29/myblog/JAVA/java%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/29/myblog/JAVA/java%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">java常规注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-29 22:56:27" itemprop="dateCreated datePublished" datetime="2022-04-29T22:56:27+08:00">2022-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-28 17:43:37" itemprop="dateModified" datetime="2022-05-28T17:43:37+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从JDK5开始,Java增加对元数据的支持，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。</p>
<p>所有的注解本质上都是继承自 Annotation 接口。但是，手动定义一个接口继承 Annotation 接口无效的，需要通过 @interface 声明注解，Annotation 接口本身也不定义注解类型，只是一个普通的接口。</p>
<h3 id="Pattern"><a href="#Pattern" class="headerlink" title="@Pattern"></a>@Pattern</h3><p>用来限定string格式，用正则表达式来限定。<br>需要导入validation-api包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">    @Setter</span><br><span class="line">    public static class StudentVO&#123;</span><br><span class="line">        @Pattern(regexp = &quot;^[A-Za-z]+$&quot;, message = &quot;只能字母&quot;)</span><br><span class="line">        private String name;</span><br><span class="line">        private Long age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>常用的正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1 匹配首尾空格的正则表达式：(^\s*)|(\s*$)</span><br><span class="line">  2 整数或者小数：^[0-9]+\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$</span><br><span class="line">  3 只能输入数字：&quot;^[0-9]*$&quot;。</span><br><span class="line">  4 只能输入n位的数字：&quot;^\d&#123;n&#125;$&quot;。</span><br><span class="line">  5 只能输入至少n位的数字：&quot;^\d&#123;n,&#125;$&quot;。</span><br><span class="line">  6 只能输入m~n位的数字：。&quot;^\d&#123;m,n&#125;$&quot;</span><br><span class="line">  7 只能输入零和非零开头的数字：&quot;^(0|[1-9][0-9]*)$&quot;。</span><br><span class="line">  8 只能输入有两位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;。</span><br><span class="line">  9 只能输入有1~3位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;。</span><br><span class="line"> 10 只能输入非零的正整数：&quot;^\+?[1-9][0-9]*$&quot;。</span><br><span class="line"> 11 只能输入非零的负整数：&quot;^\-[1-9][]0-9&quot;*$。</span><br><span class="line"> 12 只能输入长度为3的字符：&quot;^.&#123;3&#125;$&quot;。</span><br><span class="line"> 13 只能输入由26个英文字母组成的字符串：&quot;^[A-Za-z]+$&quot;。</span><br><span class="line"> 14 只能输入由26个大写英文字母组成的字符串：&quot;^[A-Z]+$&quot;。</span><br><span class="line"> 15 只能输入由26个小写英文字母组成的字符串：&quot;^[a-z]+$&quot;。</span><br><span class="line"> 16 只能输入由数字和26个英文字母组成的字符串：&quot;^[A-Za-z0-9]+$&quot;。</span><br><span class="line"> 17 只能输入由数字、26个英文字母或者下划线组成的字符串：&quot;^\w+$&quot;。</span><br><span class="line"> 18 验证用户密码：&quot;^[a-zA-Z]\w&#123;5,17&#125;$&quot;正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。</span><br><span class="line"> 19 验证是否含有^%&amp;&#x27;,;=?$\&quot;等字符：&quot;[^%&amp;&#x27;,;=?$\x22]+&quot;。</span><br><span class="line"> 20 只能输入汉字：&quot;^[\u4e00-\u9fa5]&#123;0,&#125;$&quot;</span><br><span class="line"> 21 验证Email地址：&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;。</span><br><span class="line"> 22 验证InternetURL：&quot;^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$&quot;。</span><br><span class="line"> 23 验证电话号码：&quot;^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$&quot;正确格式为：&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX&quot;。</span><br><span class="line"> 24 验证身份证号（15位或18位数字）：&quot;^\d&#123;15&#125;|\d&#123;18&#125;$&quot;。</span><br><span class="line"> 25 验证一年的12个月：&quot;^(0?[1-9]|1[0-2])$&quot;正确格式为：&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;12&quot;。</span><br><span class="line"> 26 验证一个月的31天：&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;正确格式为；&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;31&quot;。</span><br><span class="line"> 27 匹配中文字符的正则表达式： [\u4e00-\u9fa5]</span><br><span class="line"> 28 匹配双字节字符(包括汉字在内)：[^\x00-\xff]</span><br><span class="line"> 29 应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</span><br><span class="line"> 30 String.prototype.len=function()&#123;return this.replace(/[^\x00-\xff]/g,&quot;aa&quot;).length;&#125;</span><br><span class="line"> 31 匹配空行的正则表达式：\n[\s| ]*\r</span><br><span class="line"> 32 匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;\/(.*)&gt;|&lt;(.*)\/&gt;</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https://blog.csdn.net/qq_36927265/article/details/87864026</span><br></pre></td></tr></table></figure>

<p>在control层，前端调用来进行数据校验。</p>
<p>一、VO对象内用@Pattern限定，control方法中用@Valid检查。<br><a target="_blank" rel="noopener" href="http://www.wpf123.com/post/97.html">http://www.wpf123.com/post/97.html</a></p>
<p>二、control类用@Validated注解，方法内String参数用@Pattern</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Validated</span><br><span class="line">class Controller &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping</span><br><span class="line">public ResponseEntity&lt;List&lt;Permission&gt;&gt; query(</span><br><span class="line">    @RequestHeader(&quot;iv-user&quot;) String userId,</span><br><span class="line">        @Pattern(regexp = &quot;^accessor$&quot;, message = &quot;请求参数不合法&quot;)</span><br><span class="line">        @RequestParam(&quot;findBy&quot;) String accessor,</span><br><span class="line">        @RequestParam(&quot;accessorId&quot;) long accessorId)&#123;</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="JSONField"><a href="#JSONField" class="headerlink" title="@JSONField"></a>@JSONField</h3><p>来自fastjson，fastjson是阿里巴巴出品的快速解析json的一个工具,</p>
<p>一、name属性：用来指定JSON串中key的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(name = &quot;AGE&quot;)</span><br><span class="line">private String age;</span><br></pre></td></tr></table></figure>
<p>也可以作用在setter、getter方法上。</p>
<p>二、format规定日期格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(format=&quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="line">private Date date;</span><br></pre></td></tr></table></figure>

<p>三、ordinal：规定字段的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(ordinal = 3)</span><br><span class="line">private int f0;</span><br><span class="line"></span><br><span class="line">@JSONField(ordinal = 2)</span><br><span class="line">private int f1;</span><br><span class="line"></span><br><span class="line">@JSONField(ordinal = 1)</span><br><span class="line">private int f2;</span><br></pre></td></tr></table></figure>

<p>四、serialize/deserialize指定字段不序列化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(serialize=false)</span><br><span class="line">public Date date;</span><br></pre></td></tr></table></figure>

<h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><p>LomBok中的注解，用来简化代码。</p>
<p>1.默认情况下，将打印所有非静态字段。<br>2.如果要跳过某些字段，可以用注释这些字段@ToString.Exclude。<br>3.可以使用精确指定要被toString方法包含的字段，先设置@ToString(onlyExplicitlyIncluded = true)，然后使用@ToString.Include标记每个要包含的字段。<br>4.可以更改用于标识成员的名称@ToString.Include(name = “some other name”)，name相当于给字段起别名。<br>5.可以通过更改成员的打印顺序@ToString.Include(rank = 1)。rank 表示该字段的优先级，值越大排在越前面，默认为 0，等级相同的成员以它们在源文件中出现的顺序打印。</p>
<h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>开发restful API时，会用到，@RestController 是@controller和@ResponseBody 的结合。</p>
<p>@Controller 将当前修饰的类注入Spring IOC容器，使得从该类所在的项目跑起来的过程中，这个类就被实例化。</p>
<p>@ResponseBody 它的作用是指该类中所有的API接口返回的数据，甭管你对应的方法返回Map或是其他Object，它会以Json字符串的形式返回给客户端。</p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。在Spring MVC 中使用 @RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController  </span><br><span class="line">@RequestMapping(&quot;/home&quot;)  </span><br><span class="line">public class IndexController &#123;  </span><br><span class="line">    @RequestMapping(&quot;/&quot;)  </span><br><span class="line">    String get() &#123;  </span><br><span class="line">        //mapped to hostname:port/home/  </span><br><span class="line">        return &quot;go to home&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @RequestMapping(&quot;/index&quot;)  </span><br><span class="line">    String index() &#123;  </span><br><span class="line">        //mapped to hostname:port/home/index/  </span><br><span class="line">        return &quot;go to index&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>参考：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6f5aec232c97">https://www.jianshu.com/p/6f5aec232c97</a></p>
<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>@RequestParam：将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：f(@RequestParam(value=”参数名”,required=”true/false”,defaultValue=””) String s</span><br><span class="line">       , 其他入参）</span><br><span class="line"> </span><br><span class="line">value：参数名</span><br><span class="line"> </span><br><span class="line">required：是否包含该参数，默认为true，表示该请求路径中必须包含该参数，如果不包含就报错。</span><br><span class="line"> </span><br><span class="line">defaultValue：默认参数值，如果设置了该值，required=true将失效，自动为false,如果没有传该参数，就使用默认值</span><br></pre></td></tr></table></figure>

<h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)，因此@RequestBody只能用于接收POST请求的参数<br>@RequestParam接收的是key-value里面的参数(URL中的参数)，通常用于接收GET请求的参数（POST也能接收只接收URL里的，请求体的接收不到）</p>
<p>即：<br>如果参数是放在请求体VO中，传入后台的话，那么后台要用@RequestBody才能接收到；<br>如果不是放在请求体中的话，那么后台接收前台传过来的参数时，要用@RequestParam来接收。</p>
<p>总结：<br>@RequestParam和@RequestBody都能接收Post方式请求传来的数据，但是@RequestParam不能接收json字符串，而@RequestBody能，@RequestBody不能接收form-data类型的内容，@RequestParam能。<br>一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。<br>@ReuestBody接受单个参数的时候只能先使用Map&lt;String,Object&gt; params接收,然后再使用params.get(“name”)获取参数的值。</p>
<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/justry_deng/article/details/80972817">https://blog.csdn.net/justry_deng/article/details/80972817</a></p>
<h3 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h3><p>lombok中的注解。<br>Builder 使用创建者模式又叫建造者模式。简单来说，就是一步步创建一个对象，它对用户屏蔽了里面构建的细节，但却可以精细地控制对象的构造过程。</p>
<p>@Builder注解的作用主要是用来生成对象，并且可以为对象链式赋值。放在实体类上。<br>​@Builder​​注释为你的类生成相对略微复杂的构建器API。</p>
<p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student student = Student.builder()</span><br><span class="line">        .name( &quot;admin&quot; )</span><br><span class="line">        .age( 18 )</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>与@Singular结合使用<br>使用@Singular注释注释一个集合字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Singular</span><br><span class="line">private List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">.hobbies( &quot;110&quot; ).hobbies( &quot;112&quot; )</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/g56467467464/article/details/105407741">https://blog.csdn.net/g56467467464/article/details/105407741</a></p>
<h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><p>baomidou.mybatisplus的注解<br>@TableName是mybatis-plus中的注解，主要是实现实体类型和数据库中的表实现映射。<br>放在实体类DO上。</p>
<p>虽然功能相同，但是，@TableName是mybatis-plus中的注解，@Table是Hibernate中的注解。</p>
<h3 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h3><p>1 、@Param注解的作用是给参数命名,参数命名后就能根据名字得到参数值,正确的将参数传入sql语句中（一般通过#{}的方式，${}会有sql注入的问题）。<br>2、一般写在mappe接口（DAO接口）的入参，对应xml中#{}中的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用方法：</span><br><span class="line">Mapper接口方法：</span><br><span class="line">public int findById(@Param(&quot;userId&quot;) int userId);</span><br><span class="line">对应的xml文件：</span><br><span class="line"> &lt;select id=&quot;findById&quot; resultMap=&quot;baseMap&quot;&gt;</span><br><span class="line">    select &lt;include redif=&quot;all_column_list&quot;&gt; from table_name</span><br><span class="line">    where user_id = #&#123;userId&#125;</span><br><span class="line"> &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>不使用@Param注解时，参数只能有一个，并且是Javabean。</p>
<p>使用了@Param后，可以不用parameterType？ 存疑</p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="@Mapper"></a>@Mapper</h3><p>在使用Mybatis持久层框架来操作数据库时，我们可以使用@Mapper注解和@MapperScan注解来将Mapper接口类交给Sprinig进行管理。</p>
<p>目的就是为了不再写mapper映射文件（xml文件）。</p>
<p>Spring Boot的核心理念是：不建议使用xml文件配置。但是，这对MyBatis来说进退两难，因为MyBatis离不开xml，需要xml来配置sql语句。为了迎合Spring Boot的发展理念，MyBatis官方开发了mybatis-spring-boot-starter，我们要想更少的依赖xml，需要深入的研究mybatis-spring-boot-starter中的用法，尤其是@MapperScan和@Mapper的用法。</p>
<p>一、注解@Mapper，这种方式要求每一个Mapper类都需要添加此注解<br>在接口类上添加了@Mapper，在编译之后会生成相应的接口实现类</p>
<p>二、@MapperScan注解，可以让我们不用为每个Mapper类都添加@Mapper注解。指定要变成实现类的接口所在的包<br>添加位置：是在Springboot启动类上面添加，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication  </span><br><span class="line">@MapperScan(&#123;&quot;cn.mybatis.mappers.class&quot;,&quot;cn.mybatis.mappers.student&quot;&#125;)  </span><br><span class="line">public class SpringbootMybatisDemoApplication&#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">       SpringApplication.run(SpringbootMybatisDemoApplication.class, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>最终实现：直接在Mapper类中采用注解的形式操作数据库，通过@MapperScan扫描制定的映射器存放路径，最终不需要加任何注解，也不需要对应的xml文件来配置sql语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//不需要加任何注解，也不需要对应的xml文件</span><br><span class="line">public interface UserMapper&#123;</span><br><span class="line">     @Select(&quot;select * from user&quot;)</span><br><span class="line">     List&lt;User&gt; getUserList(String userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="http://www.mybatis.cn/archives/862.html">http://www.mybatis.cn/archives/862.html</a></p>
<h3 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h3><p>@PostContruct是Java自带的注解，在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法。可作为一些数据的常规化加载，比如数据字典之类的。</p>
<p>从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，@PostConstruct和@PreDestroy，这两个注解被用来修饰一个非静态的void（）方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostConstruct</span><br><span class="line">public void someMethod()&#123;&#125;</span><br><span class="line"></span><br><span class="line">public @PostConstruct void someMethod()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>执行时机：在依赖注入完成后被自动调用。在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。<br>Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct &gt;&gt; init &gt;&gt; service &gt;&gt; destroy &gt;&gt; PreDestroy</p>
<p>该注解与BeanPostProcessor接口有关，它有个实现类CommonAnnotationBeanPostProcessor，就是专门处理@PostConstruct  @PreDestroy注解。</p>
<hr>
<p>InitialzingBean接口的afterPropertiesSet和配置bean时的init-method，也有类似功能。</p>
<p>initMethod和InitializingBean是spring提供的两种对类的属性进行装配的方式。initMethod和InitializingBean指定方法的执行顺序在普通属性装配之后，initMethod指定的方法又在InitializingBean指定的方法之后执行。</p>
<p>三者执行顺序：Construction &gt; 对象属性set() 方法-&gt; @PostConstruct -&gt; InitializingBean -&gt; initMethod</p>
<p>总结：可不可以理解为@PostConstruct在初始化自己bean时，依赖注入其他属性bean后执行，而InitialzingBean接口又是在它后面。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chinawangfei/article/details/122825129">https://blog.csdn.net/chinawangfei/article/details/122825129</a></p>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>@Deprecated是java内置注解，此注解可以用在方法，属性，类上，表示已废弃，不维护，可能会删除。<br>表示不推荐程序员使用，但是还可以使用。</p>
<h3 id="Valid"><a href="#Valid" class="headerlink" title="@Valid"></a>@Valid</h3><p>用于对象属性字段的规则检测，为了避免使用冗余的代码进行if判断，使用@Valid注解实现。</p>
<p>是Spring中的注解，需要引入依赖，如果是 springboot 项目，那么可以不用引入了，已经引入了，就存在于最核心的 web 开发包 spring-boot-starter-web 里面。</p>
<p>如果不是，需要引入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.0.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.4.1.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>使用方法：在被检验的实体类中，使用注解加一些限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@NotBlank(message = &quot;请输入名称&quot;)</span><br><span class="line">@Length(message = &quot;名称不能超过个 &#123;max&#125; 字符&quot;, max = 10)</span><br><span class="line">public String name;</span><br><span class="line"> </span><br><span class="line">@NotNull(message = &quot;请输入年龄&quot;)</span><br><span class="line">@Range(message = &quot;年龄范围为 &#123;min&#125; 到 &#123;max&#125; 之间&quot;, min = 1, max = 100)</span><br><span class="line">public Integer age;</span><br><span class="line"></span><br><span class="line">@Email(message = &quot;邮箱不正确&quot;)</span><br><span class="line">@Min(value = 1000000)</span><br><span class="line"></span><br><span class="line">@NotEmpty(message=&quot;不能为空&quot;)</span><br><span class="line">@Size(message=&quot;最多5个&quot;, max=5)</span><br><span class="line">private List&lt;Intefer&gt; list;</span><br></pre></td></tr></table></figure>

<p>在Controller的对应方法中，对传入参数加@Valid注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/action/register&quot;)</span><br><span class="line">public Result registerByForm(@Valid @RequestBody RegisterUser registerUser)&#123;</span><br><span class="line">    return userService.register(registerUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43587472/article/details/110388778">https://blog.csdn.net/weixin_43587472/article/details/110388778</a></p>
<h3 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a>@Transactional注解</h3><p>声明式事务管理，是建立在AOP之上，本质上是对方法前后进行拦截，然后再目标方法开始之前创建或加入一个一个事务，在执行完目标方法之后，根据执行情况提交或者回滚事务。</p>
<p>简而言之：@Transactional注解在代码执行出错时进行事务的回滚。</p>
<p>java异常模型：<br>Throwable是最顶层的父类，有Error和Exception两个子类。<br>Error表示严重的错误（如OOM等）；<br>Exception可以分为运行时异常（RuntimeException及其子类）和非运行时异常（Exception的子类中，除了RuntimeException及其子类之外的类）。</p>
<p>非运行时异常是检查异常（checked exceptions），一定要try catch，因为这类异常是可预料的，编译阶段就检查的出来；<br>Error和运行时异常是非检查异常（unchecked exceptions），不需要try catch，因为这类异常是不可预料的，编辑阶段不会检查，没必要检查，也检查不出来。</p>
<p>spring的@Transactional注解可以很方便的开启事务，但是默认只在遇到运行时异常和Error时才会回滚，非运行时异常不回滚，即Exception的子类中，除了RuntimeException及其子类，其他的类默认不回滚。</p>
<p>而rollbackFor属性可以解决这个问题，rollbackFor = Exception.class表示Exception及其子类的异常都会触发回滚，同时不影响Error的回滚。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 运行时异常，正常回滚</span><br><span class="line">@Transactional</span><br><span class="line">public void save()&#123;</span><br><span class="line">    StudentDO studentDO = new StudentDO();</span><br><span class="line">    studentDO.setName(&quot;ltm&quot;);</span><br><span class="line">    studentDO.setAge(22);</span><br><span class="line">    studentMapper.insert(studentDO);</span><br><span class="line">    throw new RuntimeException(&quot;我是异常&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 非运行时异常，加rollbackFor属性，抛出异常，并回滚</span><br><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public void save() throws IOException&#123;</span><br><span class="line">    StudentDO studentDO = new StudentDO();</span><br><span class="line">    studentDO.setName(&quot;ltm&quot;);</span><br><span class="line">    studentDO.setAge(22);</span><br><span class="line">    studentMapper.insert(studentDO);</span><br><span class="line">    throw new IOException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c5988db897fc">https://www.jianshu.com/p/c5988db897fc</a></p>
<p>使用方法：<br>1.需要在启动类上添加@EnableTransactionManagement注解。<br>2.当作用在类上，该类所以public方法都具有该类型的事务属性。也可以加在public方法上。</p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_9177933/2978291">https://blog.51cto.com/u_9177933/2978291</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/myblog/spring/BeanFactory%E5%92%8CApplicationContext/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/myblog/spring/BeanFactory%E5%92%8CApplicationContext/" class="post-title-link" itemprop="url">BeanFactory、ApplicationContext</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-26 22:12:06" itemprop="dateCreated datePublished" datetime="2022-04-26T22:12:06+08:00">2022-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-20 19:10:40" itemprop="dateModified" datetime="2022-05-20T19:10:40+08:00">2022-05-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring%E7%90%86%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">spring理解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="BeanFactory与ApplicationContext"><a href="#BeanFactory与ApplicationContext" class="headerlink" title="BeanFactory与ApplicationContext"></a>BeanFactory与ApplicationContext</h3><p>BeanFactory使管理不同类型的java对象成为可能，应用上下文ApplacationContext建立在BeanFactor基础之上，提供了更多面向应用的功能，它提供了国际化支持和框架事件体系，更易于创建实际应用。我们一般称BeanFactory为IOC容器，而称ApplicationContext为应用上下文。但有时为了行文方便，我们也称ApplicationContext为Spring容器。</p>
<p>对于二者的用途，可以进行简单的划分：BeanFactor是Spring框架的基础设施，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都可以直接使用ApplicationContext而非底层的BeanFactory。</p>
<p>（1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：<br>①继承MessageSource，因此支持国际化。<br>②统一的资源文件访问方式。<br>③提供在监听器中注册bean的事件。<br>④同时加载多个配置文件。<br>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
<p>（2）BeanFactory通常是使用编程方式被创建的，而ApplicationContext可以用声明（就是用配置的方式）的方式创建，当然也可以使用ApplicationContext的实现类之一用编码方式来创建ApplicationContext的实例.</p>
<p>（3）BeanFactory采用的是延迟加载形式来注入bean的，只有在使用到getBean() 时，才对该bean进行加载实例化，这样我们就不能发现一些bean的配置问题。而ApplicationContext则相反，它是在容器启动的时候，一次性创建所有的bean，这样在容器启动时就能发现spring 中存在的配置错误。这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>（4）BeanFactory和ApplicationContext都支持BeanPostProcesser、BeanFactoryPostProcessor的使用，但两者的区别是：BeanFactory是手动注册的，ApplicationContext是自动注册的.</p>
<h3 id="ApplicationContext的创建方式"><a href="#ApplicationContext的创建方式" class="headerlink" title="ApplicationContext的创建方式"></a>ApplicationContext的创建方式</h3><h4 id="使用代码方式"><a href="#使用代码方式" class="headerlink" title="使用代码方式"></a>使用代码方式</h4><p>ApplicationContext接口常用实现类：</p>
<p>1.ClassPathXmlApplicationContext</p>
<p>a.加载单个配置文件方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext cxt = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>b.加载多个配置文件方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] configs = &#123;&quot;bean1.xml&quot;,&quot;bean2.xml&quot;,&quot;bean3.xml&quot;&#125;;</span><br><span class="line">ApplicationContext cxt = new ClassPathXmlApplicationContext(configs);</span><br></pre></td></tr></table></figure>

<h4 id="使用配置-声明"><a href="#使用配置-声明" class="headerlink" title="使用配置(声明)"></a>使用配置(声明)</h4><p>在javaee应用中向Servlet容器中注入Spring容器的方法</p>
<p>ContextLoader 接口，它有两个实现 :ContextLoaderListener 和 ContextLoaderServlet. 其中常用的是 ContextLoaderListener. 从 spring 文档上可以查到，他们二者实现的功能基本一样，只是 ContextLoaderListener 不能在与 Servlet2.2 兼容的 web 容器中使用。另外，因为 ContextLoaderLitener 是一个 servlet Listener ，因此，它是在 servlet context 建立后立即执行，也就以为这 servlet 已建立， spring 的 ApplicationContext 就得到了初始化，并且能够相应第一个请求，所以首选 ContextLoaderListener.</p>
<p>在web.xml中添加如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; </span><br><span class="line"> &lt;! DOCTYPE web-app</span><br><span class="line">      PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span><br><span class="line">      &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt; </span><br><span class="line"> </span><br><span class="line"> &lt; web-app &gt; </span><br><span class="line">     &lt; display-name &gt; Baselib Application &lt;/ display-name &gt; </span><br><span class="line">    </span><br><span class="line">     &lt; context-param &gt; </span><br><span class="line">        &lt; param-name &gt; contextConfigLocation &lt;/ param-name &gt; </span><br><span class="line">        &lt; param-value &gt; </span><br><span class="line">        /WEB-INF/classes/spring-sup-middelbeans.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-action.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-beans.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-cm.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-hibernate.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-resource.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-sso.xml</span><br><span class="line">        /WEB-INF/classes/com/javaeye/jert/application_context.xml</span><br><span class="line">        &lt;/ param-value &gt; </span><br><span class="line">    &lt;/ context-param &gt; </span><br><span class="line"></span><br><span class="line">    &lt; listener &gt; </span><br><span class="line">        &lt; listener-class &gt; org.springframework.web.context.ContextLoaderListener &lt;/ listener-class &gt; </span><br><span class="line">    &lt;/ listener &gt; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; param-value &gt; /WEB-INF/classes/spring-*.xml &lt;/ context-param &gt; </span><br></pre></td></tr></table></figure>

<p>这里主要是配置了 spring 的监听器 ContextLoaderListener ，它检查 contextConfigLocation 这个参数。如果它不存在的话，它将用 /WEB-INF/applicationContext.xml 作为默认的配置文件。如果 contextConfigLocation 存在的话，它将根据该参数的值查找配置文件的位置，来一一读取 spring 参数。</p>
<p>contextConfigLocation 是被 spring 固定的，专门用来查  找配置文件位置的.</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sole_ghost/article/details/1389664">https://blog.csdn.net/sole_ghost/article/details/1389664</a></p>
<h3 id="ApplicationContext-getBean"><a href="#ApplicationContext-getBean" class="headerlink" title="ApplicationContext.getBean"></a>ApplicationContext.getBean</h3><p>目的：获取Spring容器中已初始化的bean</p>
<p>第一种：getBean(String name)<br>参数name表示IOC容器中已经实例化的bean的id或者name,<br>在IOC容器中是唯一的不能重名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p&quot;);</span><br></pre></td></tr></table></figure>

<p>第二种：getBean(Class<T> type)<br>type表示要加载的Bean的类型。<br>如果该类型没有继承任何父类(Object类除外)和实现接口的话，那么要求该类型的bean在IOC容器中也必须是唯一的.(比如定义同一类的两个bean，但是property注入的属性不一样)<br>不需要类型转换。</T></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Person p = ctx.getBean(Person.class);</span><br></pre></td></tr></table></figure>

<p>第三种：getBean(String name,Class<T> type)<br>这种方式比较适合接口/抽象类，有不同实现类或子类时，type写接口或父类，name写bean name。</T></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = ctx.getBean(&quot;person&quot;,BasePerson.class);</span><br></pre></td></tr></table></figure>

<p>第四种： getBean(String name,Object[] args)<br>第二个参数Object[] args可以给bean的属性赋值，赋值的方式有两种：构造方法和工厂方法。但是通过这种方式获取的bean必须把scope属性设置为prototype，也就是非单例模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.构造方法方式：</span><br><span class="line">&lt;bean name=&quot;p3&quot; class=&quot;com.bean.Person&quot; scope=&quot;prototype&quot;/&gt;</span><br><span class="line"></span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p3&quot;,new Object[]&#123;&quot;王五&quot;,35&#125;);</span><br><span class="line"></span><br><span class="line">2.工厂注入方式：</span><br><span class="line">工厂类：</span><br><span class="line">public class PersonFactory &#123;</span><br><span class="line">//静态工厂注入</span><br><span class="line">public static Person getPersonInstance(String name,int age)throws Exception</span><br><span class="line">&#123;</span><br><span class="line">  Person p = (Person)Class.forName(&quot;com.bean.Person&quot;).newInstance();</span><br><span class="line">   Method m = p.getClass().getMethod(&quot;setName&quot;, java.lang.String.class);</span><br><span class="line">   m.invoke(p, name);</span><br><span class="line">   m = p.getClass().getMethod(&quot;setAge&quot;, int.class);</span><br><span class="line">   m.invoke(p, age);</span><br><span class="line">   return p;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置bean：</span><br><span class="line">&lt;bean name=&quot;p3&quot; class=&quot;com.factory.PersonFactory&quot; factory-method=&quot;getPersonInstance&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;name&quot;&gt;</span><br><span class="line">&lt;null/&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;age&quot; value=&quot;0&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p3&quot;,new Object[]&#123;&quot;王五&quot;,35&#125;);</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23927391/article/details/80625578">https://blog.csdn.net/qq_23927391/article/details/80625578</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jade liu"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Jade liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jadeliuliu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jadeliuliu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jadeliu1998@163.com" title="E-Mail → mailto:jadeliu1998@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jadeliu1998" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;jadeliu1998" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5823044646" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5823044646" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jade liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
