<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jadeliu&#39;s blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Jadeliu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jade liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jadeliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jadeliu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/27/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/MAC%E5%AE%89%E8%A3%85mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/27/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/MAC%E5%AE%89%E8%A3%85mysql/" class="post-title-link" itemprop="url">MAC安装MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-27 19:23:22 / Modified: 20:49:08" itemprop="dateCreated datePublished" datetime="2021-11-27T19:23:22+08:00">2021-11-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装：<code>brew install mysql</code></p>
<p>查看：<code>brew info mysql</code></p>
<p>启动数据库服务：<code>mysql.server start</code></p>
<p>登录：<code>mysql -u root -p </code></p>
<blockquote>
<p>遇到问题，发现是brew没更新，brew update更新后再试就可以</p>
</blockquote>
<p>MySQL数据库第一次安装完成后,root用户初始的登录密码为空。直接回车进行登录。</p>
<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_goods \G</span><br></pre></td></tr></table></figure>

<p>一行一行地显示，注意：\G为大写字母，不可使用小写；使用\G参数后，SQL语句后可以不加分隔符，如果加分隔符，则会报“error:no query specified”的错误。</p>
<h2 id="添加用户改密码"><a href="#添加用户改密码" class="headerlink" title="添加用户改密码"></a>添加用户改密码</h2><p><code>select User, Host, password_expired from mysql.user;</code>  显示用户</p>
<p><strong>创建用户</strong>：<code>create user &#39;name&#39;@&#39;localhost&#39; identified by &#39;password&#39;;</code></p>
<p>username：你将创建的用户名<br>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%<br>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</p>
<p><code>CREATE USER &#39;dog&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code><br><code>CREATE USER &#39;pig&#39;@&#39;192.168.1.101_&#39; IDENDIFIED BY &#39;123456&#39;;</code><br><code>CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</code></p>
<p><strong>授权</strong>：<code>grant privileges on databasename.tablename to &#39;username&#39;@&#39;host&#39;</code></p>
<p>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL<br>databasename：数据库名<br>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</p>
<p>例子:<br><code>GRANT SELECT, INSERT ON test.user TO &#39;pig&#39;@&#39;%&#39;;</code><br><code>GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;</code><br><code>GRANT ALL ON maindataplus.* TO &#39;pig&#39;@&#39;%&#39;;</code></p>
<p><strong>修改密码</strong>：<code>set password for &#39;name&#39;@&#39;localhost&#39;=password(&#39;newpass&#39;);</code></p>
<p>如果是当前登陆用户用:<br><code>SET PASSWORD = PASSWORD(&quot;newpassword&quot;);</code><br>例子:<br><code>SET PASSWORD FOR &#39;pig&#39;@&#39;%&#39; = PASSWORD(&quot;123456&quot;);</code></p>
<p><strong>撤销授权</strong>：<code>REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;</code></p>
<p>例子:<br><code>REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;;</code></p>
<p><strong>查看授权</strong>：<code>SHOW GRANTS FOR &#39;pig&#39;@&#39;%&#39;; </code></p>
<p><strong>删除用户</strong>：<code>DROP USER &#39;username&#39;@&#39;host&#39;;</code></p>
<p><strong>刷新权限</strong>：<code>flush privileges;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select User, Host, password_expired from mysql.user;</span><br><span class="line">grant all on *.* to &#x27;liuxuan&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">mysql -u liuxuan -p</span><br><span class="line">登录</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/27/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BJDBC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/27/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BJDBC/" class="post-title-link" itemprop="url">《Java基础入门》之JDBC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-27 19:20:17 / Modified: 22:39:58" itemprop="dateCreated datePublished" datetime="2021-11-27T19:20:17+08:00">2021-11-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实际开发中，项目中的数据是存储在数据库中的，Java对数据库的操作提供了一套可以执行SQL语句的API，即JDBC。</p>
<h2 id="JDBC概念"><a href="#JDBC概念" class="headerlink" title="JDBC概念"></a>JDBC概念</h2><p>JDBC（java database connectivity，Java数据库连接）是一套用于执行SQL语句的Java API。应用程序通过该API连接到关系型数据库，并使用SQL语句来完成对数据库中数据的增删改查。</p>
<p>JDBC要求各个数据库厂商按照统一的规范来提供数据库驱动，在程序中由JDBC和具体的数据库驱动联系，使得应用程序不必直接与底层数据库交互，使得代码的通用性更强。</p>
<p>JDBC在应用程序与数据库之间起到一个桥梁作用。当应用程序使用JDBC访问特定的数据库时，只需要通过不同的数据库驱动与其对应的数据库进行连接，连接后即可对该数据库进行相应的操作。</p>
<h2 id="JDBC常用API"><a href="#JDBC常用API" class="headerlink" title="JDBC常用API"></a>JDBC常用API</h2><p>JDBC的API主要位于java.sql包中，定义了一系列访问数据库的接口和类。</p>
<h3 id="Driver接口"><a href="#Driver接口" class="headerlink" title="Driver接口"></a>Driver接口</h3><p>是所有JDBC驱动程序必须实现的接口，专门提供给数据库厂商使用。</p>
<h3 id="DriverManager类"><a href="#DriverManager类" class="headerlink" title="DriverManager类"></a>DriverManager类</h3><p>用于加载JDBC驱动并创建与数据库的连接。在加载数据库驱动时，通常使用Class类的静态方法forName()来实现。参数是数据库驱动类所对应的字符串。</p>
<h3 id="Connection接口"><a href="#Connection接口" class="headerlink" title="Connection接口"></a>Connection接口</h3><p>代表Java程序和数据库的连接对象，只有获得该连接对象后，才能访问数据库，并操作数据表。</p>
<h3 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h3><p>用于执行静态的SQL语句，并返回一个结果对象。</p>
<p>Statement接口对象可以通过Connection实例的createStatement()方法获得，该方法把静态的SQL语句发送到数据库中编译执行，然后返回数据库的处理结果。</p>
<h3 id="PreparedStatement接口"><a href="#PreparedStatement接口" class="headerlink" title="PreparedStatement接口"></a>PreparedStatement接口</h3><p>使用Statement接口操作SQL语句会过于繁琐，并且存在安全隐患，因此，JDBC提供了扩展的PreparedStatement接口。是Statement的子接口，用于执行预编译的SQL语句，可以使用占位符？来替代参数，然后通过setXXX()方法为SQL语句的参数赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">&quot;insert into users(is,name,email) values(?,?,?)&quot;</span>;</span><br><span class="line">PreparedStatement prestmt = conn.preparedStatement(sql);</span><br><span class="line">prestmt.setInt(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">prestmt.setString(<span class="number">2</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">prestmt.setObject(<span class="number">3</span>,<span class="string">&quot;111@1.com&quot;</span>);  <span class="comment">//通用方法？</span></span><br><span class="line">prestmt.executeUpdate();</span><br></pre></td></tr></table></figure>

<h3 id="ResultSet接口"><a href="#ResultSet接口" class="headerlink" title="ResultSet接口"></a>ResultSet接口</h3><p>用于保存JDBC执行查询时返回的结果集，结果集封装在一个逻辑表格中。接口内部有一个指向表格数据行的游标（或指针），ResultSet对象初始化时，游标在第一行之前。调用next()方法，游标移动到下一行，若下一行没有数据，则返回false。</p>
<p>应用程序中使用next方法作为while循环的条件来迭代ResultSet结果集。</p>
<p>getXXX方法用于获取指定的数据，可以用索引（从1开始）也可用字段的名称来获取。</p>
<p>例如第1列字段名为id，字段类型int，可以用getInt(“id”)或getInt(1)获得该列的值。</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="第一步：加载数据库驱动"><a href="#第一步：加载数据库驱动" class="headerlink" title="第一步：加载数据库驱动"></a><em>第一步：加载数据库驱动</em></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <span class="comment">//加载mysql数据库的驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);   <span class="comment">//加载Oracle数据库的驱动</span></span><br></pre></td></tr></table></figure>

<h3 id="第二步：获取数据库连接"><a href="#第二步：获取数据库连接" class="headerlink" title="第二步：获取数据库连接"></a><em>第二步：获取数据库连接</em></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(String url, String user, String pwd);</span><br></pre></td></tr></table></figure>

<p>连接数据库的url需要遵循固定写法：</p>
<p><code>jdbc:mysql://hostname:port/databasename</code></p>
<p>mysql指MySQL数据库，hostname指主机的名称（如果数据库在本机上，hostname可以为localhost或127.0.0.1。如果在其他机器上，那么hostname为所要连接机器的IP地址。port指端口号，mysql默认端口号为3306，databasename指的是mysql中相应数据库的名字。</p>
<h3 id="第三步：通过Connection对象获取Statement对象"><a href="#第三步：通过Connection对象获取Statement对象" class="headerlink" title="第三步：通过Connection对象获取Statement对象"></a><em>第三步：通过Connection对象获取Statement对象</em></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br></pre></td></tr></table></figure>

<p>也可以用PreparedStatement。</p>
<h3 id="第四步：使用Statement执行SQL语句"><a href="#第四步：使用Statement执行SQL语句" class="headerlink" title="第四步：使用Statement执行SQL语句"></a><em>第四步：使用Statement执行SQL语句</em></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execute(String sql);  用于执行任意sql语句</span><br><span class="line">executeQuery(String sql);   执行查询操作，返回一个ResultSet结果集对象</span><br><span class="line">executeUpdate(String sql);  执行insert、update、delete会返回受sql语句影响的行数，执行create、alter返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line">ResultSet rs=stmt.executeQuery(sql);</span><br></pre></td></tr></table></figure>

<h3 id="第五步：操作ResultSet结果集"><a href="#第五步：操作ResultSet结果集" class="headerlink" title="第五步：操作ResultSet结果集"></a><em>第五步：操作ResultSet结果集</em></h3><h3 id="第六步：关闭连接，释放资源"><a href="#第六步：关闭连接，释放资源" class="headerlink" title="第六步：关闭连接，释放资源"></a><em>第六步：关闭连接，释放资源</em></h3><p>顺序为：ResultSet、Statement、Connection。为了保证在异常情况下也能关闭资源，用try…catch的finally代码块统一关闭资源。</p>
<h2 id="第一个JDBC程序"><a href="#第一个JDBC程序" class="headerlink" title="第一个JDBC程序"></a>第一个JDBC程序</h2><h3 id="数据库建表"><a href="#数据库建表" class="headerlink" title="数据库建表"></a>数据库建表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create database jdbc;</span><br><span class="line">show databases;</span><br><span class="line">use jdbc;</span><br><span class="line">create table test_table(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    name varchar(40),</span><br><span class="line">    sex varchar(2),</span><br><span class="line">    birthday date</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看表结构： desc test_table;</span><br><span class="line">查看建表语句：show create table test_table;</span><br></pre></td></tr></table></figure>

<p>如果出现中文乱码的情况，是因为MySQL数据库默认使用UTF-8编码格式，而命令行窗口默认使用的是GBK编码格式，所以执行带有中文数据的插入语句会出现解析错误。需要执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set character_set_client=gbk;</span><br><span class="line">set character_set_results=gbk;</span><br></pre></td></tr></table></figure>

<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into test_table(name, sex, birthday)</span><br><span class="line">values(&#x27;jade&#x27;,&#x27;男&#x27;,&#x27;2000-1-1&#x27;),(&#x27;marry&#x27;,&#x27;女&#x27;,&#x27;1999-2-21&#x27;),(&#x27;james&#x27;,&#x27;男&#x27;,&#x27;2010-2-3&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="新建项目，导入数据库驱动"><a href="#新建项目，导入数据库驱动" class="headerlink" title="新建项目，导入数据库驱动"></a>新建项目，导入数据库驱动</h3><p>IDE下正常创建一个项目，右键新建一个文件夹，取名libs。</p>
<p>下载Mysql驱动文件：<a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/connector/j/%EF%BC%8C%E9%80%89%E6%8B%A9platform">https://dev.mysql.com/downloads/connector/j/，选择platform</a> independent，下载 <strong>ZIP Archive</strong>。直接No thanks, just start my download.  复制到libs文件夹下。</p>
<p>把jar包添加到项目里，类似eclipse的add to build path功能，file – project structure – modules – dependencies – 加号 – 第一项–添加jar包 – apply。</p>
<h3 id="编写JDBC程序"><a href="#编写JDBC程序" class="headerlink" title="编写JDBC程序"></a>编写JDBC程序</h3><p>src下新建包com.liuxuan.jdbc。创建类Test。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.parser.JSONParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: JDBCdemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: jdbc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-27 22:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.加载数据库驱动 com.mysql.jdbc.Driver 多加了cj</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2.通过DriverManager获取数据库连接</span></span><br><span class="line">            String url = <span class="string">&quot;jdbc:mysql://localhost:3306/jdbc&quot;</span>;</span><br><span class="line">            String username = <span class="string">&quot;liuxuan&quot;</span>;</span><br><span class="line">            String password = <span class="string">&quot;jade&quot;</span>;</span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">            <span class="comment">//3.通过Connection对象获取Statement对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4.使用Statement执行SQL语句</span></span><br><span class="line">            String sql = <span class="string">&quot;select * from test_table&quot;</span>;</span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="comment">//5.操作ResultSet结果集</span></span><br><span class="line">            System.out.println(<span class="string">&quot;id  |  name  |  sex  &quot;</span></span><br><span class="line">                            +<span class="string">&quot;  birthday  &quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String sex = rs.getString(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">                Date birthday = rs.getDate(<span class="string">&quot;birthday&quot;</span>);</span><br><span class="line">                System.out.println(id+<span class="string">&quot;  |  &quot;</span>+name+<span class="string">&quot;  |  &quot;</span></span><br><span class="line">                                +sex+<span class="string">&quot;  |  &quot;</span>+birthday);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//6.关闭连接，释放资源</span></span><br><span class="line">            <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;rs.close();&#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;stmt.close();&#125;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;conn.close();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/26/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BGUI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/26/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BGUI/" class="post-title-link" itemprop="url">《Java基础入门》之GUI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-26 13:47:02 / Modified: 13:48:47" itemprop="dateCreated datePublished" datetime="2021-11-26T13:47:02+08:00">2021-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GUI：Graphical User Interface 图形用户接口。用来提供给用户操作的图像界面的接口。</p>
<p>java针对GUI设计提供了一些基本的图形用户接口开发工具，如AWT、Swing、JavaFX。</p>
<p>AWT是sun公司最早推出的一套API，组件种类有限，无法实现GUI设计的全部功能。</p>
<h2 id="Swing概述"><a href="#Swing概述" class="headerlink" title="Swing概述"></a>Swing概述</h2><p>早期JDK1.0发布时，就为GUI开发提供了一套基础类库（AWT），即抽象窗口工具包。AWT需要牺牲功能来实现平台无关性。因此，Sun公司对AWT进行改进，提出Swing组件，提供更加丰富的组件和功能，来满足GUI设计的一切需求。</p>
<p>Swing是一组轻量级组件，由Java语言开发，同时底层以AWT为基础。Swing并不是AWT的替代品，而是在原有的AWT的基础上进行补充和改进。</p>
<p>Swing组件的所有类都继承自Container类，然后根据GUI开发的功能扩展了两个主要分支：容器分支（Window窗口和Panel面板）和组件分支。</p>
<p>容器分支是为了实现图形用户界面窗口容器而设计的。</p>
<p>组件分支是为了实现向容器中填充数据、元素以及人机交互组件等功能。</p>
<p>Swing组件类中常用的顶级容器类包括：JApplet、JFrame和JDialog。常用的组件类：AbstractButton类及其子类就是用来定义按钮常见行为的工具类，JTextComponent类及其子类就是用来定义文本内容编辑区域的工具类。</p>
<h2 id="JavaFX概述"><a href="#JavaFX概述" class="headerlink" title="JavaFX概述"></a>JavaFX概述</h2><p>JavaFX同Swing一样，都用于处理图形用户界面，是一个强大的图形和多媒体处理工具包集合，允许开发者设计、创建、测试、调试和部署富客户端程序，并且和Java一样具有跨平台特性。</p>
<p>Sun公司于2008年推出JavaFX，来弥补Java在桌面应用程序的缺陷。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/25/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BIO%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/25/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BIO%E6%B5%81/" class="post-title-link" itemprop="url">《Java基础入门》IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-25 19:47:16 / Modified: 19:49:27" itemprop="dateCreated datePublished" datetime="2021-11-25T19:47:16+08:00">2021-11-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="I-O流概述"><a href="#I-O流概述" class="headerlink" title="I/O流概述"></a>I/O流概述</h2><p>java中将不同输入输出设备之间的数据传输抽象表述为“流”。</p>
<p>分类1：根据操作的数据单位不同，分为字节流和字符流。</p>
<p>分类2：根据传输方向，分为输入流和输出流。输入流只能从流中读取数据，而不能写入数据；输出流只能向流中写入数据，而不能从中读取数据。</p>
<p>分类3：根据流的功能不同，分为节点流和处理流。节点流被称为低级流，指可以从一个特定的I/O设备读写数据的流，它只能直接连接数据源，进行数据的读写操作。处理流也被称为高级流，用于对一个已存在的节点流进行连接和封装，通过封装后的流来实现流的读写能力。当使用处理流时，程序不会直接连接到实际的数据源，而是连接在已存在的流之上。</p>
<p>java中的I/O流主要定义在java.io包中，该包有四个顶级类，都是抽象类，是所有流类型的父类。</p>
<p><img src="https://img-blog.csdnimg.cn/f17ecff43e2a4f498e1b845d0fe6c7f7.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>计算机中，所有文件都是二进制（字节）形式存在的。JDK提供了<code>InputStream</code>和<code>OutputStream</code>。字节输入流：从源设备经流中走向程序。字节输出流：从程序输出经流中走向目标。输入输出是相对程序而言的，输入到输出到的意思。</p>
<h3 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h3><p>针对文件的读写，有两个类：<code>FileInputStream</code>和<code>FileOutputStream</code>。</p>
<p><code>FileInputStream</code>是<code>InputStream</code>的子类，由于从文件读取数据是重复的操作，因此需要通过循环语句来实现数据的持续读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//创建一个文件字节输入流来读取文件</span></span><br><span class="line">		FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">		<span class="comment">//定义int变量</span></span><br><span class="line">		<span class="keyword">int</span> b=<span class="number">0</span>; </span><br><span class="line">		<span class="comment">//通过循环读取文件，当返回值为-1结束循环</span></span><br><span class="line">		<span class="keyword">while</span>((b=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.println(b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如内容为hello，字符占一个字节，因此显示的是这五个字节所对应的ASCII码值。</p>
<p><code>FileOutputStream</code>负责将数据写入文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//创建一个文件字节输出流来写文件</span></span><br><span class="line">		FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">		<span class="comment">//定义一个字符串</span></span><br><span class="line">		String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">		<span class="comment">//将字符串转换为字节数组进行写入操作</span></span><br><span class="line">		out.write(str.getBytes());</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若文件已存在，则会首先将文件中内容擦空，再写入。</p>
<p>若想追加内容：<code>FileOutputStream out = new FileOutputStream(&quot;out.txt&quot;, true);</code></p>
<p>I/O流在进行数据读写时，会出现异常，上述代码使用throws将异常抛出。但是一旦遇到I/O异常，close方法无法执行，流对象所占用的系统资源将不能释放。因此通常将关闭流的操作写在finally代码块中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(in!=<span class="keyword">null</span>)  in.close();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(out!=<span class="keyword">null</span>)  out.close();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a>文件的拷贝</h3><p>通过输入流来读取文件中的数据，并通过输出流将数据写入新文件。</p>
<p>定义一次输出流创建一个文件，定义之后多次写入，都是追加的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;source/src.jpg&quot;</span>)</span><br><span class="line">		FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;target/src.jpg&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>((b=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			out.write(b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间为：&quot;</span>+(endTime-beginTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节流的缓冲区"><a href="#字节流的缓冲区" class="headerlink" title="字节流的缓冲区"></a>字节流的缓冲区</h3><p>一个字节一个字节地拷贝，需要频繁操作文件，因此构建一个字节数组作为临时缓冲区。可以一次性读写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;source/src.jpg&quot;</span>);</span><br><span class="line">		FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;target/src.jpg&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>((len=in.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//通过变量len记住读入数组的字节数，len表示读取字节的数目</span></span><br><span class="line">			out.write(buffer, <span class="number">0</span>, len); <span class="comment">//从buffer的0位置开始写入len个字节</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间为：&quot;</span>+(endTime-beginTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>read方法内无东西时，表示从输入流读取一个8位的字节，把它转换为0-255的整数，并返回这个整数，当没有可用字节时，将返回-1。</p>
<p>read方法内是byte数组时，表示读取若干字节，并将其保存到指定的字节数组中，返回整数表示读取的字节的数目。</p>
<p>write方法内，一个int表示写入一个字节，一个字节数组表示写入字节数组中的所有字节，也可以写入指定数目字节。</p>
<p>输出流的flush()方法表示将输出缓冲区（通常是字节数组）中的数据强制写入目标设备，此过程称为刷新。</p>
</blockquote>
<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>I/O包中提供了两个带缓冲的字节流，分别为<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>，它们的构造方法中分别接收<code>InputStream</code>和<code>OutputStream</code>类型的参数作为对象。再读写数据时提供缓冲功能。</p>
<p>其实就像是上一节的系统实现。</p>
<p>关系：源设备—字节流—字节缓冲流—应用程序—字节缓冲流—字节流—目标设备</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;source/src.jpg&quot;</span>));</span><br><span class="line">		BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;target/src.jpg&quot;</span>));</span><br><span class="line">		<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>((len=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			out.write(len)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间为：&quot;</span>+(endTime-beginTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓冲流对象内部都定义了一个大小为8192的字节数组。读写都是到一个字节数组中，充当缓冲。</p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>Reader是字符输入流，用于从某个源设备读取字符。Writer是字符输出流。用于向某个目标设备写入字符。</p>
<p>输入输出是相对程序而言的，输入到输出到的意思。读和写是读到程序和从程序中写出的意思。</p>
<h3 id="字符流操作文件"><a href="#字符流操作文件" class="headerlink" title="字符流操作文件"></a>字符流操作文件</h3><p>从文件读取字符用字符输入流FileReader。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;reader.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((b=fileReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.print((<span class="keyword">char</span>)b)</span><br><span class="line">		&#125;</span><br><span class="line">		fileReader.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read返回的是int类型，因此要获得字符需要强制类型转换。</p>
<p>向文件中写入字符用FileWriter类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		FileWriter fileWriter = <span class="keyword">new</span> FileWriter(<span class="string">&quot;writer.txt&quot;</span>);</span><br><span class="line">		fileWriter.write(<span class="string">&quot;你好,\r\n&quot;</span>);</span><br><span class="line">		fileWriter.write(<span class="string">&quot;世界。\r\n&quot;</span>);</span><br><span class="line">		fileWriterr.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入文件，如果文件已存在则先清空，项追加的话，则构造时后面加true。</p>
<p>与字节流类似，这里也可以加字符流缓冲区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>[] buff=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((len=fileReader.read(buff))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	fileWriter.write(buff, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>字符流也提供了带缓冲区的字符缓冲流，<code>BufferedReader</code>和<code>BufferedWriter</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	    <span class="comment">//创建字符输入缓冲流对象</span></span><br><span class="line">	    BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;read.txt&quot;</span>));</span><br><span class="line">	    <span class="comment">//创建字符输出缓冲流对象</span></span><br><span class="line">	    BufferedWriter out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;write.txt&quot;</span>));</span><br><span class="line">	    String str = <span class="keyword">null</span>;</span><br><span class="line">	    <span class="keyword">while</span>((str=in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	    	out.write(str);</span><br><span class="line">	    	out.newLine();</span><br><span class="line">	    &#125;</span><br><span class="line">	    in.close();</span><br><span class="line">	    out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BufferedReader</code>的readLine()方法，用于一次读取一行文本。</p>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>JDK中提供了两个类实现字节流转换为字符流。</p>
<p>字节输入流转变为字符输入流：<code>InputStreamReader</code></p>
<p>字节输出流转变为字符输出流：<code>OutputStreamWriter</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建字节输入流，获取源文件</span></span><br><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line"><span class="comment">//将字节输入流对象转换为字符输入流对象</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line"><span class="comment">//创建字符输入缓冲流对象</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建字节输出流，指定目标文件</span></span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;write.txt&quot;</span>);</span><br><span class="line"><span class="comment">//将字节输出流对象转换为字符输出流对象</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamReader(out);</span><br><span class="line"><span class="comment">//创建字符输出缓冲流对象</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问，不明白意义何在，文件时字节码文件，程序侧用字符流有何益处。</p>
</blockquote>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>通过I/O流可以对文件的内容进行读写操作，但是对文件本身进行一些常规操作，例如创建、删除、重命名等，JDK提供了一个File类。</p>
<p>File类用于封装一个路径，可以是绝对路径，也可以是相对路径。该类主要用于文件和目录的创建、文件的查找和文件的删除等。</p>
<p>File对象代表磁盘中实际存在的文件和目录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String dirname = <span class="string">&quot;/java&quot;</span>;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(dirname);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/文件夹名称：&quot;</span>+f1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/文件夹大小：&quot;</span>+f1.length()+<span class="string">&quot;bytes&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (f1.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Directory of &quot;</span> + dirname);</span><br><span class="line">            String s[] = f1.list();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">                File f = <span class="keyword">new</span> File(dirname + <span class="string">&quot;/&quot;</span> + s[i]);</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; is a directory&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; is a file&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(dirname + <span class="string">&quot; is not a directory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;是否成功删除：&quot;</span>+f1.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历某个目录下的所有文件，用list方法，除了上面的方法外，还可以采用数组工具类Arrays的stream方法进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">String[] fileNames = file.list();</span><br><span class="line">Arrays.stream(fileNames).forEach(f-&gt;System.out.println(f));</span><br></pre></td></tr></table></figure>

<p>若是想要获得指定类型的文件，例如.txt文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向list传入lambda表达式形式的参数，进行过滤。</span></span><br><span class="line">String[] fileNames=file.list((dir,name)-&gt;name.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br><span class="line">Arrays.stream(fileNames).forEach(f-&gt;System.out.println(f));</span><br></pre></td></tr></table></figure>

<p>若是要遍历所有文件及目录，包括子目录下的文件。使用listFiles方法返回的是一个File对象数组。进行递归。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;路径&quot;</span>);</span><br><span class="line">        func(file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历目录及其子目录方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        File[] listFiles=file.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File files:listFiles)&#123;</span><br><span class="line">            <span class="keyword">if</span>(files.isDirectory())&#123;</span><br><span class="line">                func(files);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：java中的删除文件是通过java虚拟机直接删除的，而不走回收站。</p>
</blockquote>
<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>不属于流类，但具有读写文件数据的功能，可以随机从文件的任何位置开始执行读写数据的操作。</p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>程序在运行过程中，需要将一些数据永久地保存到磁盘上，而数据在java中都是保存在对象当中的，如何将对象中的数据保存到磁盘上，就用java中的对象序列化。</p>
<p>对象的序列化（Serializable）是指将一个Java对象转换为一个I/O流中字节序列的过程。可以使内存中的Java对象转换成与平台无关的二进制流。</p>
<p>将I/O流中的字节序列恢复为Java对象的过程–反序列化。</p>
<p>整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
<p>想让对象序列化，那么这个对象所在的类必须是可序列化的，必须实现Serializable或Externalizable两个接口之一。Externalizable性能好但是编程复杂，因此大部分采用Serializable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">      e.name = <span class="string">&quot;Reyan Ali&quot;</span>;</span><br><span class="line">      e.address = <span class="string">&quot;Phokka Kuan, Ambehta Peer&quot;</span>;</span><br><span class="line">      e.SSN = <span class="number">11122333</span>;</span><br><span class="line">      e.number = <span class="number">101</span>;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         FileOutputStream fileOut =</span><br><span class="line">         <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/tmp/employee.ser&quot;</span>);</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">         out.writeObject(e);</span><br><span class="line">         out.close();</span><br><span class="line">         fileOut.close();</span><br><span class="line">         System.out.printf(<span class="string">&quot;Serialized data is saved in /tmp/employee.ser&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">      &#123;</span><br><span class="line">          i.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      Employee e = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/employee.ser&quot;</span>);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">         e = (Employee) in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line">         fileIn.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">      &#123;</span><br><span class="line">         i.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ClassNotFoundException c)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">         c.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Deserialized Employee...&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);</span><br><span class="line">      System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address);</span><br><span class="line">      System.out.println(<span class="string">&quot;SSN: &quot;</span> + e.SSN);</span><br><span class="line">      System.out.println(<span class="string">&quot;Number: &quot;</span> + e.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。</p>
<p>注意，readObject() 方法的返回值被转化成 Employee 引用。</p>
<p>当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>从JDK1.4开始，java提供了一系列改进的用于处理输入输出的新功能，被称为NIO（New I/O）。</p>
<p>NIO采用内存映射文件的方式来处理输入输出，将文件或文件的一段区域映射到内存中，像访问内存一样来访问文件。</p>
<p>标准的IO中使用字节流和字符流，NIO中，使用通道Channel和缓冲区Buffer。数据总是从通道读入缓冲区，或从缓冲区写入通道。</p>
<p>Buffer可以看成是一个容器，本质是一个数组缓冲区，读入或写出到Channel中的所有对象都先放在Buffer中。</p>
<p>Channel是对传统的输入输出的模拟，所有的数据都通过通道流的形式传输。</p>
<p>Selector选择器，用于监听多个通道的事件（例如连接打开、数据到达）主要用于多线程处理。</p>
<h2 id="NIO-2"><a href="#NIO-2" class="headerlink" title="NIO.2"></a>NIO.2</h2><p>JDK7引入新的I/O API，提供全面的文件输入输出以及文件系统的访问与支持，并且新增java.nio.file包及其子包，提供基于异步Channel的输入输出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/17/myblog/JAVA/%E3%80%8AJava%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E3%80%8B%E7%B1%BB%E4%B8%8E%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/17/myblog/JAVA/%E3%80%8AJava%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E3%80%8B%E7%B1%BB%E4%B8%8E%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">《Java基础入门》类与集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-17 14:07:57 / Modified: 21:04:38" itemprop="dateCreated datePublished" datetime="2021-11-17T14:07:57+08:00">2021-11-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="java中的常用类"><a href="#java中的常用类" class="headerlink" title="java中的常用类"></a>java中的常用类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String类的几种初始化方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>使用字符串常量直接初始化一个String对象</span><br><span class="line">String ss = <span class="keyword">null</span>;  初始化为空</span><br><span class="line">String ss = “”;  初始化为空字符串</span><br><span class="line">String ss = “abc”;  初始化为abc</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>使用String的构造方法初始化字符串对象</span><br><span class="line">String ss = <span class="keyword">new</span> String();  初始化为空字符串</span><br><span class="line">String ss = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);  初始化为abc</span><br><span class="line"><span class="comment">//根据指定字符数组创建字符串</span></span><br><span class="line"><span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String ss = <span class="keyword">new</span> String(ch);</span><br></pre></td></tr></table></figure>

<p>String类基本操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;abcdefghigk&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;字符串长度：&quot;</span>+s.length());</span><br><span class="line"><span class="comment">//字符串是.length()，数组是.length</span></span><br><span class="line">System.out.println(<span class="string">&quot;字符串第i个字符：&quot;</span>+s.charAt(i));</span><br><span class="line">System.out.println(<span class="string">&quot;字符c第一次出现的位置：&quot;</span>+s.indexOf(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;字符c最后一次出现的位置：&quot;</span>+s.lastIndexOf(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;子字符串第一次出现的位置：&quot;</span>+s.indexOf(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;子字符串最后一次出现的位置：&quot;</span>+s.lastIndexOf(<span class="string">&quot;ab&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>字符串的转换操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="comment">//字符串转换为字符数组：</span></span><br><span class="line"><span class="keyword">char</span>[] ch=s.toCharArray();</span><br><span class="line">System.out.println(<span class="string">&quot;int值转换为string类型：&quot;</span>+String.valueOf(<span class="number">100</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;字符串转换为大写：&quot;</span>+s.toUpperCase());</span><br></pre></td></tr></table></figure>

<p>字符串的替换和去除空格操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;  a b &quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;去除字符串两端空格后的结果：&quot;</span>+s.trim());</span><br><span class="line"><span class="comment">//用字符串替换操作完成去除空格</span></span><br><span class="line">System.out.println(<span class="string">&quot;去除字符串所有空格后的结果：&quot;</span>+s.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>replace()方法是可以替换子字符串的。</p>
<p>字符串的判断操作：返回boolean类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;Starter&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否以字符串St开头：&quot;</span>+s.startWith(<span class="string">&quot;St&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否以字符串er结尾：&quot;</span>+s.endWith(<span class="string">&quot;er&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否包含ar：&quot;</span>+s.contains(<span class="string">&quot;ar&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否为空：&quot;</span>+s.isEmpty());</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否相等：&quot;</span>+s.equals(<span class="string">&quot;St&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="和equals"><a href="#和equals" class="headerlink" title="==和equals()"></a>==和equals()</h4><p> ==对于基本类型和引用类型 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同</li>
<li>引用类型：比较的是引用（对象的内存地址）是否相同，string是引用类型。</li>
</ul>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，<strong>把它变成了值比较。</strong></p>
<p>在String类中，重写了父类Object中的equals()方法。把它变成了<strong>值比较</strong>。</p>
<p>==和equals()方法不同，equals方法用来比较两个字符串中的字符值是否相等，==方法用于比较两个字符串对象的内存地址是否相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String y = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">x==y  (<span class="keyword">true</span>)  x.equals(y)  (<span class="keyword">true</span>)</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">String m = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">z==m  (<span class="keyword">false</span>)  z.equals(m)  (<span class="keyword">true</span>)</span><br><span class="line">x==z  (<span class="keyword">false</span>)  x.equals(z)  (<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>字符串的截取与分割：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;2021-11-11&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;截取：&quot;</span>+s.substring(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//结果为11-24  左闭右开原则，从下标5开始截取</span></span><br><span class="line">System.out.println(<span class="string">&quot;截取：&quot;</span>+s.substring(<span class="number">5</span>,<span class="number">7</span>));</span><br><span class="line"><span class="comment">//结果为11</span></span><br><span class="line">String[] sArray=s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="comment">//将字符串按照某个字符进行分割，变为字符串数组</span></span><br></pre></td></tr></table></figure>

<p>java中，String类是final类型的，所以使用String类定义的字符串是一个常量，它一旦创建，内容和长度不可改变。</p>
<h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>类似一个字符容器，在其中添加和删除字符时，操作的都是这个字符容器，不会产生新的StringBuffer对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(<span class="string">&quot;abc&quot;</span>);   <span class="comment">//添加字符串，始终是添加到缓冲区的末尾</span></span><br><span class="line">sb.insert(<span class="number">3</span>,<span class="string">&quot;de&quot;</span>);   <span class="comment">//在3的前面插入，变为abcde</span></span><br><span class="line">sb.setCharAt(<span class="number">2</span>,<span class="string">&#x27;f&#x27;</span>);  <span class="comment">//修改指定位置字符，变为abfde</span></span><br><span class="line">sb.replace(<span class="number">3</span>,<span class="number">5</span>,<span class="string">&quot;gh&quot;</span>);  <span class="comment">//左闭右开替换指定位置字符串或字符</span></span><br><span class="line">System.out.println(sb.reverse());   <span class="comment">//字符串翻转结果</span></span><br><span class="line">sb.delete(<span class="number">3</span>,<span class="number">7</span>);   <span class="comment">//左闭右开删除</span></span><br><span class="line">sb.deleteCharAt(<span class="number">2</span>);   <span class="comment">//删除指定位置字符</span></span><br><span class="line">sb.delete(<span class="number">0</span>,sb.length());   <span class="comment">//清空缓冲区</span></span><br></pre></td></tr></table></figure>

<h3 id="String和StringBuffer区别"><a href="#String和StringBuffer区别" class="headerlink" title="String和StringBuffer区别"></a>String和StringBuffer区别</h3><p>（1）String类定义的字符串是常量，一旦创建后，内容和长度都是无法改变的。StringBuffer类表示字符容器，其内容和长度可以随时修改。</p>
<p>（2）String类重写了Object类的equals()方法，而StringBuffer类没有重写Object类的equals方法，依然表示内存地址相同？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String s2=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2));   <span class="comment">//结果为true</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb1=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">StringBuffer sb2=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(sb1.equals(sb2));   <span class="comment">//结果为false</span></span><br></pre></td></tr></table></figure>

<p>（3）String类对象可以用操作符+进行连接，而StringBuffer类对象之间不能。</p>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>除了使用StringBuffer外，JDK1.5之后提供了StringBuilder类，同样可以操作字符串。</p>
<p>不同之处在于，StringBuffer是线程安全的，而StringBuilder没有实现线程安全功能，所以性能略高。因此，一般创建一个内容可变的字符串对象，应该优先考虑StringBuilder类。</p>
<p>StringBuilder类的方法和StringBuffer类一样。</p>
<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>System类定义了一些与系统相关的属性和方法，它所提供的属性和方法都是静态的，可以直接使用System类进行调用（不用创建对象进行调用）。</p>
<h4 id="getProperties-方法"><a href="#getProperties-方法" class="headerlink" title="getProperties()方法"></a>getProperties()方法</h4><p>用于获取当前系统的全部属性，该方法返回一个Properties对象，其中封装了系统的所有属性，这些属性以键值对的形式存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemPropertiesDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//获取系统所有属性</span></span><br><span class="line">		Properties pro = System.getProperties();</span><br><span class="line">		<span class="comment">//获取所有系统属性的key，返回set对象</span></span><br><span class="line">        Set&lt;String&gt;proName=pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span>(String key:proName)&#123;</span><br><span class="line">            <span class="comment">//获取key（属性名）对应的属性值</span></span><br><span class="line">            String value=System.getProperty(key);</span><br><span class="line">            System.out.println(key+<span class="string">&quot;-&gt;&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h4><p>currentTimeMillis()方法返回一个long类型的值，表示当前时间与1970年1月1日0点0分0秒之间的时间差，单位毫秒。</p>
<h4 id="arraycopy-方法"><a href="#arraycopy-方法" class="headerlink" title="arraycopy()方法"></a>arraycopy()方法</h4><p>用于将一个数组中的元素快速拷贝到另一个数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=&#123;<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>,<span class="number">104</span>,<span class="number">105</span>,<span class="number">106</span>&#125;;  <span class="comment">//源数组</span></span><br><span class="line"><span class="keyword">int</span>[] b=&#123;<span class="number">201</span>,<span class="number">202</span>,<span class="number">203</span>,<span class="number">204</span>,<span class="number">205</span>&#125;;   <span class="comment">//目标数组</span></span><br><span class="line">System.arraycopy(a,<span class="number">2</span>,b,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//最终b变为103，104，105，106，205</span></span><br></pre></td></tr></table></figure>

<p>以上例子中，从a数组索引为2的元素开始拷贝，并且拷贝4个元素存放在目标数组中索引为0的位置。</p>
<p>注意：进行数组拷贝时，一定要保证源数组类型和目标数组类型一致，截取的长度不能超过源数组界限，也不能超过目标数组可以容纳的个数。</p>
<h4 id="gc-方法和exit-int-status-方法"><a href="#gc-方法和exit-int-status-方法" class="headerlink" title="gc()方法和exit(int status)方法"></a>gc()方法和exit(int status)方法</h4><p>gc()方法用于启动java的垃圾回收器，并对内存中的垃圾对象进行回收。</p>
<p>exit(int status)用于终止当前正在运行的java虚拟机，参数表示当前发生的异常状态，一般指定0，表示正常退出，否则表示异常终止。</p>
<h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p>Runtime类用于表示Java虚拟机运行时的状态，用于封装Java虚拟机进程，因此可以通过该类的实例对象来获取当前虚拟机的相关信息。</p>
<p>每次使用java命令启动java虚拟机时都会对应一个Runtime实例，并且只有一个实例，应用程序会通过该实例与其运行时的环境相连。应用程序不能创建自己的Runtime实例，若想在程序中获得一个Runtime实例，可以通过getRuntime()方法获取与之相关的Runtime对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime(); <span class="comment">//获取java程序关联的运行时对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;处理器个数：&quot;</span>+rt.availableProcessors()); <span class="comment">//单位个</span></span><br><span class="line">System.out.println(<span class="string">&quot;空闲内存大小：&quot;</span>+rt.freeMemory()); <span class="comment">//单位字节</span></span><br><span class="line">System.out.println(<span class="string">&quot;最大可用内存大小：&quot;</span>+rt.maxMemory()); <span class="comment">//单位字节</span></span><br></pre></td></tr></table></figure>

<h4 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec()方法"></a>exec()方法</h4><p>该方法用于执行一个DOS命令，实现和在终端中输入DOS命令同样的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime();</span><br><span class="line">rt.exec(<span class="string">&quot;notepad.exe&quot;</span>)   <span class="comment">//打开记事本</span></span><br></pre></td></tr></table></figure>

<p>exec()方法返回一个Process对象，该对象表示操作系统的一个进程，通过Process对象可对产生的新进程进行管理，如关闭destroy()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime();</span><br><span class="line">Process pr = rt.exec(<span class="string">&quot;notepad.exe&quot;</span>)   <span class="comment">//打开记事本</span></span><br><span class="line"><span class="comment">//程序休眠3s</span></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">pr.destroy();   <span class="comment">//关闭进程</span></span><br></pre></td></tr></table></figure>

<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>Math类是一个工具类，主要用于完成复杂的数学运算，如求绝对值，三角函数，指数运算等。其构造方法被定义为private，因此无法创建Math类的对象。</p>
<p>Math类的多有方法都是静态方法，可以直接通过类名来调用它们。</p>
<p>除静态方法外，Math类中还有两个静态常量PI和E，分别表示Π和e。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(-1);</span><br><span class="line">Math.sin/tan/cos(2.0);</span><br><span class="line">Math.sqrt(4);  //求平方根</span><br><span class="line">Math.cbrt(9);  //求立方根</span><br><span class="line">Math.pow(2,2);  //幂次运算</span><br><span class="line">Math.ceil(1.2);  //大于参数的最小整数，返回double类型的数</span><br><span class="line">Math.floor(1.2);  //小于参数的最大整数，返回double类型的数</span><br><span class="line">Math.round(1.2);  //四舍五入的整数，返回int类型的数</span><br><span class="line">Math.max(1,2);</span><br><span class="line">Math.min(1,2);</span><br><span class="line">Math.random();   //生成一个大于等于0.0小于1.0的随机值</span><br></pre></td></tr></table></figure>

<h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><p>在JDK的java.util包中，有一个Random类，可以在指定的取值范围内随机产生数字。</p>
<p>Random类有两个构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random()   无参构造，通过它创建的Random实例对象每次使用的种子随机，因此每个对象所产生的随机数不同。</span><br><span class="line">Random(<span class="keyword">long</span> seed)  有参构造，使用种子创建伪随机数生成器，当seed相同时，每次实例化Random对象会生成相同的随机数</span><br></pre></td></tr></table></figure>

<p>Random类的各种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">r.nextBoolean()    随机的<span class="keyword">boolean</span></span><br><span class="line">r.nextDouble()   <span class="keyword">double</span>类型的随机数</span><br><span class="line">r.nextFloat()  <span class="keyword">float</span>类型的随机数</span><br><span class="line">r.nextInt()   <span class="keyword">int</span>类型的随机数</span><br><span class="line">r.nextInt(<span class="number">10</span>)  <span class="number">0</span>到<span class="number">10</span>之间<span class="keyword">int</span>类型的随机数</span><br><span class="line">r.nextLong()   <span class="keyword">long</span>型随机数</span><br></pre></td></tr></table></figure>

<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>虽然Java是面向对象的编程语言，但它所包含的8种基本数据类型却不支持面向对象的编程机制（没有属性和方法）。Java之所以提供这8种基本数据类型，是为了方便常规数据的处理。但是在Java种，很多类的方法都需要接收引用类型的对象，此时就无法将一个基本数据类型的值传入。</p>
<p>为了解决这一问题，JDK提供了一系列的包装类，通过包装类可以将基本数据类型的值包装为引用数据类型的对象。</p>
<table>
<thead>
<tr>
<th align="center">byte</th>
<th align="center">Byte</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<p>包装类和基本数据类型在转换时，引入了自动装箱和自动拆箱</p>
<p>装箱：将基本数据类型的变量赋给对应的包装类变量（对象）。</p>
<p><code>int a=20;    Integer b=a;</code></p>
<p>拆箱：将包装类对象类型直接赋给一个对应的基本数据类型变量。</p>
<p><code>int c=b</code></p>
<p>此外，Java还提供了其他方法来支持基本数据类型、基本数据包装类以及字符串之间的相互转换。</p>
<p>（1）String类的valueOf()方法，将八种基本数据类型转化为字符串类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num=123;</span><br><span class="line">String s=String.valueOf(num);</span><br></pre></td></tr></table></figure>

<p>（2）包装类的valueOf()方法，既可以实现装箱，也可以实现将内容匹配的字符串转换为对应的包装类（除Character包装类）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num=123;</span><br><span class="line">Integer in=Integer.valueOf(num);</span><br><span class="line">String s=&quot;123&quot;;</span><br><span class="line">Integer in2=Integer.valueOf(s);</span><br></pre></td></tr></table></figure>

<p>（3）通过包装类的有参构造方法将基本数据类型转换为包装类（装箱），也可以将字符串转换为包装类（除Character包装类）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num=123;</span><br><span class="line">Integer in=new Integer(num);</span><br><span class="line">String s=&quot;123&quot;;</span><br><span class="line">Integer in2=new Integer(s);</span><br></pre></td></tr></table></figure>

<p>（4）通过包装类的静态方法parseXxx()方法将字符串转换为对应的基本数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s=&quot;123&quot;;</span><br><span class="line">int num=Integer.parseInt(s);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>凡是类名.方法名的，都是静态static方法</p>
</blockquote>
<p>（5）包装类都重写了Object类中的toString方法，将包装类转换为字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer in=new Integer(123);</span><br><span class="line">//Integer in=Integer.valueOf(123);</span><br><span class="line">String s=in.toString();</span><br></pre></td></tr></table></figure>

<p>注意：包装类的<code>valueOf(String s)</code>和<code>parseInt(String s)</code> 中，参数s不能为null，而且需要和解析对应。</p>
<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>JDK中的java.util包中，提供了一个Date类用来表示日期和时间，该类在JDK1.0时已经开始使用。JDK8中有两个构造方法可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date()  <span class="comment">//用来创建当前日期时间的Date对象。</span></span><br><span class="line">Date date1=<span class="keyword">new</span> Date();  <span class="comment">//Sat Jan 11:09:21 CST 2021</span></span><br><span class="line">Date(<span class="keyword">long</span> date)  <span class="comment">//用于创建指定时间的Date对象，date是1970.1.1.0.0.0以来的毫秒数，即时间戳</span></span><br><span class="line">Date date2=<span class="keyword">new</span> Date(System.currentTimeMillis()+<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//Sat Jan 11:09:22 CST 2021</span></span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>Calendar类用于完成日期和时间字段的操作，可以通过特定方法设置和读取日期的特定部分。</p>
<p>Calendar类是一个抽象类，不可以被实例化，在程序中需要调用静态方法getInstance()来得到一个Calendar对象，然后才能调用其相应的方法。</p>
<blockquote>
<p>疑问？抽象类创建对象，这是什么操作？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Calendar ca = Calendar.getInstance();</span><br><span class="line"><span class="keyword">int</span> year=ca.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> month=ca.get(Calendar.MONTH)+<span class="number">1</span>;  <span class="comment">//注意月份0-11，需要加1</span></span><br><span class="line"><span class="keyword">int</span> date=ca.get(Calendar.DATE);</span><br><span class="line"><span class="keyword">int</span> hour=ca.get(Calendar.HOUR);</span><br><span class="line"><span class="keyword">int</span> minute=ca.get(Calendar.MINUTE);</span><br><span class="line"><span class="keyword">int</span> second=ca.get(Calendar.SECOND);</span><br></pre></td></tr></table></figure>

<p>添加和修改时间的功能可以通过add和set方法实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calendar ca = Calendar.getInstance();</span><br><span class="line">ca.set(2021.11.11);   //设置指定日期</span><br><span class="line">ca.add(Calendar.DATE,100);  //为指定日期增加时间</span><br><span class="line">输出时间依然需要用get方法来获取年月日。</span><br></pre></td></tr></table></figure>

<p>Calendar有两种解释日历字段的模式，容错模式和非容错模式，容错模式下，月是12是可以接受的。默认容错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar ca = Calendar.getInstance();</span><br><span class="line">ca.set(Calendar.MONTH, 13);  //不会报错</span><br><span class="line">//开启non-lenient非容错模式</span><br><span class="line">ca.setLenient(false);</span><br><span class="line">ca.set(Calendar.MONTH, 13);  //会报错</span><br></pre></td></tr></table></figure>

<p>Date和Calendar对象之间的转化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ca.getTime());  //Calendar的getTime方法返回一个表示Calendar时间值的Date对象。</span><br><span class="line">setTime(Date date)</span><br><span class="line">Calendar ca = setTime(date);  //Calendar的setTime方法接收一个Date对象，将Date对象表示的时间值设置给Calendar对象。</span><br></pre></td></tr></table></figure>

<h3 id="JDK8的日期和时间类"><a href="#JDK8的日期和时间类" class="headerlink" title="JDK8的日期和时间类"></a>JDK8的日期和时间类</h3><p>为了满足更多的需求，JDK8比之前的版本增加了一个java.time包，在该包下包含了更多日期和时间操作类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、Clock类</span><br><span class="line">Clock cl = Clock.systemUTC();</span><br><span class="line">获取UTC时区转换的当前时间： cl.instance()</span><br><span class="line">获取UTC时区转换的毫秒数： cl.millis()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>Duration类</span><br><span class="line">Duration du = Duration.ofDays(<span class="number">1</span>);</span><br><span class="line">一天等于多少小时：  du.toHours()</span><br><span class="line">一天等于多少分钟：  du.toMinutes()</span><br><span class="line">一天等于多少秒：  du.toMillis()</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>Instant类</span><br><span class="line">Instant in = Instant.now();</span><br><span class="line">UTC时区的当前时间：in</span><br><span class="line">当前时间一小时后的时间：in.plusSeconds(<span class="number">3600</span>)</span><br><span class="line">当前时间一小时前的时间：in.minusSeconds(<span class="number">3600</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>LocalDate</span><br><span class="line">LocalDate lo = LocalDate.now();</span><br><span class="line">从默认时区的系统时钟获得当前日期：lo</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>LocalTime</span><br><span class="line">LocalDate lo = LocalDate.now();</span><br><span class="line">从默认时区的系统时钟获得当前时间：lo</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span>LocalDateTime</span><br><span class="line">LocalDateTime lo = LocalDateTime.now();</span><br><span class="line">从默认时区的系统时钟获得当前日期和时间：lo</span><br><span class="line">当前的日期和时间加上<span class="number">1</span>天<span class="number">3</span>小时<span class="number">30</span>分钟：</span><br><span class="line">LocalDateTime time = LocalDateTime.plusDays(<span class="number">1</span>).plusHours(<span class="number">3</span>).plusMinutes(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>Year、YearMonth、MonthDay</span><br><span class="line">当前年份：Year ye = Year.now();</span><br><span class="line">当前年月：YearMonth ym = YearMonth.now();</span><br><span class="line">当前月日：MonthDay md = MonthDay.now();</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>获取系统默认时区</span><br><span class="line">ZoneId zi = ZoneId.systemDefault();</span><br></pre></td></tr></table></figure>

<p>注意，clock.instant()和Instant.now()获取的时间都是默认使用UTC时区（世界协调时间，世界标准时间），比中国标准时间CST早八小时。</p>
<h3 id="格式化类"><a href="#格式化类" class="headerlink" title="格式化类"></a>格式化类</h3><h4 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h4><p>使用Date类时，程序打印Date对象所输出的当前时间都是英文格式输出的，要想以中文的格式输出，就需要DateFormat类。</p>
<p>DateFormat类专门用于将日期格式化为字符串或者将用特定格式显示的日期字符串转换为一个Date对象。</p>
<p>DateFormat类是一个抽象类，不能被直接实例化，但它提供了一系列的静态方法来获取DateFormat类的实例对象，并能调用其他相应的方法进行操作。</p>
<p>定义了四种静态方法用于获取DateFormat类的实例对象，它们分别对日期或者时间部分进行格式化。</p>
<blockquote>
<p>疑问。</p>
</blockquote>
<p>在DateFormat类中还定义了许多常量，其中四个常量值是用于作为参数传递给方法的，包括FULL、LONG、MEDIUM、SHORT。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Date对象</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">//1.当前日期的完整格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">DateFormat fullFormat = DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(fullFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.当前日期的长格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">DateFormat longFormat = DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(longFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.当前日期时间的普通格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">DateFormat mediumFormat = DateFormat.getDateTimeInstance(DateFormat.MEDIUM);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(mediumFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.当前日期时间的短格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">DateFormat shortFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(shortFormat.format(date));</span><br></pre></td></tr></table></figure>

<p>DateFormat类中还有parse(String source)方法，能够将一个字符串解析为Date对象，但是它要求字符串必须符合日期/时间的格式要求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建普通格式的DateFormat对象</span></span><br><span class="line">DateFormat dt1 = DateFormat.getDateInstance();</span><br><span class="line"><span class="comment">//创建Long格式的DateFormat对象</span></span><br><span class="line">DateFormat dt2 = DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义日期格式的字符串</span></span><br><span class="line">String s1 = <span class="string">&quot;2021-11-11&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;2021年11月11日&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出对应格式的字符串解析为Date对象后的结果</span></span><br><span class="line">System.out.println(dt1.parse(s1));</span><br><span class="line">System.out.println(dt2.parse(s2));</span><br></pre></td></tr></table></figure>

<h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><p>DateFormat类中parse方法将字符串解析为日期时，需要固定格式，不灵活。</p>
<p>SimpleDateFormat类是DateFormat类的子类，可以使用new关键字创建实例对象。在创建实例对象时，构造方法需要接收一个表示日期格式模板的字符串参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;Gyyyy年MM月dd日：今年时yyyy年的第D天，星期：E&quot;</span>);    <span class="comment">//创建对象</span></span><br><span class="line"><span class="comment">//按SimpleDateFormat对象的日期模板格式化Date对象</span></span><br><span class="line">System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br></pre></td></tr></table></figure>

<p>上面是将一个Date时间对象转换为指定格式字符串形式。</p>
<p>SimpleDateFormat类也可以将一个指定格式字符串解析为Date对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd&quot;</span>);    <span class="comment">//创建对象,并指定日期格式</span></span><br><span class="line">String s = <span class="string">&quot;2021/11/11&quot;</span>;</span><br><span class="line"><span class="comment">//将字符串解析为Date对象</span></span><br><span class="line">System.out.println(sdf.parse(s));</span><br></pre></td></tr></table></figure>

<h4 id="DateTimeFormatter类"><a href="#DateTimeFormatter类" class="headerlink" title="DateTimeFormatter类"></a>DateTimeFormatter类</h4><p>除DateFormat类以及SimpleDateFormat类，JDK8在java.time.format包下还提供了一个DateTimeFormatter类，该类也是格式化类，相当于DateFormat类以及SimpleDateFormat类的合体，它不仅可以将日期时间类型转换为字符串，还可以将字符串解析成日期、时间对象。</p>
<p>1.字符串转换成日期时间类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStringT0LocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// String --&gt; LocalDate</span></span><br><span class="line">        <span class="comment">//使用模式字符串创建DateTimeFormatter格式器</span></span><br><span class="line">        LocalDate localDate = LocalDate.parse(<span class="string">&quot;2019-12-07&quot;</span>);</span><br><span class="line">　　　　　DateTimeFormatter pattern = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);		　　　　　　    </span><br><span class="line">　　　　　System.out.println(LocalDate.parse(<span class="string">&quot;2019-10-09&quot;</span>).format(pattern));</span><br><span class="line">　　　　　</span><br><span class="line">        <span class="comment">// String --&gt; LocalTime</span></span><br><span class="line">        LocalTime localTime = LocalTime.parse(<span class="string">&quot;07:43:53&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String --&gt;LocalDateTime</span></span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>); <span class="comment">// 12小时</span></span><br><span class="line">　　　　 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); <span class="comment">// 24小时              LocalDate localDate = LocalDate.parse(&quot;2019-12-07 07:43:53&quot;,formatter);</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        System.out.println(localTime);</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.日期时间类型转换成字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLocalDateToString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//localDate --&gt; String </span></span><br><span class="line">        <span class="comment">//使用常量创建DateTimeFormatte</span></span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        String format1 = localDate.format(DateTimeFormatter.BASIC_ISO_DATE);    <span class="comment">//yyyyMMdd</span></span><br><span class="line">        String format2 = localDate.format(DateTimeFormatter.ISO_DATE);            <span class="comment">//yyyy-MM-dd</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.LocalTime  --&gt; String</span></span><br><span class="line">        LocalTime localTime = LocalTime.now();</span><br><span class="line">        String format3 = localTime.format(DateTimeFormatter.ISO_TIME);            <span class="comment">//20:19:22.42</span></span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;hh:mm:ss&quot;</span>);</span><br><span class="line">        String format4 = localTime.format(formatter);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.LocalDateTime  --&gt; String        </span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        String format5 = localDateTime.format(formatter2);</span><br><span class="line">        </span><br><span class="line">        System.out.println(format1);</span><br><span class="line">        System.out.println(format2);</span><br><span class="line">        System.out.println(format3);</span><br><span class="line">        System.out.println(format4);</span><br><span class="line">        System.out.println(format5);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>数组的长度不可变，因此为了保存数目不确定的对象，Java提供了一系列特殊的类，统称集合，集合可以存储任意类型的对象，并且长度可变。</p>
<h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><p>Java中的集合就像一个容器，专门用来存储Java对象（实际上是对象的引用），这些对象可以是任意的数据类型，并且长度可变。这些集合类都位于java.util包中。</p>
<p>集合类按照其存储结构可以分为两大类：单列集合Collection，双列集合Map。</p>
<p>（1）Collection：单列集合的根接口，用于存储一系列符合某种规律的元素。Collection集合有两个重要的子接口，分别是List和Set。List集合特点：元素有序，可重复。Set集合特点：元素无序，不可重复。List接口的主要实现类：ArrayList、LinkedList。Set接口的主要实现类：HashSet、TreeSet。</p>
<p>（2）Map：双列集合的根接口，用于存储具有键值映射关系的元素。Map接口的主要实现类：HashMap、TreeMap。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2017af8f90a9dff713a5fa908b990a05.png" alt="image-20211113111401531"></p>
<p>虚线是接口类型，实线是实现类。</p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地将实现了List接口的对象称为List集合。</p>
<p>在List集合中<strong>允许出现重复</strong>的元素，所有的元素以一种线性方式进行存储，在程序中可以通过索引来访问集合中的指定元素，另外，List集合<strong>元素有序</strong>，即元素的存入顺序和取出顺序一致。</p>
<h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><p>ArrayList是程序中最常见的一种集合。在ArrayList内部封装了一个长度可变的数组对象，当存入的元素超过数组长度时，ArrayList会在内存中分配一个更大的数组来存储这些元素，因此ArrayList可以看作是一个长度可变的数组。</p>
<p>正是由于ArrayList内部的数据存储结构是数组形式，在增加和删除指定位置的元素时，会创建新的数组，效率比较低，因此不适合做大量的增删操作。但是在遍历和查找元素时显得非常高效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList集合</span></span><br><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line">lis.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">长度： lis.size();</span><br><span class="line">查询： lis.get(i);</span><br></pre></td></tr></table></figure>

<p>注意：在使用ArrayList集合时并没有显式地指定集合中存储什么类型的元素，会产生安全隐患，涉及到泛型安全机制的问题。</p>
<h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><p>ArrayList查询时速度很快，增删时效率较低，因此另一个实现类：LinkedList。</p>
<p>该集合内部包含两个Node类型的first和last属性维护一个双向循环链表，链表中的每一个元素都使用引用的方式记住它的前一个元素和后一个元素，从而可以将所有的元素彼此连接起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LinkedList lik = <span class="keyword">new</span> LinkedList();</span><br><span class="line">lik.add(<span class="string">&quot;bb&quot;</span>);   <span class="comment">//添加元素</span></span><br><span class="line">lik.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">lik.offer(<span class="string">&quot;dd&quot;</span>);  <span class="comment">//向集合尾部追加元素</span></span><br><span class="line">lik.push(<span class="string">&quot;aa&quot;</span>);  <span class="comment">//向集合头部添加元素</span></span><br><span class="line">System.out.println(lik);   <span class="comment">//输出集合中的元素</span></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line">Object obj = lik.peek();   <span class="comment">//获取集合第一个元素</span></span><br><span class="line">System.out.println(obj);</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">lik.removeFirst();   <span class="comment">//删除集合第一个元素</span></span><br><span class="line">lik.pollLast();   <span class="comment">//删除集合最后一个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="Collection集合遍历"><a href="#Collection集合遍历" class="headerlink" title="Collection集合遍历"></a>Collection集合遍历</h3><h4 id="Iterator遍历集合"><a href="#Iterator遍历集合" class="headerlink" title="Iterator遍历集合"></a>Iterator遍历集合</h4><p>Iterator接口是Java集合框架中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用来存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被叫做迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList集合</span></span><br><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line">lis.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="comment">//获取Iterator对象</span></span><br><span class="line">Iterator it = lis.iterator();</span><br><span class="line"><span class="comment">//判断集合中是否存在下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(it.hashNext())&#123;</span><br><span class="line">	Object obj = it.next();  <span class="comment">//获取ArrayList集合中的元素</span></span><br><span class="line">	System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素。</p>
<p>在调用Iterator的next()方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，第一次调用迭代器的next()方法后，迭代器的索引指向第一个元素并将该元素返回。</p>
<p>注意：在使用Iterator迭代器对集合中的元素进行迭代时，如果调用了集合对象的remove()方法去删除元素，会出现异常。因为集合中删除了元素会导致迭代器预期的迭代次数发生变化，导致迭代器的结果不准确。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(it.hashNext())&#123;</span><br><span class="line">	Object obj = it.next();  <span class="comment">//获取ArrayList集合中的元素</span></span><br><span class="line">	System.out.println(obj);</span><br><span class="line">	<span class="keyword">if</span>(<span class="string">&quot;aa&quot;</span>.equals(obj))&#123;</span><br><span class="line">		lis.remove(obj);  <span class="comment">//删除集合元素</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法一：在删除后用break退出。</p>
<p>解决方法二：使用迭代器本身的删除方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(&quot;aa&quot;.equals(obj))&#123;</span><br><span class="line">	it.remove();   //删除集合元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用迭代器对象的remove()方法删除元素导致的迭代次数变化，对迭代器对象本身来讲是可预知的。</p>
<h4 id="foreach遍历集合"><a href="#foreach遍历集合" class="headerlink" title="foreach遍历集合"></a>foreach遍历集合</h4><p>JDK5开始提供，是一种简洁的for循环，也称增强for循环，用于遍历数组或集合中的元素。会自动遍历容器中的每个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span>(Object obj:lis)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在foreach循环遍历集合和数组时，只能访问集合中的元素，不能对其中的元素进行修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String[] str = &#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String s:str)&#123;</span><br><span class="line">	s=<span class="string">&quot;aa&quot;</span>;   <span class="comment">//改变对string数组没效果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有效果是因为代码中<code>s=&quot;aa&quot;;</code>只是将临时变量s指向一个新的字符串，和数组中的元素没有关系。</p>
<p>而在普通的for循环中，可以通过索引来进行修改。</p>
<h4 id="JDK8的forEach遍历集合"><a href="#JDK8的forEach遍历集合" class="headerlink" title="JDK8的forEach遍历集合"></a>JDK8的forEach遍历集合</h4><p>在JDK8中，根据Lambda表达式特性，增加了一个<code>forEach(Consumer action)</code>方法来遍历集合，该方法需要一个函数式接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line">lis.forEach(obj-&gt;System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj))</span><br></pre></td></tr></table></figure>

<p>该方法传递的是一个Lambda表达式形式书写的函数式接口。forEach方法在执行时会自动遍历集合元素并将元素逐个传递给Lambda表达式的形参。</p>
<p>除此之外，JDK8还为Iterator迭代器对象增加了forEachRemaining(Consumer action)方法来进行遍历，同样需要一个函数式接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Iterator it = lis.iterator();</span><br><span class="line">it.forEachRemianing(obj-&gt;System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：本节对lList集合遍历的方法，对单列集合Collection进行遍历，因此对Set集合也适用。</p>
</blockquote>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>习惯性地将实现了Set接口的对象称为Set集合。Set集合中的元素<strong>无序</strong>（指存入的顺序和一起输出的顺序是否一致），并且会以某种规则保证存入的<strong>元素不出现重复</strong>。Set接口主要有两个实现类：HashSet、TreeSet。</p>
<p>HashSet是根据对象的哈希值来确定元素在集合中的存储的位置，因此具有良好的存取和查找性能。</p>
<p>TreeSet是以二叉树的方式来存储元素，它可以实现对集合中的元素进行排序。</p>
<h4 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h4><p>HashSet是Set接口的一个实现类，元素不可重复且无序。</p>
<p>保重不重复：当向HashSet集合中添加一个元素时，即调用HashSet集合的add()方法，首先调用当前存入元素的hashCode()方法获得对象的哈希值，然后根据对象的哈希值计算出一个存储位置：如果该位置上没有元素，则直接将元素存入；如果该位置上有元素存在，则会调用equals()方法让当前存入的元素依次和该位置上的元素进行比较。如果返回的结果为false就将该元素存入集合；返回的结果为true则说明有重复元素，就将该元素舍弃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet se = <span class="keyword">new</span> HashSet();</span><br><span class="line">se.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">se.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="comment">//遍历输出Set集合的元素</span></span><br><span class="line">set.forEach(obj-&gt;System.out.println(obj));</span><br></pre></td></tr></table></figure>

<p>为了保证HashSet的正常工作，在存入对象时，需要重写Object类中的hashCode()和equals()方法。String类已经默认重写了<code>hashCode()</code>和<code>equals()</code></p>
<p>如果将开发者自定义的类型对象存入HashSet，需要重写<code>hashCode()</code>和<code>equals()</code>，改为值比较，否则没重写的<code>equals()</code>方法认为两个值相同的引用变量所引用的对象地址不同，认为是两个不同的对象，达不到去重的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String id, String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id=id;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写toString()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id+<span class="string">&quot;:&quot;</span>+name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写hashCode方法，根据id判定</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id.hashCode();  <span class="comment">//返回id属性的哈希值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写equals方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="comment">//this表示该对象，判断是否为同一对象，如果是则true相同</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断对象是否为Student类型，如果不是，返回false</span></span><br><span class="line">		<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将对象强制转换为Student类型</span></span><br><span class="line">		Student stu = (Student)obj;</span><br><span class="line">		<span class="comment">//根据id值是否相等</span></span><br><span class="line">		<span class="keyword">boolean</span> b = <span class="keyword">this</span>.id.equals(stu.id);</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h4><p>TreeSet内部采用平衡二叉树存储元素，这样的结构保证TreeSet集合中没有重复的元素，并且可以对元素进行排序（和Set的无序无关）。左子树小于根节点，右子树大于根节点。当插入一个元素时，首先与顶层元素进行比较，小于左边，大于右边，直到最后一个叶子节点，如果和叶子节点一样，则将该重复元素去掉。否则小于左边，大于右边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TreeSet ts = <span class="keyword">new</span> TreeSet();</span><br><span class="line">ts.add(<span class="number">3</span>);</span><br><span class="line">ts.add(<span class="number">9</span>);</span><br><span class="line">ts.add(<span class="number">1</span>);</span><br><span class="line">ts.add(<span class="number">21</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ts集合：&quot;</span>+ts);  <span class="comment">//输出为[1,3,9,21]有序</span></span><br><span class="line">首元素： ts.first()  <span class="comment">//1</span></span><br><span class="line">尾元素： ts.last()   <span class="comment">//21</span></span><br><span class="line"><span class="comment">//比较并获取元素</span></span><br><span class="line">ts.floor(<span class="number">9</span>)  <span class="comment">//集合中小于或等于9的最大一个元素 9</span></span><br><span class="line">ts.higher(<span class="number">10</span>)  <span class="comment">//集合中大于10的最小元素 21</span></span><br><span class="line">删除并返回第一个元素： </span><br><span class="line">Object first = ts.pollFirst();</span><br><span class="line">删除并返回最后一个元素： </span><br><span class="line">Object last = ts.pollLast();</span><br></pre></td></tr></table></figure>

<p>集合中元素添加顺序无论如何，最后都会按一定顺序排列。因为平衡二叉树，每次插入都会与其他元素进行比较，最后插入有序的对象序列中。</p>
<p>集合中的元素在进行比较时，都会调用<code>compareTo()</code>方法，该方法是<code>Comparable</code>接口中定义的，因此要想对集合中的元素进行排序，就必须实现<code>Comparable</code>接口。Java中大多数类都实现了<code>Comparable</code>接口，并默认实现接口中的<code>compareTo()</code>方法，如Integer、Double、String等。</p>
<p>实际开发中，对自定义类型的数据没有实现<code>Comparable</code>接口，无法直接在TreeSet集合中进行排序操作。因此，Java提供了两种TreeSet的排序规则：自然排序、定制排序。默认情况下采用自然排序。</p>
<p>（1）自然排序</p>
<p>自然排序要求向TreeSet集合中存储的元素所在类必须实现<code>Comparable</code>接口，并重写<code>compareTo()</code>方法。然后TreeSet集合就会对该类型元素使用<code>compareTo()</code>方法进行比较，默认升序排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义Teacher类实现Comparable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name+<span class="string">&quot;:&quot;</span>+age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写compareTo方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		Teacher s = (Teacher)obj;</span><br><span class="line">		<span class="comment">//定义比较方式，先比较年龄age，再比较name,升序</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.age-s.age&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.age-s.age==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(s.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）定制排序</p>
<p>通过在创建TreeSet集合时就自定义一个比较器来对元素进行定制排序。自定义的类型数据中无需实现Comparable接口，并且可以按照自己的想法进行排序。</p>
<p>例子：按照集合中字符串的长度进行定制排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="comment">//定义比较器实现Comparator接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object obj1, Object obj2)</span></span>&#123;</span><br><span class="line">		String s1=(String)obj1;</span><br><span class="line">		String s2=(String)obj2;</span><br><span class="line">		<span class="keyword">int</span> temp=s1.length()-s2.length();</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="comment">//法1.创建集合时，传入Comparator接口实现定制排序</span></span><br><span class="line">		TreeSet ts=<span class="keyword">new</span> TreeSet(<span class="keyword">new</span> MyComparator());</span><br><span class="line">		ts.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		ts.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">		ts.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">		System.out.println(ts);</span><br><span class="line">	<span class="comment">//法2.创建集合时，使用Lambda表达式定制排序，无序上面的MyComparator</span></span><br><span class="line">		TreeSet ts2=<span class="keyword">new</span> TreeSet((obj1,obj2)-&gt;&#123;</span><br><span class="line">			String s1=(String)obj1;</span><br><span class="line">			String s2=(String)obj2;</span><br><span class="line">			<span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">		&#125;);</span><br><span class="line">		ts2.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		ts2.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">		ts2.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">		System.out.println(ts2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map接口是一种双列集合，包含键对象key和值value，键和值对象之间存在一种映射，一对一的，一个key对应唯一一个value，键对象key不可重复。</p>
<h4 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h4><p>HahMap集合存储键值映射关系，该集合的键和值允许为空，但键不能重复，且集合中的元素是<strong>无序的</strong>。</p>
<p>HashMap底层：哈希表结构=数组+链表。数组是HashMap的主体结构，链表则是为了解决哈希值冲突而存在的分支结构。因此HashMap对元素的增删改查表现出的效率都很高。</p>
<p>水平方向上数组的长度称为HashMap集合的容量（capacity），竖直方向每个元素对应的链表结构称为一个桶（bucket），每个桶的位置在集合中都有对应的桶值，用于快速定位。每个链表结构是&lt;key,value&gt;的键值对。</p>
<p>当向HashMap集合添加元素时，首先调用键对象k的hash(k)方法，快速定位并寻址到该元素在集合中要存储的位置。在定位到存储元素键对象k的哈希值所对应桶位置后，会出现两种情况：<br>1.键对象k的hash值所在的桶位置为空，则直接向该桶插入元素对象。<br>2.键对象k的hash值所在的桶位置不为空，则继续通过键对象的equals(k)方法比较新插入的元素键对象k和已存在的元素键对象k是否相同：<br>1.如果相同，则会对原有元素的值对象v进行替换并返回原来的旧值。<br>2.如果都不相同，则在该桶的链表结构头部新增一个节点来插入新的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>);  <span class="comment">//put已存在的key，会进行覆盖</span></span><br><span class="line">System.out.println(m);  <span class="comment">//打印</span></span><br><span class="line"><span class="comment">//查看键是否存在</span></span><br><span class="line">m.containsKey(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment">//获取键对应的值</span></span><br><span class="line">m.get(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment">//获取键集合、值集合</span></span><br><span class="line">m.keySet()</span><br><span class="line">m.values()</span><br><span class="line"><span class="comment">//替换指定键的值</span></span><br><span class="line">m.replace(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">删除指定键值对</span><br><span class="line">m.remove(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意，HashMap查找时，需要遍历链表，逐一通过equals方法进行比对，因此桶越多，HashMap中的链表越少，性能越好。属于空间换时间。</p>
<p>HashMap中，<strong>动态分配桶的数量</strong>：通过<code>new HashMap()</code>方法创建HashMap时，会默认集合容量capacity大小为16，加载因子loadFactor为0.75，此时集合桶的阈值为12，超过12个时，HashMap会默认增加一倍桶的数量。开发者也可以使用<code>new HashMap(int intialCapacity, float loadFactor)</code>构造方法，在创建HashMap集合时指定集合容量和加载因子。</p>
<h4 id="Map集合遍历"><a href="#Map集合遍历" class="headerlink" title="Map集合遍历"></a>Map集合遍历</h4><h5 id="Iterator迭代器遍历"><a href="#Iterator迭代器遍历" class="headerlink" title="Iterator迭代器遍历"></a>Iterator迭代器遍历</h5><p>使用Iterator迭代器遍历Map集合，需要先将Map集合转换为Iterator接口对象，然后进行遍历，有两种方法进行转换：</p>
<p>（1）keySet()方法</p>
<p>先将Map集合中所有键对象转换为Set单列集合，然后将Set集合转换为Iterator接口对象，遍历得到键，再获得值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>); </span><br><span class="line">Set keySet = map.keySet();   <span class="comment">//获取键的集合</span></span><br><span class="line">Iterator it = keySet.iterator();  <span class="comment">//迭代键的集合</span></span><br><span class="line"><span class="keyword">while</span>(it.hashNext())&#123;</span><br><span class="line">	Object k = it.next();</span><br><span class="line">	Object v = m.get(key);</span><br><span class="line">	System.out.println(k+<span class="string">&quot;:&quot;</span>+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）entrySet()方法</p>
<p>将原有Map集合中的键值对作为一个整体返回为Set集合，接着将Set转换为Iterator接口对象，然后获取键值对映射关系，取出键和值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>); </span><br><span class="line">Set entrySet = m.entrySet();</span><br><span class="line">Iterator it = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	Map.Entry en = (Map.Entry)(it.next());</span><br><span class="line">	Object k = en.getKey();</span><br><span class="line">	Object v = en.getValue();</span><br><span class="line">	System.out.println(k+<span class="string">&quot;:&quot;</span>+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map.Entry是Map接口内部类，每个Map.Entry对象代表Map中的一个键值对。getKey和getValue是映射对象的方法。</p>
<h5 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach()方法"></a>forEach()方法</h5><p>再JDK8中根据Lambda表达式特性新增了一个forEach方法来遍历Map集合，该方法需要的参数是一个函数式接口，可以用Lambda表达式书写这个函数式接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>); </span><br><span class="line">m.forEach((k,v)-&gt;System.out.println(k+<span class="string">&quot;:&quot;</span>+v));</span><br></pre></td></tr></table></figure>

<p>如果只想遍历value：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection v = m.values();</span><br><span class="line">v.forEach(va-&gt;System.out.println(va));</span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>HashMap无序，不保证集合元素存入和取出的顺序。</p>
<p>但是LinkedHashMap是HashMap的子类，和LinkedList一样使用双向链表来维护内部元素的关系，使得元素有序（存入和取出的顺序）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> LinkedHashMap();  <span class="comment">//创建</span></span><br></pre></td></tr></table></figure>

<h4 id="TreeMap集合"><a href="#TreeMap集合" class="headerlink" title="TreeMap集合"></a>TreeMap集合</h4><p>Map接口的另一个实现类TreeMap，同样不允许重复的键。TreeMap内部是通过二叉树的原理来保证键的唯一性，这与TreeSet集合存储的原理一样，因此，TreeMap中所有的键是按照某种顺序排列的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> TreeMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">System.out.println(m);</span><br></pre></td></tr></table></figure>

<p>上面的键是String类型，String类实现了Comparable接口，因此默认会按照自然顺序从小到大进行排列。</p>
<p>桶TreeSet一样，TreeMap可以自定义比较器Comparator的方式对所有的键进行定制排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义比较器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object obj1, Object obj2)</span></span>&#123;</span><br><span class="line">		String key1 = (String)obj1;</span><br><span class="line">		String key2 = (String)obj2;</span><br><span class="line">	    <span class="keyword">return</span> key2.compareTo(key1);  <span class="comment">//从大到小排列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Map m = <span class="keyword">new</span> TreeMap(<span class="keyword">new</span> MyComparator());</span><br></pre></td></tr></table></figure>

<h4 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h4><p>Map接口还有一个实现来Hashtable，它和HashMap十分相似，区别在于Hashtable是线程安全的，因此在使用上Hashtable的效率不及HashMap。因此通常使用HashMap。</p>
<p>但是Hashtable有一个子类Properties，主要用来存储字符串类型的键值，在实际开发中，经常用来存取应用的配置项。</p>
<p>假设有一个配置文件：test.properties</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color = red;</span><br><span class="line">size = 10;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.通过Properties进行属性文件读取操作</span></span><br><span class="line">	Properties pps = <span class="keyword">new</span> Properties();</span><br><span class="line">	<span class="comment">//加载文件</span></span><br><span class="line">	pps.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.properties&quot;</span>));</span><br><span class="line">	<span class="comment">//遍历键值对信息</span></span><br><span class="line">	pps.forEach((k,v)-&gt;System.out.println(k+<span class="string">&quot;:&quot;</span>+v));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.通过Properties进行属性文件写入操作</span></span><br><span class="line">	<span class="comment">//指定写入操作的文件名称和位置</span></span><br><span class="line">	<span class="function">FileOutputStream out new <span class="title">FileOutputStream</span><span class="params">(<span class="string">&quot;test.properties&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">//向Properties类文件进行写入键值对信息</span></span><br><span class="line">	pps.setProperty(<span class="string">&quot;charset&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">	<span class="comment">//将此Properties集合中新增的键值对写入配置文件</span></span><br><span class="line">	pps.store(out, <span class="string">&quot;新增charset编码&quot;</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Properties的setProperty方法，用来新增一个键值对元素。store方法用来将新增信息写入到properties配置文件。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在之前创建集合，当把一个对象存入集合后，集合会忘记这个对象的类型，将该对象从集合中取出时，这个对象的编译类型就会统一变成Object类型。也就是说，存入元素啥类型都行，但是取出元素后，进行强制转换容易出错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList lis = new ArrayList();</span><br><span class="line">lis.add(&quot;aa&quot;);</span><br><span class="line">lis.add(&quot;bb&quot;);</span><br><span class="line">for(Object obj:lis)&#123;</span><br><span class="line">	String s = (String)obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为解决该问题，Java引入“参数化类型”概念，即泛型。泛型可以限定操作的数据类型，在定义集合类时，可以使用“&lt;参数化类型&gt;”的形式指定集合中存储的数据类型。</p>
<p><code>ArrayList&lt;String&gt;lis = new ArrayList&lt;String&gt;();</code></p>
<p>这样限定了集合元素的数据类型，程序编译时类型不必配的话会编译不通过，避免运行时发生错误。遍历时<code>for(String s:lis)&#123;&#125;</code></p>
<h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>Java提供的一个专门工具类用来操作集合，位于java.util包中。Collections类中提供了大量的静态方法用于对集合中的元素进行排序、查找、修改等操作。</p>
<h4 id="添加、排序"><a href="#添加、排序" class="headerlink" title="添加、排序"></a>添加、排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt;lis = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">Collections.addAll(lis,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">//集合可以直接输出，而数组不可以，数组可以用forEach的Lambda表达式？</span></span><br><span class="line">System.out.println(lis);</span><br><span class="line">Collections.sort(lis);  <span class="comment">//排序</span></span><br><span class="line">Collections.reverse(lis);  <span class="comment">//反转</span></span><br><span class="line">Collections.shuffle(lis);  <span class="comment">//随机打乱集合顺序</span></span><br><span class="line">Collections.swap(lis,<span class="number">0</span>,lis.size()-<span class="number">1</span>);  <span class="comment">//交换元素</span></span><br></pre></td></tr></table></figure>

<h4 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt;lis = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">Collections.addAll(lis,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">最大元素： Collections.max(lis);</span><br><span class="line">最小元素： Collections.min(lis);</span><br><span class="line">Collections.replace(lis,<span class="number">2</span>,<span class="number">0</span>);  <span class="comment">//将集合中的2用0替换掉</span></span><br><span class="line">Collections.sort(lis);  <span class="comment">//排序</span></span><br><span class="line"><span class="comment">//通过二分查找查找元素3所在的角标，一定要先排序</span></span><br><span class="line"><span class="keyword">int</span> index = Collections.binarySearch(lis, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h3><p>java针对数组操作提供的数据工具类Arrays，提供大量静态方法。</p>
<h4 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">不能通过System.out直接打印数组，需要<span class="keyword">for</span>循环打印</span><br><span class="line">Arrays.sort(arr);  <span class="comment">//排序</span></span><br><span class="line">Arrays.sort(arr,<span class="number">1</span>,<span class="number">4</span>);  左闭右开</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">int</span> index=Arrays.binarySearch(arr,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><p>在不破坏原数组的情况下使用数组的部分元素，将指定范围的元素拷贝到一个新的数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] cop = Arrays.copyOfRange(arr, <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">//结果cop：8，3，5，2，0，0，左闭右开共六个，没有的用默认0</span></span><br></pre></td></tr></table></figure>

<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>将数组的所有元素替换为一个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(arr,<span class="number">8</span>);  <span class="comment">//全换为8</span></span><br></pre></td></tr></table></figure>

<h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>Lambda表达式可以简化集合和数组的遍历、过滤和提取等操作。基于此特性，JDK8新增了聚合操作。</p>
<h4 id="Stream接口"><a href="#Stream接口" class="headerlink" title="Stream接口"></a>Stream接口</h4><p>JDK8提供，该接口将集合、数组中的元素转换为Stream流的形式，并结合Lambda表达式进一步简化集合、数组中元素的查找、过滤、转换操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt;lis <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">lis.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line"><span class="comment">//创建一个Stream流对象</span></span><br><span class="line">Stream&lt;String&gt;stream = lis.stream();</span><br><span class="line"><span class="comment">//对Stream流中的元素进行过滤、截取</span></span><br><span class="line">Stream&lt;String&gt;stream2 = stream.filter(i-&gt;i.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">Stream&lt;String&gt;stream3 = stream.filter(i-&gt;i.length()&gt;<span class="number">1</span>);</span><br><span class="line">Stream&lt;String&gt;stream4 = stream2.limit(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//对Stream流中的元素进行终结操作</span></span><br><span class="line">stream4.forEach(j-&gt;System.out.println(j));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过链式表达式的形式完成聚合操作</span></span><br><span class="line">lis.stream().filter(i-&gt;i.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">			.limit(<span class="number">1</span>)</span><br><span class="line">			.forEach(j-&gt;System.out.println(j));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问：创建list时，最先的List和ArrayList有何区别？</p>
<p>List<int>可以吗？还是说元素必须为引用类型</int></p>
</blockquote>
<p>链式表达式：调用有返回值的方法时不获取返回值而是直接再调用另一个方法，实现聚合操作，也被称为操作管道流。</p>
<p>执行某个方法返回类型仍为stream流对象的方法归为中间操作，如过滤截取排序。</p>
<p>执行方法后返回类型不再是Stream流对象的方法归为终结操作，如遍历统计收集。</p>
<h4 id="创建Stream流对象"><a href="#创建Stream流对象" class="headerlink" title="创建Stream流对象"></a>创建Stream流对象</h4><p>聚合操作针对的是可迭代数据进行操作：如集合、数组。因此创建Stream流对象是将集合、数组通过一些方法转换为Stream流对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Stream流对象的集中方法</span></span><br><span class="line">Integer[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//将数组转换为List集合</span></span><br><span class="line">List&lt;Integer&gt;lis=Arrays.asList(arr);</span><br><span class="line"><span class="comment">//1.使用集合对象的stream()静态方法创建stream流对象</span></span><br><span class="line">Stream&lt;Integer&gt;stream=lis.stream();</span><br><span class="line">stream.forEach(i-&gt;System.out.print(i+<span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用Stream接口的of()静态方法为基本类型包装类数组、引用类型数组、单个元素创建stream流对象</span></span><br><span class="line">Stream&lt;Integer&gt;stream2=Stream.of(arr);</span><br><span class="line">stream2.forEach(i-&gt;System.out.print(i+<span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用Arrays数组工具类的stream()静态方法创建stream流对象</span></span><br><span class="line">Stream&lt;Integer&gt;stream3=Arrays.stream(arr);</span><br><span class="line">stream3.forEach(i-&gt;System.out.print(i+<span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure>

<p>注意：集合对象的stream()静态方法只是针对单列集合Collection接口对象提供的，对Map集合首先通过Map集合的<code>keySet()  values()  entrySet()</code>方法转换为单列Set集合。</p>
<h4 id="map-映射"><a href="#map-映射" class="headerlink" title="map()映射"></a>map()映射</h4><p>Stream流对象的map()方法可以将流对象中的元素通过特定的规则进行修改然后映射为另一个流对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt;stream=Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">stream.map(String::toUpperCase)  <span class="comment">//流中所有元素字母转为大写</span></span><br><span class="line">	  .sorted()</span><br><span class="line">	  .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="截取limit"><a href="#截取limit" class="headerlink" title="截取limit()"></a>截取limit()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.skip(<span class="number">1</span>)   <span class="comment">//跳过流中的前一个元素</span></span><br><span class="line">      .limit(<span class="number">2</span>)   <span class="comment">//截取前2个元素</span></span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><p>forEach()操作无法将进行中间操作后的流元素作为我们熟悉的对象或是数据类型进行保存，为此JDK8为操作流对象增加了一个终结操作—-collect。</p>
<p>collect可以把Stream中的元素保存为另一种形式，如集合、字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存为List集合</span></span><br><span class="line">Stream&lt;String&gt;stre = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">List&lt;String&gt;lis = stre.filter(i-&gt;i,startWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">					  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//将流元素使用&quot;and&quot;连接，收集到一个字符串中</span></span><br><span class="line">Stream&lt;String&gt;stre = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">String st = stre.filter(i-&gt;i,startWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">					  .collect(Collectors.joining(<span class="string">&quot;and&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存为数组</span></span><br><span class="line">Stream&lt;String&gt;stre = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">String[] arr = stre.filter(i-&gt;i,startWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">					  .collect(Collectors.toArray());</span><br></pre></td></tr></table></figure>

<p>注意：一个Stream可以进行多个中间操作，但只能进行一个终结操作，一旦进行了终结操作，流对象就不复存在了。因此，只能保存一次。</p>
<h4 id="Parrel-Stream并行流"><a href="#Parrel-Stream并行流" class="headerlink" title="Parrel Stream并行流"></a>Parrel Stream并行流</h4><p>JDK8针对大批量数据提供并行流，并行流是将源数据分为多个子流对象进行多线程操作（多个管道流），然后将处理的结果再汇总为一个流对象。</p>
<p>并行流可以提高程序执行效率，但是在多线程执行时会出现线程安全问题，需要保证源数据在并行执行时不会被改变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建List集合数据源</span></span><br><span class="line">List&lt;String&gt;lis = Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">//1.直接用Collection接口的parallelStream()创建并行流</span></span><br><span class="line">Stream&lt;String&gt;para = lis.parallelStream();</span><br><span class="line"><span class="comment">//判断是否为并行流</span></span><br><span class="line">System.out.println(para.isParallel());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用BaseStream接口的parallel()方法将串行流转变为并行流</span></span><br><span class="line">Stream&lt;String&gt;str = Stream.of(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>.<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">Stream&lt;String&gt;para = str.parallel();</span><br><span class="line"><span class="comment">//判断是否为并行流</span></span><br><span class="line">System.out.println(para.isParallel());</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/08/myblog/JAVA/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/08/myblog/JAVA/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B/" class="post-title-link" itemprop="url">《Java基础入门》面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-08 10:33:43" itemprop="dateCreated datePublished" datetime="2021-11-08T10:33:43+08:00">2021-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-17 14:07:08" itemprop="dateModified" datetime="2021-11-17T14:07:08+08:00">2021-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java开发入门"><a href="#Java开发入门" class="headerlink" title="Java开发入门"></a>Java开发入门</h2><p>Java是由Sun公司于1995年开发的可编写跨平台应用软件、完全面向对象的程序设计语言。2009年被Oracle公司收购。</p>
<h3 id="Java三个技术平台"><a href="#Java三个技术平台" class="headerlink" title="Java三个技术平台"></a>Java三个技术平台</h3><p>针对不同的开发市场，Sun公司将Java划分为三个技术平台。</p>
<p>（1）Java SE：（standard edition）Java平台标准版，为开发普通桌面和商务应用程序提供的解决方案，是三个平台中最核心的部分，Java EE和Java ME都是从Java SE的基础上发展而来，Java SE包括Java最核心的类库，如集合、IO、数据库连接及网络编程。</p>
<p>（2）Java EE：（enterprise edition）平台企业版，为开发企业级应用程序提供的解决方案，包括Servlet、JSP、JavaBean、EJB、Web Service等。用来做web开发的java框架。</p>
<p>（3）Java ME：（micro edition）平台微型版，为开发电子消费产品和嵌入式设备提供的解决方案，用于微型数字电子设备上软件程序的开发，例如家用电器增加智能化控制和联网功能，未手机增加游戏和通讯录管理功能。此外，还提供HTTP等协议，为移动电话提供Client/Server方式访问Internet，提供无线交流。</p>
<p>不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。</p>
<p>J2SE是标准版本，J2ME是手机方向的，J2EE是网站开发方向的。</p>
<h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><ul>
<li>简单易用：丢弃了c++中的：操作符重载、多继承、自动强制类型转换、不使用指针而是引用，提供自动分配和回收内存空间。</li>
<li>安全可靠：Java通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。</li>
<li>跨平台：通过JVM虚拟机在不同的操作系统上允许Java程序。</li>
<li>面向对象：将一切事物都看成对象，类、接口、继承。只支持类之间的单继承，支持接口之间的多继承，支持类与接口之间的实现机制（implements）。java全面支持动态绑定，c++只对虚函数使用动态绑定。</li>
<li>支持多线程：内置了多线程控制，可使用户程序并发执行。</li>
</ul>
<h3 id="JDK-gt-JRE-gt-JVM"><a href="#JDK-gt-JRE-gt-JVM" class="headerlink" title="JDK&gt;JRE&gt;JVM"></a><strong>JDK&gt;JRE&gt;JVM</strong></h3><p><strong>JVM</strong> ：（Java Virtual Machine）， Java 虚拟机。它只认识 xxx.class 类型的文件，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。jvm 是 Java 能够跨平台的核心。</p>
<p><strong>JRE</strong> ：（Java Runtime Environment），Java 运行时环境。主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。普通用户只需要JRE进行运行已经编译好的java程序，而不需要开发。</p>
<p><strong>JDK</strong> ：（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe（编译 java 源码的编译器 javac），java.exe（java运行工具），jar.exe（java打包工具），java文档生成工具 等很多 java 程序调试和分析的工具。</p>
<p>1996年推出jdk1.0，随后到1.5改变命名方式，jdk1.5=jdk5.2017年jdk9，2018年jdk10.但是并不稳定。目前最多运用jdk8.</p>
<p>安装jdk时，安装开发工具（包括javac.exe、java.exe等，以及一个专用JRE环境），源代码（Java所有核心类库的源代码），公共JRE相当于多装一个JRE在其他路径，所以不需要。</p>
<p>JDK=JRE(JVM+JAVA基本类库)+开发工具</p>
<h3 id="JDK目录"><a href="#JDK目录" class="headerlink" title="JDK目录"></a>JDK目录</h3><ul>
<li>bin目录：存放一些可执行程序，如javac.exe（java编译器）、java.exe（java运行工具）、jar.exe（打包工具）、javadoc.exe（文档生成工具）等。</li>
<li>db目录：纯java实现的支持JDBC4.0所有规范的小型数据库。</li>
<li>include目录：由于JDK是通过C和C++实现的，因此在启动时引入一些C语言的头文件，该目录就是存放这些头文件的。</li>
<li>jre目录：Java运行时环境的根目录，，包括java虚拟机、运行时的类包、java应用启动器以及一个bin目录，不包括开发环境中的开发工具。</li>
<li>lib目录：java类库或库文件，是开发工具使用的归档包文件。</li>
</ul>
<blockquote>
<p>javac.exe：编译器工具，将java文件编译成可执行的java字节码文件.class</p>
<p>java.exe：java运行工具，会启动一个java虚拟机进程，专门负责运行字节码文件</p>
</blockquote>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>目的：在任何位置都能够编译和运行java程序。</p>
<p>配置：PATH：用于告知操作系统去指定路径寻找JDK，CLASSPATH：告知JDK去指定路径查找类文件(.class文件)</p>
<p>当在命令窗口中运行一个可执行文件时，操作系统首先会在当前目录下寻找是否存在该文件，如果不存在，会在PATH环境变量中定义的路径下寻找这个文件。</p>
<h3 id="java运行机制"><a href="#java运行机制" class="headerlink" title="java运行机制"></a>java运行机制</h3><p>.java文件，</p>
<p>使用javac.exe即java编译器进行编译，</p>
<p>.class文件，</p>
<p>使用java命令开启Java虚拟机运行程序，java虚拟机首先将编译好的字节码文件加载到内存（类加载，由类加载器完成），然后虚拟机通过java解析器对加载到内存中的java类进行解释执行，</p>
<p>机器码文件，</p>
<p>计算机运行机器码文件。</p>
<blockquote>
<p>java程序是由java虚拟机负责解释执行的，而不是操作系统，因此跨平台。</p>
</blockquote>
<h3 id="类包"><a href="#类包" class="headerlink" title="类包"></a>类包</h3><p>import导包：import 包名.类名  /  import 包名.*</p>
<p>java的核心类主要放在java包及其子包下。java扩展的大部分类在javax包及其子包下。</p>
<p>java.util：java的大量工具类、集合类，如Arrays、List、Set等</p>
<p>java.net：java网络编程相关的类和接口</p>
<p>java.io：java输入输出相关类和接口</p>
<p>java.awt：构建图形界面GUI的类和接口</p>
<p>java.sql：数据库编程</p>
<h2 id="Java编程基础"><a href="#Java编程基础" class="headerlink" title="Java编程基础"></a>Java编程基础</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行//  多行/*  */</p>
<p>文档注释：对某个类或类中的方法进行系统性解释说明。开发人员可使用JDK提供的javadoc工具将文档注释提取出来生成一份API帮助文档。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  content</span><br><span class="line">*  content</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>包名：一律小写<br>类名、接口名：首字母大写<br>常量名：都大写下划线连接<br>变量名和方法名：一个单词首字母小写，后面首字母大写</p>
<h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>八种基本数据类型：<br>byte：是8位、有符号的，以二进制补码表示的整数；-128~127；<br>short：16位<br>int：32位<br>long：64位，所赋的值超过int的取值范围，则需要加L，long num=10000000L;<br>float：单精度32位，小数默认为double类型，因此定义float型需要在后面加f/F<br>double：双精度64位<br>boolean：布尔<br>char：字符，2个字节</p>
<p>引用数据类型：<br>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型。<br>所有引用类型的默认值都是null，表示没有指向任何对象。</p>
<p><code>char c=&#39;a&#39;</code> 和 <code>char c=97</code>一样。因为可以将char变量赋值为0-65535范围内的整数，计算机将整数自动转化为对应的字符。</p>
<h3 id="变量的类型转换"><a href="#变量的类型转换" class="headerlink" title="变量的类型转换"></a>变量的类型转换</h3><p>（1）自动类型转换（隐式类型转换）：将一个类型取值范围小的数值直接赋值给另一个取值范围大的数据类型变量。大壶装小壶。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte b=3;</span><br><span class="line">int x=b;</span><br><span class="line">double y=x;</span><br></pre></td></tr></table></figure>

<p>（2）强制类型转换（显式类型转换）：目标类型取值范围小于源类型。小壶装大壶。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte a;</span><br><span class="line">int b=298;</span><br><span class="line">a=(byte)b;   //结果a会变成42</span><br></pre></td></tr></table></figure>

<p>强制类型转换中可能丢失精度，例如int占用4个字节，而byte占用1个字节，298变二进制后只留下最低的八位。</p>
<p>（3）表达式类型自动提升：byte、short、char类型的变量在运算期间类型会自动提示为int类型，然后进行运算，因此在最后获得结果时需要强制类型转换。</p>
<p>（4）在使用+=、-=、*=等运算符时，强制类型转换会自动完成。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>整形常量：二进制0b/0B开头，八进制0开头，十六进制0x/0X开头。</p>
<p>null：表示对象的引用为空。</p>
<p>需要用final关键字定义常量：<br><code>final int a=0</code></p>
<p>转义符<br>\r  回车符<br>\n  换行符<br>\t  制表符<br>\b  退格符，backspace<br>\后加&#39;或&quot;或\表示本身</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选，可以不break而继续执行。</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选，最后才看</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义的三种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">剖析：<span class="keyword">int</span>[] nums;  nums变量的类型是<span class="keyword">int</span>[]。</span><br><span class="line">nums会占用一块内存单元，nums=<span class="keyword">new</span> <span class="keyword">int</span>[]; 表示创建数组，并将数组的内存地址赋值给变量nums。在程序运行期间可以用变量nums来引用数组.</span><br></pre></td></tr></table></figure>

<p>多维数组：<code>String[][] str = new String[3][4];</code></p>
<p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>对数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">Arrays.sort(arr,<span class="number">1</span>,<span class="number">4</span>);  左闭右开</span><br></pre></td></tr></table></figure>

<h2 id="面向对象（上）"><a href="#面向对象（上）" class="headerlink" title="面向对象（上）"></a>面向对象（上）</h2><p>面向对象是把构成问题的事物按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。</p>
<p>封装：将对象的属性和行为封装起来。</p>
<p>继承：描述类与类之间的关系，使得无须重新编写原有类的情况下对原有类的功能进行扩展。</p>
<p>多态：一个类中定义的属性和功能被其他类继承后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现出的多种不同行为特征。</p>
<p>类是对象的抽象，共同特征作为属性（成员变量），共同行为作为类的方法（成员方法）。对象是类的实例。</p>
<p>创建对象：<code>Person p=new Person();</code></p>
<p>第一步：<code>Person p;</code> 声明一个Person类型的变量p</p>
<p>第二步：<code>=new Person();</code>创建Person对象，并将Person对象在内存中的地址赋值给变量p，这样变量p便持有了对象的引用。</p>
<p>内存中，p变量存对象的地址，在栈内存，p是一个引用，指向真正的对象。对象创建在堆内存。</p>
<blockquote>
<p>栈内存：存放基本类型的变量和对象的引用变量。</p>
<p>堆内存：存放new创建的对象和数组。</p>
</blockquote>
<p>创建好对象后，可以通过对象的引用来访问对象的所有成员。对象引用.对象成员</p>
<p>也可以使用创建的对象本身来引用对象成员：<code>new Person().成员</code>。由于没有对象引用的存在，在完成一个对象成员的访问后，该对象变成垃圾对象。<strong>当对象没有被任何变量所引用就会变成垃圾。</strong></p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>访问控制级别由小到大：private→default→protected→public</p>
<ul>
<li>private（当前类访问级别）：该成员只能被该类的其他成员访问，其他类无法直接访问。</li>
<li>default（包访问级别）：不使用任何访问控制修饰符的话，就是default，表示这个类或者类的成员只能被本包中的其他类访问。</li>
<li>protected（子类访问级别）：成员能被同一包内的其他类访问，也能被不同包下该类的子类访问。</li>
<li>public（公共访问级别）：该类或类的成员能被所有的类访问，不管是否在同一包中。</li>
</ul>
<blockquote>
<p>如果一个java源文件中定义的所有类都没有public修饰符，那么这个源文件的文件名可以是一切合法的文件名。</p>
<p>如果java源文件中定义了一个public修饰的类，则源文件名必须与public修饰的类的类名一致。</p>
</blockquote>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类的封装，是指将对象的属性隐藏在对象内部，设为private级别，不允许外部程序直接访问对象的内部信息，而通过类内public的方法（setxxx，getxxx）实现对内部信息的操作及访问。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>在实例化对象的同时为这个对象的属性进行赋值，可以通过构造方法来实现。</p>
<p>构造方法需要满足的三个条件：方法名与类名相同、在方法名的前面没有返回值类型的声明、方法中不能使用return返回一个值但是可以单独return来结束方法。</p>
<p>构造方法的重载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line">    TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java中每个类都至少有一个构造方法，如果一个类中没有显示地定义构造方法，系统会自动为这个类创建一个无参构造方法。但是一旦自己定义了有参的构造方法，系统将不再提供无参的构造方法。</p>
<blockquote>
<p>疑问：构造方法用来在实例化对象的时候为对象的成员变量赋值，而在定义类的时候，可以声明变量（不赋值）也可以定义变量（赋值），那么定义了变量之后，实例化对象，是给对象的成员赋初值了吗？应该是吧</p>
</blockquote>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>关键字this用来指代当前对象，用来在方法中访问对象的其他成员。</p>
<ul>
<li>通过this关键字调用成员变量，解决与局部变量名称冲突的问题。</li>
<li>通过this关键字调用成员方法。</li>
<li>通过this关键字调用构造函方法，构造方法是在实例化对象时被java虚拟机自动调用的，但是可以<strong>在一个构造方法中</strong>用<code>this(参数);</code>的形式来调用其他的构造方法。注意：只能在构造方法中用，且必须是构造方法中的第一条语句，且只能出现一次，而且不能在两个构造方法中相互调用。</li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>（1）静态变量</p>
<p>类内的数据成员被一个类的所有实例对象所共享时使用，例如学校学生的学校名。不必要在每个对象占用的空间中都声明这个对象，而是在对象之外的空间中声明一个变量供所有对象来共享。</p>
<p>注意：static关键字只能用于修饰成员变量，不能用于修饰局部变量。</p>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String schoolName;</span><br><span class="line">&#125;</span><br><span class="line">main函数中：</span><br><span class="line">Student.schoolName=<span class="string">&quot;daxue&quot;</span>;</span><br><span class="line">Student stu1=<span class="keyword">new</span> Student();</span><br><span class="line">使用： stu1.schoolName</span><br></pre></td></tr></table></figure>

<p>（2）静态方法</p>
<p>希望在不创建对象的情况下就可以调用某个方法时使用。</p>
<p>访问方式：<code>类名.方法</code>    或    <code>实例对象名.方法</code></p>
<p>注意：在一个静态方法中只能访问用static修饰的成员，原因在于没有没sttaic修饰的成员需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象。</p>
<blockquote>
<p>思考：一个文件中可以有多个类，文件名叫public的类的名字，类内可以有public static main函数，有main函数的类得是public的?</p>
<p>static 的成员函数，只能访问static的成员（函数或变量），public static main函数中可以创建其他类的对象，然后访问其他非static类的成员。</p>
</blockquote>
<p>（3）静态代码块</p>
<p>static{…}  在类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块也只执行一次。通常使用静态代码块对类的成员变量进行初始化。第一次实例化对象时会加载类。</p>
<h2 id="面向对象（下）"><a href="#面向对象（下）" class="headerlink" title="面向对象（下）"></a>面向对象（下）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>is a的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类在继承父类的时候，会自动拥有父类所有公共的成员。</p>
<p>java中只支持单继承，不允许多继承，一个类只能有一个直接父类。</p>
<h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>不能使用比父类中重写的方法更严格的访问权限，如父类的访问权限是public，子类方法不能是private。</p>
<p>也可以重新定义父类的属性。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>子类重写父类方法或重新定义父类属性后，子类对象无法直接访问他们，因此，用super访问。<code>super.成员变量/成员方法</code></p>
<p>还可以用super关键字来调用父类的构造方法。<code>super([参数1,参数2]);</code>但是，只能出现在子类构造方法的第一行，且只能出现一次。</p>
<p>注意：子类的构造方法中一定会调用父类的某个构造方法，可以通过super指定。如果没有super，则会默认调用父类无参的构造方法。因此，如果父类只定义了有参的构造方法，系统不给默认无参构造方法，就会出错。因此需要在父类添加无参构造方法，或者子类指定调用父类有参构造方法。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>java中的Object类是所有类的父类，每个类都直接或间接地继承自该类，称为超类、基类、或根类。Object类中有一些自定义的方法。</p>
<p><code>对象名.toString()  </code>返回对象的字符串表示。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>不可更改，最终的意思。</p>
<p>（1）修饰类：不能被继承。</p>
<p>（2）修饰方法：不能被子类重写</p>
<p>（3）修饰变量：常量，只能被赋值一次。</p>
<p>final修饰的成员变量，必须在声明的同时进行赋值。</p>
<p>final修饰的局部变量，可以先声明，再进行一次赋值。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>例如在定义Animal类时，shout()方法无法明确表示，java提供抽象方法来使得其无需提供方法的具体实现。</p>
<p>抽象方法：<code>public abstract void shout();</code>没有大括号</p>
<p>包含抽象方法的类一定是抽象类，class前加abstract，但是抽象类中可以不包含抽象方法。</p>
<p>抽象类不能被实例化，只能创建子类，并在子类中实现抽象类中的抽象方法。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种特殊的抽象类，它不包含普通方法，内部所有方法都是抽象方法。</p>
<p>JDK8中对接口进行了重新定义，接口中除了抽象方法外，可以有default修饰的默认方法，static修饰的静态方法，这两种方法都允许有方法体。</p>
<p>用interface修饰，可以extends多个接口。接口内部可以有final常量，定义常量时必须进行初始化赋值。</p>
<p>小提示：定义常量时<code>public static final</code>可省略，定义方法时<code>public abstract</code>可省略</p>
<p>调用静态方法：<code>接口名.方法名</code></p>
<p>调用抽象方法和默认方法需要通过接口实现类的实例对象来调用。默认方法不需要子类中实现。</p>
<p><code>public interface Hockey extends Sports, Event</code>   接口的多继承</p>
<p>一个类可以在继承一个类的同时实现多个接口：<code>public class 类名 extends 类名 implements 接口1，接口2</code>  ，extend需要在前面</p>
<blockquote>
<p>注意：如果一个类通过implement实现接口，如果该类是抽象类，则可以实现接口中的部分抽象方法，如果不是抽象类，则需要实现接口中的所有抽象方法。</p>
</blockquote>
<p>总结：类继承类（只能继承一个类，但同时可以实现多个接口），接口继承接口（可一次继承多个接口），类实现接口（可一次实现多个接口）</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指一个类中定义的属性和方法被其他类继承或重写后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现的多种不同形态。</p>
<p>把子类对象直接赋值给父类引用变量时，程序只有在运行时才知道该引用变量具体代表哪个子类对象。</p>
<h3 id="对象的类型转换"><a href="#对象的类型转换" class="headerlink" title="对象的类型转换"></a>对象的类型转换</h3><p>子类对象当作父类类型使用：向上转型</p>
<p><code>Animal an1=new Cat();</code>   不需要任何显示声明，但是不能通过父类变量去调用子类特有的方法。</p>
<p>要想使用子类特有的方法，需要将本质为Cat类型的an1对象由Animal类型向下转型为Cat类型。</p>
<p><code>Cat cat=(Cat)an1;</code> 就可以用cat变量来调用子类特有方法了。</p>
<p><code>instanceof</code>关键字，用来判断一个对象是否为某个类或接口的实例或子类实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal an1=new Cat();</span><br><span class="line">if(an1 instanceof Cat)&#123;</span><br><span class="line">    Cat cat=(Cat)an1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>java中允许一个类的内部定义类，这样的类叫内部类。内部类所在类叫外部类。根据内部类的位置、修饰符、定义方式的不同分为四种。</p>
<p>（1）成员内部类</p>
<p>像成员变量、成员方法一样的存在，在成员内部类中，可以访问外部类的所有成员。在外部类中，可以访问成员内部类的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">外部类访问内部类的成员：</span><br><span class="line">Inner inner = new Inner();</span><br><span class="line">inner.成员</span><br><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer out = new Outer();  创建外部类对象</span><br><span class="line">Outer.Inner in = new Inner();   创建内部类对象</span><br></pre></td></tr></table></figure>

<p>（2）局部内部类</p>
<p>也叫方法内部类，是定义在某个方法内的，有效范围仅限于方法内部。</p>
<p>局部内部类可以访问外部类所有成员，而只有在包含局部内部类的方法中才可以访问内部类的成员。</p>
<p>（3）静态内部类</p>
<p>使用static关键字修饰的成员内部类，静态内部类只能访问外部类的静态成员.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer.Inner inner = new Outer.Inner();</span><br><span class="line">inner.成员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般在刷题时，定义Solution类，类内定义成员方法实现算法。测试时，定义另一个类，类内main函数中输入输出，然后定义对象<code>Solution s = new Solution();</code>通过对象访问算法方法。</p>
</blockquote>
<p>（4）匿名内部类</p>
<p>在java中调用某个方法时，如果该方法的参数是一个接口类型，除了可以传入一个参数接口实现类，还可以使用匿名内部类实现接口来作为该方法的参数。</p>
<p>匿名内部类就是没有名称的内部类，在调用包含有接口类型参数的方法时，通常为了简化代码，不会创建一个接口的实现类作为方法参数传入，而是直接通过匿名内部类的形式传入一个接口类型参数，在匿名内部类中直接完成方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义动物类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String name=<span class="string">&quot;maomao&quot;</span>;</span><br><span class="line">		<span class="comment">//定义匿名内部类作为参数传递给animalShout方法</span></span><br><span class="line">		animalShout(<span class="keyword">new</span> Animal()&#123;</span><br><span class="line">		    <span class="comment">//匿名内部类中实现shout方法</span></span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">		    	<span class="comment">//JDK8开始，局部内部类、匿名内部类可以访问非final的局部变量</span></span><br><span class="line">		    	System.out.println(name+“喵喵”)；</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;)；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义静态方法animalShout(),接收接口类型参数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">animalShout</span><span class="params">(Animal an)</span></span>&#123;</span><br><span class="line">		an.shout(); <span class="comment">//调用传入对象的shout()方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分两步：</p>
<p>第一步 <code>animalShout(new Animal()&#123;&#125;)</code> 参数位置创建一个实例对象，表示创建的对象为Animal的子类实例，该子类是匿名的。</p>
<p>第二步<code>&#123;&#125;</code>中编写匿名子类的实现代码。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda 表达式，也可称为<strong>闭包</strong>，它是推动 Java 8 发布的最重要新特性。它使用一个清晰简洁的表达式来表达一个接口。</p>
<p>匿名内部类存在一个问题：如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然冗余。</p>
<p>Lambda表达式针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br><span class="line">可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</span><br><span class="line">可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</span><br><span class="line">可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</span><br><span class="line">可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，return可省略</span><br></pre></td></tr></table></figure>

<p>上面的例子，用lambda表达式来做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animalShout(()-&gt;System.out.println(name+“喵喵”);)</span><br></pre></td></tr></table></figure>

<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>Lambda表达式可以实现匿名内部类的功能，但是局限在于接口中只有一个抽象方法时才能使用Lambda表达式代替匿名内部类。</p>
<p>因为Lambda表达式是基于函数式接口实现的，函数式接口就是只有一个抽象方法的接口。</p>
<p>JDK8中专门为函数式接口引入@FunctionalInterface注解，显示地标识接口是一个函数式接口，如果不是编译器就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculate</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		showSum(<span class="number">10</span>, <span class="number">20</span>, (x,y)-&gt;x+y);  <span class="comment">//实现方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建参数为接口的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Calculate cu)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;和为：&quot;</span>+cu.sum(x, y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式的引用形式"><a href="#Lambda表达式的引用形式" class="headerlink" title="Lambda表达式的引用形式"></a>Lambda表达式的引用形式</h3><p>Lambda表达式的主体只有一条语句时，程序可通过<code>：：</code>的语法格式来引用方法和构造器。本质是对Lambda表达式的主体部分已存在的方法进行直接引用。</p>
<p>相当于calc方法需要实现，而又现成的abs方法可以用。</p>
<p>（1）类名引用普通方法/静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculate</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含静态方法的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&lt;<span class="number">0</span>)  <span class="keyword">return</span> -num;</span><br><span class="line">		<span class="keyword">else</span>  <span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAbs</span><span class="params">(<span class="keyword">int</span> num, Calculate cu)</span></span>&#123;</span><br><span class="line">		System.out.println(cu.calc(num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, n-&gt;Math.abs(n));</span><br><span class="line">		<span class="comment">//使用方法引用</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, Math::abs);  类名::类静态方法/普通方法名</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）对象名引用方法</p>
<p>也可以通过实例化对象的名称来对其方法进行引用。是普通方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math ma = new Math();</span><br><span class="line">printAbs(-10, n-&gt;ma.abs(n));</span><br><span class="line">printAbs(-10,ma::abs);</span><br></pre></td></tr></table></figure>

<p>（3）构造器引用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">buildPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个Person类，并添加有参构造方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(String name, PersonBuilder bu)</span></span>&#123;</span><br><span class="line">		System.out.println(bu.buildPerson(name).getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式   ()-&gt;new 类名()</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, name-&gt;<span class="keyword">new</span> Person(name));</span><br><span class="line">		<span class="comment">//使用方法引用    类名::new</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, Person::<span class="keyword">new</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>java语言引入了异常，以异常类的形式对正常情况进行封装。</p>
<p>异常类都继承自java.lang.Throwable类。</p>
<p>Throwable有两个直接子类Error和Exception。</p>
<p>其中Error称为错误类，代表Java运行时产生的系统内部错误或资源耗尽的错误，如系统崩溃、虚拟机错误。</p>
<p>Exception类称为异常类，标识程序本身可以处理的错误，异常处理都是针对该类及其子类。RuntimeException表示运行时异常，其他表示编译时异常。</p>
<p>Throwable类中常用的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String getMessage()</span><br><span class="line">返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</span><br><span class="line">public void printStackTrace()</span><br><span class="line">打印toString()结果和栈层次到System.err，即错误输出流。</span><br><span class="line">public Throwable getCause()</span><br><span class="line">返回一个Throwable 对象代表异常原因。</span><br></pre></td></tr></table></figure>

<p>运行时异常是在程序运行时由Java虚拟机自动进行捕获处理的。例如数组越界。</p>
<h3 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在除法方法中：</span><br><span class="line">try&#123;</span><br><span class="line">   可能发生异常的语句</span><br><span class="line">&#125;catch(Exception类或其子类 e1)&#123;</span><br><span class="line">   对捕获的异常进行相应的处理</span><br><span class="line">   System.out.println(&quot;异常：&quot;+e1.getMessage());</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	无论程序是否异常都会执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try{}中的代码块发生异常，系统会将这个异常的信息封装成一个异常对象，传递给catch(){}代码块，catch代码块需要一个参数指明它所能接收的异常类型，必须是Exception类或其子类。</p>
<p>finally{}中的代码不受return语句和程序异常的影响，可以用来完成必须要做的事，例如释放系统资源、关闭线程池等。但是在try…catch…代码块中执行了<code>System.exit(0)</code>语句的话，finally不会执行，因为<code>System.exit(0)</code>表示退出当前的java虚拟机。</p>
<h3 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h3><p>用于将异常从当前方法中抛出，throws写在方法声明的后面，后跟声明方法中发生异常的类型，这种做法叫做方法申明抛出一个异常。一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int divide(int x, int y) throws Exception&#123;</span><br><span class="line">	int res=x/y;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了throws后，还需要再出现异常的代码（main中）处使用try…catch…代码块进行捕获处理。</p>
<h3 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h3><p>throw用于方法体内，并且抛出的是一个异常类对象。</p>
<p>通过throw关键字抛出异常后，还需要try…catch…或throws关键字对异常进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void deposit(double amount) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">  if(判断)&#123;</span><br><span class="line">      throw new Exception(&quot;异常&quot;); //可以用来指示异常信息</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throw抛出异常对象，然后通过throws关键字抛出异常，最后通过try…catch…语句捕获异常。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>java允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类。在构造方法中使用super()语句调用Exception的构造方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 	<span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();  <span class="comment">//调用无参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(message);  <span class="comment">//调用有参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>java提供垃圾回收机制（Java GC），虚拟机会自动回收垃圾对象所占用的内存空间。</p>
<p>当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分为三种：</p>
<p>（1）可用状态：对象被创建后，有一个以上的引用变量引用它，那么这个对象在程序中将处于可用状态，程序可以通过引用变量来调用该对象的实例变量和方法。</p>
<p>（2）可恢复状态：程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。系统准备回收，回收之前会调用可恢复状态对象的<code>finalize()</code>方法进行资源清理。如果在调用<code>finalize()</code>方法之前重新使一个引用变量引用该对象，则这个对象会再次变为可用对象。</p>
<p>（3）不可用状态：调用<code>finalize()</code>方法后，对象进入不可用状态，内存被清理。</p>
<blockquote>
<p>一个对象在失去引用成为垃圾后，会暂时保存在内存中，垃圾堆积到一定程度时，java虚拟机会启动垃圾回收器将这些垃圾对象从内存中释放，也就说回收的时机无法把握。</p>
</blockquote>
<p>强制系统进行垃圾回收的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br><span class="line">或：</span><br><span class="line">Runtime.getRuntime().gc();</span><br></pre></td></tr></table></figure>

<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>当一个对象在内存中被释放时，它的<code>finalize()</code>方法会自动调用，<code>finalize()</code>方法是定义在Object类中的实例方法，方法原型：</p>
<p><code>protected void finalize() throws Throwable&#123;&#125;</code></p>
<p>任何java类都可以重写Object类的<code>finalize()</code>方法，在该方法中清理对象占用的资源。重写实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">	public void finalize()&#123;</span><br><span class="line">		System.out.println(&quot;d&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/" class="post-title-link" itemprop="url">javaのleecode二叉树篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-07 16:56:08 / Modified: 20:17:04" itemprop="dateCreated datePublished" datetime="2021-11-07T16:56:08+08:00">2021-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二叉树的输入和遍历"><a href="#二叉树的输入和遍历" class="headerlink" title="二叉树的输入和遍历"></a>二叉树的输入和遍历</h2><p>二叉树定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序创建二叉树：输入一个节点回车一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入二叉树！&quot;</span>);</span><br><span class="line">        TreeNode root = creatTree();</span><br><span class="line">        ArrayList&lt;Integer&gt; qianxu = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        qianxu=preOrderReverse(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>+qianxu);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照前序遍历方式创建二叉树，0代表空，例如1左2右3：1200300</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">creatTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeNode root;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="comment">//回车结束输入</span></span><br><span class="line">        <span class="comment">//Scanner in=new Scanner(System.in);</span></span><br><span class="line">        <span class="comment">//num=in.nextInt();</span></span><br><span class="line">        <span class="comment">//还是回车结束</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.next();</span><br><span class="line">        num=Integer.parseInt(str);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            root=<span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root=<span class="keyword">new</span> TreeNode(num);</span><br><span class="line">            root.left=creatTree();</span><br><span class="line">            root.right=creatTree();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归法进行遍历</span></span><br><span class="line">    <span class="comment">//前序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">preOrderReverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);           <span class="comment">// 注意这一句</span></span><br><span class="line">        preOrder(root.left, result);</span><br><span class="line">        preOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序创建二叉树：输入一个节点空格一次，一行输入。</p>
<h2 id="前中后序遍历，用递归，带输入输出"><a href="#前中后序遍历，用递归，带输入输出" class="headerlink" title="前中后序遍历，用递归，带输入输出"></a>前中后序遍历，用递归，带输入输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建二叉树</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入二叉树！&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">            b[j] = Integer.parseInt(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = creatTree(b);</span><br><span class="line">        <span class="comment">//前序遍历</span></span><br><span class="line">        ArrayList&lt;Integer&gt; qianxu = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        qianxu=preOrderReverse(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>+qianxu);</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        List&lt;Integer&gt; zhongxu = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        zhongxu=inorderTraversal(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>+zhongxu);</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        List&lt;Integer&gt; houxu = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        houxu=postorderTraversal(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历：&quot;</span>+houxu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照前序遍历方式创建二叉树，0代表空，例如1左2右3：1200300</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">creatTree</span><span class="params">(<span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">        TreeNode root;</span><br><span class="line">        <span class="keyword">int</span> num=b[t++];</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root=<span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        root.left=creatTree(b);</span><br><span class="line">        root.right=creatTree(b);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归法进行遍历</span></span><br><span class="line">    <span class="comment">//前序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">preOrderReverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);           <span class="comment">// 注意这一句</span></span><br><span class="line">        preOrder(root.left, result);</span><br><span class="line">        preOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, list);</span><br><span class="line">        postorder(root.right, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前中后序遍历，用迭代"><a href="#前中后序遍历，用迭代" class="headerlink" title="前中后序遍历，用迭代"></a>前中后序遍历，用迭代</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur = stack.pop();</span><br><span class="line">               result.add(cur.val);</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//checkFun01(root,0);</span></span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS--递归方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFun01</span><span class="params">(TreeNode node, Integer deep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resList.size() &lt; deep) &#123;</span><br><span class="line">            <span class="comment">//当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS--迭代方式--借助队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFun02</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> len = que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="keyword">null</span>) que.offer(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="keyword">null</span>) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226题-翻转二叉树"><a href="#226题-翻转二叉树" class="headerlink" title="226题.翻转二叉树"></a>226题.翻转二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前后序遍历都可以</span></span><br><span class="line"><span class="comment">     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        swapChildren(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapChildren</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = deque.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = deque.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;deque.offer(node.left);&#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;deque.offer(node.right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101题-对称二叉树"><a href="#101题-对称二叉树" class="headerlink" title="101题.对称二叉树"></a>101题.对称二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较外侧</span></span><br><span class="line">        <span class="keyword">boolean</span> compareOutside = compare(left.left, right.right);</span><br><span class="line">        <span class="comment">// 比较内侧</span></span><br><span class="line">        <span class="keyword">boolean</span> compareInside = compare(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> compareOutside &amp;&amp; compareInside;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用双端队列，相当于两个栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.offerFirst(root.left);</span><br><span class="line">        deque.offerLast(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            TreeNode leftNode = deque.pollFirst();</span><br><span class="line">            TreeNode rightNode = deque.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> &amp;&amp; rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> || rightNode == <span class="keyword">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerFirst(leftNode.left);</span><br><span class="line">            deque.offerFirst(leftNode.right);</span><br><span class="line">            deque.offerLast(rightNode.right);</span><br><span class="line">            deque.offerLast(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用普通队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric3</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.offer(root.left);</span><br><span class="line">        deque.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            TreeNode leftNode = deque.poll();</span><br><span class="line">            TreeNode rightNode = deque.poll();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> &amp;&amp; rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> || rightNode == <span class="keyword">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里顺序与使用Deque不同</span></span><br><span class="line">            deque.offer(leftNode.left);</span><br><span class="line">            deque.offer(rightNode.right);</span><br><span class="line">            deque.offer(leftNode.right);</span><br><span class="line">            deque.offer(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="257题-二叉树的所有路径"><a href="#257题-二叉树的所有路径" class="headerlink" title="257题.二叉树的所有路径"></a>257题.二叉树的所有路径</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; paths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        traversal(root, paths, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        paths.add(root.val);</span><br><span class="line">        <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                sb.append(paths.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(paths.get(paths.size() - <span class="number">1</span>));</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traversal(root.left, paths, res);</span><br><span class="line">            paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traversal(root.right, paths, res);</span><br><span class="line">            paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="39题-组合总和"><a href="#39题-组合总和" class="headerlink" title="39题.组合总和"></a>39题.组合总和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br><span class="line">说明：</span><br><span class="line">所有数字（包括 target）都是正整数。</span><br><span class="line">解集不能包含重复的组合。</span><br><span class="line">示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剪枝优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates); <span class="comment">// 先进行排序</span></span><br><span class="line">        backtracking(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到了数字和为 target 的组合</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(res, path, candidates, target, sum + candidates[i], i);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯，移除路径 path 最后一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/" class="post-title-link" itemprop="url">javaのleecode字符串篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-07 13:42:43 / Modified: 15:04:08" itemprop="dateCreated datePublished" datetime="2021-11-07T13:42:43+08:00">2021-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>char ch : s.<strong>toCharArray()</strong>  遍历字符串中的字符。c++中的 ch：s 不可用。</p>
<p>字符串中，获得第几个字符，不能用s[i]，而是：s.<strong>charAt(i)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.setCharAt(<span class="number">0</span>,<span class="string">&#x27;v&#x27;</span>);  <span class="comment">//替换某位置的字符</span></span><br></pre></td></tr></table></figure>

<h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Runoob&quot;;</span><br><span class="line">String str2=new String(&quot;Runoob&quot;);</span><br><span class="line">String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</span><br><span class="line">char[] helloArray = &#123; &#x27;r&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;b&#x27;&#125;;</span><br><span class="line">String helloString = new String(helloArray);  </span><br></pre></td></tr></table></figure>

<p>**注意:**String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。</p>
<p>如果需要对字符串做很多修改，那么应该选择使用 [StringBuffer &amp; StringBuilder 类]。</p>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String site = &quot;www.runoob.com&quot;;</span><br><span class="line">int len = site.length();   (结果为14)</span><br></pre></td></tr></table></figure>

<h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;我的名字是 &quot;.concat(&quot;Runoob&quot;);</span><br><span class="line">String string1 = &quot;菜鸟教程网址：&quot;;     </span><br><span class="line">System.out.println(&quot;1、&quot; + string1 + &quot;www.runoob.com&quot;);  </span><br></pre></td></tr></table></figure>

<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(字符串变量的值为%s&quot;, stringVar);</span><br><span class="line">String fs;</span><br><span class="line">fs = String.format(&quot; 字符串变量的值为 %s&quot;, stringVar);</span><br></pre></td></tr></table></figure>

<h3 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h3><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p>
<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，<strong>所以如果需要对字符串进行修改推荐使用 StringBuffer。</strong></p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，<strong>所以多数情况下建议使用 StringBuilder 类。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder(10);  //定大小</span><br><span class="line">sb.append(&quot;Runoob..&quot;);    //在容量内加</span><br><span class="line">sb.insert(8, &quot;Java&quot;);    //在容量外加</span><br><span class="line">System.out.println(sb); </span><br><span class="line">sb.delete(5,8);    //删除</span><br><span class="line">变成string字符串：  res.toString();</span><br></pre></td></tr></table></figure>

<p><strong>在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类</strong>。</p>
<h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Str.substring(4)   从4开始，包括4</span><br><span class="line">Str.substring(4, 10)   左闭右开，包括4不包括10</span><br></pre></td></tr></table></figure>

<h3 id="字符串转换为int"><a href="#字符串转换为int" class="headerlink" title="字符串转换为int"></a>字符串转换为int</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.valueOf(&quot;444&quot;,16)  //16进制</span><br><span class="line">Integer.parseInt(arr[j]);</span><br></pre></td></tr></table></figure>

<h3 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb=new StringBuilder(s);</span><br><span class="line">return sb.reverse().toString();</span><br></pre></td></tr></table></figure>

<h2 id="344题-反转字符串"><a href="#344题-反转字符串" class="headerlink" title="344题.反转字符串"></a>344题.反转字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</span><br><span class="line">不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</span><br><span class="line">示例 1：</span><br><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p>思路：一头一尾双指针，交换即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            s[l] ^= s[r]; </span><br><span class="line">            s[r] ^= s[l];  </span><br><span class="line">            s[l] ^= s[r];  </span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="541题-反转字符串Ⅱ"><a href="#541题-反转字符串Ⅱ" class="headerlink" title="541题.反转字符串Ⅱ"></a>541题.反转字符串Ⅱ</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</span><br><span class="line">如果剩余字符少于 k 个，则将剩余字符全部反转。</span><br><span class="line">如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</span><br><span class="line">示例:</span><br><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;bacdfeg&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解法一：用StringBuffer类，对字符串进行改变。用到append（）方法、substring方法（）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; length) &#123;</span><br><span class="line">            <span class="comment">// 找到k处和2k处</span></span><br><span class="line">            StringBuffer temp = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="comment">// 与length进行判断，如果大于length了，那就将其置为length</span></span><br><span class="line">            <span class="keyword">int</span> firstK = (start + k &gt; length) ? length : start + k;</span><br><span class="line">            <span class="keyword">int</span> secondK = (start + (<span class="number">2</span> * k) &gt; length) ? length : start + (<span class="number">2</span> * k);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//无论start所处位置，至少会反转一次</span></span><br><span class="line">            temp.append(s.substring(start, firstK));</span><br><span class="line">            res.append(temp.reverse());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果firstK到secondK之间有元素，这些元素直接放入res里即可。</span></span><br><span class="line">            <span class="keyword">if</span> (firstK &lt; secondK) &#123; <span class="comment">//此时剩余长度一定大于k。</span></span><br><span class="line">                res.append(s.substring(firstK, secondK));</span><br><span class="line">            &#125;</span><br><span class="line">            start += (<span class="number">2</span> * k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：用char型数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="comment">//这里是判断尾数够不够k个来取决end指针的位置</span></span><br><span class="line">            <span class="keyword">int</span> end = Math.min(ch.length - <span class="number">1</span>, start + k - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//用异或运算反转 </span></span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                ch[end] ^= ch[start];</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);   <span class="comment">//char型数组变string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指offer05-替换空格"><a href="#剑指offer05-替换空格" class="headerlink" title="剑指offer05.替换空格"></a>剑指offer05.替换空格</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br><span class="line">示例 1： 输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<p>思路：直接用一个stringbuilder来新建字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//选用 StringBuilder 单线程使用，比较快</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//碰到空格则替换，否则直接复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">		<span class="comment">//str.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot; &quot;</span>.equals(String.valueOf(s.charAt(i))))&#123;</span><br><span class="line">        <span class="comment">//.valueOf类型转换，类似parseInt也可以string转int</span></span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，逐个翻转字符串中的每个单词。</span><br><span class="line">示例 1：</span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<p>思路：首先将整个字符串反转过来，然后将字符串中的单词反转一下，即可。</p>
<ul>
<li>移除多余空格 : “the sky is blue”</li>
<li>字符串反转：”eulb si yks eht”</li>
<li>单词反转：”blue is sky the”</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.reverseWords2() called with: s = [&quot; + s + &quot;]&quot;);</span></span><br><span class="line">        <span class="comment">// 1.去除首尾以及中间多余空格</span></span><br><span class="line">        StringBuilder sb = removeSpace(s);</span><br><span class="line">        <span class="comment">// 2.反转整个字符串</span></span><br><span class="line">        reverseString(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.反转各个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">removeSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(start) == <span class="string">&#x27; &#x27;</span>) start++;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseEachWord</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = sb.length();</span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseString(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer58-II-左旋转字符串"><a href="#剑指Offer58-II-左旋转字符串" class="headerlink" title="剑指Offer58-II.左旋转字符串"></a>剑指Offer58-II.左旋转字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<p>思路：如果要求不申请额外空间</p>
<ol>
<li>反转区间为前n的子串</li>
<li>反转区间为n到末尾的子串</li>
<li>反转整个字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        reverseString(sb,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        reverseString(sb,n,len-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//翻转函数</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="459题-重复的子字符串"><a href="#459题-重复的子字符串" class="headerlink" title="459题.重复的子字符串"></a>459题.重复的子字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</span><br><span class="line">输入: &quot;abab&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure>

<p>思路：KMP算法，KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>
<p>KMP的精髓所在就是前缀表，前缀表：起始位置到下表i之前（包括i）的子串中，有多大长度的相同前缀后缀。</p>
<p>前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。</p>
<p>后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了</span></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 构造 next 数组过程，j从0开始(空格)，i从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 匹配不成功，j回到前一位置 next 数组所对应的值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">// 匹配成功，j往后移</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">// 更新 next 数组的值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值</span></span><br><span class="line">        <span class="keyword">if</span> (next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">javaのleecode栈与队列篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-07 13:42:43 / Modified: 15:03:52" itemprop="dateCreated datePublished" datetime="2021-11-07T13:42:43+08:00">2021-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Character&gt; st = new Stack&lt;Character&gt;();</span><br><span class="line">或</span><br><span class="line">Deque&lt;Character&gt; st = new LinkedList&lt;Character&gt;();</span><br><span class="line">st.isEmpty()</span><br><span class="line">st.peek()</span><br><span class="line">st.pop();</span><br><span class="line">st.push(ch);</span><br></pre></td></tr></table></figure>

<h2 id="20题-有效的括号"><a href="#20题-有效的括号" class="headerlink" title="20题.有效的括号"></a>20题.有效的括号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串，判断字符串是否有效。</span><br><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        if (n % 2 == 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = new HashMap&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">            put(&#x27;)&#x27;, &#x27;(&#x27;);</span><br><span class="line">            put(&#x27;]&#x27;, &#x27;[&#x27;);</span><br><span class="line">            put(&#x27;&#125;&#x27;, &#x27;&#123;&#x27;);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        //Deque&lt;Character&gt; stack = new LinkedList&lt;Character&gt;();</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            char ch = s.charAt(i);</span><br><span class="line">            if (pairs.containsKey(ch)) &#123;</span><br><span class="line">                if (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue1= new LinkedList&lt;&gt;();</span><br><span class="line">queue1.isEmpty()</span><br><span class="line">queue2.offer(x);   //添加一个元素并返回true   如果队列已满，则返回false</span><br><span class="line">queue1.poll()   //移除并返问队列头部的元素  如果队列为空，则返回null</span><br><span class="line">queue1.peek()  //返回队列头部的元素   如果队列为空，则返回null</span><br><span class="line">remove   移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常</span><br><span class="line">element  返回队列头部的元素  如果队列为空，则抛出一个NoSuchElementException异常</span><br><span class="line">add       增加一个元索   如果队列已满，则抛出一个IIIegaISlabEepeplian异常</span><br><span class="line">put       添加一个元素  如果队列满，则阻塞</span><br><span class="line">take      移除并返回队列头部的元素    如果队列为空，则阻塞</span><br><span class="line"></span><br><span class="line">1、add()和offer()区别:</span><br><span class="line">add()和offer()都是向队列中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。因此就可以在程序中进行有效的判断！</span><br><span class="line"></span><br><span class="line"> 2、poll()和remove()区别：</span><br><span class="line">remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。</span><br><span class="line"></span><br><span class="line">3、element() 和 peek() 区别：</span><br><span class="line">element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。</span><br></pre></td></tr></table></figure>

<h2 id="deque与queue"><a href="#deque与queue" class="headerlink" title="deque与queue"></a>deque与queue</h2><p><strong>Queue</strong>是简单的FIFO队列，<strong>Deque</strong>继承<strong>Queue</strong>实现双端队列。</p>
<p>队列(queue)是一种常用的<strong>数据结构</strong>，可以将队列看做是一种特殊的线性表，该结构遵循的先进先出原则。Java中，<strong>LinkedList实现了Queue接口</strong>,因为LinkedList进行插入、删除操作效率较高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      抛出异常	返回特殊值</span><br><span class="line">插入	add(e)	offer(e)</span><br><span class="line">移除	remove()	poll()</span><br><span class="line">检查	element()	peek()</span><br><span class="line"></span><br><span class="line">boolean add(E e);将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。</span><br><span class="line">boolean offer(E e);将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。</span><br><span class="line">E remove();获取并移除此队列的头。</span><br><span class="line">E poll();获取并移除此队列的头，如果此队列为空，则返回 null。</span><br><span class="line">E element();获取，但是不移除此队列的头。</span><br><span class="line">E peek();获取但不移除此队列的头；如果此队列为空，则返回 null。</span><br></pre></td></tr></table></figure>

<p>双向队列<strong>Deque</strong>继承了<strong>Queue</strong>，此队列两端都能进行出列和入列操作。除了继承了<strong>Queue</strong>的接口，又对每种方法额外添加了<code>first</code>与<code>last</code>方法用以实现操作双端队列。</p>
<h3 id="队列queue的使用："><a href="#队列queue的使用：" class="headerlink" title="队列queue的使用："></a>队列queue的使用：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Queue&lt;String&gt;que = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        que.offer(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        que.offer(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        que.offer(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的队列：&quot;</span>+que);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str=que.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的队列：&quot;</span>+que);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向队列deque的使用："><a href="#双向队列deque的使用：" class="headerlink" title="双向队列deque的使用："></a>双向队列deque的使用：</h3><p>第一种用法：同queue一样，作为单向队列使用，此时使用offer入列，poll出列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDeque1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Deque&lt;String&gt; deq = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        deq.offer(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        deq.offer(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        deq.offer(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的队列：&quot;</span>+deq);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(deq.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str=deq.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的队列：&quot;</span>+deq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种用法：作为双向队列使用，此时使用offerFirst、pollFirst，offerLast、pollFirst，则可以实现队首队尾入列或者出列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDeque2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Deque&lt;String&gt; deq2 = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        deq2.offerLast(<span class="string">&quot;aa&quot;</span>);  <span class="comment">//从后面进入</span></span><br><span class="line">        deq2.offerLast(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        deq2.offerLast(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的队列：&quot;</span>+deq2);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(deq2.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str= deq2.pollFirst();  <span class="comment">//从前面输出</span></span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的队列：&quot;</span>+deq2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种用法：作为栈来使用，遵循先入后出的原则，使用push和pop进行入栈和出栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDeque3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Deque&lt;String&gt; st = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        st.push(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        st.push(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        st.push(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的栈：&quot;</span>+st);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(st.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str= st.pop(); </span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的栈：&quot;</span>+st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>queue是单向队列，遵循先入先出的原则，而deque是queue的子接口，不仅可以作为单向队列使用，同时可以作为双向队列使用，根据入列出列在队尾或者队首决定输出元素顺序，在使用push和poll方法时，deque被称为栈，实现先入后出的原则。</p>
<h2 id="239题-滑动窗口最大值"><a href="#239题-滑动窗口最大值" class="headerlink" title="239题.滑动窗口最大值"></a>239题.滑动窗口最大值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span><br><span class="line">返回滑动窗口中的最大值。</span><br><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br></pre></td></tr></table></figure>

<p>思路：单调队列，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。</p>
<p>每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回我们要的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用双端队列手动实现单调队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span></span><br><span class="line">            <span class="comment">// 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="number">1</span>)&#123;</span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            deque.offer(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">                res[idx++] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="347题-前K个高频元素（优先级队列）"><a href="#347题-前K个高频元素（优先级队列）" class="headerlink" title="347题.前K个高频元素（优先级队列）"></a>347题.前K个高频元素（优先级队列）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</span><br><span class="line">示例 1:</span><br><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<p>思路：统计元素出现的频率，对频率进行排序，找出前k个高频元素。首先统计元素出现的频率，这一类的问题可以使用map来进行统计。然后是对频率进行排序，这里我们可以使用一种 容器适配器就是<strong>优先级队列</strong>。</p>
<p>优先级队列：其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p>
<p>而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？</p>
<p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。</p>
<p><strong>堆是一颗完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p>
<p>大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p>
<p>本题<strong>要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="comment">// 根据map的value值正序排，相当于一个小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123;</span><br><span class="line">            queue.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; k) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = queue.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/03/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/03/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/" class="post-title-link" itemprop="url">javaのleecode哈希表篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-03 21:33:12" itemprop="dateCreated datePublished" datetime="2021-11-03T21:33:12+08:00">2021-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 17:03:30" itemprop="dateModified" datetime="2021-11-07T17:03:30+08:00">2021-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
<p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p>
<p>哈希函数、哈希碰撞：拉链法。线性探测法（要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了）</p>
<p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<h3 id="Java中Map与HashMap-Hashtable-HashSet的区别"><a href="#Java中Map与HashMap-Hashtable-HashSet的区别" class="headerlink" title="Java中Map与HashMap,Hashtable,HashSet的区别"></a>Java中Map与HashMap,Hashtable,HashSet的区别</h3><p>HashMap和Hashtable两个类都实现了Map接口，二者保存K-V对（key-value对）；HashSet则实现了Set接口，性质类似于集合。</p>
<p>HashTable和HashMap区别：</p>
<p>一、继承的父类不同<br>Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。<br>二、线程安全性不同<br>Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理。<br>三、是否提供contains方法<br>HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。<br>Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。<br>四、key和value是否允许null值<br>其中key和value都是对象，并且不能包含重复key，但可以包含重复的value。<br>Hashtable中，key和value都不允许出现null值。<br>HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。<br>五、两个遍历方式的内部实现上不同<br>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。<br>六、hash值不同<br>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。<br>七、内部实现使用的数组初始化和扩容方式不同<br>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。<br>HashMap中hash数组的默认大小是16，而且一定是2的指数。</p>
<h2 id="242题-有效的字母异位词"><a href="#242题-有效的字母异位词" class="headerlink" title="242题.有效的字母异位词"></a>242题.有效的字母异位词</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</span><br><span class="line">示例 1: 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true</span><br><span class="line">示例 2: 输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false</span><br></pre></td></tr></table></figure>

<p>思路：用map，先遍历一个往里加，再遍历另一个减，如果没有或者value是0，则false。看到只有小写字母，所以长度为26的数组来充当map也可以。</p>
<p>知识：char ch : s.<strong>toCharArray()</strong>  遍历字符串中的字符。c++中的 ch：s 不可用。</p>
<p>字符串中，获得第几个字符，不能用s[i]，而是：s.<strong>charAt(i)</strong></p>
<p>判断map中是否有某key：if(!m.containsKey(ch))</p>
<p>获得key对应的value：m.get(key)</p>
<p>改变某key的value，直接覆盖？不能：m[i]++;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt;m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())&#123;</span><br><span class="line">        <span class="comment">//数组的长度length不加括号，字符串的长度要加括号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m.containsKey(ch))&#123;</span><br><span class="line">                m.put(ch,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m.put(ch, m.get(ch)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:t.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m.containsKey(ch) || m.get(ch)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//a==0 和 a.equals(0) 一样</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m.put(ch, m.get(ch)-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方法：单纯的字符串排序比较</p>
<p>首先将字符串变成字符数组，然后进行排序，然后进行比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="349题-两个数组的交集"><a href="#349题-两个数组的交集" class="headerlink" title="349题.两个数组的交集"></a>349题.两个数组的交集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定两个数组，编写一个函数来计算它们的交集。</span><br><span class="line">说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</span><br></pre></td></tr></table></figure>

<p>思路：哈希set即可。一个遍历得到数字，一个存储结果。</p>
<p>int[] 是固定长数组，没法像vector一样push_back</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组2的过程中判断哈希表中是否存在该元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">                resSet.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] resArr = <span class="keyword">new</span> <span class="keyword">int</span>[resSet.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将结果几何转为数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : resSet) &#123;  <span class="comment">//数组、set可以这样做，string不行</span></span><br><span class="line">            resArr[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="202题-快乐数"><a href="#202题-快乐数" class="headerlink" title="202题.快乐数"></a>202题.快乐数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</span><br></pre></td></tr></table></figure>

<p>思路：使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p>
<p>知识：set判断某数是否存在：s.contains(i);</p>
<p>set添加一个数：s.add(i);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; record = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !record.contains(n)) &#123;</span><br><span class="line">            record.add(n);</span><br><span class="line">            n = getsum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得n各位平方后的和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n % <span class="number">10</span>;</span><br><span class="line">            res += temp * temp;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="454题-四数相加"><a href="#454题-四数相加" class="headerlink" title="454题.四数相加"></a>454题.四数相加</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</span><br><span class="line"></span><br><span class="line">为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</span><br></pre></td></tr></table></figure>

<p>思路：用一个map代表双层循环，另外再来个双层循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span>[] nums3, <span class="keyword">int</span>[] nums4)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计两个数组中的元素之和，同时统计出现的次数，放入map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : nums2) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line">                    map.put(temp, map.get(temp) + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(temp, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : nums4) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15题-三数之和"><a href="#15题-三数之和" class="headerlink" title="15题.三数之和"></a>15题.三数之和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</span><br><span class="line">注意： 答案中不可以包含重复的三元组。</span><br><span class="line">示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</span><br></pre></td></tr></table></figure>

<p>思路：难点在于去重</p>
<p>方法一：两层循环，第二层加一个set。注意去重。</p>
<p>方法二：双指针法，其实是三指针，i指针后，left和right。三数之和如果大了，右指针左移，小了，左指针右移。</p>
<p>知识：动态数组ArrayList。添加数：result.add(Arrays.asList(nums[i], nums[left], nums[right])); （）asList是降int[]变成list的意思。</p>
<p>数组int[] 排序：Arrays.sort(nums);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    right--; </span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18题-四数之和"><a href="#18题-四数之和" class="headerlink" title="18题.四数之和"></a>18题.四数之和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span><br><span class="line">注意：答案中不可以包含重复的四元组。</span><br><span class="line">示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</span><br></pre></td></tr></table></figure>

<p>四数之和，和15.三数之和是一个思路，都是使用双指针法, 基本解法就是在15.三数之和的基础上再套一层for循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); </span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jade liu"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Jade liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jadeliuliu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jadeliuliu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jadeliu1998@163.com" title="E-Mail → mailto:jadeliu1998@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jadeliu1998" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;jadeliu1998" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5823044646" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5823044646" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jade liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
