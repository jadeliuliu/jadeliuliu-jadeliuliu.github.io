<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mac下vscode配置cpp环境</title>
    <url>/2021/08/23/myblog/cpp%E4%BF%AE%E7%82%BC/Mac%E4%B8%8Bvscode%E9%85%8D%E7%BD%AEcpp%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="1-安装vscode"><a href="#1-安装vscode" class="headerlink" title="1.安装vscode"></a>1.安装vscode</h3><h3 id="2-插件安装"><a href="#2-插件安装" class="headerlink" title="2.插件安装"></a>2.插件安装</h3><p>安装“C/C++”、“C/C++ Clang Command Adapter”</p>
<h3 id="3-新建cpp文件"><a href="#3-新建cpp文件" class="headerlink" title="3.新建cpp文件"></a>3.新建cpp文件</h3><h3 id="4-配置1-c-cpp-properties-json"><a href="#4-配置1-c-cpp-properties-json" class="headerlink" title="4.配置1 c_cpp_properties.json"></a>4.配置1 c_cpp_properties.json</h3><p>按 <code>Command + Shift + P</code> 打开命令行面板，输入 <code>C/Cpp: Edit Configurations</code>命令<br>此时会在当前工作空间目录生成.vscode配置目录<br>同时在配置目录会生成一个c_cpp_properties.json文件</p>
<p>将要用到的库的路径添加到includePath数组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Mac&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                        &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">                        &quot;/Library/Developer/CommandLineTools/usr/include/c++/v1&quot;,</span><br><span class="line">                        &quot;/usr/local/include&quot;,</span><br><span class="line">                        &quot;/Library/Developer/CommandLineTools/usr/include&quot;,</span><br><span class="line">                    ],</span><br><span class="line">            &quot;defines&quot;: [],</span><br><span class="line">            &quot;macFrameworkPath&quot;: [</span><br><span class="line">                &quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;compilerPath&quot;: &quot;/usr/bin/clang&quot;,</span><br><span class="line">            &quot;cStandard&quot;: &quot;c17&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;c++98&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;macos-clang-x64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-配置2-tasks-json"><a href="#5-配置2-tasks-json" class="headerlink" title="5.配置2 tasks.json"></a>5.配置2 tasks.json</h3><p>按 <code>Command + Shift + P</code> 打开命令行面板，输入 <code>tasks</code>，选择 <code>Tasks:Configure Task</code> 生成 <code>tasks.json</code> 配置文件，选择的模板为MSBuild</p>
<p>该文件其实就是一个命令行构建工具<br>把运行程序时在终端输入的命令和参数对于”command”和”args”的值<br>输入shift+command+b，便可构建成功，生成可执行文件a.out</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // See https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">    // for the documentation about the tasks.json format</span><br><span class="line">        &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">        &quot;tasks&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;label&quot;: &quot;c++&quot;,</span><br><span class="line">                &quot;command&quot;: &quot;clang++&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">                &quot;args&quot;: [</span><br><span class="line">                    &quot;main.cpp&quot;,</span><br><span class="line">                    &quot;-std=c++11&quot;,</span><br><span class="line">                    &quot;-g&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;presentation&quot;: &#123;</span><br><span class="line">                    &quot;echo&quot;: true,</span><br><span class="line">                    &quot;reveal&quot;: &quot;always&quot;,</span><br><span class="line">                    &quot;focus&quot;: false,</span><br><span class="line">                    &quot;panel&quot;: &quot;new&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="6-配置3-launch-json"><a href="#6-配置3-launch-json" class="headerlink" title="6.配置3 launch.json"></a>6.配置3 <strong>launch.json</strong></h3><p>如果需要对项目进行进行 <code>debug</code>，则需要先生成 <code>launch.json</code> 文件并对其做相应的配置</p>
<ul>
<li><p>按 <code>Command + Shift + D</code> 进入到运行界面</p>
</li>
<li><p>点击 <code>创建 launch.json 文件</code>，选择 <code>C++(GDB/LLDB)</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;c/c++ Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/a.out&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: true,</span><br><span class="line">            &quot;MIMode&quot;: &quot;lldb&quot;,</span><br><span class="line">            &quot;preLaunchTask&quot;:&quot;c++&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>![image-20210816193726334](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210816193726334.png)</p>
<h3 id="7-shift-command-b编译失败"><a href="#7-shift-command-b编译失败" class="headerlink" title="7.shift+command+b编译失败"></a>7.shift+command+b编译失败</h3><p>于VScode报错“终端将被任务重用，按任意键关闭”的解决方案：</p>
<p>原因是本地端口是被共享的，所以必须关闭一个进程才能执行另一个，只需要对 <code>tasks.json</code>文件做一些修改即可。</p>
<p>tasks.json里把”panel”=”shared”改成：”panel”=”new”</p>
<h3 id="8-如何运行？"><a href="#8-如何运行？" class="headerlink" title="8.如何运行？"></a>8.如何运行？</h3><p>输入shift+command+b，便可构建成功，生成可执行文件a.out</p>
<p>编译完成后，会在项目路径下生成 <code>main</code> 文件，使用 <code>./main</code> 即可执行</p>
<hr>
<p>出现错误，重新参考，理解三个配置文件</p>
<hr>
<p>在配置环境之前先检查一下机器上都安装了什么C++编译器，通过以下两条命令可以查看是否安装了g++/clang编译器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ --version</span><br><span class="line">clang++ --version</span><br></pre></td></tr></table></figure>

<p>然后安装两个插件</p>
<p>然后新建工程目录，在里面新建一个cpp文件命名为main.cpp。</p>
<p>然后点击侧边栏的Debug按钮，点击设置图标，便会提示你选择环境，这里就选择C++那一项。</p>
<p>此时VSCode会在你的工程目录下自动新建一个.vscode的文件夹，并新建了一个launch.json的文件，这里需要对生成的文件进行一些小改动。本人配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;(lldb) Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/a.out&quot;,</span><br><span class="line">            //a.out 是需要运行的二进制文件可以改名</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: true,</span><br><span class="line">            &quot;MIMode&quot;: &quot;lldb&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后按快捷键⇧⌘B编译，此时会出现提示没有找到要运行的生成任务，所以接下来将进行生成任务的配置工作，VSCode提供了一些模版，有需要的可以自行选择，这里就选则Others。</p>
<p>此时.vscode目录下会出现一个task.json文件，对它进行改写。本人配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // See https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">    // for the documentation about the tasks.json format</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;hello world&quot;,  //描述</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;clang++&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">            </span><br><span class="line">                &quot;main.cpp&quot;  //文件名</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;:&quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;presentation&quot;: &#123;</span><br><span class="line">                &quot;echo&quot;: true,</span><br><span class="line">                &quot;reveal&quot;: &quot;always&quot;,</span><br><span class="line">                &quot;focus&quot;: false,</span><br><span class="line">                &quot;panel&quot;: &quot;new&quot;  //新建端口</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后再次按快捷键⇧⌘B就能够顺利编译了，编译完成后按F5执行，得到输出结果。</p>
<p>每次编译完成后，我们会发现目录下多了一个a.out文件，这个文件是Linux/Unix环境下编译器编译源代码并连接产生的可执行文件，在未指定的情况下其默认命名为a.out。那么如何通过修改配置文件来修改这个文件的命名呢？</p>
<p>方法很简单，在task.json中的args属性下填入<code>-o yourfilename.out</code></p>
<p>可以发现这里的command和args两个属性就相当于在命令行中执行了<code>clang++ -o yourfilename.out main.cpp</code>，所以如果还有其他的需求也可以对这里进行改写。最后不要忘记修改launch.json中的program属性，将.out的文件名修改为与task.json一致。便可以成功编译执行了。</p>
<hr>
<p>用了第二种之后，control+command+b 编译</p>
<p>再F5执行，不行，应该是branch文件配置的原因。</p>
<p>但是./\ app.out 可以运行。先这样。</p>
<p>参考：</p>
<p><a href="https://blog.csdn.net/qq_43119354/article/details/89219180?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/qq_43119354/article/details/89219180?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&amp;spm=1001.2101.3001.4242</a></p>
]]></content>
      <categories>
        <category>cpp开发</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>go-channel</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-channel/</url>
    <content><![CDATA[<h3 id="1-channel简介"><a href="#1-channel简介" class="headerlink" title="1.channel简介"></a>1.channel简介</h3><p>Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。</p>
<p>它的操作符是箭头 <strong>&lt;-</strong> 。用来协程间传递数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    // 发送值v到Channel ch中</span><br><span class="line">v := &lt;-ch  // 从Channel ch中接收数据，并将数据赋值给v</span><br><span class="line">ch := make(chan int, 100)  //容量(capacity)代表Channel容纳的最多的元素的数量，代表Channel的缓存的大小。</span><br><span class="line">如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞， 而只有缓存空了后receive才会阻塞。一个nil channel不会通信。</span><br><span class="line">close(ch)  //关闭channel</span><br></pre></td></tr></table></figure>

<p>无缓冲阻塞场景：1.没有协程在写却读   2.没有协程在读却写</p>
<p>有缓冲阻塞场景：1.缓冲中无数据却读  2.缓冲已满却写</p>
<p>无缓冲的channel，不管是入还是出，都会阻塞，所以在同一个goroutine中，不能同时对同一个无缓冲channel进行入和出操作；</p>
<p>带缓冲的channel，在队列满之前，不会阻塞；队列满之后，依然会阻塞。</p>
<h3 id="2-应用1：作为一个FIFO队列"><a href="#2-应用1：作为一个FIFO队列" class="headerlink" title="2.应用1：作为一个FIFO队列"></a>2.应用1：作为一个FIFO队列</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//用channel实现队列，查看是否原子性</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(ch))</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(ch))</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++&#123;</span><br><span class="line">    	ch &lt;- i+<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">30</span>)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="number">30</span>; j++&#123;</span><br><span class="line">		<span class="keyword">go</span> get(&amp;ch, &amp;wg, &amp;err)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(ch *<span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup, err *error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> x := &lt;- *ch:   <span class="comment">//如果可以读出，就读</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;get number: %d, channel size: %d\n&quot;</span>, x, <span class="built_in">len</span>(*ch))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:     <span class="comment">//失败返回</span></span><br><span class="line">	    fmt.Println(<span class="string">&quot;no number&quot;</span>)</span><br><span class="line">		*err = errors.New(<span class="string">&quot;channel has no data&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-应用2：实现类似sync-WaitGroup的同步"><a href="#3-应用2：实现类似sync-WaitGroup的同步" class="headerlink" title="3.应用2：实现类似sync.WaitGroup的同步"></a>3.应用2：实现类似sync.WaitGroup的同步</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//用sleep实现定时器</span></span><br><span class="line">	fmt.Println(time.Now())</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(time.Now())</span><br><span class="line">	<span class="comment">//用timer实现定时器</span></span><br><span class="line">	timer := time.NewTimer(time.Second)</span><br><span class="line">	fmt.Println(&lt;-timer.C)</span><br><span class="line">	<span class="comment">//用after实现定时器</span></span><br><span class="line">	fmt.Println(&lt;-time.After(time.Second))</span><br><span class="line">	<span class="comment">//周期定时</span></span><br><span class="line">	tiker := time.NewTicker(time.Second)</span><br><span class="line">	<span class="keyword">for</span> i :=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++&#123;</span><br><span class="line">			fmt.Println(&lt;-tiker.C)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//定时完成的操作写在协程里</span></span><br><span class="line">	ticker := time.NewTicker(time.Second * <span class="number">3</span>)</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  <span class="comment">//该channel完成同步，实现下面的协程执行完主线程才结束</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">		<span class="keyword">for</span> x &lt; <span class="number">10</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">				x++</span><br><span class="line">				fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, x)</span><br><span class="line">				fmt.Println(time.Now())</span><br><span class="line">				time.Sleep(time.Second * <span class="number">1</span>)  <span class="comment">//case里的操作不要超过定时时间，不然会不符合预期</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ticker.Stop()</span><br><span class="line">		ch &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-ch</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">//这里的channel 实现了一个 sync.WaitGroup的效果，主进程直接到&lt;-ch，无拥塞channel，里面没东西，直接拿是会阻塞的，直到里面有东西</span></span><br><span class="line"><span class="comment">//也就是上面协程里的10次定时都结束，往channel写一个东西，就终止阻塞，使程序结束</span></span><br><span class="line"><span class="comment">// ch := make(chan int)  和   ch := make(chan int， 1) 理解：</span></span><br><span class="line"><span class="comment">// 有1的缓冲channel，一个协程写入拿到这个数，其他再拿都拿不到，配合select，拿不到就走，那个协程执行完操作之后，再往里写个数，其他协程就可以拿了。</span></span><br><span class="line"><span class="comment">//其实不管是有缓冲还是无缓冲，单纯用都会阻塞，无非是有一个buffer</span></span><br><span class="line"><span class="comment">//但是，加上select，都可以实现不拥塞，直接过。</span></span><br></pre></td></tr></table></figure>

<h3 id="4-应用3：搭配select实现锁效果"><a href="#4-应用3：搭配select实现锁效果" class="headerlink" title="4.应用3：搭配select实现锁效果"></a>4.应用3：搭配select实现锁效果</h3><p>mutex实现的锁：拥塞的，一个获锁，其他需要一直等待，直到上一个操作释放，再执行操作</p>
<p>channel实现的锁：可以选择拥塞不拥塞，得不到可以直接放弃，也可以等待一段时间执行其他操作。</p>
<p>搭配select 实现的是io操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//实现初始化一台实例的锁，不同appid都可以更新map</span></span><br><span class="line"><span class="comment">//实现channle的拥塞锁</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	wg.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++&#123;</span><br><span class="line">		<span class="keyword">go</span> get_blockf(&amp;ch, &amp;wg, &amp;err)  <span class="comment">//一直拥塞</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	wg.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++&#123;</span><br><span class="line">		<span class="keyword">go</span> get_block(&amp;ch, &amp;wg, &amp;err)  <span class="comment">//拥塞2s</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	wg.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++&#123;</span><br><span class="line">		<span class="keyword">go</span> get_noblock(&amp;ch, &amp;wg, &amp;err)  <span class="comment">//无拥塞</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_blockf</span><span class="params">(ch *<span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup, err *error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> x := &lt;- *ch:   <span class="comment">//如果可以读出，就读</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Block get number: %d, channel size: %d\n&quot;</span>, x, <span class="built_in">len</span>(*ch))</span><br><span class="line">		time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">		*ch &lt;-x+<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_block</span><span class="params">(ch *<span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup, err *error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> x := &lt;- *ch:   <span class="comment">//如果可以读出，就读</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Block 2s get number: %d, channel size: %d\n&quot;</span>, x, <span class="built_in">len</span>(*ch))</span><br><span class="line">		time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">		*ch &lt;-x+<span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> &lt;- time.After(time.Second *<span class="number">20</span>):  <span class="comment">//等待过程中一直尝试，尝试成功即从ch取数，超时还取不到执行下面操作</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;no number&quot;</span>)</span><br><span class="line">		*err = errors.New(<span class="string">&quot;channel has no data&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_noblock</span><span class="params">(ch *<span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup, err *error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> x := &lt;- *ch:   <span class="comment">//如果可以读出，就读</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Block 2s get number: %d, channel size: %d\n&quot;</span>, x, <span class="built_in">len</span>(*ch))</span><br><span class="line">		time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">		*ch &lt;-x+<span class="number">1</span></span><br><span class="line">	<span class="keyword">default</span>:       <span class="comment">//等待过程中一直尝试，尝试成功即从ch取数，超时还取不到执行下面操作</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;no number&quot;</span>)</span><br><span class="line">		*err = errors.New(<span class="string">&quot;channel has no data&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-http请求</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-http%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>内容丢失</p>
]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-mutex锁</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-mutex%E9%94%81/</url>
    <content><![CDATA[<h3 id="Go语言里的Mutex和RwMutex"><a href="#Go语言里的Mutex和RwMutex" class="headerlink" title="Go语言里的Mutex和RwMutex"></a>Go语言里的Mutex和RwMutex</h3><p>共享锁(S锁)又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。（多读/单写）</p>
<p>排他锁(X锁)又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。（单读/单写）</p>
<p>go里的mutex（普通锁）：全局互斥锁特性(不支持同时读)—-读写操作一样待遇 （类似于：只能加X锁，读写都是X锁）<br>sync.RWMutex：读写锁，支持单写多读特性。—-读写操作不同待遇  （类似于：分两种Lock排他锁，RLock共享锁）</p>
<p>意思是：RWMutex是完全可以实现mutex的功能的，而RWMtex可以实现同时读。</p>
<ul>
<li>func (m *Mutex) Lock()<br>Lock⽅法锁住m，如果m已经加锁，则阻塞直到m解锁。</li>
<li>func (m *Mutex) Unlock()<br>Unlock⽅法解锁m，如果m未加锁会导致运⾏时错误。锁和线程无关，可以由不同的线程加锁和解锁。</li>
</ul>
<p>1.mutex无法实现分布式，多个请求怎么共享一个公共变量？</p>
<p>2.除非分布式请求，共享 sync.RWMutex 变量</p>
<h3 id="Mutex使用"><a href="#Mutex使用" class="headerlink" title="Mutex使用"></a>Mutex使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 共享变量</span><br><span class="line">var (</span><br><span class="line">	m  sync.Mutex</span><br><span class="line">	v1 int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 修改共享变量</span><br><span class="line">// 在Lock()和Unlock()之间的代码部分是临界区</span><br><span class="line">func change(i int, m *sync.Mutex) &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	v1 = v1 + 1</span><br><span class="line">	fmt.Printf(&quot;Write %dth time, v1:%d.\n&quot;, i, v1)</span><br><span class="line">	m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func read(i int, m *sync.Mutex) &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	fmt.Printf(&quot;Read %dth time, v1:%d.\n&quot;, i, v1)</span><br><span class="line">	m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var numGR = 10</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for i := 0; i &lt; numGR; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func(i int) &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			change(i, &amp;m)</span><br><span class="line">			read(i, &amp;m)     //读和写都不会同时进行</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RWMutex使用"><a href="#RWMutex使用" class="headerlink" title="RWMutex使用"></a>RWMutex使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 共享变量</span><br><span class="line">var (</span><br><span class="line">	m  sync.RWMutex</span><br><span class="line">	v1 int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 修改共享变量</span><br><span class="line">// 在Lock()和Unlock()之间的代码部分是临界区</span><br><span class="line">func change(i int, m *sync.RWMutex) &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	v1 = v1 + 1</span><br><span class="line">	fmt.Printf(&quot;Write %dth time, v1:%d.\n&quot;, i, v1)</span><br><span class="line">	m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func read(i int, m *sync.RWMutex) &#123;</span><br><span class="line">	m.RLock()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	v1 = v1 + 1</span><br><span class="line">	fmt.Printf(&quot;Read %dth time, v1:%d.\n&quot;, i, v1)</span><br><span class="line">	m.RUnlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var numGR = 10000</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for i := 0; i &lt; numGR; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func(i int) &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">		//	change(i, &amp;m)</span><br><span class="line">			read(i, &amp;m)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示：并发量不高的情况下，如100，发现用共享锁获得的数据是完全没重复的，像是互斥锁的效果。但是只是并发量不高，10000并发量，共享锁的效果就提现出来了。猜测：for循环间隔时间大于自增时间了？？盲猜</p>
]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-实现一个队列queue</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97queue/</url>
    <content><![CDATA[<h2 id="go容器"><a href="#go容器" class="headerlink" title="go容器"></a>go容器</h2><p>*解引用  &amp;取地址</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//数组</span></span><br><span class="line">	<span class="comment">//var nums [5]int  //不初始化</span></span><br><span class="line">	<span class="keyword">var</span> nums = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="built_in">len</span>(nums); i++&#123;</span><br><span class="line">		fmt.Println(nums[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//切片slice</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> slice[]<span class="keyword">int</span>  <span class="comment">//切片不需要说明长度 ==nil为空</span></span><br><span class="line">    slice = <span class="built_in">append</span>(slice, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">//可以不用make</span></span><br><span class="line">    fmt.Println(slice)</span><br><span class="line">    <span class="keyword">var</span> slice1 = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">20</span>) <span class="comment">//长度10，容量20</span></span><br><span class="line">	fmt.Println(slice1)  <span class="comment">//输出为10个0</span></span><br><span class="line">	<span class="keyword">for</span> i, num := <span class="keyword">range</span> slice&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;slice[%d]=%d\t&quot;</span>, i, num)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> slice2 = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="built_in">copy</span>(slice2, slice1)</span><br><span class="line">	fmt.Println(slice2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//map</span></span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>    <span class="comment">//声明，默认是nil</span></span><br><span class="line">	m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)  <span class="comment">//创建</span></span><br><span class="line">	<span class="comment">//或者一步到位： m := make(map[int]string)</span></span><br><span class="line">	m[<span class="number">1</span>] = <span class="string">&quot;two&quot;</span></span><br><span class="line">	m[<span class="number">1</span>] =<span class="string">&quot;one&quot;</span>  <span class="comment">//覆盖掉</span></span><br><span class="line">	m[<span class="number">2</span>] =<span class="string">&quot;two&quot;</span></span><br><span class="line">	m[<span class="number">3</span>] =<span class="string">&quot;three&quot;</span></span><br><span class="line">	value, ok :=m [<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(m,<span class="number">1</span>)  <span class="comment">//删除</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;key:%d, value:%s\t&quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//list双向链表</span></span><br><span class="line">	li := list.New()  <span class="comment">//元素类型为接口类型，什么都能存</span></span><br><span class="line">	li.PushBack(<span class="number">1</span>)  <span class="comment">// 追加元素到末尾</span></span><br><span class="line">	li.PushBack(<span class="number">2</span>)</span><br><span class="line">	li.PushBack(<span class="number">3</span>)</span><br><span class="line">	zero := li.PushFront(<span class="number">0</span>)  <span class="comment">//添加元素在开头</span></span><br><span class="line">	li.InsertAfter(<span class="number">0.5</span>, zero)</span><br><span class="line">	<span class="keyword">for</span> e := li.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		fmt.Println(e.Value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现一个队列queue并加锁"><a href="#实现一个队列queue并加锁" class="headerlink" title="实现一个队列queue并加锁"></a>实现一个队列queue并加锁</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//切片实现固定长度队列，并加锁</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用一个结构体管理队列</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	maxSize <span class="keyword">int64</span></span><br><span class="line">	array []<span class="keyword">int64</span> <span class="comment">//数组=&gt;模拟队列</span></span><br><span class="line">	front  <span class="keyword">int64</span> <span class="comment">//表示指向队列列首</span></span><br><span class="line">	rear <span class="keyword">int64</span> <span class="comment">//表示指向队列的尾部</span></span><br><span class="line">	flag <span class="keyword">bool</span> <span class="comment">//表示队尾是否在对头后面</span></span><br><span class="line">	mut *sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现结构体初始化有默认值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">(max <span class="keyword">int64</span>)</span> <span class="title">Queue</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Queue&#123;</span><br><span class="line">		maxSize: max,</span><br><span class="line">		array: <span class="built_in">make</span>([]<span class="keyword">int64</span>, max),</span><br><span class="line">		front:   <span class="number">0</span>,</span><br><span class="line">		rear:    <span class="number">-1</span>,</span><br><span class="line">		flag: <span class="literal">true</span>,</span><br><span class="line">		mut: &amp;sync.Mutex&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加数据到队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span> <span class="title">AddQueue</span><span class="params">(val <span class="keyword">int64</span>)</span><span class="params">(err error)</span></span>&#123;</span><br><span class="line">	this.mut.Lock()</span><br><span class="line">	<span class="keyword">defer</span> this.mut.Unlock()</span><br><span class="line">	<span class="comment">//先判断队列是否已满</span></span><br><span class="line">	<span class="keyword">if</span> this.IsFull()&#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;queue full&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	this.rear++<span class="comment">//rear 后移</span></span><br><span class="line">	<span class="keyword">if</span> this.rear == this.maxSize&#123;</span><br><span class="line">		this.rear = <span class="number">0</span></span><br><span class="line">		this.flag = !this.flag</span><br><span class="line">	&#125;</span><br><span class="line">	this.array[this.rear] = val</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从队列中取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span> <span class="title">GetQueue</span><span class="params">()</span> <span class="params">(val <span class="keyword">int64</span>, err error)</span></span>&#123;</span><br><span class="line">	this.mut.Lock()</span><br><span class="line">	<span class="keyword">defer</span> this.mut.Unlock()</span><br><span class="line">	<span class="comment">//先判断队列是否空</span></span><br><span class="line">	<span class="keyword">if</span> this.IsEmpty() &#123;<span class="comment">//队空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">&quot;queue empty&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	val = this.array[this.front]</span><br><span class="line">	this.front++</span><br><span class="line">	<span class="keyword">if</span> this.front == this.maxSize&#123;</span><br><span class="line">		this.front = <span class="number">0</span></span><br><span class="line">		this.flag = !this.flag</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> val,err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (this.flag == <span class="literal">true</span> &amp;&amp; this.rear == this.front<span class="number">-1</span>) || (this.flag == <span class="literal">false</span> &amp;&amp; this.front == <span class="number">0</span> &amp;&amp; this.rear == this.maxSize<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span> <span class="title">IsFull</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (this.flag == <span class="literal">true</span> &amp;&amp; this.front == <span class="number">0</span> &amp;&amp; this.rear == this.maxSize<span class="number">-1</span>) || (this.flag == <span class="literal">false</span> &amp;&amp; this.rear == this.front<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求队列中元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span> <span class="title">QueueSize</span><span class="params">()</span> <span class="title">int64</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> this.flag == <span class="literal">false</span> &amp;&amp; this.front == <span class="number">0</span> &amp;&amp; this.rear == this.maxSize<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> this.flag == <span class="literal">true</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> this.rear-this.front+<span class="number">1</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> this.maxSize-(this.front-this.rear<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示队列,找到队首，然后到遍历到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span> <span class="title">ShowQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">	size := this.QueueSize()</span><br><span class="line">	front := this.front</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">int64</span>(<span class="number">1</span>) ; i &lt;= size; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d\t&quot;</span>,this.array[front])</span><br><span class="line">		front++</span><br><span class="line">		<span class="keyword">if</span> front == this.maxSize&#123;</span><br><span class="line">			front =<span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//先创建一个队列</span></span><br><span class="line">	max := <span class="keyword">int64</span>(<span class="number">50</span>)</span><br><span class="line">	queue := NewQueue(max)</span><br><span class="line">	queue.ShowQueue()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">50</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=<span class="number">50</span>; i++ &#123;</span><br><span class="line">		queue.AddQueue(<span class="keyword">int64</span>(i))</span><br><span class="line">	&#125;</span><br><span class="line">	queue.ShowQueue()</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=<span class="number">50</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			out, err :=queue.GetQueue()</span><br><span class="line">			log.Println(err, queue.QueueSize(), <span class="string">&quot;out:&quot;</span>, out)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	queue.ShowQueue()</span><br><span class="line">	fmt.Println(queue.QueueSize())</span><br><span class="line">	fmt.Println(queue.GetQueue())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-函数结束协程结束吗</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-%E5%87%BD%E6%95%B0%E7%BB%93%E6%9D%9F%E5%8D%8F%E7%A8%8B%E7%BB%93%E6%9D%9F%E5%90%97/</url>
    <content><![CDATA[<h3 id="结论为先"><a href="#结论为先" class="headerlink" title="结论为先"></a>结论为先</h3><p> 在main或其他函数中开协程，主程序结束了，协程还继续执行吗?</p>
<p> 结论：main函数中的协程，如果main结束了，协程也会结束</p>
<pre><code>  其他函数里的协程，函数结束了，只要main没结束，协程就会执行。
</code></pre>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test()</span><br><span class="line">	time.Sleep(time.Second*<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//定时完成的操作写在协程里</span></span><br><span class="line">	ticker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line">	<span class="comment">//ch := make(chan int)</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">		<span class="keyword">for</span> x &lt; <span class="number">10</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">				x++</span><br><span class="line">				fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, x)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ticker.Stop()</span><br><span class="line">		<span class="comment">//ch &lt;- 0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//&lt;- ch</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;bye&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-操作mysql数据库</title>
    <url>/2021/08/20/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="1-mysql原始命令"><a href="#1-mysql原始命令" class="headerlink" title="1.mysql原始命令"></a>1.mysql原始命令</h2><h3 id="a-登录"><a href="#a-登录" class="headerlink" title="a.登录"></a>a.登录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">登录：</span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p密码  <span class="operator">/</span><span class="operator">/</span>连本机的</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span>, Host, Password <span class="keyword">FROM</span> mysql.user;  <span class="operator">/</span><span class="operator">/</span>查看用户</span><br><span class="line"></span><br><span class="line">添加新用户：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;liuxuan14&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">修改密码：</span><br><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> <span class="string">&#x27;liuxuan14&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span><span class="operator">=</span>password(<span class="string">&#x27;1998&#x27;</span>);</span><br><span class="line">为用户授权：</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>允许访问所有数据库下的所有表</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>指定数据库下的指定表</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> test.test <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>只拥有查询权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line">FLUSH PRIVILEGES;  <span class="operator">/</span><span class="operator">/</span>刷新权限</span><br><span class="line"></span><br><span class="line">删除用户：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> liuxuan<span class="variable">@localhost</span>；</span><br><span class="line"></span><br><span class="line">连接远程数据库：</span><br><span class="line">MySQL 连接远程数据库（<span class="number">192.168</span><span class="number">.5</span><span class="number">.116</span>），端口“<span class="number">3306</span>”，用户名为“root”，密码“<span class="number">123456</span>”</span><br><span class="line">mysql <span class="operator">-</span>h <span class="number">192.168</span><span class="number">.5</span><span class="number">.116</span> <span class="operator">-</span>P <span class="number">3306</span> <span class="operator">-</span>u root <span class="operator">-</span>p123456</span><br><span class="line">mysql <span class="operator">-</span>h ip <span class="operator">-</span>P 端口 <span class="operator">-</span>A <span class="operator">-</span>u name  <span class="operator">-</span>p 密码</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database name</span><br></pre></td></tr></table></figure>

<h3 id="b-建表"><a href="#b-建表" class="headerlink" title="b.建表"></a>b.建表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `mytable`(</span><br><span class="line">   `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">   `app_id` bigint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;应用id&#x27;,</span><br><span class="line">   `time` int NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;时间&#x27;,</span><br><span class="line">   `date` DATE,</span><br><span class="line">   PRIMARY KEY ( `id` )</span><br><span class="line">   UNIQUE KEY `idx_app` (`app_id`) USING BTREE</span><br><span class="line">   KEY `idx_ip` (`machine_ip`) USING BTREE,</span><br><span class="line">   KEY `idx_app_machineid` (`app_id`,`machine_id`) USING BTREE</span><br><span class="line">)ENGINE=InnoDB DEFAULT COMMENT=&#x27;表名&#x27;;</span><br><span class="line"></span><br><span class="line">AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</span><br><span class="line">PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</span><br><span class="line">ENGINE 设置存储引擎，CHARSET 设置编码。</span><br><span class="line"></span><br><span class="line">表结构：desc name；</span><br><span class="line">建表语句：show create tablename；</span><br></pre></td></tr></table></figure>

<p>注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释：comment</span><br><span class="line">create table test1 ( </span><br><span class="line">    field_name int comment &#x27;字段的注释&#x27; </span><br><span class="line">)comment=&#x27;表的注释&#x27;;</span><br><span class="line">修改表的注释：</span><br><span class="line">alter table test1 comment &#x27;修改后的表的注释&#x27;;</span><br><span class="line">修改字段的注释：</span><br><span class="line">alter table test1 modify column field_name int comment &#x27;修改后的字段注释&#x27;; </span><br><span class="line">查看表注释：</span><br><span class="line">show  create  table  test1; </span><br><span class="line">查看字段注释：</span><br><span class="line">show  full  columns  from  test1; </span><br></pre></td></tr></table></figure>

<p>索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">唯一索引：</span><br><span class="line">UNIQUE KEY</span><br><span class="line">1  主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。</span><br><span class="line">2  主键创建后一定包含一个唯一性索引，唯一性索引不一定就是主键。</span><br><span class="line">3   唯一性索引列允许空值， 而主键列不允许为空值。</span><br><span class="line">4   主键可以被其他表引用为外键，而唯一索引不能。</span><br><span class="line">5   一个表最多只能创建一个主键，但是可以创建多个唯一索引。</span><br><span class="line">6   主键更适合那些不容易改变的唯一标识，如自动递增列，身份证号等。</span><br><span class="line">7   在RBO 模式下，主键的执行计划优先级高于唯一索引。两者可以提高查询的速度。</span><br></pre></td></tr></table></figure>

<h3 id="c-添加一个字段"><a href="#c-添加一个字段" class="headerlink" title="c.添加一个字段"></a>c.添加一个字段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table tablename add `app_name` varchar(16) NOT NULL DEFAULT &#x27;&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="d-修改数据"><a href="#d-修改数据" class="headerlink" title="d.修改数据"></a>d.修改数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tablename set 字段=&#x27;修改的值&#x27; where 条件；</span><br><span class="line">多个字段中间加,</span><br></pre></td></tr></table></figure>

<h3 id="e-删除"><a href="#e-删除" class="headerlink" title="e.删除"></a>e.删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删库：drop database name;</span><br><span class="line">删表：drop table name；</span><br><span class="line"></span><br><span class="line">mysql删除一行：</span><br><span class="line">delete from 表 where 条件；</span><br></pre></td></tr></table></figure>

<h3 id="f-添加一行"><a href="#f-添加一行" class="headerlink" title="f.添加一行"></a>f.添加一行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into tablename (app_id,machine_id,machine_ip,ctime,use_perc) values(?,?,?,?,?);   //对应字段加</span><br><span class="line"></span><br><span class="line">insert into 表名 values(int,&#x27;string&#x27;)(..);  //可一次性加多行，一行全部数都有</span><br><span class="line"></span><br><span class="line">insert into 表名 set 列名=&#x27;&#x27;, ...;</span><br></pre></td></tr></table></figure>

<h2 id="2-go操作数据库"><a href="#2-go操作数据库" class="headerlink" title="2.go操作数据库"></a>2.go操作数据库</h2><p>使用：database/sql包</p>
<p>mysql默认端口号3306</p>
<p>查看：mysql内，<code>show global variables like &#39;port&#39;; </code></p>
<p>查看mysql配置文件目录：</p>
<p><code>mysql --help|grep &#39;my.cnf&#39;</code></p>
<h3 id="a-创建连接池"><a href="#a-创建连接池" class="headerlink" title="a.创建连接池"></a>a.创建连接池</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.创建连接池</span><br><span class="line">func newPool() *sql.DB &#123;  //sql.DB 表示一个连接池</span><br><span class="line">	cfg := mysql.NewConfig()</span><br><span class="line">	cfg.User = &quot;name&quot;</span><br><span class="line">	cfg.Passwd = &quot;123456&quot;</span><br><span class="line">	cfg.Net = &quot;tcp&quot;</span><br><span class="line">	cfg.Addr = &quot;127.0.0.1:3306&quot;</span><br><span class="line">	cfg.DBName = &quot;mydb&quot;</span><br><span class="line">	dsn := cfg.FormatDSN()</span><br><span class="line"></span><br><span class="line">	db, err := sql.Open(&quot;mysql&quot;, dsn)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	if err := db.Ping(); err != nil &#123; //ping测试网络连通性及用户密码是否正确</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	return db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="b-query查询"><a href="#b-query查询" class="headerlink" title="b.query查询"></a>b.query查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func QueryUser(id int64) (*User, error) &#123;</span><br><span class="line">  var db = newPool()  //创建连接</span><br><span class="line">	rows, err := db.Query(&quot;select `id`, `name` from `users` where `id` = ?&quot;, id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	defer rows.Close() // 注意这里，一定要关闭</span><br><span class="line">	user := User&#123;&#125;</span><br><span class="line">	for rows.Next() &#123;</span><br><span class="line">		if err := rows.Scan(&amp;user.ID, &amp;user.Name); err != nil &#123;</span><br><span class="line">			return nil, err</span><br><span class="line">		&#125;</span><br><span class="line">		break</span><br><span class="line">	&#125;</span><br><span class="line">	if err := rows.Err(); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;user, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接池对程序员是透明的，这里并不需要显式的从连接池里获取连接，而是通过连接池来执行查询语句。<br>Query 方法返回一个 *Rows 指针，代表结果集。</p>
<p>要注意的是 defer rows.Close() 如果忘了关闭，可能会造成连接泄露。</p>
<p>rows.Scan 方法有个方便的特性，如果id在数据库里是 varchar(50) 类型，我们传的参数&amp;user.ID指向int64，这依然可以工作，Scan 方法会执行自动转换。</p>
<h3 id="c-单行查询queryrow"><a href="#c-单行查询queryrow" class="headerlink" title="c.单行查询queryrow"></a>c.单行查询queryrow</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// QueryUser1 单行查询</span><br><span class="line">func QueryUser1(id int64) (*User, error) &#123;</span><br><span class="line">	row := pool.QueryRow(&quot;select `id`, `name` from `users` where `id` = ?&quot;, id)</span><br><span class="line">	user := User&#123;&#125;</span><br><span class="line">	if err := row.Scan(&amp;user.ID, &amp;user.Name); err != nil &#123;</span><br><span class="line">		if err == sql.ErrNoRows &#123;</span><br><span class="line">			return nil, nil  // 返回 (*User)(nil) 表示查询结果不错在</span><br><span class="line">		&#125;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;user, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="d-插入更新删除exec"><a href="#d-插入更新删除exec" class="headerlink" title="d.插入更新删除exec"></a>d.插入更新删除exec</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// InsertUser 插入用户</span><br><span class="line">func InsertUser(name string) (int64, error) &#123;</span><br><span class="line">	res, err := pool.Exec(&quot;insert into `users` (`name`) values (?)&quot;, name)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return 0, err</span><br><span class="line">	&#125;</span><br><span class="line">	return res.LastInsertId()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// UpdateUser 更新用户</span><br><span class="line">func UpdateUser(id int64, name string) error &#123;</span><br><span class="line">	_, err := pool.Exec(&quot;update `users` set `name` = ? where `id` = ?&quot;, name, id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// DeleteUser 删除用户</span><br><span class="line">func DeleteUser(id int64) error &#123;</span><br><span class="line">	_, err := pool.Exec(&quot;delete from `users` where `id` = ?&quot;, id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="e-事务"><a href="#e-事务" class="headerlink" title="e.事务"></a>e.事务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// UpdateFooBar 更新</span><br><span class="line">func UpdateFooBar(id int64, x, y string) (err error) &#123;</span><br><span class="line">	tx, err := pool.Begin()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		switch &#123;</span><br><span class="line">		case err != nil:</span><br><span class="line">			tx.Rollback()</span><br><span class="line">		default:</span><br><span class="line">			err = tx.Commit()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	_, err = tx.Exec(&quot;update `foo` set `x` = ? where `id` = ?&quot;, x, id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = tx.Exec(&quot;update `bar` set `y` = ? where `id` = ?&quot;, y, id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-mysql加锁"><a href="#3-mysql加锁" class="headerlink" title="3.mysql加锁"></a>3.mysql加锁</h2><p>读锁全表锁(LOCK TABLE 表 READ)<br>读锁行锁(SELECT … LOCK IN SHARE MODE)<br>写锁全表锁(LOCK TABLE 表 WRITE)<br>写锁行锁(SELECT … FOR UPDATE)</p>
<p>锁总体可以分为乐观锁和悲观锁，简单说，乐观锁用版本号控制，悲观锁用锁控制。<br>乐观锁：核心原理是增加一个version的字段来控制。添加一个version字段，每个更新时where条件都加上它，并且也更新它UPDATE users SET name=”雪山飞猪”,version=version+1 WHERE id=3 AND version=0 UPDATE users SET name=”chenqionghe”,version=version+1 WHERE id=3 AND version=0。这就是最简单的CAS机制。<br>悲观锁：类似Go语言里的Mutex和RwMutex</p>
<p>共享锁(S锁)又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p>
<p>排他锁(X锁)又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写锁表锁：</span><br><span class="line">加锁：lock table kiss_share_idproducer write;</span><br><span class="line">此时其他进程无法读也无法写。</span><br><span class="line">解锁：unlock table;</span><br><span class="line">--------------------------------</span><br><span class="line">写锁行锁：</span><br><span class="line">begin;</span><br><span class="line">加锁：select * from  kiss_share_idproducer where app_id=21 for update;</span><br><span class="line">其他再加锁，等待，直到占锁的commit；</span><br><span class="line">更新：update kiss_share_idproducer set mix_id=7 where app_id=21;</span><br><span class="line">解锁：commit;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读锁表锁：</span><br><span class="line">加锁：lock table kiss_share_idproducer read;</span><br><span class="line">此时其他进程可以读但无法写。</span><br><span class="line">解锁：unlock table;</span><br><span class="line">-------------------------------</span><br><span class="line">读锁行锁：</span><br><span class="line">加锁：select * from  kiss_share_idproducer where app_id=21 lock in share mode;</span><br><span class="line">其他再加锁，等待，直到占锁的commit；</span><br><span class="line">更新：update kiss_share_idproducer set mix_id=7 where app_id=21;</span><br><span class="line">解锁：commit;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>go的mysql操作：<a href="https://blog.csdn.net/embinux/article/details/84031620">https://blog.csdn.net/embinux/article/details/84031620</a></p>
<p>mysql加锁：<a href="https://blog.csdn.net/weixin_33838871/article/details/113566444">https://blog.csdn.net/weixin_33838871/article/details/113566444</a></p>
]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-获取本机id</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip/</url>
    <content><![CDATA[<p>~~~<br>package main</p>
<p>import (<br>    “fmt”<br>    “net”<br>)</p>
<p>func main() {<br>    netInterfaces, err := net.Interfaces()<br>    if err != nil {<br>        fmt.Println(“net.Interfaces failed, err:”, err.Error())<br>    }<br>    for i := 0; i &lt; len(netInterfaces); i++ {<br>        if (netInterfaces[i].Flags &amp; net.FlagUp) != 0 {<br>            addrs, _ := netInterfaces[i].Addrs()</p>
<pre><code>        for _, address := range addrs &#123;
            if ipnet, ok := address.(*net.IPNet); ok &amp;&amp; !ipnet.IP.IsLoopback() &#123;
                if ipnet.IP.To4() != nil &#123;
                    fmt.Println(ipnet.IP.String())
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记-go入门1.0</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-go%E5%85%A5%E9%97%A81.0/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言在多核并发上拥有原生的设计优势，兼顾性能和开发效率</span><br><span class="line">号称：Python的开发速度，C/C++的性能和安全</span><br><span class="line">php迁<span class="keyword">go</span>属于大的架构调整，从架构角度  个人认为<span class="keyword">go</span>符合，简单、合适的原则</span><br><span class="line"><span class="number">1</span>、架构设计的主要目的</span><br><span class="line">是为了解决软件系统复杂度带来的问题</span><br><span class="line"><span class="number">2</span>、系统复杂度的主要来源</span><br><span class="line">高性能、高可用、可扩展性、低成本、安全、规模</span><br><span class="line"><span class="number">3</span>、架构设计三原则</span><br><span class="line">合适原则、简单原则、演化原则</span><br><span class="line"></span><br><span class="line">菜鸟教程：https:<span class="comment">//www.runoob.com/go/go-tutorial.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>：开源、可靠高效、多核并发、编译型语言、<span class="number">2012</span>发布Go1稳定版本。</span><br><span class="line">特点：简洁、快读、安全、并行、有趣、开源、内存管理、数组安全、编译迅速</span><br><span class="line">适用：Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。</span><br><span class="line">对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。</span><br><span class="line"></span><br><span class="line">计算机软件经历了数十年的发展，形成了多种学术流派，有面向过程编程、面向对象编程、函数式编程、面向消息编程等，这些思想究竟孰优孰劣，众说纷纭。</span><br><span class="line">除了OOP外，近年出现了一些小众的编程哲学，Go语言对这些思想亦有所吸收。例如，Go语言接受了函数式编程的一些想法，支持匿名函数与闭包。再如，Go语言接受了以Erlang语言为代表的面向消息编程思想，支持goroutine和通道，并推荐使用消息而不是共享内存来进行并发编程。总体来说，Go语言是一个非常现代化的语言，精小但非常强大。</span><br><span class="line">Go 语言最主要的特性：</span><br><span class="line">自动垃圾回收</span><br><span class="line">更丰富的内置类型</span><br><span class="line">函数多返回值</span><br><span class="line">错误处理</span><br><span class="line">匿名函数和闭包</span><br><span class="line">类型和接口</span><br><span class="line">并发编程</span><br><span class="line">反射</span><br><span class="line">语言交互性</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>安装 菜鸟方案</span><br><span class="line"><span class="number">1.</span>下载二进制安装包：https:<span class="comment">//golang.google.cn/dl/</span></span><br><span class="line">go1<span class="number">.16</span>.linux-amd64.tar.gz</span><br><span class="line">问题：.pkg和.tar.gz只是压缩方式的不同吗</span><br><span class="line"><span class="number">2.</span>解压安装包到目录</span><br><span class="line">tar -C /usr/local -xzf go1<span class="number">.4</span>.linux-amd64.tar.gz</span><br><span class="line"><span class="number">3.</span>添加PATH环境变量</span><br><span class="line">export PATH=$PATH:/usr/local/<span class="keyword">go</span>/bin</span><br><span class="line">MAC 系统下你可以使用 .pkg 结尾的安装包直接双击来完成安装，安装目录在 /usr/local/<span class="keyword">go</span>/ 下。</span><br><span class="line"></span><br><span class="line">问题：<span class="keyword">go</span>安装到哪？</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>安装 GDP2方案</span><br><span class="line"><span class="number">1.</span>配置环境变量</span><br><span class="line">建议把 <span class="keyword">go</span> 本身安装在 ~/sdk/ 目录下，如 ~/sdk/go1<span class="number">.16</span>。</span><br><span class="line">先设置环境变量（建议写入到 ~/.bash_profile 文件 ）？</span><br><span class="line">export GOBIN=$HOME/<span class="keyword">go</span>/bin  </span><br><span class="line">export PATH=$PATH:$GOBIN:$HOME/sdk/go1<span class="number">.16</span>/bin</span><br><span class="line">作用：</span><br><span class="line">后续使用 <span class="keyword">go</span> 命令安装的二进制程序都在 $HOME/<span class="keyword">go</span>/bin 目录里</span><br><span class="line">设置 $PATH以让 <span class="keyword">go</span> 和 使用 <span class="keyword">go</span> 安装的二进制程序能直接使用</span><br><span class="line"><span class="number">2.</span>安装：哪种方式安装？</span><br><span class="line">MAC直接安装：brew install <span class="keyword">go</span></span><br><span class="line">内网测试机deck环境安装：deck install <span class="keyword">go</span><span class="number">-1.16</span></span><br><span class="line">go1<span class="number">.13</span>开始的依赖管理工具Go Module</span><br><span class="line"></span><br><span class="line">问导师：直接安装pkg的，自动安装到一个目录，环境变量也不需要自己配了。然后学一下语法，可以在终端编译。装一下vscode。配一下Go module，镜像。</span><br><span class="line"></span><br><span class="line">brew是MacOS上的包管理工具，可以简化操作系统上软件的安装。</span><br><span class="line">brew是ruby开发的，需要确认ruby是否已安装，默认是已经安装的。</span><br><span class="line">which命令：查看安装路径</span><br><span class="line">安装brew：</span><br><span class="line">ruby -e <span class="string">&quot;$(curl -fsSL </span></span><br><span class="line"><span class="string">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span>  （没反应）</span><br><span class="line">另一条命令：</span><br><span class="line">/bin/zsh -c <span class="string">&quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span></span><br><span class="line"></span><br><span class="line">（MAC安装和使用<span class="keyword">go</span>：https:<span class="comment">//www.jianshu.com/p/67dcf4e828e9）</span></span><br><span class="line">安装好了brew再<span class="keyword">go</span> version就有了。</span><br><span class="line"><span class="keyword">go</span> env 查看环境变量</span><br><span class="line">which <span class="keyword">go</span> 查看安装目录：/usr/local/<span class="keyword">go</span>/bin/<span class="keyword">go</span></span><br><span class="line"><span class="keyword">go</span>的开发项目路径修改：  ？？</span><br><span class="line">export GOPATH=/Users/liuxuan14/work/go_project</span><br><span class="line"></span><br><span class="line">vim一个hello.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">go</span> run hello.<span class="keyword">go</span> <span class="comment">//直接运行</span></span><br><span class="line">或者：</span><br><span class="line"><span class="keyword">go</span> build hello.<span class="keyword">go</span> <span class="comment">//先编译</span></span><br><span class="line">./hello  <span class="comment">//运行编译文件 ./是运行的意思</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言结构：</span><br><span class="line"><span class="keyword">go</span>语言的基础组成：包声明、引入包、函数、变量、语句 &amp; 表达式、注释</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main  <span class="comment">//第一行，表明该文件属于main包，表示一个可独立执行的程序。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  <span class="comment">//导包：fmt包实现格式化IO</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  <span class="comment">//init()函数？</span></span><br><span class="line">   <span class="comment">/* 这是我的第一个简单的程序 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">  <span class="comment">//在最后自动增加换行字符\n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：&#123;不能单独放在一行</span><br><span class="line"></span><br><span class="line">标识符（包括常量、变量、类型、函数名、结构字段等等）如果以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。</span><br><span class="line"></span><br><span class="line">包结构，文件名与包名</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言基础语法：</span><br><span class="line">一行代表一个语句结束，无需；</span><br><span class="line">除非非要写在一行，用；人为区分</span><br><span class="line">标识符：第一个字符需要是字母或下划线不能是数字，不能是<span class="keyword">go</span>关键字，不能有运算符。</span><br><span class="line">字符串连接：fmt.Println(<span class="string">&quot;Google&quot;</span> + <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line"><span class="keyword">go</span>变量的申明必须使用空格隔开：</span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span>;</span><br><span class="line">fmt.</span><br><span class="line">Sprintf 格式化字符串并赋值给新串。</span><br><span class="line"><span class="keyword">var</span> stockcode=<span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> enddate=<span class="string">&quot;2020-12-31&quot;</span></span><br><span class="line"><span class="keyword">var</span> url=<span class="string">&quot;Code=%d &amp; endDate=%s&quot;</span></span><br><span class="line"><span class="keyword">var</span> target_url=fmt.Sprintf(url,stockcode,enddate)</span><br><span class="line">fmt.Println(target_url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>数据类型：</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span>=<span class="literal">true</span></span><br><span class="line">布尔型、数字类型、字符串类型、派生类型（指针、数组、结构化、channel、函数、切片、接口<span class="keyword">interface</span>、<span class="keyword">map</span>）</span><br><span class="line"><span class="keyword">uint8</span>（<span class="number">0</span><span class="number">-255</span>）<span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">int8</span>(<span class="number">-128</span><span class="number">-127</span>) </span><br><span class="line"><span class="keyword">float32</span>:<span class="number">32</span>位浮点数</span><br><span class="line"><span class="keyword">float64</span>：<span class="number">64</span>位浮点数</span><br><span class="line"><span class="keyword">complex64</span>：<span class="number">32</span>位实数和虚数</span><br><span class="line"><span class="keyword">byte</span> 类似<span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">rune</span> 类似<span class="keyword">int32</span></span><br><span class="line"><span class="keyword">uintptr</span> 无符号整型，用于存放一个指针。</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>变量：</span><br><span class="line"><span class="keyword">var</span> a,b <span class="keyword">type</span> <span class="comment">//一次定义两个变量</span></span><br><span class="line"><span class="keyword">var</span> b,c <span class="keyword">int</span>=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">fmt.Println(b,c)</span><br><span class="line">变量只声明但是不初始化，默认为零值。</span><br><span class="line">可以根据值自行判定变量类型。</span><br><span class="line">定义变量可省略<span class="keyword">var</span></span><br><span class="line">a:=<span class="number">1</span>  <span class="comment">//一定是需要定义新的变量，如果变量存在会编译错误。省略申明格式的写法只能在函数体中出现。</span></span><br><span class="line"><span class="keyword">var</span> a,b =<span class="number">1</span>,<span class="number">2</span> <span class="comment">//和python很像，不需要显示声明类型，自动判断。非全局变量</span></span><br><span class="line"><span class="keyword">var</span>（</span><br><span class="line">  a <span class="keyword">int</span></span><br><span class="line">  b <span class="keyword">int</span></span><br><span class="line">）  <span class="comment">//因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line"></span><br><span class="line">值类型和引用类型</span><br><span class="line">值类型的变量的值存储在栈中。</span><br><span class="line">一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</span><br><span class="line">这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。</span><br><span class="line">同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。</span><br><span class="line">当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。</span><br><span class="line">如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。</span><br><span class="line"></span><br><span class="line"><span class="comment">//思考：在go中，引用类型中存放的是指针，指针相当于内存地址。用一个引用类型给另一个引用类型赋值，地址被赋值，地址一样，值变动，两个引用类型都指向这个修改后的内容。</span></span><br><span class="line"></span><br><span class="line">函数中如果你声明了一个局部变量却没有在相同的代码块中使用它，会编译错误。</span><br><span class="line">多个变量可以同时声明、初始化。</span><br><span class="line">_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>常量：</span><br><span class="line">常量是一个简单值的标识符，在程序运行时，不会被修改的量。</span><br><span class="line">常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</span><br><span class="line"><span class="keyword">const</span> b <span class="keyword">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">常量还可用作枚举</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="literal">iota</span>：特殊常量，可以认为是一个可以被编译器修改的常量。</span><br><span class="line"><span class="literal">iota</span> 在 <span class="keyword">const</span>关键字出现时将被重置为 <span class="number">0</span>(<span class="keyword">const</span> 内部的第一行之前)，<span class="keyword">const</span> 中每新增一行常量声明将使 <span class="literal">iota</span> 计数一次(<span class="literal">iota</span> 可理解为 <span class="keyword">const</span> 语句块中的行索引)。</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br><span class="line">发现：下一行如果啥都没写的话，就跟上一行一样。</span><br><span class="line">左移&lt;&lt;n 相当于*（<span class="number">2</span>^n）</span><br><span class="line">fmt.Printf() 不会自动换行，需要\n</span><br><span class="line">fmt.Println() 会自动换行</span><br><span class="line">&amp;按位与</span><br><span class="line">|按位或</span><br><span class="line">^按位异或，不同为<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span> 定义指针变量</span><br><span class="line">ptr=&amp;a  </span><br><span class="line">疑问：引用类型和指针类型？区别在哪</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">循环控制语句多一个：</span><br><span class="line"><span class="keyword">goto</span>语句：将控制转移到被标记的语句。</span><br><span class="line"><span class="built_in">len</span>()函数：返回该类型长度</span><br><span class="line">函数模板：</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line">   <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">   <span class="comment">/* 调用函数并返回最大值 */</span></span><br><span class="line">   ret = max(a, b)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;最大值是 : %d\n&quot;</span>, ret )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">多个返回值：</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">指针和引用的理解：</span><br><span class="line">c++中：*解引用 &amp;取地址</span><br><span class="line"><span class="keyword">int</span> a,b,*p=&amp;a,&amp;r=a;<span class="comment">//正确</span></span><br><span class="line">r=<span class="number">3</span>;<span class="comment">//正确：等价于a=3</span></span><br><span class="line"><span class="keyword">int</span> &amp;rr;<span class="comment">//出错：引用必须初始化</span></span><br><span class="line">p=&amp;a;<span class="comment">//正确：p中存储a的地址，即p指向a</span></span><br><span class="line">*p=<span class="number">4</span>;<span class="comment">//正确：p中存的是a的地址，对a所对应的存储空间存入值4</span></span><br><span class="line">p=&amp;b<span class="comment">//正确：p可以多次赋值，p存储b的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>中：</span><br><span class="line">有的变量是引用类型，而不是叫变量的别名。指针可以赋值给引用类型，引用类型可以看做是对指针的封装。</span><br><span class="line">指针变量指向一个值的内存地址。</span><br><span class="line"><span class="keyword">go</span>语言中的值类型：</span><br><span class="line">　　<span class="keyword">int</span>、float、<span class="keyword">bool</span>、array、sturct等</span><br><span class="line">　　值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数</span><br><span class="line">　　声明一个值类型变量时，编译器会在栈中分配一个空间，空间里存储的就是该变量的值　　　　</span><br><span class="line"><span class="keyword">go</span>语言中的引用类型：</span><br><span class="line">　　slice，<span class="keyword">map</span>，channel，<span class="keyword">interface</span>，<span class="function"><span class="keyword">func</span>，<span class="title">string</span>等</span></span><br><span class="line">　　声明一个引用类型的变量，编译器会把实例的内存分配在堆上</span><br><span class="line">　　<span class="keyword">string</span>和其他语言一样，是引用类型，<span class="keyword">string</span>的底层实现<span class="keyword">struct</span> String &#123; <span class="keyword">byte</span>* str; intgo <span class="built_in">len</span>; &#125;; 但是因为<span class="keyword">string</span>不允许修改，每次操作<span class="keyword">string</span>只能生成新的对象，所以在看起来使用时像值类型。</span><br><span class="line">　　所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</span><br><span class="line">　　需要注意的是：引用类型在函数的内部可以对它的值进行修改，但是如果给形参重新赋值，重新赋值后的形参再怎么修改都不会影响外面的实参了</span><br><span class="line">　　<span class="literal">nil</span>可以赋值给引用类型（除<span class="keyword">string</span>外）、error类型和指针类型</span><br><span class="line"><span class="keyword">go</span>语言中的指针类型：</span><br><span class="line">　　一个指针变量指向了一个值的内存地址</span><br><span class="line"> 　 当一个指针被定义后没有分配到任何变量时，它的值为 <span class="literal">nil</span>。<span class="literal">nil</span> 指针也称为空指针</span><br><span class="line">　　一个指针变量通常缩写为 ptr</span><br><span class="line">　　其实引用类型可以看作对指针的封装</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">PS.<span class="keyword">go</span>和C++中指针的区别：</span><br><span class="line">指针是用来指向任何一个变量的内存地址的类型变量，它所指向的变量的内存地址在 <span class="number">32</span> 和 <span class="number">64</span> 位机器上分别占用 <span class="number">4</span> 或者 <span class="number">8</span> 个字节，占用字节的大小与所指向的值的大小无关。</span><br><span class="line"><span class="number">1.</span>用法不同：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span> <span class="comment">// 一个整型变量a</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">string</span> = <span class="string">&quot;abcdefg&quot;</span> <span class="comment">// 一个字符串变量b</span></span><br><span class="line">    ptr:=&amp;b</span><br><span class="line">    <span class="comment">// 打印ptr的类型</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;ptr type: %T\n&quot;</span>, ptr)</span><br><span class="line">    <span class="comment">// 打印ptr的地址</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;address: %p\n&quot;</span>, ptr)</span><br><span class="line">    <span class="comment">//对指针进行取值</span></span><br><span class="line">    value：=*ptr</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p %p&quot;</span>, &amp;a, &amp;b) <span class="comment">// 分别输出a和b的地址</span></span><br><span class="line">&#125;</span><br><span class="line">--</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">int</span> a  = <span class="number">1</span>; <span class="comment">// 一个整型变量a</span></span><br><span class="line">    <span class="keyword">string</span> b  = <span class="string">&quot;abcdefg&quot;</span>; <span class="comment">// 一个字符串变量b</span></span><br><span class="line">    cout&lt;&lt; &amp;a &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; &amp;b &lt;&lt;endl; <span class="comment">// 分别输出a和b的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>C++语言中可以直接对指针做算术运算（+、-、++、--），但是Golang中是不行的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">引用传递</span><br><span class="line">/* 定义交换值函数*/</span><br><span class="line">func swap(x *int, y *int) &#123;</span><br><span class="line">   var temp int</span><br><span class="line">   temp = *x    /* 保持 x 地址上的值 */</span><br><span class="line">   *x = *y      /* 将 y 值赋给 x */</span><br><span class="line">   *y = temp    /* 将 temp 值赋给 y */</span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;a,&amp;b)</span><br><span class="line">和指针作为参数传递一模一样，一个更简洁的：</span><br><span class="line">func swap(x *int, y *int)&#123;</span><br><span class="line">    *x, *y = *y, *x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>函数用法：</span><br><span class="line"><span class="number">1.</span>可作为另一个函数的实参</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 声明函数变量 */</span></span><br><span class="line">   getSquareRoot := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 使用函数 */</span></span><br><span class="line">   fmt.Println(getSquareRoot(<span class="number">9</span>))</span><br><span class="line">&#125;</span><br><span class="line">感觉像是在main函数中定义了一个函数，然后调用，不需要再main函数外定义。像是定义一个变量一样。</span><br><span class="line"><span class="number">2.</span>匿名函数，可作为闭包。</span><br><span class="line">内联在函数中，优越性在于可以直接使用函数内的变量，不必声明。</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;  <span class="comment">//返回一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">像是给变量取别名，两次使用是独立的。</span><br><span class="line"><span class="number">3.</span>函数方法</span><br><span class="line">Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。语法格式如下：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(variable_name variable_data_type)</span> <span class="title">function_name</span><span class="params">()</span> [<span class="title">return_type</span>]</span>&#123;</span><br><span class="line">   <span class="comment">/* 函数体*/</span></span><br><span class="line">&#125;</span><br><span class="line">--</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">)</span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c1 Circle</span><br><span class="line">  c1.radius = <span class="number">10.00</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;圆的面积 = &quot;</span>, c1.getArea())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">getArea</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="comment">//c.radius 即为 Circle 类型对象中的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line">感觉把本来应该在函数名后面括号中的变量，也就是要传进去的变量放在了<span class="function"><span class="keyword">func</span>后的括号中。</span></span><br><span class="line">然后使用的时候像是使用c++中类的一个方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>变量作用域：</span><br><span class="line">Go 语言中变量可以在三个地方声明：</span><br><span class="line">函数内定义的变量称为局部变量（包括main函数）</span><br><span class="line">函数外定义的变量称为全局变量</span><br><span class="line">函数定义中的变量称为形式参数</span><br><span class="line">Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>数组</span><br><span class="line">val nums [<span class="number">10</span>] <span class="keyword">int</span></span><br><span class="line">val nums=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">nums:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">val nums=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">nums:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>,<span class="number">3</span>:<span class="number">3</span>&#125; <span class="comment">//只修改部分</span></span><br><span class="line">nums[<span class="number">0</span>]</span><br><span class="line">多维数组：</span><br><span class="line">nums:=[][]<span class="keyword">int</span>&#123;&#125;  <span class="comment">//创建</span></span><br><span class="line">row1:=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">row2:=[]<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">nums=<span class="built_in">append</span>(nums,row1) <span class="comment">//添加一行</span></span><br><span class="line">fmt.Println(nums[<span class="number">0</span>])  <span class="comment">//输出一行，有别于c++</span></span><br><span class="line">也可以直接输出二维数组nums</span><br><span class="line">初始化二维数组：</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   </span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   </span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;,  </span><br><span class="line">&#125;  <span class="comment">//最后或者&#125;&#125;  也可以写在一行2</span></span><br><span class="line">作为函数参数传递：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言结构体</span><br><span class="line">结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</span><br><span class="line">结构体定义需要使用 <span class="keyword">type</span> 和 <span class="keyword">struct</span> 语句。<span class="keyword">struct</span> 语句定义一个新的数据类型，结构体中有一个或多个成员。<span class="keyword">type</span> 语句设定了结构体的名称。结构体的格式如下：</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的结构体</span></span><br><span class="line">    fmt.Println(Books&#123;<span class="string">&quot;Go 语言&quot;</span>, <span class="string">&quot;www.runoob.com&quot;</span>, <span class="string">&quot;Go 语言教程&quot;</span>, <span class="number">6495407</span>&#125;)</span><br><span class="line">    <span class="comment">// 也可以使用 key =&gt; value 格式</span></span><br><span class="line">    fmt.Println(Books&#123;title: <span class="string">&quot;Go 语言&quot;</span>, author: <span class="string">&quot;www.runoob.com&quot;</span>, subject: <span class="string">&quot;Go 语言教程&quot;</span>, book_id: <span class="number">6495407</span>&#125;)</span><br><span class="line">    <span class="comment">// 忽略的字段为 0 或 空</span></span><br><span class="line">   fmt.Println(Books&#123;title: <span class="string">&quot;Go 语言&quot;</span>, author: <span class="string">&quot;www.runoob.com&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line">定义结构体变量：</span><br><span class="line"><span class="keyword">var</span> BOOK1 Books</span><br><span class="line">访问结构体成员：</span><br><span class="line">BOOK1.title=<span class="string">&quot;go&quot;</span></span><br><span class="line">结构体作为函数参数：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title)</span><br><span class="line">&#125;</span><br><span class="line">调用函数：</span><br><span class="line"><span class="keyword">var</span> Book1 Books </span><br><span class="line">再访问结构体成员进行赋值</span><br><span class="line">printBook(Book1)</span><br><span class="line">结构体指针：</span><br><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br><span class="line">struct_pointer = &amp;Book1</span><br><span class="line">使用结构体指针访问结构体成员：</span><br><span class="line">struct_pointer.title</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言切片</span><br><span class="line">Go 语言切片是对数组的抽象。</span><br><span class="line">Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(<span class="string">&quot;动态数组&quot;</span>)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</span><br><span class="line">数组：</span><br><span class="line">val nums=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">nums:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">定义切片：</span><br><span class="line">可通过未指定大小的数组来定义切片：</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">或使用<span class="built_in">make</span>()函数来创建切片：</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br><span class="line">s:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br><span class="line">容量<span class="built_in">cap</span>为可选参数</span><br><span class="line">定义+初始化切片：</span><br><span class="line">s:=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s:=arr[:] <span class="comment">//arr为数组</span></span><br><span class="line">s:=arr[startIndex:endIndex]</span><br><span class="line">切片是可索引的，并且可以由 <span class="built_in">len</span>() 方法获取长度。</span><br><span class="line">切片提供了计算容量的方法 <span class="built_in">cap</span>() 可以测量切片最长可以达到多少。</span><br><span class="line">注：切片<span class="built_in">make</span>指定<span class="built_in">len</span>和<span class="built_in">cap</span>条件下，只定义没初始化的话，<span class="built_in">len</span>长度的数初始化为<span class="number">0</span>，而<span class="built_in">len</span>之外<span class="built_in">cap</span>之内还没有数。而只是定义的话，<span class="built_in">len</span>=<span class="number">0</span>，<span class="built_in">cap</span>=<span class="number">0</span></span><br><span class="line">一个切片未初始化之前（<span class="keyword">var</span> s[]<span class="keyword">int</span>）默认<span class="literal">nil</span>，长度为<span class="number">0</span></span><br><span class="line">切片可通过设置上下限来截取切片,左闭右开的</span><br><span class="line">s[<span class="number">0</span>:<span class="built_in">len</span>(s)] 全部</span><br><span class="line">s[<span class="number">1</span>:] 除了<span class="number">0</span></span><br><span class="line">如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</span><br><span class="line"><span class="built_in">append</span>()函数：增加切片内容：</span><br><span class="line"><span class="keyword">var</span> s[]<span class="keyword">int</span></span><br><span class="line">s=<span class="built_in">append</span>(s,<span class="number">0</span>,<span class="number">1</span>)  可一次增加多个内容</span><br><span class="line">创建另一个切片</span><br><span class="line">s1:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(s),(<span class="built_in">cap</span>(s))*<span class="number">2</span>)</span><br><span class="line">拷贝s的内容到s1</span><br><span class="line"><span class="built_in">copy</span>(s1,s)</span><br><span class="line">疑问：<span class="keyword">go</span>语言中数组和切片的定义没有明确的区别？还是说[]中指定大小就是数组，[]中无数就是切片？</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言范围<span class="keyword">range</span>：</span><br><span class="line">Go 语言中 <span class="keyword">range</span> 关键字用于 <span class="keyword">for</span> 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(<span class="keyword">map</span>)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</span><br><span class="line"><span class="keyword">for</span> _,num:=<span class="keyword">range</span> nums&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i,num:=<span class="keyword">range</span> nums&#123;&#125;</span><br><span class="line">kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">&quot;go&quot;</span> &#123;</span><br><span class="line">    fmt.Println(i, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</span><br><span class="line">Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</span><br><span class="line">可以使用内建函数 <span class="built_in">make</span> 也可以使用 <span class="keyword">map</span> 关键字来定义 Map:</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span> <span class="comment">//声明变量，默认map是nil</span></span><br><span class="line">m=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>) <span class="comment">//如果不初始化，nil不能存放键值对</span></span><br><span class="line">或者：</span><br><span class="line">m:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">m[<span class="number">1</span>]=<span class="string">&quot;liu&quot;</span> <span class="comment">//插入键值对</span></span><br><span class="line"><span class="keyword">for</span> i,s:=<span class="keyword">range</span> m&#123;  <span class="comment">//如果:前只有一个变量，那么就key</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;key:&quot;</span>,i,<span class="string">&quot;value:&quot;</span>,s)</span><br><span class="line">&#125;</span><br><span class="line">查看某个键i是不是存在值</span><br><span class="line">s,ok:=m[i]</span><br><span class="line"><span class="keyword">if</span>(ok)&#123;存在，是s&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;不存在&#125;</span><br><span class="line"><span class="built_in">delete</span>()删除元素：参数是原<span class="keyword">map</span>和要删除的key</span><br><span class="line"><span class="built_in">delete</span>(m,i)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言支持递归函数</span><br><span class="line"><span class="keyword">go</span>语言类型转换,<span class="keyword">go</span>不支持隐试转换类型</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span>=<span class="keyword">float32</span>(i)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言接口</span><br><span class="line">Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</span><br><span class="line">思考：有点类似C++的多态，在接口中定义一个方法，之后会给出不同的实现方式。向内传入的变量不同，方法的具体实现也不同。</span><br><span class="line">接口内的方法可以多个，传入的都是结构体变量？根据传入的结构体变量类型决定采用哪个方法。不同方法的输出可以不一样？每一种方法根据输入有很多种实现？</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;   <span class="comment">//实现error接口跟函数方法一样？</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone  <span class="comment">//定义接口变量</span></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)  <span class="comment">//为接口变量赋值，看方法的实现中要传入什么变量</span></span><br><span class="line">    phone.call()  <span class="comment">//跟函数方法一样的实现</span></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line">&#125;</span><br><span class="line">在上面的例子中，我们定义了一个接口Phone，接口里面有一个方法call()。然后我们在main函数里面定义了一个Phone类型变量，并分别为之赋值为NokiaPhone和IPhone。然后调用call()方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>错误处理</span><br><span class="line">Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</span><br><span class="line">error类型是一个接口类型，这是它的定义：</span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">我们可以在编码中通过实现 error 接口类型来生成错误信息。</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"><span class="comment">// 定义一个 DivideError 结构</span></span><br><span class="line"><span class="keyword">type</span> DivideError <span class="keyword">struct</span> &#123;</span><br><span class="line">    dividee <span class="keyword">int</span></span><br><span class="line">    divider <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现 `error` 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(de *DivideError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    strFormat := <span class="string">`</span></span><br><span class="line"><span class="string">    Cannot proceed, the divider is zero.</span></span><br><span class="line"><span class="string">    dividee: %d</span></span><br><span class="line"><span class="string">    divider: 0</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(strFormat, de.dividee)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义 `int` 类型除法运算的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(varDividee <span class="keyword">int</span>, varDivider <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>, errorMsg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> varDivider == <span class="number">0</span> &#123;</span><br><span class="line">            dData := DivideError&#123;</span><br><span class="line">                    dividee: varDividee,</span><br><span class="line">                    divider: varDivider,</span><br><span class="line">            &#125;   <span class="comment">//定义结构体</span></span><br><span class="line">            errorMsg = dData.Error()  <span class="comment">//使用方法</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> varDividee / varDivider, <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 正常情况</span></span><br><span class="line">    <span class="keyword">if</span> result, errorMsg := Divide(<span class="number">100</span>, <span class="number">10</span>); errorMsg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;100/10 = &quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当除数为零的时候会返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span> _, errorMsg := Divide(<span class="number">100</span>, <span class="number">0</span>); errorMsg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;errorMsg is: &quot;</span>, errorMsg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">//条件语句</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Go 语言支持并发，我们只需要通过 <span class="keyword">go</span> 关键字来开启 goroutine 即可。</span><br><span class="line">goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</span><br><span class="line">Go 允许使用 <span class="keyword">go</span> 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">                time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">                fmt.Println(s)</span><br><span class="line">        &#125;   <span class="comment">//for循环语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">        say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;   </span><br><span class="line">输出的hello和world没有固定的先后顺序，因为它们是两个goroutine在执行。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">通道channel</span><br><span class="line">通道（channel）是用来传递数据的一个数据结构。</span><br><span class="line">通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 &lt;- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</span><br><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">           <span class="comment">// 并把值赋给 v</span></span><br><span class="line">创建通道：使用前必须要先创建</span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">                sum += v</span><br><span class="line">        &#125;</span><br><span class="line">        c &lt;- sum <span class="comment">// 把 sum 发送到通道 c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">        <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">        x, y := &lt;-c, &lt;-c <span class="comment">// 从通道 c 中接收</span></span><br><span class="line">        fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br><span class="line">思考：实现了一个数组分两部分，分别求和，把结果放入通道，从结果来看，通道像是一个栈？后进先出？不是，应该是由于goroutine没有先后顺序。感觉实际实现的是函数返回的问题，不加<span class="keyword">return</span>，把要返回的值放入通道中。这个用<span class="keyword">go</span>线程并行执行。</span><br><span class="line">疑问，如果函数有返回值，怎么用<span class="keyword">go</span>。</span><br><span class="line">默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。</span><br><span class="line">设置缓冲区：</span><br><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">100</span>)</span><br><span class="line">带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</span><br><span class="line">不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</span><br><span class="line">注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</span><br><span class="line">ch&lt;<span class="number">-1</span></span><br><span class="line">ch&lt;<span class="number">-2</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)  <span class="comment">//输出：1 2</span></span><br><span class="line"><span class="keyword">go</span>遍历通道和关闭通道：</span><br><span class="line">Go 通过 <span class="keyword">range</span> 关键字来实现遍历读取到的数据，类似于与数组或切片。</span><br><span class="line">v, ok := &lt;-ch</span><br><span class="line">如果通道接收不到数据后 ok 就为 <span class="literal">false</span>，这时通道就可以使用 <span class="built_in">close</span>() 函数来关闭。</span><br><span class="line">斐波那契数组：</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                c &lt;- x</span><br><span class="line">                x, y = y, x+y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">        <span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line">        <span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line">        <span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line">        <span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">                fmt.Println(i)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>环境配置问题：</span><br><span class="line">GOPATH 自己的<span class="keyword">go</span>语言工作目录，下有src存源码，bin存可执行文件，发布<span class="keyword">go</span> build时生成，pkg编译包，debug时生成的可执行文件，理解为中间文件。</span><br><span class="line">GOROOT是<span class="keyword">go</span>的安装目录</span><br><span class="line">要执行<span class="keyword">go</span>命令和<span class="keyword">go</span>工具，就必须将<span class="keyword">go</span>的可执行文件/usr/local/<span class="keyword">go</span>/bin添加到系统的PATH环境变量中。这样，无论在终端的任何路径，都可识别<span class="keyword">go</span>命令和<span class="keyword">go</span>相关工具。</span><br><span class="line">环境变量是为了告诉系统一个路径</span><br><span class="line">cd ~</span><br><span class="line">vim .bash_profile 中可配置环境变量</span><br><span class="line">source .bash_profile <span class="comment">//使配置生效</span></span><br><span class="line">GOBIN需要吗？</span><br><span class="line">export GOBIN=$GOPATH/bin</span><br><span class="line">事实证明 没有用</span><br><span class="line">export GOROOT=/usr/local/<span class="keyword">go</span></span><br><span class="line">export PATH=$PATH:$GOROOT/bin  <span class="comment">//已有，这个的作用要懂</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">goland安装与激活：</span><br><span class="line">首先安装官方包，使用。</span><br><span class="line">下载压缩包得到jetbrains-agent-latest.zip</span><br><span class="line">打开IDE，将该zip拖入IDE窗口，激活即可。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">goland中左下角terminal可打开终端</span><br><span class="line">配置GOPATH，这一步非常重要，否则代码中的依赖包将无法识别。一般GOPATH都配置到项目名这一层</span><br><span class="line">配置教程：https:<span class="comment">//blog.csdn.net/zxy_666/article/details/80182688</span></span><br><span class="line">GOPATH是什么路径？？？</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">关于环境变量的理解：</span><br><span class="line">认为配置PATH是为了在终端的任何位置都可以识别<span class="keyword">go</span>命令和<span class="keyword">go</span>相关工具。</span><br><span class="line">配置GOPATH相当于是<span class="keyword">go</span>项目的一个工作目录。</span><br><span class="line">！！在终端中export配置是当前终端临时的，关闭无效？ 还是说goland的终端？</span><br><span class="line">所以在文件中配置。</span><br><span class="line">GOPATH 是 Go语言中使用的一个环境变量，它使用绝对路径提供项目的工作目录。</span><br><span class="line">GOPATH 适合处理大量 Go语言源码、多个包组合而成的复杂工程。</span><br><span class="line">在 GOPATH 指定的工作目录下，代码总是会保存在 $GOPATH/src 目录下。在工程经过 <span class="keyword">go</span> build、<span class="keyword">go</span> install 或 <span class="keyword">go</span> get 等指令后，会将产生的二进制可执行文件放在 $GOPATH/bin 目录下，生成的中间缓存文件会被保存在 $GOPATH/pkg 下。</span><br><span class="line">如果需要将整个源码添加到版本管理工具（Version Control System，VCS）中时，只需要添加 $GOPATH/src 目录的源码即可。bin 和 pkg 目录的内容都可以由 src 目录生成。</span><br><span class="line"></span><br><span class="line">设置全局 GOPATH 的方法可能会导致当前项目错误引用了其他目录的 Go 源码文件从而造成编译输出错误的版本或编译报出一些无法理解的错误提示。</span><br><span class="line">因此，建议大家无论是使用命令行或者使用集成开发环境编译 Go 源码时，GOPATH 跟随项目设定。在 Jetbrains 公司的 GoLand 集成开发环境（IDE）中的 GOPATH 设置分为全局 GOPATH 和项目 GOPATH。</span><br><span class="line"></span><br><span class="line">Global GOPATH 代表全局 GOPATH，一般来源于系统环境变量中的 GOPATH；Project GOPATH 代表项目所使用的 GOPATH，该设置会被保存在工作目录的 .idea 目录下，不会被设置到环境变量的 GOPATH 中，但会在编译时使用到这个目录。建议在开发时只填写项目 GOPATH，每一个项目尽量只设置一个 GOPATH，不使用多个 GOPATH 和全局的 GOPATH。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">遗留问题：</span><br><span class="line">gopath除了作为工作目录之外什么用处？</span><br><span class="line">编译为什么不会自动在bin目录下生成可执行文件？</span><br><span class="line">不设置gopath会怎样？</span><br><span class="line">gopath是为了什么？</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记-go入门2.0</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-go%E5%85%A5%E9%97%A82.0/</url>
    <content><![CDATA[<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">go编译型语言，so函数编写的顺序无关紧要。</span><br><span class="line">goroutine 协程</span><br><span class="line">Go语言里面拥三种类型的函数：</span><br><span class="line">-普通的带有名字的函数</span><br><span class="line">-匿名函数或者 lambda 函数</span><br><span class="line">-方法</span><br><span class="line"></span><br><span class="line">同一种类型返回值和带有变量名的返回值</span><br><span class="line">func name()(int,int)&#123;return a,b&#125;</span><br><span class="line">func name()(a , b int)&#123;return&#125;</span><br><span class="line">不可以：</span><br><span class="line">func name()(a,b int,int)&#123;return&#125;</span><br><span class="line"></span><br><span class="line">定义函数变量：</span><br><span class="line">var fname func()</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">匿名函数篇：</span><br><span class="line">① 函数内部定义函数：闭包</span><br><span class="line">好处：内联在函数中，不需要声明，可直接使用函数的变量</span><br><span class="line">Go语言中闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量</span><br><span class="line">函数 + 引用环境 = 闭包</span><br><span class="line">一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”，函数是编译期静态的概念，而闭包是运行期动态的概念。</span><br><span class="line">闭包（Closure）在某些编程语言中也被称为 Lambda 表达式。</span><br><span class="line">闭包对环境中变量的引用过程也可以被称为“捕获”，在 C++<span class="number">11</span> 标准中，捕获有两种类型，分别是引用和复制，可以改变引用的原值叫做“引用捕获”，捕获的过程值被复制到闭包中使用叫做“复制捕获”。</span><br><span class="line"><span class="comment">// C++ 与 C# 中为闭包创建了一个类，而被捕获的变量在编译时放到类中的成员中，闭包在访问被捕获的变量时，实际上访问的是闭包隐藏类的成员。</span></span><br><span class="line">在闭包内部修改引用的变量</span><br><span class="line">闭包对它作用域上部的变量可以进行修改，修改引用的变量会对变量进行实际修改，通过下面的例子来理解：</span><br><span class="line">例子：</span><br><span class="line"><span class="comment">// 准备一个字符串</span></span><br><span class="line">str := <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment">// 创建一个匿名函数</span></span><br><span class="line">foo := func() &#123; </span><br><span class="line">    <span class="comment">// 匿名函数中访问str</span></span><br><span class="line">    str = <span class="attr">&quot;hello dude&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用匿名函数</span></span><br><span class="line">foo()</span><br><span class="line">被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。</span><br><span class="line"></span><br><span class="line">② 函数内部调用其他函数：函数调用</span><br><span class="line"></span><br><span class="line">③ 函数内部调用参数传过来的函数：回调函数</span><br><span class="line">将一个函数的指针作为参数传递给另一个函数，在外部再定义这个函数的实现。</span><br><span class="line">回调函数例子：</span><br><span class="line">func visit(list []int, f func(int)) &#123;</span><br><span class="line">    for _, v := range list &#123;</span><br><span class="line">        f(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    <span class="comment">// 使用匿名函数打印切片内容，可改变传入函数的实现</span></span><br><span class="line">    visit([]int&#123;1, 2, 3, 4&#125;, func(v int) &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">④ 函数内部调用自己这个函数：递归</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>接口篇：</span><br><span class="line">定义接口：</span><br><span class="line"><span class="keyword">type</span> Invoker <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 需要实现一个Call方法</span></span><br><span class="line">    Call(<span class="keyword">interface</span>&#123;&#125;)  <span class="comment">//这个传参？？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>结构体实现接口</span><br><span class="line"><span class="keyword">type</span> Struct <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现Invoker的Call</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Struct)</span> <span class="title">Call</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;from struct&quot;</span>, p)</span><br><span class="line">&#125;</span><br><span class="line">main函数中：</span><br><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">var</span> invoker Invoker</span><br><span class="line"><span class="comment">// 实例化结构体</span></span><br><span class="line">s := <span class="built_in">new</span>(Struct)</span><br><span class="line"><span class="comment">// 将实例化的结构体赋值到接口</span></span><br><span class="line">invoker = s</span><br><span class="line"><span class="comment">// 使用接口调用实例化结构体的方法Struct.Call</span></span><br><span class="line">invoker.Call(<span class="string">&quot;hello&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>函数体实现接口</span><br><span class="line">函数的声明不能直接实现接口，需要将函数定义为类型后，使用类型实现结构体，当类型方法被调用时，还需要调用函数本体。</span><br><span class="line"><span class="comment">// 函数定义为类型</span></span><br><span class="line"><span class="keyword">type</span> FuncCaller <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="comment">// 实现Invoker的Call</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FuncCaller)</span> <span class="title">Call</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用f()函数本体</span></span><br><span class="line">    f(p)</span><br><span class="line">&#125;</span><br><span class="line">main函数中：</span><br><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">var</span> invoker Invoker</span><br><span class="line"><span class="comment">// 将匿名函数转为FuncCaller类型, 再赋值给接口</span></span><br><span class="line">invoker = FuncCaller(<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;from function&quot;</span>, v)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 使用接口调用FuncCaller.Call, 内部会调用函数本体</span></span><br><span class="line">invoker.Call(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TODO:标记部分代码以供将来参考：优化和改进的领域、可能的更改、要讨论的问题等。</span><br><span class="line"></span><br><span class="line">Go语言goroutine和channel使用</span><br><span class="line">goroutine是Go语言中的轻量级线程实现，由Go语言运行时(runtime)管理。使用的时候在函数前面加“<span class="keyword">go</span>”这个单词作为关键词，也是与普通函数的区别了。在函数前面加<span class="keyword">go</span>关键字就可以创建一个新的goroutine进行并发执行。</span><br><span class="line">channel是Go语言提供的goroutine间的通信方式，我们可以使用channel在两个或多个goroutine之家传递消息。channel使用的关键字是用“<span class="keyword">chan</span>”.</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>方法：</span><br><span class="line"><span class="keyword">go</span>语言中函数的概念和c语言中的函数类似，函数名其实是一个指针，而<span class="keyword">go</span>语言的方法是拥有接收者的函数，其实是c++中类的方法的概念。函数是独立存在的，而方法必须有接收者，即必须依附于某个对象。<span class="keyword">go</span>语言使用<span class="keyword">struct</span>来抽象对象。因此方法的接收者可以是<span class="keyword">struct</span>实例或<span class="keyword">struct</span>的指针。</span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">        name  <span class="keyword">string</span>,</span><br><span class="line">        email <span class="keyword">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Email is %s&quot;</span>, email)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是方法的定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">notify</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Email is %d&quot;</span>, email)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go error类型：</span><br><span class="line">见go入门。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对方法的接收者传值：不改变接收者。传地址才改变。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defer：</span><br><span class="line">Go语言的 defer 语句会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。</span><br><span class="line">当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出）</span><br><span class="line">defer func()&#123;   &#125;</span><br><span class="line">go func()&#123;   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go中&#123;&#125;后的（）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>java数和数组输入</title>
    <url>/2021/10/13/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/0.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>java的输入需要依赖Scanner类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br></pre></td></tr></table></figure>

<p>如果需要输入，则先声明一个Scanner对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scanner s = new Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>Scanner附属于输入流System.in，声明Scanner对象之后，在输入的时候需要使用<strong>next()方法</strong>系列指定输入的类型，如输入整数、输入字符串等。遇到回车结束。</p>
<p>常用的next()方法系列：nextInt():输入整数  nextLine():输入字符串   nextDouble():输入双精度数   next():输入字符串（以空格作为分隔符）。</p>
<p>next()方法读取到空白符就结束l；<br>nextLine()读取到回车结束也就是“\r”；</p>
<p>!!!意思是next(),空格结束是键盘输入，回车之后，拿取空格之前的，还是需要回车的。</p>
<p>就不能空格结束算作输入一个吗？？？貌似不能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入数字</span></span><br><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> x;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        x=in.nextFloat();</span><br><span class="line">        System.out.println(x);   <span class="comment">//换行输出，输出之后自动换行</span></span><br><span class="line">        System.out.print(x);    <span class="comment">//不换行打印</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;输出是：%f&quot;</span>, x);   <span class="comment">//按格式输出</span></span><br><span class="line"></span><br><span class="line">        String s1;</span><br><span class="line">        Scanner sin=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        s1=sin.next();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        String s2;</span><br><span class="line">        Scanner sin2=<span class="keyword">new</span> Scanner(System.in);  <span class="comment">//每次输入之前，都需要重新来？？？</span></span><br><span class="line">        s2=sin2.nextLine();</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入数组</span></span><br><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">nums</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输入不定长的数组</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">            b[j] = Integer.parseInt(arr[j]);</span><br><span class="line">            System.out.print(b[j] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输入定长数组</span></span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入三个数：&quot;</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span>[] c=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c.length; i++)&#123;</span><br><span class="line">            c[i]=in.nextInt();</span><br><span class="line">            System.out.print(c[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode两数之和</title>
    <url>/2021/10/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/2.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line">你可以按任意顺序返回答案。</span><br><span class="line"></span><br><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p>关于hashmap的使用：</p>
<p>m.put(a,b)  插入<br>m.containkey(a)  查找key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">twonumbersum</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先写功能函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt;m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a= target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (m.containsKey(a)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;m.get(a), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再写测试函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入数组：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            nums[j] = Integer.parseInt(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入目标值：&quot;</span>);</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> target = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res=twoSum(nums, target);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> re : res) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;结果：&quot;</span>);</span><br><span class="line">            System.out.print(re + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>疑问：功能函数不是static型时，main函数也不能事static的，但是无运行按钮。除非把两个函数都变成static型。</p>
]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java二分查找</title>
    <url>/2021/10/13/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/1.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>有序的序列，每次都是以序列的中间位置的数来与待查找的关键字进行比较，每次缩小一半的查找范围，直到匹配成功。</p>
<p>一个情景：将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">twosplit</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类内二分查找函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">commonBinarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = <span class="number">0</span>;            <span class="comment">//定义middle</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; arr[low] || key &gt; arr[high]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            middle = low + (high - low) / <span class="number">2</span>;  <span class="comment">//防止溢出</span></span><br><span class="line">            <span class="comment">//如果 left 和 right 足够大，mid = (left + right)/2，可能会由于 left+right 导致 int 数据类型越界。</span></span><br><span class="line">            <span class="keyword">if</span> (arr[middle] &gt; key) &#123;</span><br><span class="line">                high = middle - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[middle] &lt; key) &#123;</span><br><span class="line">                low = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;        <span class="comment">//最后仍然没有找到，则返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入输出+测试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入有序数组：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            nums[j] = Integer.parseInt(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入目标值：&quot;</span>);</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> target = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=commonBinarySearch(nums, target);</span><br><span class="line">        System.out.printf(<span class="string">&quot;结果：%d&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode丢失的数字</title>
    <url>/2022/01/04/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/2022.1.4.%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</span><br><span class="line">输入：nums = [3,0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p>首先解决输入，输入数组，next()方法读取到空白符就结束，因此使用nextLine()方法，可以规定以空格还是逗号来分割字符串，变为字符串数组，然后将字符串转变为int类型数字。</p>
<p>方法：如果先排序的话，排序算法时间复杂度高，排完序还得遍历一遍。不如直接遍历一遍，求和，然后算少谁，输出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: leeco</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 丢失的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-01-04 20:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">missedNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入[0，n]的n个数字：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);  <span class="comment">//首先Scanner对象</span></span><br><span class="line">        String str = sc.nextLine();    <span class="comment">//使用Scanner的方法</span></span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);  <span class="comment">//分割字符串函数</span></span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];  <span class="comment">//数组长度没括号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            b[i] = Integer.parseInt(arr[i]); <span class="comment">//字符串转数字函数parseInt</span></span><br><span class="line">        &#125;</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(s.missingNumber(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;  <span class="comment">//Solution类不能是public的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = (<span class="number">1</span>+nums.length)*nums.length/<span class="number">2</span> - sum;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知识点：</p>
<p>求平方：<code>double pre = Math.pow(nums.length, 2);</code></p>
<p>double类型转换为int类型：<code>int res = new Double(pre).intValue();</code></p>
<p>数组排序：<code>Arrays.sort(nums);</code></p>
<p>其他方法：</p>
<p>哈希集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> missing = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i)) &#123;</span><br><span class="line">                missing = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异或运算：自己与自己异或，得到的是0，自己与0异或，得到的是自己。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            xor ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            xor ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> xor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode Excel表列名称</title>
    <url>/2022/01/05/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/2022.1.5.Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。</span><br><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span> </span><br></pre></td></tr></table></figure>

<p>首先要输入一个int，输出一个string，应该涉及到大写字母到小写字母的转换，以及字母到ASCII码的转换。</p>
<p>相当于26进制的转换，10进制变26进制，再转变为字母。</p>
<blockquote>
<p>A的ASCII码是65，a的ASCII码是97，ASCII码表中，小写字母排在大写字母的后面，一个字母的大小写数值相差32，一般知道大写字母的ASCII码数值，其对应的小写字母的ASCII码数值就算出来了，是大写字母的ASCII码数值+32。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: leeco</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Excel表列名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-01-05 14:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">excelTable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;输入一个数字：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">        excelTableSolution s = <span class="keyword">new</span> excelTableSolution();</span><br><span class="line">        System.out.println(s.convertToTitle(num));</span><br><span class="line">        System.out.println(s.convertToTitle1(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">excelTableSolution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(columnNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pre = (columnNumber-<span class="number">1</span>) % <span class="number">26</span> +<span class="number">1</span>;  <span class="comment">//26除余是0，这样变为26</span></span><br><span class="line">            res += (<span class="keyword">char</span>) (pre - <span class="number">1</span> + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            columnNumber = (columnNumber - pre) / <span class="number">26</span>; <span class="comment">//注意！</span></span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(res);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//或者，直接用StringBuilder类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle1</span><span class="params">(<span class="keyword">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(columnNumber &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre = (columnNumber-<span class="number">1</span>) % <span class="number">26</span> +<span class="number">1</span>;  <span class="comment">//26除余是0，这样变为26</span></span><br><span class="line">            sb.append((<span class="keyword">char</span>) (pre - <span class="number">1</span> + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            columnNumber = (columnNumber - pre) / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode 整数转罗马数字</title>
    <url>/2022/01/08/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/2022.1.8.%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。  1 &lt;= num &lt;= 3999</span><br><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br><span class="line">；</span><br><span class="line">通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><br><span class="line"></span><br><span class="line">I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><br><span class="line">X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><br><span class="line">C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/integer-to-roman</span><br><span class="line"></span><br><span class="line">输入: num = 9</span><br><span class="line">输出: &quot;IX&quot;</span><br><span class="line">输入: num = 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>

<p>注意总共 13 个独特的符号（每个符号由 1 个或 2 个字母组成）。确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。</p>
<p>思路：建立一个数值-罗马符号的列表，从大到小排列，对列表进行遍历，如果num值大于当前遍历到的列表元素，就减去，并加上相应的字符串，直到num变为0。需要注意：同一个符号可能用好多次。所以while循环。列表就用数组表示，两个数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: leeco</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 罗马数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-01-08 20:04</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">luomashuzi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;输入一个整数：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">        luomashuziSolution s = <span class="keyword">new</span> luomashuziSolution();</span><br><span class="line">        System.out.print(s.intToRoman(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">luomashuziSolution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = values[i];</span><br><span class="line">            String symbol = symbols[i];</span><br><span class="line">            <span class="keyword">while</span>(num &gt;= value)&#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                res.append(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode二叉树篇</title>
    <url>/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/</url>
    <content><![CDATA[<h2 id="二叉树的输入和遍历"><a href="#二叉树的输入和遍历" class="headerlink" title="二叉树的输入和遍历"></a>二叉树的输入和遍历</h2><p>二叉树定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序创建二叉树：输入一个节点回车一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入二叉树！&quot;</span>);</span><br><span class="line">        TreeNode root = creatTree();</span><br><span class="line">        ArrayList&lt;Integer&gt; qianxu = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        qianxu=preOrderReverse(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>+qianxu);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照前序遍历方式创建二叉树，0代表空，例如1左2右3：1200300</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">creatTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeNode root;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="comment">//回车结束输入</span></span><br><span class="line">        <span class="comment">//Scanner in=new Scanner(System.in);</span></span><br><span class="line">        <span class="comment">//num=in.nextInt();</span></span><br><span class="line">        <span class="comment">//还是回车结束</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.next();</span><br><span class="line">        num=Integer.parseInt(str);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            root=<span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root=<span class="keyword">new</span> TreeNode(num);</span><br><span class="line">            root.left=creatTree();</span><br><span class="line">            root.right=creatTree();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归法进行遍历</span></span><br><span class="line">    <span class="comment">//前序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">preOrderReverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);           <span class="comment">// 注意这一句</span></span><br><span class="line">        preOrder(root.left, result);</span><br><span class="line">        preOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序创建二叉树：输入一个节点空格一次，一行输入。</p>
<h2 id="前中后序遍历，用递归，带输入输出"><a href="#前中后序遍历，用递归，带输入输出" class="headerlink" title="前中后序遍历，用递归，带输入输出"></a>前中后序遍历，用递归，带输入输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建二叉树</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入二叉树！&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">            b[j] = Integer.parseInt(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = creatTree(b);</span><br><span class="line">        <span class="comment">//前序遍历</span></span><br><span class="line">        ArrayList&lt;Integer&gt; qianxu = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        qianxu=preOrderReverse(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>+qianxu);</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        List&lt;Integer&gt; zhongxu = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        zhongxu=inorderTraversal(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>+zhongxu);</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        List&lt;Integer&gt; houxu = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        houxu=postorderTraversal(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历：&quot;</span>+houxu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照前序遍历方式创建二叉树，0代表空，例如1左2右3：1200300</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">creatTree</span><span class="params">(<span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">        TreeNode root;</span><br><span class="line">        <span class="keyword">int</span> num=b[t++];</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root=<span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        root.left=creatTree(b);</span><br><span class="line">        root.right=creatTree(b);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归法进行遍历</span></span><br><span class="line">    <span class="comment">//前序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">preOrderReverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);           <span class="comment">// 注意这一句</span></span><br><span class="line">        preOrder(root.left, result);</span><br><span class="line">        preOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, list);</span><br><span class="line">        postorder(root.right, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前中后序遍历，用迭代"><a href="#前中后序遍历，用迭代" class="headerlink" title="前中后序遍历，用迭代"></a>前中后序遍历，用迭代</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur = stack.pop();</span><br><span class="line">               result.add(cur.val);</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//checkFun01(root,0);</span></span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS--递归方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFun01</span><span class="params">(TreeNode node, Integer deep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resList.size() &lt; deep) &#123;</span><br><span class="line">            <span class="comment">//当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS--迭代方式--借助队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFun02</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> len = que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="keyword">null</span>) que.offer(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="keyword">null</span>) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226题-翻转二叉树"><a href="#226题-翻转二叉树" class="headerlink" title="226题.翻转二叉树"></a>226题.翻转二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前后序遍历都可以</span></span><br><span class="line"><span class="comment">     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        swapChildren(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapChildren</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = deque.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = deque.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;deque.offer(node.left);&#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;deque.offer(node.right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101题-对称二叉树"><a href="#101题-对称二叉树" class="headerlink" title="101题.对称二叉树"></a>101题.对称二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较外侧</span></span><br><span class="line">        <span class="keyword">boolean</span> compareOutside = compare(left.left, right.right);</span><br><span class="line">        <span class="comment">// 比较内侧</span></span><br><span class="line">        <span class="keyword">boolean</span> compareInside = compare(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> compareOutside &amp;&amp; compareInside;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用双端队列，相当于两个栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.offerFirst(root.left);</span><br><span class="line">        deque.offerLast(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            TreeNode leftNode = deque.pollFirst();</span><br><span class="line">            TreeNode rightNode = deque.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> &amp;&amp; rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> || rightNode == <span class="keyword">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerFirst(leftNode.left);</span><br><span class="line">            deque.offerFirst(leftNode.right);</span><br><span class="line">            deque.offerLast(rightNode.right);</span><br><span class="line">            deque.offerLast(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用普通队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric3</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.offer(root.left);</span><br><span class="line">        deque.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            TreeNode leftNode = deque.poll();</span><br><span class="line">            TreeNode rightNode = deque.poll();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> &amp;&amp; rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> || rightNode == <span class="keyword">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里顺序与使用Deque不同</span></span><br><span class="line">            deque.offer(leftNode.left);</span><br><span class="line">            deque.offer(rightNode.right);</span><br><span class="line">            deque.offer(leftNode.right);</span><br><span class="line">            deque.offer(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="257题-二叉树的所有路径"><a href="#257题-二叉树的所有路径" class="headerlink" title="257题.二叉树的所有路径"></a>257题.二叉树的所有路径</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; paths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        traversal(root, paths, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        paths.add(root.val);</span><br><span class="line">        <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                sb.append(paths.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(paths.get(paths.size() - <span class="number">1</span>));</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traversal(root.left, paths, res);</span><br><span class="line">            paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traversal(root.right, paths, res);</span><br><span class="line">            paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="39题-组合总和"><a href="#39题-组合总和" class="headerlink" title="39题.组合总和"></a>39题.组合总和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br><span class="line">说明：</span><br><span class="line">所有数字（包括 target）都是正整数。</span><br><span class="line">解集不能包含重复的组合。</span><br><span class="line">示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 剪枝优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates); <span class="comment">// 先进行排序</span></span><br><span class="line">        backtracking(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到了数字和为 target 的组合</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(res, path, candidates, target, sum + candidates[i], i);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯，移除路径 path 最后一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode字符串篇</title>
    <url>/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>char ch : s.<strong>toCharArray()</strong>  遍历字符串中的字符。c++中的 ch：s 不可用。</p>
<p>字符串中，获得第几个字符，不能用s[i]，而是：s.<strong>charAt(i)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sb.setCharAt(<span class="number">0</span>,<span class="string">&#x27;v&#x27;</span>);  <span class="comment">//替换某位置的字符</span></span><br></pre></td></tr></table></figure>

<h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = &quot;Runoob&quot;;</span><br><span class="line">String str2=new String(&quot;Runoob&quot;);</span><br><span class="line">String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</span><br><span class="line">char[] helloArray = &#123; &#x27;r&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;b&#x27;&#125;;</span><br><span class="line">String helloString = new String(helloArray);  </span><br></pre></td></tr></table></figure>

<p>**注意:**String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。</p>
<p>如果需要对字符串做很多修改，那么应该选择使用 [StringBuffer &amp; StringBuilder 类]。</p>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String site = &quot;www.runoob.com&quot;;</span><br><span class="line">int len = site.length();   (结果为14)</span><br></pre></td></tr></table></figure>

<h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;我的名字是 &quot;.concat(&quot;Runoob&quot;);</span><br><span class="line">String string1 = &quot;菜鸟教程网址：&quot;;     </span><br><span class="line">System.out.println(&quot;1、&quot; + string1 + &quot;www.runoob.com&quot;);  </span><br></pre></td></tr></table></figure>

<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.printf(字符串变量的值为%s&quot;, stringVar);</span><br><span class="line">String fs;</span><br><span class="line">fs = String.format(&quot; 字符串变量的值为 %s&quot;, stringVar);</span><br></pre></td></tr></table></figure>

<h3 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h3><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p>
<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，<strong>所以如果需要对字符串进行修改推荐使用 StringBuffer。</strong></p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，<strong>所以多数情况下建议使用 StringBuilder 类。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder(10);  //定大小</span><br><span class="line">sb.append(&quot;Runoob..&quot;);    //在容量内加</span><br><span class="line">sb.insert(8, &quot;Java&quot;);    //在容量外加</span><br><span class="line">System.out.println(sb); </span><br><span class="line">sb.delete(5,8);    //删除</span><br><span class="line">变成string字符串：  res.toString();</span><br></pre></td></tr></table></figure>

<p><strong>在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类</strong>。</p>
<h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Str.substring(4)   从4开始，包括4</span><br><span class="line">Str.substring(4, 10)   左闭右开，包括4不包括10</span><br></pre></td></tr></table></figure>

<h3 id="字符串转换为int"><a href="#字符串转换为int" class="headerlink" title="字符串转换为int"></a>字符串转换为int</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer.valueOf(&quot;444&quot;,16)  //16进制</span><br><span class="line">Integer.parseInt(arr[j]);</span><br></pre></td></tr></table></figure>

<h3 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuilder sb=new StringBuilder(s);</span><br><span class="line">return sb.reverse().toString();</span><br></pre></td></tr></table></figure>

<h2 id="344题-反转字符串"><a href="#344题-反转字符串" class="headerlink" title="344题.反转字符串"></a>344题.反转字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</span><br><span class="line">不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</span><br><span class="line">示例 1：</span><br><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p>思路：一头一尾双指针，交换即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            s[l] ^= s[r]; </span><br><span class="line">            s[r] ^= s[l];  </span><br><span class="line">            s[l] ^= s[r];  </span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="541题-反转字符串Ⅱ"><a href="#541题-反转字符串Ⅱ" class="headerlink" title="541题.反转字符串Ⅱ"></a>541题.反转字符串Ⅱ</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</span><br><span class="line">如果剩余字符少于 k 个，则将剩余字符全部反转。</span><br><span class="line">如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</span><br><span class="line">示例:</span><br><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;bacdfeg&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解法一：用StringBuffer类，对字符串进行改变。用到append（）方法、substring方法（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; length) &#123;</span><br><span class="line">            <span class="comment">// 找到k处和2k处</span></span><br><span class="line">            StringBuffer temp = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="comment">// 与length进行判断，如果大于length了，那就将其置为length</span></span><br><span class="line">            <span class="keyword">int</span> firstK = (start + k &gt; length) ? length : start + k;</span><br><span class="line">            <span class="keyword">int</span> secondK = (start + (<span class="number">2</span> * k) &gt; length) ? length : start + (<span class="number">2</span> * k);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//无论start所处位置，至少会反转一次</span></span><br><span class="line">            temp.append(s.substring(start, firstK));</span><br><span class="line">            res.append(temp.reverse());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果firstK到secondK之间有元素，这些元素直接放入res里即可。</span></span><br><span class="line">            <span class="keyword">if</span> (firstK &lt; secondK) &#123; <span class="comment">//此时剩余长度一定大于k。</span></span><br><span class="line">                res.append(s.substring(firstK, secondK));</span><br><span class="line">            &#125;</span><br><span class="line">            start += (<span class="number">2</span> * k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：用char型数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="comment">//这里是判断尾数够不够k个来取决end指针的位置</span></span><br><span class="line">            <span class="keyword">int</span> end = Math.min(ch.length - <span class="number">1</span>, start + k - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//用异或运算反转 </span></span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                ch[end] ^= ch[start];</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);   <span class="comment">//char型数组变string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指offer05-替换空格"><a href="#剑指offer05-替换空格" class="headerlink" title="剑指offer05.替换空格"></a>剑指offer05.替换空格</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br><span class="line">示例 1： 输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<p>思路：直接用一个stringbuilder来新建字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//选用 StringBuilder 单线程使用，比较快</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//碰到空格则替换，否则直接复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">		<span class="comment">//str.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot; &quot;</span>.equals(String.valueOf(s.charAt(i))))&#123;</span><br><span class="line">        <span class="comment">//.valueOf类型转换，类似parseInt也可以string转int</span></span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个字符串，逐个翻转字符串中的每个单词。</span><br><span class="line">示例 1：</span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<p>思路：首先将整个字符串反转过来，然后将字符串中的单词反转一下，即可。</p>
<ul>
<li>移除多余空格 : “the sky is blue”</li>
<li>字符串反转：”eulb si yks eht”</li>
<li>单词反转：”blue is sky the”</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.reverseWords2() called with: s = [&quot; + s + &quot;]&quot;);</span></span><br><span class="line">        <span class="comment">// 1.去除首尾以及中间多余空格</span></span><br><span class="line">        StringBuilder sb = removeSpace(s);</span><br><span class="line">        <span class="comment">// 2.反转整个字符串</span></span><br><span class="line">        reverseString(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.反转各个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">removeSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(start) == <span class="string">&#x27; &#x27;</span>) start++;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseEachWord</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = sb.length();</span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseString(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer58-II-左旋转字符串"><a href="#剑指Offer58-II-左旋转字符串" class="headerlink" title="剑指Offer58-II.左旋转字符串"></a>剑指Offer58-II.左旋转字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<p>思路：如果要求不申请额外空间</p>
<ol>
<li>反转区间为前n的子串</li>
<li>反转区间为n到末尾的子串</li>
<li>反转整个字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        reverseString(sb,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        reverseString(sb,n,len-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//翻转函数</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="459题-重复的子字符串"><a href="#459题-重复的子字符串" class="headerlink" title="459题.重复的子字符串"></a>459题.重复的子字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</span><br><span class="line">输入: &quot;abab&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure>

<p>思路：KMP算法，KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>
<p>KMP的精髓所在就是前缀表，前缀表：起始位置到下表i之前（包括i）的子串中，有多大长度的相同前缀后缀。</p>
<p>前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。</p>
<p>后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了</span></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 构造 next 数组过程，j从0开始(空格)，i从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 匹配不成功，j回到前一位置 next 数组所对应的值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">// 匹配成功，j往后移</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">// 更新 next 数组的值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值</span></span><br><span class="line">        <span class="keyword">if</span> (next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode刷题数组篇</title>
    <url>/2021/10/31/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E6%95%B0%E7%BB%84%E7%AF%87/</url>
    <content><![CDATA[<h2 id="27题の移除元素"><a href="#27题の移除元素" class="headerlink" title="27题の移除元素"></a>27题の移除元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p>思路：暴力解法：两个for循环，每找到一个，都将它后面的元素一个个往前移。时间复杂度是O(n^2)。</p>
<p>简单解法：快慢指针法，对哪个指针进行判断是关键，如果对慢指针进行判断，则有一个就会后面一直相邻交换。应该对快指针进行判断，快指针判断到不是目标值，将该值赋给慢指针所在位置，慢指针移动1，如果是目标值，直接跳过，慢指针不移动。因此一层循环可以解决，<strong>循环内是快指针</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fast=<span class="number">0</span>; fast&lt;nums.length; fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=val)&#123;</span><br><span class="line">                nums[slow]=nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="977题の有序数组的平方"><a href="#977题の有序数组的平方" class="headerlink" title="977题の有序数组的平方"></a>977题の有序数组的平方</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</span><br><span class="line"></span><br><span class="line">示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</span><br><span class="line"></span><br><span class="line">示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>

<p>思路：双指针，因为原始数组是有序的，但是左边可能是负数，所以，数组的左右各一个指针，都往中间移动，判断两头的大小，挨个按照逆序塞到结果数组中。</p>
<p>知识：创建数组 int[] nums=new int[size];<br>Math.pow(n,m)幂次运算结果为double类型<br>强制类型转换(int)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];  <span class="comment">//创建数组</span></span><br><span class="line">        <span class="keyword">int</span> index=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.pow(nums[left],<span class="number">2</span>)&gt;=Math.pow(nums[right],<span class="number">2</span>))&#123;</span><br><span class="line">                res[index--]=(<span class="keyword">int</span>)Math.pow(nums[left],<span class="number">2</span>);</span><br><span class="line">                <span class="comment">//pow幂次运算结果是double类型，(int)来强制类型转换</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[index--]=(<span class="keyword">int</span>)Math.pow(nums[right],<span class="number">2</span>);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="209题の长度最小的子数组"><a href="#209题の长度最小的子数组" class="headerlink" title="209题の长度最小的子数组"></a>209题の长度最小的子数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<p>思路：滑动窗口，想象一下：右边加一个数，左边可以少几个数<br>窗口：连续的数组<br>起始位置：终止位置移动后，根据窗口内的和来判断是否移动起始指针<br>终止位置：<strong>循环内</strong>一个一个移动</p>
<p>知识：int的最大值：Integer.MAX_VALUE<br>最小运算：Math.min(a,b)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=<span class="number">0</span>; right&lt;nums.length; right++)&#123;</span><br><span class="line">            sum+=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">                <span class="comment">//这里得是&gt;=，并且min运算得在前面，因为开始窗口移动后可能不足target</span></span><br><span class="line">                res=Math.min(right-left+<span class="number">1</span>, res); <span class="comment">//注意判断的位置，一定得是while里</span></span><br><span class="line">                sum-=nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==Integer.MAX_VALUE? <span class="number">0</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59题の螺旋矩阵Ⅱ"><a href="#59题の螺旋矩阵Ⅱ" class="headerlink" title="59题の螺旋矩阵Ⅱ"></a>59题の螺旋矩阵Ⅱ</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</span><br><span class="line">示例:</span><br><span class="line">输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</span><br></pre></td></tr></table></figure>

<p>思路：判断是否进入四个角，需要拐弯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n*n; k++)&#123;</span><br><span class="line">            res[i][j]=k;</span><br><span class="line">            <span class="keyword">if</span>((i==<span class="number">0</span>||res[i-<span class="number">1</span>][j]!=<span class="number">0</span>)&amp;&amp;j&lt;n-<span class="number">1</span>&amp;&amp;res[i][j+<span class="number">1</span>]==<span class="number">0</span>)  j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((j==n-<span class="number">1</span>||res[i][j+<span class="number">1</span>]!=<span class="number">0</span>)&amp;&amp;i&lt;n-<span class="number">1</span>&amp;&amp;res[i+<span class="number">1</span>][j]==<span class="number">0</span>) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((i==n-<span class="number">1</span>||res[i+<span class="number">1</span>][j]!=<span class="number">0</span>)&amp;&amp;j&gt;=<span class="number">1</span>&amp;&amp;res[i][j-<span class="number">1</span>]==<span class="number">0</span>) j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((j==<span class="number">0</span>||res[i][j-<span class="number">1</span>]!=<span class="number">0</span>)&amp;&amp;i&gt;=<span class="number">1</span>&amp;&amp;res[i-<span class="number">1</span>][j]==<span class="number">0</span>) i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于数组，思考一些双指针法、快慢指针法、滑动窗口法。</p>
<h2 id="动态数组ArrayList"><a href="#动态数组ArrayList" class="headerlink" title="动态数组ArrayList"></a>动态数组ArrayList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 ArrayList 类</span></span><br><span class="line">ArrayList&lt;E&gt; objectName =<span class="keyword">new</span> ArrayList&lt;&gt;();　 <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">访问 ArrayList 中的元素可以使用 get() 方法：</span><br><span class="line">System.out.println(sites.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">如果要修改 ArrayList 中的元素可以使用 set() 方法：</span><br><span class="line">sites.set(<span class="number">2</span>, <span class="string">&quot;Wiki&quot;</span>); <span class="comment">// 第一个参数为索引位置，第二个为要修改的值</span></span><br><span class="line"></span><br><span class="line">如果要删除 ArrayList 中的元素可以使用 remove() 方法：</span><br><span class="line">sites.remove(<span class="number">3</span>); <span class="comment">// 删除第四个元素</span></span><br><span class="line"></span><br><span class="line">如果要计算 ArrayList 中的元素数量可以使用 size() 方法：</span><br><span class="line">System.out.println(sites.size());</span><br><span class="line"></span><br><span class="line">Collections.sort(sites);  <span class="comment">// 字母排序</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode哈希表篇</title>
    <url>/2021/11/03/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
<p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p>
<p>哈希函数、哈希碰撞：拉链法。线性探测法（要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了）</p>
<p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<h3 id="Java中Map与HashMap-Hashtable-HashSet的区别"><a href="#Java中Map与HashMap-Hashtable-HashSet的区别" class="headerlink" title="Java中Map与HashMap,Hashtable,HashSet的区别"></a>Java中Map与HashMap,Hashtable,HashSet的区别</h3><p>HashMap和Hashtable两个类都实现了Map接口，二者保存K-V对（key-value对）；HashSet则实现了Set接口，性质类似于集合。</p>
<p>HashTable和HashMap区别：</p>
<p>一、继承的父类不同<br>Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。<br>二、线程安全性不同<br>Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理。<br>三、是否提供contains方法<br>HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。<br>Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。<br>四、key和value是否允许null值<br>其中key和value都是对象，并且不能包含重复key，但可以包含重复的value。<br>Hashtable中，key和value都不允许出现null值。<br>HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。<br>五、两个遍历方式的内部实现上不同<br>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。<br>六、hash值不同<br>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。<br>七、内部实现使用的数组初始化和扩容方式不同<br>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。<br>HashMap中hash数组的默认大小是16，而且一定是2的指数。</p>
<h2 id="242题-有效的字母异位词"><a href="#242题-有效的字母异位词" class="headerlink" title="242题.有效的字母异位词"></a>242题.有效的字母异位词</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</span><br><span class="line">示例 1: 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true</span><br><span class="line">示例 2: 输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false</span><br></pre></td></tr></table></figure>

<p>思路：用map，先遍历一个往里加，再遍历另一个减，如果没有或者value是0，则false。看到只有小写字母，所以长度为26的数组来充当map也可以。</p>
<p>知识：char ch : s.<strong>toCharArray()</strong>  遍历字符串中的字符。c++中的 ch：s 不可用。</p>
<p>字符串中，获得第几个字符，不能用s[i]，而是：s.<strong>charAt(i)</strong></p>
<p>判断map中是否有某key：if(!m.containsKey(ch))</p>
<p>获得key对应的value：m.get(key)</p>
<p>改变某key的value，直接覆盖？不能：m[i]++;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt;m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())&#123;</span><br><span class="line">        <span class="comment">//数组的长度length不加括号，字符串的长度要加括号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m.containsKey(ch))&#123;</span><br><span class="line">                m.put(ch,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m.put(ch, m.get(ch)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:t.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m.containsKey(ch) || m.get(ch)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//a==0 和 a.equals(0) 一样</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m.put(ch, m.get(ch)-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方法：单纯的字符串排序比较</p>
<p>首先将字符串变成字符数组，然后进行排序，然后进行比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="349题-两个数组的交集"><a href="#349题-两个数组的交集" class="headerlink" title="349题.两个数组的交集"></a>349题.两个数组的交集</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定两个数组，编写一个函数来计算它们的交集。</span><br><span class="line">说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</span><br></pre></td></tr></table></figure>

<p>思路：哈希set即可。一个遍历得到数字，一个存储结果。</p>
<p>int[] 是固定长数组，没法像vector一样push_back</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组2的过程中判断哈希表中是否存在该元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">                resSet.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] resArr = <span class="keyword">new</span> <span class="keyword">int</span>[resSet.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将结果几何转为数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : resSet) &#123;  <span class="comment">//数组、set可以这样做，string不行</span></span><br><span class="line">            resArr[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="202题-快乐数"><a href="#202题-快乐数" class="headerlink" title="202题.快乐数"></a>202题.快乐数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</span><br></pre></td></tr></table></figure>

<p>思路：使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p>
<p>知识：set判断某数是否存在：s.contains(i);</p>
<p>set添加一个数：s.add(i);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; record = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !record.contains(n)) &#123;</span><br><span class="line">            record.add(n);</span><br><span class="line">            n = getsum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得n各位平方后的和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n % <span class="number">10</span>;</span><br><span class="line">            res += temp * temp;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="454题-四数相加"><a href="#454题-四数相加" class="headerlink" title="454题.四数相加"></a>454题.四数相加</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</span><br><span class="line"></span><br><span class="line">为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</span><br></pre></td></tr></table></figure>

<p>思路：用一个map代表双层循环，另外再来个双层循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span>[] nums3, <span class="keyword">int</span>[] nums4)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计两个数组中的元素之和，同时统计出现的次数，放入map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : nums2) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line">                    map.put(temp, map.get(temp) + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(temp, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : nums4) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15题-三数之和"><a href="#15题-三数之和" class="headerlink" title="15题.三数之和"></a>15题.三数之和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</span><br><span class="line">注意： 答案中不可以包含重复的三元组。</span><br><span class="line">示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</span><br></pre></td></tr></table></figure>

<p>思路：难点在于去重</p>
<p>方法一：两层循环，第二层加一个set。注意去重。</p>
<p>方法二：双指针法，其实是三指针，i指针后，left和right。三数之和如果大了，右指针左移，小了，左指针右移。</p>
<p>知识：动态数组ArrayList。添加数：result.add(Arrays.asList(nums[i], nums[left], nums[right])); （）asList是降int[]变成list的意思。</p>
<p>数组int[] 排序：Arrays.sort(nums);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    right--; </span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18题-四数之和"><a href="#18题-四数之和" class="headerlink" title="18题.四数之和"></a>18题.四数之和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span><br><span class="line">注意：答案中不可以包含重复的四元组。</span><br><span class="line">示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</span><br></pre></td></tr></table></figure>

<p>四数之和，和15.三数之和是一个思路，都是使用双指针法, 基本解法就是在15.三数之和的基础上再套一层for循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); </span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode栈与队列篇</title>
    <url>/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack&lt;Character&gt; st = new Stack&lt;Character&gt;();</span><br><span class="line">或</span><br><span class="line">Deque&lt;Character&gt; st = new LinkedList&lt;Character&gt;();</span><br><span class="line">st.isEmpty()</span><br><span class="line">st.peek()</span><br><span class="line">st.pop();</span><br><span class="line">st.push(ch);</span><br></pre></td></tr></table></figure>

<h2 id="20题-有效的括号"><a href="#20题-有效的括号" class="headerlink" title="20题.有效的括号"></a>20题.有效的括号</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串，判断字符串是否有效。</span><br><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        if (n % 2 == 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = new HashMap&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">            put(&#x27;)&#x27;, &#x27;(&#x27;);</span><br><span class="line">            put(&#x27;]&#x27;, &#x27;[&#x27;);</span><br><span class="line">            put(&#x27;&#125;&#x27;, &#x27;&#123;&#x27;);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        //Deque&lt;Character&gt; stack = new LinkedList&lt;Character&gt;();</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            char ch = s.charAt(i);</span><br><span class="line">            if (pairs.containsKey(ch)) &#123;</span><br><span class="line">                if (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue1= new LinkedList&lt;&gt;();</span><br><span class="line">queue1.isEmpty()</span><br><span class="line">queue2.offer(x);   //添加一个元素并返回true   如果队列已满，则返回false</span><br><span class="line">queue1.poll()   //移除并返问队列头部的元素  如果队列为空，则返回null</span><br><span class="line">queue1.peek()  //返回队列头部的元素   如果队列为空，则返回null</span><br><span class="line">remove   移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常</span><br><span class="line">element  返回队列头部的元素  如果队列为空，则抛出一个NoSuchElementException异常</span><br><span class="line">add       增加一个元索   如果队列已满，则抛出一个IIIegaISlabEepeplian异常</span><br><span class="line">put       添加一个元素  如果队列满，则阻塞</span><br><span class="line">take      移除并返回队列头部的元素    如果队列为空，则阻塞</span><br><span class="line"></span><br><span class="line">1、add()和offer()区别:</span><br><span class="line">add()和offer()都是向队列中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。因此就可以在程序中进行有效的判断！</span><br><span class="line"></span><br><span class="line"> 2、poll()和remove()区别：</span><br><span class="line">remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。</span><br><span class="line"></span><br><span class="line">3、element() 和 peek() 区别：</span><br><span class="line">element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。</span><br></pre></td></tr></table></figure>

<h2 id="deque与queue"><a href="#deque与queue" class="headerlink" title="deque与queue"></a>deque与queue</h2><p><strong>Queue</strong>是简单的FIFO队列，<strong>Deque</strong>继承<strong>Queue</strong>实现双端队列。</p>
<p>队列(queue)是一种常用的<strong>数据结构</strong>，可以将队列看做是一种特殊的线性表，该结构遵循的先进先出原则。Java中，<strong>LinkedList实现了Queue接口</strong>,因为LinkedList进行插入、删除操作效率较高。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      抛出异常	返回特殊值</span><br><span class="line">插入	add(e)	offer(e)</span><br><span class="line">移除	remove()	poll()</span><br><span class="line">检查	element()	peek()</span><br><span class="line"></span><br><span class="line">boolean add(E e);将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。</span><br><span class="line">boolean offer(E e);将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。</span><br><span class="line">E remove();获取并移除此队列的头。</span><br><span class="line">E poll();获取并移除此队列的头，如果此队列为空，则返回 null。</span><br><span class="line">E element();获取，但是不移除此队列的头。</span><br><span class="line">E peek();获取但不移除此队列的头；如果此队列为空，则返回 null。</span><br></pre></td></tr></table></figure>

<p>双向队列<strong>Deque</strong>继承了<strong>Queue</strong>，此队列两端都能进行出列和入列操作。除了继承了<strong>Queue</strong>的接口，又对每种方法额外添加了<code>first</code>与<code>last</code>方法用以实现操作双端队列。</p>
<h3 id="队列queue的使用："><a href="#队列queue的使用：" class="headerlink" title="队列queue的使用："></a>队列queue的使用：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Queue&lt;String&gt;que = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        que.offer(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        que.offer(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        que.offer(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的队列：&quot;</span>+que);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str=que.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的队列：&quot;</span>+que);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向队列deque的使用："><a href="#双向队列deque的使用：" class="headerlink" title="双向队列deque的使用："></a>双向队列deque的使用：</h3><p>第一种用法：同queue一样，作为单向队列使用，此时使用offer入列，poll出列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDeque1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Deque&lt;String&gt; deq = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        deq.offer(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        deq.offer(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        deq.offer(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的队列：&quot;</span>+deq);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(deq.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str=deq.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的队列：&quot;</span>+deq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种用法：作为双向队列使用，此时使用offerFirst、pollFirst，offerLast、pollFirst，则可以实现队首队尾入列或者出列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDeque2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Deque&lt;String&gt; deq2 = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        deq2.offerLast(<span class="string">&quot;aa&quot;</span>);  <span class="comment">//从后面进入</span></span><br><span class="line">        deq2.offerLast(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        deq2.offerLast(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的队列：&quot;</span>+deq2);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(deq2.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str= deq2.pollFirst();  <span class="comment">//从前面输出</span></span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的队列：&quot;</span>+deq2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种用法：作为栈来使用，遵循先入后出的原则，使用push和pop进行入栈和出栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDeque3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Deque&lt;String&gt; st = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        st.push(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        st.push(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        st.push(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的栈：&quot;</span>+st);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(st.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str= st.pop(); </span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的栈：&quot;</span>+st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>queue是单向队列，遵循先入先出的原则，而deque是queue的子接口，不仅可以作为单向队列使用，同时可以作为双向队列使用，根据入列出列在队尾或者队首决定输出元素顺序，在使用push和poll方法时，deque被称为栈，实现先入后出的原则。</p>
<h2 id="239题-滑动窗口最大值"><a href="#239题-滑动窗口最大值" class="headerlink" title="239题.滑动窗口最大值"></a>239题.滑动窗口最大值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span><br><span class="line">返回滑动窗口中的最大值。</span><br><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br></pre></td></tr></table></figure>

<p>思路：单调队列，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。</p>
<p>每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回我们要的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用双端队列手动实现单调队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span></span><br><span class="line">            <span class="comment">// 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="number">1</span>)&#123;</span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            deque.offer(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">                res[idx++] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="347题-前K个高频元素（优先级队列）"><a href="#347题-前K个高频元素（优先级队列）" class="headerlink" title="347题.前K个高频元素（优先级队列）"></a>347题.前K个高频元素（优先级队列）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</span><br><span class="line">示例 1:</span><br><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<p>思路：统计元素出现的频率，对频率进行排序，找出前k个高频元素。首先统计元素出现的频率，这一类的问题可以使用map来进行统计。然后是对频率进行排序，这里我们可以使用一种 容器适配器就是<strong>优先级队列</strong>。</p>
<p>优先级队列：其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p>
<p>而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？</p>
<p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。</p>
<p><strong>堆是一颗完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p>
<p>大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p>
<p>本题<strong>要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="comment">// 根据map的value值正序排，相当于一个小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123;</span><br><span class="line">            queue.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; k) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = queue.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode刷题链表篇</title>
    <url>/2021/11/02/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/%E9%93%BE%E8%A1%A8%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h2 id="链表的定义输入输出"><a href="#链表的定义输入输出" class="headerlink" title="链表的定义输入输出"></a>链表的定义输入输出</h2><p>首先使用结构体定义，与c++不同，java中没有指针，隐藏指针，让指向某对象的指针看起来更像那个对象本身。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">为什么java中的main函数不能是非static？</span><br><span class="line"></span><br><span class="line">不能在main方法中打印this关键字的信息，因为不能在静态方法中调用this。理由很简单，this表示“这个对象”，也就是声明一个类的对象，然而静态方法是不属于某一个特定对象而是属于这个类的。那么问题来了，为什么main函数必须设置成静态的呢？</span><br><span class="line"></span><br><span class="line">首先，main函数作为java程序的入口，也可以理解为一个接口，这个接口不是提供给程序员使用的，这时提供给用户等使用的，用户等不需要知道程序内部的实现，只需要知道接口就可以了，如果是非静态的，那么当用户开始使用时，就必须先去创建对象，那么创建对象的代码又写在哪里呢？呵呵，所以这个很难讲清。</span><br><span class="line"></span><br><span class="line">Main方法是我们学习Java编程语言时知道的第一个方法，你是否曾经想过为什么main方法是public、static、void的。当然，很多人首先学的是C和C++，但是在Java中main方法与前者有些细微的不同，它不会返回任何值，为什么main方式是public、static、void，这篇文章尝试去找到一些答案。</span><br><span class="line"></span><br><span class="line">Main方法是Java程序的入口，记住，我们这里不会讨论Servlet、MIDlet和其他任何容器管理的java程序，在java核心编程中，JVM会查找类中的public static void main(String[] args)，如果找不到该方法就抛出错误NoSuchMethodError:main 程序终止。</span><br><span class="line">Main方法必须严格遵循它的语法规则，方法签名必须是public static void，参数是字符串数组类型，如果是Java1.5及以后的版本还可以使用可变参数：</span><br><span class="line">public  static void main(String... args)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么main方法是静态的（static）</span><br><span class="line"></span><br><span class="line">正因为main方法是静态的，JVM调用这个方法就不需要创建任何包含这个main方法的实例。</span><br><span class="line">因为C和C++同样有类似的main方法作为程序执行的入口。</span><br><span class="line">如果main方法不声明为静态的，JVM就必须创建main类的实例，因为构造器可以被重载，JVM就没法确定调用哪个main方法。</span><br><span class="line">静态方法和静态数据加载到内存就可以直接调用而不需要像实例方法一样创建实例后才能调用，如果main方法是静态的，那么它就会被加载到JVM上下文中成为可执行的方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么main方法是公有的（public）</span><br><span class="line">Java指定了一些可访问的修饰符如：private、protected、public，任何方法或变量都可以声明为public，Java可以从该类之外的地方访问。因为main方法是公共的，JVM就可以轻松的访问执行它。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么main方法没有返回值（Void） </span><br><span class="line"></span><br><span class="line">因为main返回任何值对程序都没任何意义，所以设计成void，意味着main不会有任何值返回</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总结</span><br><span class="line"></span><br><span class="line">main方法必须声明为public、static、void，否则JVM没法运行程序</span><br><span class="line">如果JVM找不到main方法就抛出NoSuchMethodError:main异常，例如：如果你运行命令：java HelloWrold，JVM就会在HelloWorld.class文件中搜索public static void main (String[] args) 放法</span><br><span class="line">main方式是程序的入口，程序执行的开始处。</span><br><span class="line">main方法被一个特定的线程”main”运行，程序会一直运行直到main线程结束或者non-daemon线程终止。</span><br><span class="line">当你看到“Exception in Thread main”如：Excpetion in Thread main:Java.lang.NullPointedException ,意味着异常来自于main线程</span><br><span class="line">你可以声明main方法使用java1.5的可变参数的方式如：</span><br><span class="line">public  static void main(String... args)</span><br><span class="line">除了static、void、和public，你可以使用final，synchronized、和strictfp修饰符在main方法的签名中，如：</span><br><span class="line">public  strictfp final  synchronized static  void main(String[] args)</span><br><span class="line">main方法在Java可以像其他方法一样被重载，但是JVM只会调用上面这种签名规范的main方法。</span><br><span class="line">你可以使用throws子句在方法签名中，可以抛出任何checked和unchecked异常</span><br><span class="line">静态初始化块在JVM调用main方法前被执行，它们在类被JVM加载到内存的时候就被执行了。</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a href="https://blog.csdn.net/peikunye/article/details/100513579">https://blog.csdn.net/peikunye/article/details/100513579</a></p>
<p><a href="https://blog.csdn.net/maxiao1204/article/details/75142811?yyue=a21bo.50862.201879">https://blog.csdn.net/maxiao1204/article/details/75142811?yyue=a21bo.50862.201879</a></p>
<p>对于java的构造函数有点懵逼，有参构造和无参构造可以同时存在吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链表节点定义：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;  <span class="comment">//必须要加public吗？</span></span><br><span class="line">    <span class="keyword">public</span> ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反转链表：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseListNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输入输出+测试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输入不定长的数组</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入链表：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        ListNode head = <span class="keyword">null</span>; <span class="comment">//代表是个空节点</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>; <span class="comment">//pre在这里定义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">            b[j] = Integer.parseInt(arr[j]);</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(b[j]); <span class="comment">//真正的构造节点</span></span><br><span class="line">            <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;  <span class="comment">//首先判断是不是头节点</span></span><br><span class="line">                head = node;</span><br><span class="line">                pre = head; <span class="comment">//pre在这里等于head，不能在上面等于</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next=node;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        printList(head);</span><br><span class="line">        ListNode res = reversal(head);</span><br><span class="line">        printList(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reversal</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode front = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = front;</span><br><span class="line">            front = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="203题-移除链表元素"><a href="#203题-移除链表元素" class="headerlink" title="203题.移除链表元素"></a>203题.移除链表元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题意：删除链表中等于给定值 val 的所有节点。</span><br><span class="line">示例 1：</span><br><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p>思路：有可能头节点是要删除的，所以用prehead节点。c/c++需要清理节点内存。java/python则不需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链表节点定义：</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode() &#123;&#125;</span><br><span class="line">     ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">     ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        prehead.next = head;</span><br><span class="line">        <span class="comment">//ListNode prehead = new ListNode(-1, head);</span></span><br><span class="line">        ListNode pre = prehead;</span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//括号内不可以只是pre.next</span></span><br><span class="line">            <span class="keyword">if</span>(pre.next.val == val)&#123;</span><br><span class="line">                pre.next=pre.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24题-两两交换链表中得节点"><a href="#24题-两两交换链表中得节点" class="headerlink" title="24题.两两交换链表中得节点"></a>24题.两两交换链表中得节点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span><br><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>

<p>思路：相当于是swap节点，不能只改变值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        prehead.next = head;</span><br><span class="line">        ListNode pre = prehead;</span><br><span class="line">        <span class="keyword">while</span>(pre.next!=<span class="keyword">null</span> &amp;&amp; pre.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode node1 = pre.next;</span><br><span class="line">            pre.next = node1.next;</span><br><span class="line">            ListNode node2 = pre.next.next;</span><br><span class="line">            pre.next.next = node1;</span><br><span class="line">            node1.next = node2;</span><br><span class="line">            pre = pre.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19题-删除链表的倒数第N个节点"><a href="#19题-删除链表的倒数第N个节点" class="headerlink" title="19题.删除链表的倒数第N个节点"></a>19题.删除链表的倒数第N个节点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span><br><span class="line">输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] </span><br></pre></td></tr></table></figure>

<p>思路：明显的双指针法，为了降低时间复杂度，尽可能扫描一次链表来解决。一个指针先走n步，再一起走，当前面的走到头，那就是要删除的倒数第n个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        prehead.next=head;</span><br><span class="line">        ListNode left = prehead;</span><br><span class="line">        ListNode right = prehead;</span><br><span class="line">        <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            left=left.next;</span><br><span class="line">            right=right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next=left.next.next;</span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题02-07-链表相交"><a href="#面试题02-07-链表相交" class="headerlink" title="面试题02.07.链表相交"></a>面试题02.07.链表相交</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</span><br></pre></td></tr></table></figure>

<p>思路：一眼双指针，阿里二面题目，这道题里链表相交的话后面是重叠了，合并，而不是只交一个点，交一个点的话只能双层for循环了。两个指针走完了都走另一个，会同时到达合并的第一个节点。如果没有合并，同时遍历到空节点返回空节点。如果两个合并的长度一样，则走到第一个点就会返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode a = headA;</span><br><span class="line">        ListNode b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="keyword">null</span>)  a=headB;</span><br><span class="line">            <span class="keyword">else</span> a=a.next;</span><br><span class="line">            <span class="keyword">if</span>(b==<span class="keyword">null</span>)  b=headA;</span><br><span class="line">            <span class="keyword">else</span> b=b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142题-环形链表Ⅱ"><a href="#142题-环形链表Ⅱ" class="headerlink" title="142题.环形链表Ⅱ"></a>142题.环形链表Ⅱ</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><br><span class="line">为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</span><br><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p>思路：经典的快慢指针。一个一次走一格，一个一次走两格。不需要虚拟头节点。这是判断链表是否有环的方法，如果有环，两个指针都会一直走，两个指针一定会相遇。但是相遇的点不一定是环的入口。</p>
<p>这个环肯定是后面一个环就不再出来了。</p>
<p>而要找到环的入口，画个图，最后得出来：x = (n - 1) (y + z) + z。再跑一遍就可以得到环的入口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)&#123;  <span class="comment">//有环了，下面再找入口</span></span><br><span class="line">                <span class="keyword">while</span>(head!=slow)&#123;</span><br><span class="line">                    head=head.next;</span><br><span class="line">                    slow=slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>链表的种类主要为：单链表，双链表，循环链表</li>
<li>链表的存储方式：链表的节点在内存中是分散存储的，通过指针连在一起。</li>
</ul>
]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>leecode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux日常使用</title>
    <url>/2021/09/02/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/Linux%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="给用户添加sudo权限"><a href="#给用户添加sudo权限" class="headerlink" title="给用户添加sudo权限"></a>给用户添加sudo权限</h2><p>–切换到拥有sudo权限的用户下，可以是su。 –输入命令”sudo vim /etc/sudoers”开始编辑/etc/sudoers文件。 –找到”root ALL=(ALL:ALL) ALL”这一 行，在它下面添加”xxx ALL=(ALL:ALL) ALL”(这里的xxx是你的用户名)，然后保存退出。因为是只读模式，输入”:wq!”强制保存并退出。</p>
<h2 id="获得本机ip"><a href="#获得本机ip" class="headerlink" title="获得本机ip"></a>获得本机ip</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig | grep &quot;inet&quot;</span><br><span class="line">ifconfig en0</span><br></pre></td></tr></table></figure>

<p>localhost：127.0.0.1 ，在 Linux 中，其定义位于 /etc/hosts。用于本机中各个应用之间的网络交互。不需要联网，本机访问。</p>
<p>localhost等于127.0.0.1，不过localhost是域名，127.0.0.1是IP地址。</p>
<p>本机 IP 就是本机对外放开访问的IP地址，这个网址就是与物理网卡绑定的IP地址。</p>
<p>访问127.0.0.1不调用网卡驱动，而是立即转发到本机IP层进行处理，不涉及底层操作。</p>
<p>本机IP，我们可以理解为本机有三块网卡，一块网卡叫做loopback（虚拟网卡），一块叫做ethernet（有线网卡），一块叫做wlan（你的无线网卡）。127.0.0.1 这个地址通常分配给 loopback 接口。</p>
<p>ping 127.0.0.1一般作为测试本机TCP/IP协议栈正常与否的判断之一。</p>
<h3 id="共有ip："><a href="#共有ip：" class="headerlink" title="共有ip："></a>共有ip：</h3><p>组建一个企业级网络，需要去向“电信运营商ISP”申请一个接入Internet的宽带，同时ISP还会给我们分配一个或多个IP地址，这些IP地址可以供我们企业内部上网，这些ISP分配给我们的IP，就是公有IP。</p>
<p>公有地址（Public address，也可称为公网地址）由Internet NIC（Internet Network Information Center因特网信息中心）负责。这些IP地址分配给注册并向Internet NIC提出申请的组织机构。通过它直接访问因特网，它是广域网范畴内的。</p>
<h3 id="私有IP："><a href="#私有IP：" class="headerlink" title="私有IP："></a>私有IP：</h3><p>我们企业或家庭内部组建局域网用的IP，一般都会用私有IP。</p>
<p>私有地址（Private address，也可称为专网地址）属于非注册地址，专门为组织机构内部使用，它是局域网范畴内的，私有IP禁止出现在Internet中，在ISP连接用户的地方，将来自于私有IP的流量全部都会阻止并丢掉。私有ip在公网上不能被识别。必须通过NAT将内部IP地址转换成公网上可用的IP地址，从而实现内部IP地址与外部公网的通信。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP地址分固定和动态的两种，固定IP地址不会变，价格比较贵，多是企事业单位使用。</span><br><span class="line">家庭宽带连接就是动态IP，在不上网的时候,先前所用IP资源就会被释放出来供他人使用. 如果再上网，系统又分配一个IP给你，所以家庭用户的IP都是自动分配的，上网了就找一个给你用，断网了马上收回，再给其它人用，这样可以缓解IP地址紧张的问题。</span><br></pre></td></tr></table></figure>

<h3 id="子网掩码-netmask："><a href="#子网掩码-netmask：" class="headerlink" title="子网掩码 netmask："></a><strong>子网掩码 netmask：</strong></h3><p>将某个IP地址划分成网络地址和主机地址两部分，子网掩码必须是多个 1 相连，多个 0 相连的形式，总共 8 * 4 = 32 位。1的部分就是网络地址部分 0的部分就是主机地址部分。</p>
<p>255.255.255.0这个子网掩码可以容纳2的8次方（台）电脑，也就是256台，但是有两个IP是不能用的，位数全为0为网络号 位数全为1位广播号，减去这两台，就是254台。</p>
<p>一种子网掩码的简便写法:<br>192.163.1.199/24<br>ip后面的/24就是子网掩码255.255.255.0的简写 意为网络位为24位也就是二进制左边24个1</p>
<h3 id="广播地址broadcast："><a href="#广播地址broadcast：" class="headerlink" title="广播地址broadcast："></a>广播地址broadcast：</h3><p>广播地址(Broadcast Address)是专门用于同时向网络中所有工作站进行发送的一个地址。在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.0.0.0 ）网段，其直播广播地址为10.255.255.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.255.255.255 的分组（封包）时，它将被分发给该网段上的所有计算机。</p>
<h3 id="my-Mac-地址："><a href="#my-Mac-地址：" class="headerlink" title="my Mac 地址："></a>my Mac 地址：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inet 172.22.150.82 netmask 0xfffffe00 broadcast 172.22.151.255</span><br><span class="line">inet是本机ip</span><br><span class="line">netmask表示了23位网络位，9位主机位</span><br><span class="line">broadcast表示150二进制：10010110，前七位网络号，后面一位变1，即广播号：172.22.151.255</span><br></pre></td></tr></table></figure>

<h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls  显示所有文件</span><br><span class="line">ls -a   显示包括.开头的隐藏文件</span><br><span class="line">ls -l   列出文件详细信息  = ll</span><br><span class="line">ll -a = ls -al</span><br><span class="line"></span><br><span class="line">tree  数状显示当前目录下所有文件</span><br><span class="line">tree需要先安装</span><br><span class="line">tree --version  参看是否安装</span><br><span class="line">sudo apt/brew install tree   安装</span><br><span class="line">tree -L 2   显示二级目录</span><br></pre></td></tr></table></figure>

<h2 id="文本查看相关"><a href="#文本查看相关" class="headerlink" title="文本查看相关"></a>文本查看相关</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat 是一个文本文件查看和连接工具。</span><br><span class="line">cat -n a.md   带行号显示</span><br><span class="line">cat -b a.md   空白行不编号</span><br><span class="line">cat a.md &gt; b.md  a内容写到b中，覆盖</span><br><span class="line">cat a.md b.md &gt; c.md  a.b.都写到c里</span><br><span class="line">cat a.md|tail -n2   显示最后两行</span><br><span class="line">cat a.md|tail -n+2   显示从第二行到尾</span><br><span class="line">cat a.md|head -n2   显示前两行</span><br><span class="line">cat a.md|head -n4 | tail -n+2   显示2-4行 tail从2开始，head前4行，两者交集</span><br><span class="line">cat /dev/null &gt; a.md  清空文件</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail 命令可用于查看文件的内容，-f 常用于查阅正在改变的日志。</span><br><span class="line">tail -f -n10 a.md  不断循环读取尾部10行</span><br><span class="line">tail -n10 a.md  显示最后10行</span><br><span class="line">tail -n +20 notes.log   从第20行显示至末尾</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;2,4p&#x27; a.md    显示2-4行</span><br></pre></td></tr></table></figure>

<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>场景：求日志中某一值的个数及平均值<br>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。<br>样式扫描和处理语言。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf|grep &#x27;ns&#x27;|awk -F &#x27;ns&#x27; &#x27;&#123;print $1&#125;&#x27;|awk &#x27;BEGIN&#123;sum=0&#125;&#123;sum=sum+$1&#125;END&#123;print sum/NR&#125;&#x27;</span><br><span class="line">//输出平均</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -f platform-idproducer.log.wf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /dev/null &gt; platform-idproducer.log.wf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf|grep &#x27;ns&#x27;|awk -F &#x27;ns&#x27; &#x27;&#123;print $1&#125;&#x27;|awk &#x27;END&#123;print NR&#125;&#x27;</span><br><span class="line">//输出行数</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf</span><br><span class="line">//-F指定分隔符用来指定分隔符，指定&#x27;Cost time:&#x27;为分隔符。</span><br><span class="line">//总共分成两个域，&#x27;&#123;print $2&#125;&#x27;表示输出第二个域，&#x27;&#x27;少不了</span><br></pre></td></tr></table></figure>

<p>awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>
<p>awk工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf|grep &#x27;ns&#x27;</span><br><span class="line">//表示上一步输出的文本，逐行筛选，有ns的输出，不加&#x27;&#x27;也行</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf|grep &#x27;ns&#x27;|awk -F &#x27;ns&#x27; &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line">//上一步输出逐行的***ns，这一步自定义ns为分隔符，输出第一个域，相当于去掉了ns，只剩下数字</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf|grep &#x27;ns&#x27;|awk -F &#x27;ns&#x27; &#x27;&#123;print $1&#125;&#x27;|awk &#x27;&#123;print NR,$0&#125;&#x27;</span><br><span class="line">//NR表示每行的记录号，这个输出行号+所有域</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf|grep &#x27;ns&#x27;|awk -F &#x27;ns&#x27; &#x27;&#123;print $1&#125;&#x27;|awk &#x27;BEGIN&#123;sum=0&#125;&#123;sum=sum+$1&#125;END&#123;print sum/NR&#125;&#x27;</span><br><span class="line">//BEGIN 初始化代码块，主要是引用全局变量</span><br><span class="line">//END 结尾代码块，在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息</span><br><span class="line">//begin的作用在于不会每行都刷新sum，保证sum的全局性</span><br><span class="line">//end的意思是最后遍历完才执行后面的语句，如果不用end，则每行都计算一下</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用：查看日志中error为0的行数：</span><br><span class="line">awk &#x27;&#123;print $0&#125;&#x27; old.log|grep &#x27;errno&quot;:0&#x27;|awk &#x27;END&#123;print NR&#125;&#x27;</span><br><span class="line">//输出有error：0的行数，即正确请求数</span><br></pre></td></tr></table></figure>

<h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符|</h2><p>利用Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。</p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>Linux ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -A    显示所有进程信息</span><br><span class="line">-e和-A的意思是一样的，即显示有关其他用户进程的信息，包括那些没有控制终端的进程。</span><br><span class="line">-f显示用户id，进程id，父进程id，最近CPU使用情况，进程开始时间等等。</span><br><span class="line">ps -ef|grep idpro</span><br></pre></td></tr></table></figure>

<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep命令是查找，是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<p>grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;UpdateItem&#x27; ./platform-idproducer.log  //必须得是单引号</span><br></pre></td></tr></table></figure>

<h2 id="参看端口使用"><a href="#参看端口使用" class="headerlink" title="参看端口使用"></a>参看端口使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsof</span><br><span class="line">lsof(list open files)是一个列出当前系统打开文件的工具。</span><br><span class="line">而有一点要切记，在Unix中一切（包括网络套接口）都是文件。</span><br><span class="line">lsof 查看端口占用语法格式：</span><br><span class="line">lsof -i:端口号</span><br><span class="line">使用-i:port来显示与指定端口相关的网络信息</span><br><span class="line"></span><br><span class="line">参考：https://www.jianshu.com/p/a3aa6b01b2e1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat</span><br><span class="line">yum install -y net-tools</span><br><span class="line">netstat -tunlp | grep 端口号</span><br><span class="line">-t (tcp) 仅显示tcp相关选项</span><br><span class="line">-u (udp)仅显示udp相关选项</span><br><span class="line">-n 拒绝显示别名，能显示数字的全部转化为数字</span><br><span class="line">-l 仅列出在Listen(监听)的服务状态</span><br><span class="line">-p 显示建立相关链接的程序名</span><br><span class="line">netstat -ntlp   //查看当前所有tcp端口</span><br><span class="line">netstat -ntulp | grep 80   //查看所有80端口使用情况</span><br><span class="line">netstat -ntulp | grep 3306   //查看所有3306端口使用情况</span><br></pre></td></tr></table></figure>

<h2 id="yum-apt-brew"><a href="#yum-apt-brew" class="headerlink" title="yum apt brew"></a>yum apt brew</h2><p>linux系统基本上分两大类：<br>1.RedHat系列：Redhat、Centos、Fedora等，使用yum<br>2.Debian系列：Debian、Ubuntu等，使用apt-get</p>
<p>Mac系统:<br>Homebrew，Homebrew简称brew</p>
<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>在网络中ping是一个十分强大的TCP/IP工具。它的作用主要为：<br>（1）用来检测网络的连通情况和分析网络速度；<br>（2）根据域名得到服务器IP；<br>（3）根据ping返回的TTL值来判断对方所使用的操作系统及数据包经过路由器数量。</p>
<blockquote>
<p>我们通常会用它来直接ping IP地址，来测试网络的连通情况。</p>
<p>bytes值：数据包大小，也就是字节。</p>
<p>time值：响应时间，这个时间越小，说明你连接这个地址速度越快。</p>
<p>TTL值：Time To Live,表示DNS记录在DNS服务器上存在的时间，它是IP协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过Ping返回的TTL值大小，粗略地判断目标系统类型是Windows系列还是UNIX/Linux系列。</p>
<p>默认情况下，Linux系统的TTL值为64或255，WindowsNT/2000/XP系统的TTL值为128，Windows98系统的TTL值为32，UNIX主机的TTL值为255。</p>
<p>100<del>130ms之间，Windows系统 ；<br>240</del>255ms之间，UNIX/Linux系统。</p>
</blockquote>
<h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>测试指定端口连通性：</p>
<blockquote>
<p>telnet 102.106.228.173 8601即可</p>
<p>1、检测主机是否安装telnet<br>rpm -qa telnet-server<br>若无输入内容，则表示没有安装。出于安全考虑telnet-server.rpm是默认没有安装的，而telnet的客户端是标配。即下面的软件是默认安装的。</p>
<p>2、若未安装，则安装telnet-server，否则忽略此步骤<br>yum install telnet-server 　</p>
<p>3、检测telnet-server的rpm包是否安装<br>rpm -qa telnet<br>输出：telnet-0.17-47.el6_3.1.x86_64</p>
<p>4、若未安装，则安装telnet，否则忽略此步骤<br>yum install telnet</p>
<p>5.测试<br>Trying ::1…<br>Connected to localhost.<br>Escape character is ‘^]’.</p>
<p>表明连接成功。（stats查看状态，flush_all:清楚缓存）</p>
</blockquote>
<p>8080端口一下访问不了？</p>
<h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p>在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://www.linux.com  //访问网址</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">保存网页：</span><br><span class="line">1.使用linux的重定向功能保存</span><br><span class="line">curl http://www.linux.com &gt;&gt; linux.html</span><br><span class="line">2.可以使用curl的内置option:-o(小写)保存网页</span><br><span class="line">curl -o linux.html http://www.linux.com</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">保存网页中的文件：</span><br><span class="line">curl -O http://www.linux.com/hello.sh</span><br><span class="line">要注意这里后面的url要具体到某个文件，不然抓不下来</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl进行post请求：</span><br><span class="line">-H后面为请求头，可以添加多个，curl默认的请求方式是GET，我们要使用POST的话，就得加上“-X POST</span><br><span class="line"></span><br><span class="line">请求体，也就是json格式，此时只需要添加-d后，加上单引号，单引号里面添加花括号，然后json格式的key-value添加进去即可</span><br><span class="line"></span><br><span class="line">curl &#x27;http://10.12.205.134:8182/pt/idproducer/v2/createapp&#x27; -H &quot;Content-Type:application/json&quot; -X POST -d &#x27;&#123;&quot;appid&quot;:10001,&quot;machineid&quot;:250031,&quot;step&quot;:10000,&quot;autoincre&quot;:0&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>curl命令，只能linux上操作，mac上还不行。</p>
<h2 id="Linux-的打印命令-echo"><a href="#Linux-的打印命令-echo" class="headerlink" title="Linux 的打印命令 echo"></a>Linux 的打印命令 echo</h2><p><code>echo &quot;c.biancheng.net&quot;</code> </p>
<p>如果加入了 <code>-n</code>选项，则在输出内容结束后，不会换行，直接显示新行的提示符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出时间：</span><br><span class="line">echo &quot;访问时间是：`date &#x27;+%Y%m%d %H:%M:%S&#x27;`&quot;</span><br><span class="line">输出：访问时间是：20210902 17:14:27</span><br><span class="line"></span><br><span class="line">想要输出换行：</span><br><span class="line">echo -e &quot;hello\nman&quot;</span><br></pre></td></tr></table></figure>

<p>shell脚本中打印变量：<br><code>a=1 echo $a a=$a+1 echo $a</code><br>这样打印的是字符型<code>1+1</code><br>Bash 本质上只有字符型变量<br>执行<code>M=$((45+20)</code>，或<code>let M=45+20 </code>才能得到65。如果事先声明变量是整型数，就不必使用<code>$((…))</code>或者<code>let</code>。</p>
<p>用带选项-i 的declare 命令，可以使变量具有整数（integer）属性。</p>
<p><code>declare -i a</code></p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ A=15 B=30</span><br><span class="line">$ declare -i C=$A+$B</span><br><span class="line">$ D=$A+$B</span><br><span class="line">$ echo C=$C, D=$D</span><br><span class="line">C=45, D=15+30</span><br></pre></td></tr></table></figure>

<h2 id="vim快速操作"><a href="#vim快速操作" class="headerlink" title="vim快速操作"></a>vim快速操作</h2><p>在vim的普通模式下.</p>
<p><code>gg</code>光标跳转到该文件的行首</p>
<p>应用鼠标： 按下<code>:</code>之后，<code>set mouse=a</code></p>
<p>关闭鼠标功能：<code>:set mouse-=a</code></p>
<h2 id="linux执行多行命令"><a href="#linux执行多行命令" class="headerlink" title="linux执行多行命令"></a>linux执行多行命令</h2><p><code>;</code>隔开即可</p>
<h2 id="shell脚本后台一直运行"><a href="#shell脚本后台一直运行" class="headerlink" title="shell脚本后台一直运行"></a>shell脚本后台一直运行</h2><p>使用sh，其中test.sh为所执行的脚本，out.txt为输出信息的地方。<br>sh test.sh&gt;&amp;out.txt &amp;</p>
<h2 id="rm-mv-cp"><a href="#rm-mv-cp" class="headerlink" title="rm mv cp"></a>rm mv cp</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用指令 cp 将当前目录 test/ 下的所有文件复制到新目录 newtest 下，输入如下命令：</span><br><span class="line">cp –r test/ newtest</span><br><span class="line"></span><br><span class="line">删除当前目录下的所有文件及目录，命令行为：</span><br><span class="line">rm  -r  *</span><br><span class="line">-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</span><br><span class="line">-r 将目录及以下之档案亦逐一删除。</span><br><span class="line"></span><br><span class="line">将 /usr/runoob 下的所有文件和目录移到当前目录下</span><br><span class="line">mv /usr/runoob/*  . </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC安装MySQL</title>
    <url>/2021/11/27/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/MAC%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装：<code>brew install mysql</code></p>
<p>查看：<code>brew info mysql</code></p>
<p>启动数据库服务：<code>mysql.server start</code></p>
<p>登录：<code>mysql -u root -p </code></p>
<blockquote>
<p>遇到问题，发现是brew没更新，brew update更新后再试就可以</p>
</blockquote>
<p>MySQL数据库第一次安装完成后,root用户初始的登录密码为空。直接回车进行登录。</p>
<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t_goods \G</span><br></pre></td></tr></table></figure>

<p>一行一行地显示，注意：\G为大写字母，不可使用小写；使用\G参数后，SQL语句后可以不加分隔符，如果加分隔符，则会报“error:no query specified”的错误。</p>
<h2 id="添加用户改密码"><a href="#添加用户改密码" class="headerlink" title="添加用户改密码"></a>添加用户改密码</h2><p><code>select User, Host, password_expired from mysql.user;</code>  显示用户</p>
<p><strong>创建用户</strong>：<code>create user &#39;name&#39;@&#39;localhost&#39; identified by &#39;password&#39;;</code></p>
<p>username：你将创建的用户名<br>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%<br>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</p>
<p><code>CREATE USER &#39;dog&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code><br><code>CREATE USER &#39;pig&#39;@&#39;192.168.1.101_&#39; IDENDIFIED BY &#39;123456&#39;;</code><br><code>CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</code></p>
<p><strong>授权</strong>：<code>grant privileges on databasename.tablename to &#39;username&#39;@&#39;host&#39;</code></p>
<p>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL<br>databasename：数据库名<br>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</p>
<p>例子:<br><code>GRANT SELECT, INSERT ON test.user TO &#39;pig&#39;@&#39;%&#39;;</code><br><code>GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;</code><br><code>GRANT ALL ON maindataplus.* TO &#39;pig&#39;@&#39;%&#39;;</code></p>
<p><strong>修改密码</strong>：<code>set password for &#39;name&#39;@&#39;localhost&#39;=password(&#39;newpass&#39;);</code></p>
<p>如果是当前登陆用户用:<br><code>SET PASSWORD = PASSWORD(&quot;newpassword&quot;);</code><br>例子:<br><code>SET PASSWORD FOR &#39;pig&#39;@&#39;%&#39; = PASSWORD(&quot;123456&quot;);</code></p>
<p><strong>撤销授权</strong>：<code>REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;</code></p>
<p>例子:<br><code>REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;;</code></p>
<p><strong>查看授权</strong>：<code>SHOW GRANTS FOR &#39;pig&#39;@&#39;%&#39;; </code></p>
<p><strong>删除用户</strong>：<code>DROP USER &#39;username&#39;@&#39;host&#39;;</code></p>
<p><strong>刷新权限</strong>：<code>flush privileges;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select User, Host, password_expired from mysql.user;</span><br><span class="line">grant all on *.* to &#x27;liuxuan&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">mysql -u liuxuan -p</span><br><span class="line">登录</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac日常使用</title>
    <url>/2021/08/27/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/MAC%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="查看ssd寿命"><a href="#查看ssd寿命" class="headerlink" title="查看ssd寿命"></a>查看ssd寿命</h3><p>brew安装查询工具：<code>brew install smartmontools</code></p>
<p>参看磁盘：<code>diskutil list</code></p>
<p>参看使用情况：<code>smartctl -a disk0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMART/Health Information (NVMe Log 0x02)</span><br><span class="line">Critical Warning:                   0x00</span><br><span class="line">Temperature:                        47 Celsius</span><br><span class="line">Available Spare:                    83%</span><br><span class="line">Available Spare Threshold:          2%</span><br><span class="line">Percentage Used:                    5%</span><br><span class="line">Data Units Read:                    97,383,945 [49.8 TB]</span><br><span class="line">Data Units Written:                 85,617,562 [43.8 TB]</span><br><span class="line">Host Read Commands:                 1,110,595,079</span><br><span class="line">Host Write Commands:                574,485,961</span><br><span class="line">Controller Busy Time:               0</span><br><span class="line">Power Cycles:                       11,730</span><br><span class="line">Power On Hours:                     389</span><br><span class="line">Unsafe Shutdowns:                   34</span><br><span class="line">Media and Data Integrity Errors:    0</span><br><span class="line">Error Information Log Entries:      0</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.xiaoyuanjiu.com/18812.html">https://www.xiaoyuanjiu.com/18812.html</a></p>
<h3 id="打开终端"><a href="#打开终端" class="headerlink" title="打开终端"></a>打开终端</h3><p>command + 空格，搜索终端，即出来了。</p>
<h3 id="打开后台"><a href="#打开后台" class="headerlink" title="打开后台"></a>打开后台</h3><p>command+option+esc：打开后台</p>
<h3 id="文件夹添加为收藏"><a href="#文件夹添加为收藏" class="headerlink" title="文件夹添加为收藏"></a>文件夹添加为收藏</h3><p>文件夹往过拖就行</p>
<h3 id="安装brew"><a href="#安装brew" class="headerlink" title="安装brew"></a>安装brew</h3><p><code>/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</code></p>
<p>brew help检查</p>
<h3 id="iterm2终端"><a href="#iterm2终端" class="headerlink" title="iterm2终端"></a>iterm2终端</h3><p>1.iTerm2 是默认终端的替代品，也是目前 macOS 下最好用的终端工具，集颜值和效率于一身。</p>
<p>官网安装即可，配置颜色，窗口，光标等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考：https://cloud.tencent.com/developer/article/1772592</span><br><span class="line">https://www.jianshu.com/p/5ba0a559416e</span><br></pre></td></tr></table></figure>

<p>2.安装on my zsh </p>
<p><code>$ sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;&quot;</code></p>
<p>如果不行，就自建脚本复制粘贴，然后允许，一样的意思。</p>
<p>3.安装<strong>powerlevel10k</strong></p>
<p>powerlevel10k是一款 zsh 主题，是 powerlevel9k的升级版，强调快速、高效和开箱即用。powerlevel10k 免去了之前 powerlevel9k 比较繁琐的安装方式，如安装字体，配置样式、修改主题等一系列繁琐的操作，开箱即用，非常简单。</p>
<p><code>brew install romkatv/powerlevel10k/powerlevel10k</code>，并根据brew提示，在.zshrc中添加<code>source /usr/local/opt/powerlevel10k/powerlevel10k.zsh-theme</code></p>
<p><code>source ~/.zshrc</code></p>
<p><code>p10k configure</code> //开始配置</p>
<p>4.安装插件</p>
<p>安装zsh命令行高亮插件<code>brew install zsh-syntax-highlighting</code>，并根据brew提示在.zshrc中添加<code>source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</code></p>
<p>安装zsh自动提示插件<code>brew install zsh-autosuggestions</code>，并根据brew提示在.zshrc中添加<code>source /usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zsh</code></p>
<p><code>source ~/.zshrc</code></p>
<h3 id="切换输入法"><a href="#切换输入法" class="headerlink" title="切换输入法"></a>切换输入法</h3><p>control+空格</p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>git与github应用</title>
    <url>/2021/09/02/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/git%E5%BA%94%E7%94%A8%E4%B8%8Egithub/</url>
    <content><![CDATA[<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是[Linus Torvalds]为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p>
<h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>SSH 为 [Secure Shell](<a href="https://baike.baidu.com/item/Secure">https://baike.baidu.com/item/Secure</a> Shell) 的缩写，是建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。</p>
<p>传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的， 就是很容易受到“中间人”（man-in-the-middle）这种方式的攻击。所谓“中间人”的攻击方式， 就是“中间人”冒充真正的服务器接收你传给服务器的数据，然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中间人”一转手做了手脚之后，就会出现很严重的问题。<strong>通过使用SSH，你可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗</strong>。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以<strong>可以加快传输的速度</strong>。SSH有很多功能，它既可以代替Telnet，又可以为FTP、PoP、甚至为PPP提供一个安全的”通道”   。</p>
<p>git 使用 rsa，rsa 要解决的一个核心问题是，如何使用一对特定的数字，使其中一个数字可以用来加密，而另外一个数字可以用来解密。这两个数字就是你在使用 git 和 github 的时候所遇到的 public key 也就是公钥以及 private key 私钥。本地用私钥，上传公钥。</p>
<h4 id="本地创建ssh-key"><a href="#本地创建ssh-key" class="headerlink" title="本地创建ssh key"></a>本地创建ssh key</h4><p><code>$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code></p>
<p><code>~/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的key。标题建议和仓库名一致, 便于区分. </code></p>
<p>验证：<code>$ ssh -T git@github.com</code></p>
<p>本地设置git：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;jadeliuliu&quot;</span><br><span class="line">git config --global user.email &quot;xxxxx@163.com&quot;</span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<h3 id="与github建立连接"><a href="#与github建立连接" class="headerlink" title="与github建立连接"></a>与github建立连接</h3><p>1.github上建立仓库</p>
<p>2.本地建立仓库 <code>git init // 把这个目录变成Git可以管理的仓库，本地多一个.git文件夹，用来跟踪管理版本库</code></p>
<p><code>mac第一次建仓库出现问题：xcode-select --install</code></p>
<p><code>git clone git@github.com:jadeliuliu/HelloWorld.git（复制自项目的链接）    相当于创建一个远程仓库的克隆版本</code></p>
<p>3.关联github仓库 <code>git remote add origin git@github.com:Hexagon-Man/HelloWorld.git</code></p>
<p>4.提交代码</p>
<p><code>git add 添加文件</code></p>
<p><code>git add . // 将当前目录下修改的所有代码从工作区添加到暂存区 . 代表当前目录</code></p>
<p><code>git remote add origin git@github.com:xxx/xxx.git // 关联远程仓库</code></p>
<p><code>git commit -m &quot;&quot;  // 提交到了 HEAD，但是还没到你的远端仓库 </code></p>
<p><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt; ，例如 git push origin HEAD：refs/for/master  // refs/for 的意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的 </code> </p>
<p><code>git push -u origin master // 把本地库的所有内容推送到远程库上</code></p>
<h3 id="git仓库结构"><a href="#git仓库结构" class="headerlink" title="git仓库结构"></a>git仓库结构</h3><p>本地仓库由 git 维护的三部分组成。第一个是 <code>工作目录</code>，它持有实际文件；第二个是 <code>暂存区（Index）</code>，它像个缓存区域，临时保存改动；最后是 <code>HEAD</code>，它指向你最后一次提交的结果。</p>
<h3 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h3><p><code>git checkout -b f  //创建并切换分支</code></p>
<p><code>git branch -d f    //删除分支</code></p>
<p><code>git branch -a     # 查看本地和远程的所有分支</code></p>
<p><code>git push origin &lt;branch&gt;    //分支推送到远端</code></p>
<p><code>git pull   //获取fetch并合并到本地</code></p>
<p><code>git rm 文件  //将文件从暂存区和工作区中删除，加-f强制删除</code></p>
<p><code>git rm --cached 文件  //将文件从暂存区中删除</code></p>
<p><code>删除缓存区所有文件命令:  git rm -r --cached .   #主要这个点一定要写</code></p>
<p><code>git log --oneline</code></p>
<h3 id="git空间与命令"><a href="#git空间与命令" class="headerlink" title="git空间与命令"></a>git空间与命令</h3><p>Working Directory：即工作区。操作系统层面的目录树结构，也可以理解为一个tree目录对象</p>
<p>Stage(Index)：即暂存区，为等待Commit的文件列表。是以扁平的文件清单实现的，不过从理解层面上也可以理解为tree目录对象</p>
<p>Local Repository(History)：本地版本库。有向无环图，其每一个节点都是一个tree目录对象</p>
<p>Remote Repository：远程版本库。有向无环图，其每一个节点都是一个tree目录对象<br><img src="https://img-blog.csdnimg.cn/e1d1bb1fa97743cfb9074e383841a1eb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"><br>转自：<a href="https://www.cnblogs.com/kekec/p/9248487.html">https://www.cnblogs.com/kekec/p/9248487.html</a></p>
<p>git status 是看暂存区的改动，如果commit了，暂存区就空了。</p>
<h3 id="应用：在本地进行了add-commit还未push，想要撤销本地的本次commit"><a href="#应用：在本地进行了add-commit还未push，想要撤销本地的本次commit" class="headerlink" title="应用：在本地进行了add-commit还未push，想要撤销本地的本次commit"></a>应用：在本地进行了add-commit还未push，想要撤销本地的本次commit</h3><p>git log 查看commit id，拿上一个commit id，而不是最新的commit id（这是要回退的id）<br>git reset ：回退到某个版本，不清空暂存区，工作区也不变，需要再提交的话需要add后commit<br>git reset –soft：回退到某个版本，不清空暂存区，工作区也不变，需要再提交的话直接commit<br>git reset –hard：彻底回退到某个版本，撤销的commit中的所有更改都被冲掉，暂存区为空了，工作区也恢复为版本库版本。</p>
<h3 id="应用：本地修改了，没有add，想撤销修改变为版本库里的"><a href="#应用：本地修改了，没有add，想撤销修改变为版本库里的" class="headerlink" title="应用：本地修改了，没有add，想撤销修改变为版本库里的"></a>应用：本地修改了，没有add，想撤销修改变为版本库里的</h3><p>用git reset –hard 解决  //恢复为本地库里的内容</p>
<p>用  git checkout – hello.go  比较好，相当于清空了暂存区内容，工作区内容也变为修改前的。</p>
<p>用  git rm –cached hello.go  不行，从暂存区中删除文件，会显示delete，修改的也会记录，只不过还需要add，不改变工作区。<br>不懂了，不管是有没有add，都会加一条delete，而不是把原本的删掉。</p>
<h3 id="应用：git-commit之后，想再在这个commit里加add"><a href="#应用：git-commit之后，想再在这个commit里加add" class="headerlink" title="应用：git commit之后，想再在这个commit里加add"></a>应用：git commit之后，想再在这个commit里加add</h3><p>$ git commit -m ‘initial commit’<br>$ git add forgotten_file<br>$ git commit –amend<br>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p>
<h3 id="应用：本地版本恢复为远程版本"><a href="#应用：本地版本恢复为远程版本" class="headerlink" title="应用：本地版本恢复为远程版本"></a>应用：本地版本恢复为远程版本</h3><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  </p>
<p>git pull origin master</p>
<h3 id="应用：本地只有master分支，本地拉取线上其他分支"><a href="#应用：本地只有master分支，本地拉取线上其他分支" class="headerlink" title="应用：本地只有master分支，本地拉取线上其他分支"></a>应用：本地只有master分支，本地拉取线上其他分支</h3><p>git branch -a  //查看要拉取线上的什么分支</p>
<p>git pull origin 分支名：本地分支名  //直接git pull origin 分支名，本地新建该分支</p>
<p>git checkout 分支名  //切换</p>
<h3 id="应用：想新开发一版，但又不想保留目前"><a href="#应用：想新开发一版，但又不想保留目前" class="headerlink" title="应用：想新开发一版，但又不想保留目前"></a>应用：想新开发一版，但又不想保留目前</h3><p>想的再建一个仓库来的，没必要。</p>
<p>在不同分支上开发就行？</p>
<p>1.远程创建分支</p>
<p>2.创建完成后<code>git branch -a </code>并没有看到新分支</p>
<p>3.本地创建并切换新分支<code>git checkout -b mbox-7354 </code>，代码之前分支一样，并不是master代码。</p>
<p>4.切换分支并不会更改代码。是因为没有<code>git add + git commit</code>，修改的代码在本地工作区，执行commit操作后代码修改到了本地版本库，这时再切换分支，代码没有提现另一个分支的修改了。</p>
<p>5.切换到mbox-7354分支，pull 代码</p>
<p><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  </code></p>
<p><code>git pull origin mbox-7354 : mbox-7354</code> 被拒绝</p>
<p>出现<code>non-fast-forward</code>的错误，证明本地库跟远程库的提交记录不一致，即本地库版本需要更新</p>
<p>6.pull不行，换从远程拉取分支</p>
<p>删除分支，先切换到别的分支，再<code>git brqanch -d name</code> -D强制删除</p>
<p><code>git checkout -b mbox-7354 origin/master</code> 创建</p>
<p><code>git pull origin master</code>  把远程分支上的内容都拉取到本地</p>
<p>7.拉取了和线上master一样的代码，接下来可以修改代码</p>
<h3 id="应用：commit之后想改commit的名字"><a href="#应用：commit之后想改commit的名字" class="headerlink" title="应用：commit之后想改commit的名字"></a>应用：commit之后想改commit的名字</h3><p><code>git commit -m &quot;v2&quot;</code></p>
<p><code>git commit --amend -m &quot;v2 add two interfaces&quot;</code></p>
<h3 id="应用：本地创建多个分支互不干扰"><a href="#应用：本地创建多个分支互不干扰" class="headerlink" title="应用：本地创建多个分支互不干扰"></a>应用：本地创建多个分支互不干扰</h3><p>（1）本地已有分支dev，写了需求a，但是不要提交。</p>
<p>（2）执行git stash命令，将工作区的内容“储存起来”</p>
<p>（3）接着在dev分支上修改bug，并提交，push</p>
<p>（4）执行git stash pop，恢复工作区原来的内容。</p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个hexo博客</title>
    <url>/2021/09/12/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/hexo/</url>
    <content><![CDATA[<h3 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1.新建仓库"></a>1.新建仓库</h3><p>jadeliuliu.github.io</p>
<h3 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h3><p>首先需要安装npm，Node Package Manager ，是一个NodeJS包管理和分发工具，大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<h4 id="安装npm"><a href="#安装npm" class="headerlink" title="安装npm"></a>安装npm</h4><p><code>brew install node</code>     安装好了nodejs和npm </p>
<p><code>npm -v</code>  检查</p>
<p>安装hexo:<code>npm install -g hexo</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/390f202c5b0e">https://www.jianshu.com/p/390f202c5b0e</a></p>
<h3 id="3-初始化项目"><a href="#3-初始化项目" class="headerlink" title="3.初始化项目"></a>3.初始化项目</h3><p><code>hexo init</code>  </p>
<p><code>hexo s</code>  浏览器可访问</p>
<h3 id="4-部署到github"><a href="#4-部署到github" class="headerlink" title="4.部署到github"></a>4.部署到github</h3><p>在项目根目录下找到 <code>_congif.yml</code>，找到 <code>deploy</code> 字段并填写完整</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">  repo: https://github.com/jadeliuliu/jadeliuliu.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>需要额外的一个工具来帮助我们推到仓库上，是 <code>hexo-deployer-git</code></p>
<p><code>npm install hexo-deployer-git --save</code></p>
<p><code>hexo clean</code></p>
<p><code>hexo deploy</code></p>
<h3 id="5-出现443的问题"><a href="#5-出现443的问题" class="headerlink" title="5.出现443的问题"></a>5.出现443的问题</h3><p>连接超时的问题：网上主流解决方法是自定义一个接口代理或输入如下语句禁用接口代理</p>
<p><code>git config --global --unset https.proxy</code></p>
<p>参考：<a href="https://blog.csdn.net/longroad1216/article/details/114853527">https://blog.csdn.net/longroad1216/article/details/114853527</a></p>
<p>或者https换成git试一试</p>
<p>6.登录github需要tocken</p>
<p>参考：<a href="https://blog.csdn.net/weixin_41010198/article/details/119698015">https://blog.csdn.net/weixin_41010198/article/details/119698015</a></p>
<h3 id="6-更换next主题"><a href="#6-更换next主题" class="headerlink" title="6.更换next主题"></a>6.更换next主题</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/theme</span>-<span class="keyword">next</span>/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<p>配置文件里改theme</p>
<p>hexo s 看效果</p>
<p>hexo -s 看帮助</p>
<h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_39766258/article/details/110638797</span><br><span class="line">（比较全的指南）</span><br><span class="line"></span><br><span class="line">https://www.jianshu.com/p/e17711e44e00</span><br><span class="line">（添加分类）</span><br></pre></td></tr></table></figure>

<h3 id="8-添加分类"><a href="#8-添加分类" class="headerlink" title="8.添加分类"></a>8.添加分类</h3><p>测试：</p>
<p>// 我们可以写成一条命令<br>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br>$ hexo d</p>
<p>文章：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 如何搭建一个hexo博客</span><br><span class="line">date: <span class="number">2021</span>年<span class="number">09</span>月<span class="number">15</span>日 <span class="number">20</span>:<span class="number">58</span>:<span class="number">49</span></span><br><span class="line">categories: </span><br><span class="line">- 后端</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="9-增加目录"><a href="#9-增加目录" class="headerlink" title="9.增加目录"></a>9.增加目录</h3><p>主题配置文件位于<code>themes/next/_config.yml</code></p>
<p>每行目录超长自动换行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true  </span><br><span class="line">  wrap: true </span><br></pre></td></tr></table></figure>

<h3 id="10-首页只显示文章标题"><a href="#10-首页只显示文章标题" class="headerlink" title="10.首页只显示文章标题"></a>10.首页只显示文章标题</h3><span id="more"></span>     #首页只会显示标记以前的内容，标记后的内容可以通过阅读更多查阅

<p><a href="https://blog.csdn.net/yueyue200830/article/details/104470646">https://blog.csdn.net/yueyue200830/article/details/104470646</a></p>
<h3 id="11-如何改变创建时间"><a href="#11-如何改变创建时间" class="headerlink" title="11.如何改变创建时间"></a>11.如何改变创建时间</h3><p>改变date格式</p>
<h3 id="12-增加访问统计"><a href="#12-增加访问统计" class="headerlink" title="12.增加访问统计"></a>12.增加访问统计</h3><p>没成功，害我搞的deploy一直报错，花里胡哨</p>
<h3 id="13-插入图片问题"><a href="#13-插入图片问题" class="headerlink" title="13.插入图片问题"></a>13.插入图片问题</h3><p><a href="https://www.jianshu.com/p/f72aaad7b852">https://www.jianshu.com/p/f72aaad7b852</a></p>
<h3 id="更新出现问题"><a href="#更新出现问题" class="headerlink" title="更新出现问题"></a>更新出现问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br></pre></td></tr></table></figure>

<p>解决方法：<code>xcode-select --install</code></p>
<h3 id="14-博客添加search功能"><a href="#14-博客添加search功能" class="headerlink" title="14.博客添加search功能"></a>14.博客添加search功能</h3><p>1.安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令：</p>
<p><code>npm install hexo-generator-searchdb --save</code></p>
<p>2.全局配置文件_config.yml，新增如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>3.hexo主题配置文件（\themes\next\_config.yml），修改local_search的enable为true：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>

<h3 id="15-博客增加访客统计"><a href="#15-博客增加访客统计" class="headerlink" title="15.博客增加访客统计"></a>15.博客增加访客统计</h3><p>1.打开next主题配置文件\themes\next\_config.yml，搜索找到<strong>busuanzi_count</strong>，把enable设置为true。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true    //访客数</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true    //访问数</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true     //文章阅读数</span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure>

<p>2.同样是在next主题配置文件\themes\next\_config.yml下，搜索<strong>footer</strong>，在它底下添加counter，设值为true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  Counter: true</span><br></pre></td></tr></table></figure>

<p>3.来到themes\next\layout\_partials，找到<strong>footer.swig</strong>文件，打开编辑，在底下添加代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.footer.counter %&#125;</span><br><span class="line">    &lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql实战</title>
    <url>/2021/09/02/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/mysql%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="1-mysql增删改查"><a href="#1-mysql增删改查" class="headerlink" title="1.mysql增删改查"></a>1.mysql增删改查</h2><h3 id="a-登录"><a href="#a-登录" class="headerlink" title="a.登录"></a>a.登录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">登录：</span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p密码  <span class="operator">/</span><span class="operator">/</span>连本机的</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span>, Host, Password <span class="keyword">FROM</span> mysql.user;  <span class="operator">/</span><span class="operator">/</span>查看用户</span><br><span class="line"></span><br><span class="line">添加新用户：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;liuxuan14&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">修改密码：</span><br><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> <span class="string">&#x27;liuxuan14&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span><span class="operator">=</span>password(<span class="string">&#x27;1998&#x27;</span>);</span><br><span class="line">为用户授权：</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>允许访问所有数据库下的所有表</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>指定数据库下的指定表</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> test.test <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>只拥有查询权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line">FLUSH PRIVILEGES;  <span class="operator">/</span><span class="operator">/</span>刷新权限</span><br><span class="line"></span><br><span class="line">删除用户：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> liuxuan<span class="variable">@localhost</span>；</span><br><span class="line"></span><br><span class="line">连接远程数据库：</span><br><span class="line">MySQL 连接远程数据库（<span class="number">192.168</span><span class="number">.5</span><span class="number">.116</span>），端口“<span class="number">3306</span>”，用户名为“root”，密码“<span class="number">123456</span>”</span><br><span class="line">mysql <span class="operator">-</span>h <span class="number">192.168</span><span class="number">.5</span><span class="number">.116</span> <span class="operator">-</span>P <span class="number">3306</span> <span class="operator">-</span>u root <span class="operator">-</span>p123456</span><br><span class="line">mysql <span class="operator">-</span>h ip <span class="operator">-</span>P 端口 <span class="operator">-</span>A <span class="operator">-</span>u name  <span class="operator">-</span>p 密码</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database name</span><br></pre></td></tr></table></figure>

<h3 id="b-建表"><a href="#b-建表" class="headerlink" title="b.建表"></a>b.建表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `mytable`(</span><br><span class="line">   `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">   `app_id` bigint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;应用id&#x27;,</span><br><span class="line">   `time` int NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;时间&#x27;,</span><br><span class="line">   `date` DATE,</span><br><span class="line">   PRIMARY KEY ( `id` )</span><br><span class="line">   UNIQUE KEY `idx_app` (`app_id`) USING BTREE</span><br><span class="line">   KEY `idx_ip` (`machine_ip`) USING BTREE,</span><br><span class="line">   KEY `idx_app_machineid` (`app_id`,`machine_id`) USING BTREE</span><br><span class="line">)ENGINE=InnoDB DEFAULT COMMENT=&#x27;表名&#x27;;</span><br><span class="line"></span><br><span class="line">AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</span><br><span class="line">PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</span><br><span class="line">ENGINE 设置存储引擎，CHARSET 设置编码。</span><br><span class="line"></span><br><span class="line">表结构：desc name；</span><br><span class="line">建表语句：show create tablename；</span><br></pre></td></tr></table></figure>

<p>注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释：comment</span><br><span class="line">create table test1 ( </span><br><span class="line">    field_name int comment &#x27;字段的注释&#x27; </span><br><span class="line">)comment=&#x27;表的注释&#x27;;</span><br><span class="line">修改表的注释：</span><br><span class="line">alter table test1 comment &#x27;修改后的表的注释&#x27;;</span><br><span class="line">修改字段的注释：</span><br><span class="line">alter table test1 modify column field_name int comment &#x27;修改后的字段注释&#x27;; </span><br><span class="line">查看表注释：</span><br><span class="line">show  create  table  test1; </span><br><span class="line">查看字段注释：</span><br><span class="line">show  full  columns  from  test1; </span><br></pre></td></tr></table></figure>

<p>索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">唯一索引：</span><br><span class="line">UNIQUE KEY</span><br><span class="line">1  主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。</span><br><span class="line">2  主键创建后一定包含一个唯一性索引，唯一性索引不一定就是主键。</span><br><span class="line">3   唯一性索引列允许空值， 而主键列不允许为空值。</span><br><span class="line">4   主键可以被其他表引用为外键，而唯一索引不能。</span><br><span class="line">5   一个表最多只能创建一个主键，但是可以创建多个唯一索引。</span><br><span class="line">6   主键更适合那些不容易改变的唯一标识，如自动递增列，身份证号等。</span><br><span class="line">7   在RBO 模式下，主键的执行计划优先级高于唯一索引。两者可以提高查询的速度。</span><br></pre></td></tr></table></figure>

<h3 id="c-添加一个字段"><a href="#c-添加一个字段" class="headerlink" title="c.添加一个字段"></a>c.添加一个字段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table tablename add `app_name` varchar(16) NOT NULL DEFAULT &#x27;&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="d-修改数据"><a href="#d-修改数据" class="headerlink" title="d.修改数据"></a>d.修改数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tablename set 字段=&#x27;修改的值&#x27; where 条件；</span><br><span class="line">多个字段中间加,</span><br></pre></td></tr></table></figure>

<h3 id="e-删除"><a href="#e-删除" class="headerlink" title="e.删除"></a>e.删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删库：drop database name;</span><br><span class="line">删表：drop table name；</span><br><span class="line"></span><br><span class="line">mysql删除一行：</span><br><span class="line">delete from 表 where 条件；</span><br></pre></td></tr></table></figure>

<h3 id="f-添加一行"><a href="#f-添加一行" class="headerlink" title="f.添加一行"></a>f.添加一行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into tablename (app_id,machine_id,machine_ip,ctime,use_perc) values(?,?,?,?,?);   //对应字段加</span><br><span class="line"></span><br><span class="line">insert into 表名 values(int,&#x27;string&#x27;)(..);  //可一次性加多行，一行全部数都有</span><br><span class="line"></span><br><span class="line">insert into 表名 set 列名=&#x27;&#x27;, ...;</span><br></pre></td></tr></table></figure>

<h2 id="2-渤海"><a href="#2-渤海" class="headerlink" title="2.渤海"></a>2.渤海</h2><p>两张表，一张Customer，有ID、NAME、CITY（用户城市）。一张Card，有ID、CID（卡编号）、BAL（卡内余额）。</p>
<p>同一个用户可能有多张卡片，现在需要连接两张表，查找并打印出北京地区个人持有账户总额最高的客户，若存在多个，则按照用户姓名的字母顺序进行排序。</p>
<p>顺序：select from where group by having order by</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select re.`Customer Name`,re.sum_val from</span><br><span class="line">( SELECT c2.NAME as &quot;Customer Name&quot;,sum(c.bal) as sum_val FROM Card as c left join Customer as c2 on c.ID = c2.ID where c2.CITY = &quot;beijing&quot; GROUP BY c.ID ) as re </span><br><span class="line">where re.sum_val = ( SELECT max(sum_value) from</span><br><span class="line">( SELECT sum(c3.bal) as sum_value FROM Card as c3 left join Customer as c4 on c3.ID = c4.ID where c4.CITY = &quot;beijing&quot; GROUP BY c3.ID ) as t1 )</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select Customer.name as &#x27;Customer Name&#x27; from Customer join Card on Customer.id = Card.id where Customer.city = &#x27;beijing&#x27; group by Customer.id having sum(Card.bal) = (select max(sum_bal) from (     select sum(bal) as sum_bal from Customer join Card     on Customer.id = Card.id  where Customer.city = &#x27;beijing&#x27;  group by Customer.id) as t);</span><br><span class="line"></span><br><span class="line">(as 后面的别名的&#x27;&#x27;不是必须的,as也不是必须的)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证：</span><br><span class="line">drop table if exists Customer;</span><br><span class="line">CREATE TABLE `Customer` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">`name` varchar(14) NOT NULL,</span><br><span class="line">`city` varchar(32) NOT NULL);</span><br><span class="line"></span><br><span class="line">INSERT INTO Customer VALUES(1,&#x27;刘一&#x27;,&#x27;beijing&#x27;);</span><br><span class="line">INSERT INTO Customer VALUES(2,&#x27;刘二&#x27;,&#x27;beijing&#x27;);</span><br><span class="line">INSERT INTO Customer VALUES(3,&#x27;刘三&#x27;,&#x27;tianjin&#x27;);</span><br><span class="line"></span><br><span class="line">drop table if exists Card;</span><br><span class="line">CREATE TABLE `Card` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">`cid` int NOT NULL,</span><br><span class="line">`bal` int NOT NULL);</span><br><span class="line"></span><br><span class="line">INSERT INTO Card VALUES(1,11,100);</span><br><span class="line">INSERT INTO Card VALUES(1,12,100);</span><br><span class="line">INSERT INTO Card VALUES(2,13,200);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在用进行嵌套查询的时候，子查询执行出来的的结果是需要作为一个派生表来给上一级进行查询使用的，所以子查询的结果必须要有一个别名，这里“别名”的使用可以理解为是用作临时变量记录子查询的结果</span><br></pre></td></tr></table></figure>

<h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p>select from where group by having order by</p>
<p>from后可以是单表，也可以是几张表join连接后的表</p>
<p>where是单表，group by having根据字段进行分组。两个可以一起用。先where 再group by。<br>having可选，限制显示行</p>
<p>注意having 和where的区别，</p>
<p>order by 是最后对显示的行根据某一字段进行排序，因此在最后。</p>
<h2 id="去重查询"><a href="#去重查询" class="headerlink" title="去重查询"></a>去重查询</h2><p><code>select distinct 字段 from table</code></p>
<p><code>distinct</code>是加在<code>select</code>后面的，后面如果有多个字段，意思就是只有多个字段不是完全一样就ok</p>
<h2 id="limit限制个数"><a href="#limit限制个数" class="headerlink" title="limit限制个数"></a>limit限制个数</h2><p>不一定非得搭配order by</p>
<p><code>select 字段 from table limit n;</code>    //表示输出前n个</p>
<p><code>select 字段 from table limit start,n;</code>  // 表示输出从start开始n个，0是第一个，limit0,1 表示第一个</p>
<h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p><code>where id&gt;3;</code>        <code>where id between 2 and 3</code></p>
<p><code>where id!=3</code></p>
<p><code>where age!=&#39;&#39;;     //不为空</code></p>
<p><code>and 且 or 或</code></p>
<p><code>where university in (&#39;北京大学&#39;,&#39;复旦大学&#39;,&#39;山东大学&#39;);</code></p>
<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p><code>where university like &#39;%北京%&#39;;    //里面包含北京</code></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>select count(gender),round(avg(gpa),1) from user_profile where gender=&#39;male&#39;;</code></p>
<p>round函数，round(a,b)返回a值保留到小数点b位</p>
<p><code>(count(q.question_id)/count(distinct(q.device_id)))</code><br>平均每个device_id有多少question行，注意去重。关于行的平均。</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p><code>from table group by a,b   //两个字段</code></p>
<p>如果对显示字段有条件 <code>group by a having 条件 </code></p>
<p>分组应用场景一般求分组后对多行的个数、平均之类的。</p>
<p>用<code>group by having</code> 出现<code>Unknown column xxx in having clause</code>错误，原因：<code>having</code>之后的筛选字段不是<code>select</code>后面的了，因此找不到。</p>
<p><code>having</code>筛选和<code>where</code>筛选不一样，<code>having</code>只能用select后的字段，where可以用表里的所有字段。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>在group by having 之后，<code>order by a asc/desc</code></p>
<h2 id="两表连接（连接查询）"><a href="#两表连接（连接查询）" class="headerlink" title="两表连接（连接查询）"></a>两表连接（连接查询）</h2><p>连接的前提：两张表中有一个字段一样，也就是on后面要加的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inner join：理解为“有效连接”，两张表中都有的数据才会显示</span><br><span class="line">left join：理解为“有左显示”，比如on a.field=b.field，则显示a表中存在的全部数据及a、b中都有的数据，a中有、b中没有的数据以null显示</span><br><span class="line">right join：理解为“有右显示”，比如on a.field=b.field，则显示b表中存在的全部数据及a、b中都有的数据，b中有、a中没有的数据以null显示</span><br><span class="line">full join：理解为“全连接”，两张表中所有数据都显示，实际就是inner +(left-inner)+(right-inner)</span><br></pre></td></tr></table></figure>

<p>注意：连接后，还可以用where限制显示的的行<br><code>SELECT    * FROM A a, B b WHERE a.id = b.pid</code>  相当于是<br><code>SELECT    * FROM A a INNER JOIN B b ON a.id = b.pid</code><br>where隐性连接， join显性连接<br>join = inner join</p>
<p>注意：对于两张表中同一字段，select后要表明用谁的。</p>
<p>join谁前谁后无所谓，</p>
<p>连接就是要进行的查询需要根据另一张表分组也好显示也好，连接之后就可以相当于一张表操作，再where，或者group by having 分组之类的。</p>
<p>注意：可以多张表连接，inner join.. on.. 之后，相当于一张表，再inner join.. on.. 就是再连接一张表</p>
<p><a href="https://www.nowcoder.com/practice/5400df085a034f88b2e17941ab338ee8?tpId=199&tags=&title=&difficulty=0&judgeStatus=0&rp=0">一个三表连接例子</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select universit, difficult_level, </span><br><span class="line">(count(qp.question_id)/count(distinct(qp.device_id)))</span><br><span class="line">//求用户做题数的平均</span><br><span class="line">as avg_answer_cnt</span><br><span class="line">from user_profile as u inner join </span><br><span class="line">question_practice_detail as qp</span><br><span class="line">on u.device_id=qp.device_id</span><br><span class="line">inner join question_detail as qd</span><br><span class="line">on qp.question_id=qd.question_id</span><br><span class="line">//连接完，三张表相当于一张表，可进行操作</span><br><span class="line">group by university, difficult_level</span><br><span class="line">having 可加条件</span><br><span class="line">order by university asc;</span><br></pre></td></tr></table></figure>

<h2 id="union-和-union-all和or（组合查询）"><a href="#union-和-union-all和or（组合查询）" class="headerlink" title="union 和 union all和or（组合查询）"></a>union 和 union all和or（组合查询）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。</span><br><span class="line">1、对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录。</span><br><span class="line">2、对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。</span><br></pre></td></tr></table></figure>

<p>union是连接两个select where语句，去重，union all不去重</p>
<p>or是where里，结果和union一样，也是去重的。</p>
<h2 id="计算20岁以下和25岁以上的用户数量（条件函数）"><a href="#计算20岁以下和25岁以上的用户数量（条件函数）" class="headerlink" title="计算20岁以下和25岁以上的用户数量（条件函数）"></a>计算20岁以下和25岁以上的用户数量（条件函数）</h2><p>自制可分组字段</p>
<p>想成一个分组问题，就像根据gender男女分组，只不过这个需要自己来构建一个字段来进行分组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">case when age&gt;=25 then &#x27;25岁以及上&#x27;</span><br><span class="line">else &#x27;25岁以下&#x27; end      //构建一个用于分组的字段</span><br><span class="line">as age_cut,</span><br><span class="line">count(device_id) as number</span><br><span class="line">from user_profile</span><br><span class="line">group by age_cut;</span><br></pre></td></tr></table></figure>

<p>case when then else end 语句</p>
<p>用来将一个字段按范围变成另一个字段，可用来分组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select device_id, gender,</span><br><span class="line">case when age&gt;=20 and age&lt;=24 then &#x27;20-24岁&#x27;</span><br><span class="line">when age&gt;=25 then &#x27;25岁以上&#x27;</span><br><span class="line">when age&lt;20 then &#x27;20岁以下&#x27;</span><br><span class="line">else &#x27;其他&#x27; end</span><br><span class="line">from user_profile;</span><br></pre></td></tr></table></figure>

<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><p>day(2021-09-01)  month(  )   year(  )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#date是2021-08-01 格式</span><br><span class="line">Select day(date) as day, count(question_id) as question_cnt</span><br><span class="line">From question_practice_detail</span><br><span class="line">where year(date)=2021 and month(date)=08</span><br><span class="line">#相当于：where substr(date,1,7)=&#x27;2021-08&#x27;</span><br><span class="line">#相当于：where date like&#x27;2021-08%&#x27;</span><br><span class="line">Group by day</span><br></pre></td></tr></table></figure>

<h2 id="用户的平均次日留存率"><a href="#用户的平均次日留存率" class="headerlink" title="用户的平均次日留存率"></a>用户的平均次日留存率</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">    count(id) / </span><br><span class="line">    (select count(distinct device_id, date) from question_practice_detail)</span><br><span class="line">    as avg_ret</span><br><span class="line">from</span><br><span class="line">    (select</span><br><span class="line">        a.device_id as id</span><br><span class="line">        ,a.date as date1 </span><br><span class="line">        ,lead(a.date,1) over(partition by device_id order by a.date) as date2</span><br><span class="line">    from </span><br><span class="line">        (select distinct device_id, date from question_practice_detail) a</span><br><span class="line">    ) b </span><br><span class="line">    #嵌套查询，一定要取别名</span><br><span class="line">where DATEDIFF(date2,date1) =1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>项目相关</title>
    <url>/2021/09/02/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/project%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="修改路由"><a href="#修改路由" class="headerlink" title="修改路由"></a>修改路由</h2><p>![image-20210901112055198](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210901112055198.png)</p>
<p>路由字符串可随意修改，后面跟action下的文件里的函数名就好。</p>
<p>注意后面跟的create和文件名没关系，文件名可以改成别的。</p>
<p>文件里的函数名必须是是Create，需要大写。</p>
<p>访问的接口的create可大写可小写。</p>
<h2 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h2><p>首先查看端口占用，再更改配置</p>
<p>![image-20210901112159550](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210901112159550.png)</p>
<h2 id="post请求怎么通过url访问"><a href="#post请求怎么通过url访问" class="headerlink" title="post请求怎么通过url访问"></a>post请求怎么通过url访问</h2><p>post请求当然无法通过url访问，内容不在url里，而在body里。</p>
<p>用curl</p>
<h2 id="访问网址的脚本"><a href="#访问网址的脚本" class="headerlink" title="访问网址的脚本"></a>访问网址的脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;访问时间是：`date &#x27;+%Y%m%d %H:%M:%S&#x27;`--$code---&gt;$url&quot; &gt;&gt; result.log</span><br><span class="line">n=0</span><br><span class="line">max=11</span><br><span class="line">while(($n&lt;max))</span><br><span class="line">do</span><br><span class="line">    curl &#x27;https://www.baidu.com/&#x27; //访问url</span><br><span class="line">    n=($n+1)</span><br><span class="line">    sleep 1s</span><br><span class="line">done</span><br><span class="line">#while循环访问url,直到状态码为200跳出循环</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">result.log</span><br><span class="line">n=0</span><br><span class="line">max=20</span><br><span class="line"><span class="meta">while(($</span><span class="bash">n&lt;max))</span></span><br><span class="line">do</span><br><span class="line">    echo -e &quot;times:$n, time:`date &#x27;+%Y%m%d %H:%M:%S&#x27;`&quot; &gt;&gt; new.log</span><br><span class="line">    curl &#x27;http://10.12.205.134:8182/pt/idproducer/v2/create?appid=10001&#x27;&gt;&gt;new.log</span><br><span class="line">    echo -e &quot;\n&quot;&gt;&gt;new.log</span><br><span class="line">    </span><br><span class="line">    echo -e &quot;times:$n, time:`date &#x27;+%Y%m%d %H:%M:%S&#x27;`&quot; &gt;&gt; old.log</span><br><span class="line">    curl &#x27;http://10.12.205.134:8182/pt/idproducer/create?appid=3&#x27;&gt;&gt;old.log</span><br><span class="line">    echo -e &quot;\n&quot;&gt;&gt;old.log</span><br><span class="line">    n=($n+1)</span><br><span class="line">    sleep 1s</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>不加次数时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">n=0</span><br><span class="line">max=3600</span><br><span class="line"><span class="meta">while(($</span><span class="bash">n&lt;max))</span></span><br><span class="line">do</span><br><span class="line">    curl &#x27;http://10.229.66.155:2010/pt/idproducer/v2/create?appid=10001&#x27;&gt;&gt;new.log</span><br><span class="line">    echo -e &quot;\n&quot; &gt;&gt; new.log</span><br><span class="line">    curl &#x27;http://10.229.66.155:2010/pt/idproducer/create?appid=13&#x27;&gt;&gt;old.log</span><br><span class="line">    echo -e &quot;\n&quot; &gt;&gt; old.log</span><br><span class="line">    n=$n+1</span><br><span class="line">    sleep 1s</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="快速计算的脚本"><a href="#快速计算的脚本" class="headerlink" title="快速计算的脚本"></a>快速计算的脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo -n &quot;please input your name and age:&quot;</span><br><span class="line">read name age</span><br><span class="line">echo &quot;welcome $name, your age is $age&quot;</span><br><span class="line"></span><br><span class="line">read -p &quot;please input your name and age:&quot; name age</span><br><span class="line">echo &quot;welcome $name, your age is $age&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo -n &quot;please input your maxid and oldstep and newstep:&quot;</span><br><span class="line">read maxid oldstep newstep</span><br><span class="line">declare -i a=$maxid+$oldstep*5000000</span><br><span class="line">declare -i b=$a/$newstep</span><br><span class="line">echo &quot;after calcu is: $b&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
  </entry>
  <entry>
    <title>高并发压测工具</title>
    <url>/2021/08/19/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="1-ab压测工具"><a href="#1-ab压测工具" class="headerlink" title="1.ab压测工具"></a>1.ab压测工具</h2><p>ab是apache自带的压力测试工具。ab进行的一切测试本质上是基于HTTP的。</p>
<h3 id="linux下安装"><a href="#linux下安装" class="headerlink" title="linux下安装"></a>linux下安装</h3><p>yum -y install httpd-tools</p>
<p>版本信息：ab -V</p>
<p>ab -n1000 -c100 <a href="https://www.imooc.com/">https://www.imooc.com/</a>   请求1000次,每次并发100;</p>
<h3 id="输出信息说明"><a href="#输出信息说明" class="headerlink" title="输出信息说明"></a>输出信息说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server Software:        web服务器软件及版本</span><br><span class="line">Server Hostname:        表示请求的URL中的主机部分名称</span><br><span class="line">Server Port:            被测试的Web服务器的监听端口</span><br><span class="line"> </span><br><span class="line">Document Path:          请求的页面路径</span><br><span class="line">Document Length:        页面大小</span><br><span class="line"> </span><br><span class="line">Concurrency Level:      并发数</span><br><span class="line">Time taken for tests:   测试总共花费的时间</span><br><span class="line">Complete requests:      完成的请求数</span><br><span class="line">Failed requests:        失败的请求数，这里的失败是指请求的连接服务器、发送数据、接收数据等环节发生异常，以及无响应后超时的情况。对于超时时间的设置可以用ab的-t参数。如果接受到的http响应数据的头信息中含有2xx以外的状态码，则会在测试结果显示另一个名为“Non-2xx responses”的统计项，用于统计这部分请求数，这些请求并不算是失败的请求。</span><br><span class="line">Write errors:           写入错误</span><br><span class="line">Total transferred:      总共传输字节数，包含http的头信息等。使用ab的-v参数即可查看详细的http头信息。</span><br><span class="line">HTML transferred:       html字节数，实际的页面传递字节数。也就是减去了Total transferred中http响应数据中头信息的长度。</span><br><span class="line">Requests per second:    每秒处理的请求数，服务器的吞吐量，等于：Complete requests / Time taken for tests</span><br><span class="line">Time per request:       平均数，用户平均请求等待时间</span><br><span class="line">Time per request:       服务器平均处理时间</span><br><span class="line">Transfer rate:          平均传输速率（每秒收到的速率）。可以很好的说明服务器在处理能力达到限制时，其出口带宽的需求量。</span><br><span class="line"> </span><br><span class="line">Connection Times (ms)	压力测试时的连接处理时间。</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0   67 398.4      9    3009			</span><br><span class="line">Processing:    49 2904 2327.2   2755   12115</span><br><span class="line">Waiting:       48 2539 2075.1   2418   12110</span><br><span class="line">Total:         53 2972 2385.3   2789   12119</span><br></pre></td></tr></table></figure>

<p>Connect 无法送出要求、目标主机连接失败、要求的过程中被中断。<br>Length 响应的内容长度不一致 ( 以 Content-Length 头值为判断依据 )。<br>Exception 发生无法预期的错误。 </p>
<h3 id="发生错误"><a href="#发生错误" class="headerlink" title="发生错误"></a>发生错误</h3><p>并发大时：apr_socket_recv: Connection reset by peer (104)</p>
<p>解决：ab -n 100000 -c20000 <strong>-r <a href="http://xxxxurl/">http://xxxxurl/</a></strong></p>
<h2 id="2-charles"><a href="#2-charles" class="headerlink" title="2.charles"></a>2.charles</h2><p>使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力。<br><a href="https://blog.csdn.net/linjpg/article/details/77839281">https://blog.csdn.net/linjpg/article/details/77839281</a></p>
<p>参考:</p>
<p><a href="https://blog.csdn.net/feiwutudou/article/details/80334099">https://blog.csdn.net/feiwutudou/article/details/80334099</a></p>
<p><a href="https://blog.csdn.net/weixin_34381666/article/details/91546268">https://blog.csdn.net/weixin_34381666/article/details/91546268</a></p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
  </entry>
  <entry>
    <title>前端寄出-CSS层叠样式表</title>
    <url>/2021/08/19/myblog/%E5%89%8D%E7%AB%AF%E9%97%A8%E5%A4%96%E6%B1%89/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>CSS被用来同时控制多重网页的样式和布局。</p>
<p>通过使用 CSS，所有的格式化均可从 HTML 中剥离出来，并存储于一个独立的文件中。</p>
<p>CSS 指层叠样式表 (Cascading Style Sheets)<br>样式定义如何显示 HTML 元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;标题&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">body</span><br><span class="line">&#123;</span><br><span class="line">	background-color:#d0e4fe;</span><br><span class="line">&#125;</span><br><span class="line">h1    //h1是选择器</span><br><span class="line">&#123;          //大括号里是一条或多条声明</span><br><span class="line">	color:orange;     //每一条声明由属性和值组成 ：分开</span><br><span class="line">	text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">p</span><br><span class="line">&#123;</span><br><span class="line">	font-family:&quot;Times New Roman&quot;;</span><br><span class="line">	font-size:20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;     //style元素在head元素里</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;CSS 实例!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;这是一个段落。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h2><p>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:<br>选择器通常是您需要改变样式的 HTML 元素。<br>每条声明由一个属性和一个值组成。<br>属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。<br>css中，也就是<code>&lt;style&gt;</code>中，注释是 /*   */</p>
<h2 id="2-id选择器"><a href="#2-id选择器" class="headerlink" title="2.id选择器"></a>2.id选择器</h2><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p>
<p>HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;标题&lt;/title&gt; </span><br><span class="line">&lt;style&gt;</span><br><span class="line">#para1</span><br><span class="line">&#123;</span><br><span class="line">	text-align:center;</span><br><span class="line">	color:red;</span><br><span class="line">&#125; </span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p id=&quot;para1&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;p&gt;这个段落不受该样式的影响。&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>不要以数字开头</p>
<h2 id="3-class选择器"><a href="#3-class选择器" class="headerlink" title="3.class选择器"></a>3.class选择器</h2><p>class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。</p>
<p>class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点”.”号显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;标题&lt;/title&gt; </span><br><span class="line">&lt;style&gt;</span><br><span class="line">.center</span><br><span class="line">&#123;</span><br><span class="line">	text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 class=&quot;center&quot;&gt;标题居中&lt;/h1&gt;</span><br><span class="line">&lt;p class=&quot;center&quot;&gt;段落居中。&lt;/p&gt; </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>你也可以指定特定的HTML元素使用class。比如<code>p.center</code> 就只有标了类属性的段落起作用</p>
<h2 id="4-如何创建"><a href="#4-如何创建" class="headerlink" title="4.如何创建"></a>4.如何创建</h2><h3 id="（1）内联模式"><a href="#（1）内联模式" class="headerlink" title="（1）内联模式"></a>（1）内联模式</h3><p><code>&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;</code></p>
<h3 id="2-内部样式表"><a href="#2-内部样式表" class="headerlink" title="(2) 内部样式表"></a>(2) 内部样式表</h3><p>上面的示例都是，<code>&lt;head&gt;</code>里的<code>&lt;style&gt;</code></p>
<h3 id="（3）外部样式表"><a href="#（3）外部样式表" class="headerlink" title="（3）外部样式表"></a>（3）外部样式表</h3><p>当样式需要应用于很多页面时，外部样式表将是理想的选择。可以通过改变一个文件来改变整个站点的外观。</p>
<p>使用 <code>&lt;link&gt; </code>标签链接到样式表。</p>
<p>html中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<p>css：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hr &#123;color:sienna;&#125;</span><br><span class="line">p &#123;margin-left:20px;&#125;</span><br><span class="line">body &#123;background-image:url(&quot;/images/back40.gif&quot;);&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础-html层叠样式表</title>
    <url>/2021/08/19/myblog/%E5%89%8D%E7%AB%AF%E9%97%A8%E5%A4%96%E6%B1%89/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTML/</url>
    <content><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>HTML 是一种在 Web 上使用的通用标记语言。HTML 允许你格式化文本，添加图片，创建链接、输入表单、框架和表格等等，并可将之存为文本文件，浏览器即可读取和显示。</p>
<p>HTML 的关键是标签，其作用是指示将出现的内容。</p>
<p>页面F12看代码</p>
<!--         -->是注释语句。

<p>&lt;!     &gt;这不是，<!DOCTYPE HTML>这是放在第一行的声明，指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。</p>
<p>对于中文网页需要使用 <meta charset="utf-8"> 声明编码，否则会出现乱码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  //声明版本</span><br><span class="line">&lt;html&gt;     //根元素</span><br><span class="line">&lt;head&gt;    //包含文档元数据</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;    </span><br><span class="line">&lt;title&gt;标题&lt;/title&gt;  //文档标题</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;    //可见的页面部分</span><br><span class="line">&lt;h1&gt;我的第一个标题&lt;/h1&gt;    //h1 -- h6</span><br><span class="line">&lt;hr&gt;       //一条水平线</span><br><span class="line">&lt;p&gt;我的第一个段落。&lt;/p&gt;</span><br><span class="line">&lt;a href=&quot;https://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt;   </span><br><span class="line">//&lt;a是标签   href是属性</span><br><span class="line">&lt;img loading=&quot;lazy&quot; src=&quot;/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt;</span><br><span class="line">&lt;b&gt;加粗文本&lt;/b&gt;</span><br><span class="line">&lt;i&gt;斜体文本&lt;/i&gt;</span><br><span class="line">&lt;sub&gt; 下标&lt;/sub&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="（1）元素-amp-标签"><a href="#（1）元素-amp-标签" class="headerlink" title="（1）元素 &amp; 标签"></a>（1）元素 &amp; 标签</h3><ul>
<li>HTML 元素以<strong>开始标签</strong>起始</li>
<li>HTML 元素以<strong>结束标签</strong>终止</li>
<li><strong>元素的内容</strong>是开始标签与结束标签之间的内容</li>
<li>大多数 HTML 元素可拥有<strong>属性</strong></li>
<li>HTML 标签对大小写不敏感：<P> 等同于 <p></p></P></li>
</ul>
<h3 id="（2）属性"><a href="#（2）属性" class="headerlink" title="（2）属性"></a>（2）属性</h3><ul>
<li>HTML 元素可以设置<strong>属性</strong></li>
<li>属性可以在元素中添加<strong>附加信息</strong></li>
<li>属性一般描述于<strong>开始标签</strong> &lt;&gt;里面</li>
<li>属性总是以名称/值对的形式出现，**比如：name=”value”**。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">class</td>
<td align="left">为html元素定义一个或多个类名（classname）(类名从样式文件引入)</td>
</tr>
<tr>
<td align="left">id</td>
<td align="left">定义元素的唯一id</td>
</tr>
<tr>
<td align="left">style</td>
<td align="left">规定元素的行内样式（inline style）</td>
</tr>
<tr>
<td align="left">title</td>
<td align="left">描述了元素的额外信息 (作为工具条使用)</td>
</tr>
</tbody></table>
<h3 id="（3）可添加在头部的标签"><a href="#（3）可添加在头部的标签" class="headerlink" title="（3）可添加在头部的标签"></a>（3）可添加在头部<head>的标签</head></h3><head> 元素包含了所有的头部标签元素。在 <head>元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。

<p>可以添加在头部区域的元素标签为:<code> &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt; 和 &lt;base&gt;</code>。</p>
<table>
<thead>
<tr>
<th align="center">标签</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;title&gt;</code></td>
<td align="center">搜索引擎以及收藏夹中的标题</td>
</tr>
<tr>
<td align="center"><code>&lt;base&gt;</code></td>
<td align="center">定义了页面链接标签的默认链接地址</td>
</tr>
<tr>
<td align="center"><code>&lt;link&gt;</code></td>
<td align="center">文档和外部资源之间的关系</td>
</tr>
<tr>
<td align="center"><code>&lt;style&gt;</code></td>
<td align="center">定义了HTML文档的样式文件</td>
</tr>
<tr>
<td align="center"><code>&lt;meta&gt;</code></td>
<td align="center">定义了文档的元数据</td>
</tr>
<tr>
<td align="center"><code>&lt;script&gt;</code></td>
<td align="center">定义了客户端的脚本文件</td>
</tr>
</tbody></table>
<h3 id="（4）CSS"><a href="#（4）CSS" class="headerlink" title="（4）CSS"></a>（4）CSS</h3><p>CSS (Cascading Style Sheets) 用于渲染HTML元素标签的样式。使用方法：</p>
<ul>
<li>内联样式- 在HTML元素中使用”style” <strong>属性</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body style=&quot;background-color:yellow;&quot;&gt;</span><br><span class="line">&lt;h2 style=&quot;background-color:red;&quot;&gt;这是一个标题&lt;/h2&gt;</span><br><span class="line">&lt;p style=&quot;background-color:green;&quot;&gt;这是一个段落。&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>内部样式表 -在HTML文档头部 <code>&lt;head&gt;</code> 区域使用<code>&lt;style&gt; </code><strong>标签</strong> 来包含CSS</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;标题&lt;/title&gt; </span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">body &#123;background-color:yellow;&#125;</span><br><span class="line">p &#123;color:blue;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;这是一个标题&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;这是一个段落。&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>外部引用 - 使用外部 CSS <strong>文件</strong>（适合一个样式应用与多个页面）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<h3 id="（5）script脚本"><a href="#（5）script脚本" class="headerlink" title="（5）script脚本"></a>（5）script脚本</h3><p>JavaScript 使 HTML 页面具有更强的动态和交互性。</p>
<ul>
<li>使用<code>&lt;script&gt;</code>标签，可以在<code>&lt;head&gt;</code>也可以在<code>&lt;body&gt;</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">document.write(&quot;Hello World!&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></head></head>]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>前端寄出-JavaScript</title>
    <url>/2021/08/19/myblog/%E5%89%8D%E7%AB%AF%E9%97%A8%E5%A4%96%E6%B1%89/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-JavaScript/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><strong>JavaScript</strong></h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>JavaScript 是脚本语言，可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。<br>JavaScript 是一种轻量级的编程语言。<br>JavaScript 是可插入 HTML 页面的编程代码。<br>JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。<br>JavaScript 语句向浏览器发出的命令。语句的作用是告诉浏览器该做什么。</p>
<p>作用：直接写入html输出流。对事件做出反应。改变HTML内容。改变HTML图像。改变HTML样式。验证输入。等</p>
<p>JavaScript 与 Java 是两种完全不同的语言，无论在概念上还是设计上。</p>
<p>Java（由 Sun 发明）是更复杂的编程语言。</p>
<p>JavaScript 由 Brendan Eich 发明。它于 1995 年出现，被 ECMA（一个标准协会）采纳。。</p>
<h2 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h2><h3 id="1-内部方式"><a href="#1-内部方式" class="headerlink" title="(1)内部方式"></a>(1)内部方式</h3><p>脚本必须位于<code> &lt;script&gt;</code> 与 <code>&lt;/script&gt;</code> 标签之间。<br>脚本可被放置在 HTML 页面的 <code>&lt;body&gt; </code>和 <code>&lt;head&gt; </code>部分中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;标题&lt;/title&gt; </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	</span><br><span class="line">&lt;h1&gt;我的第一段 JavaScript&lt;/h1&gt;</span><br><span class="line">&lt;p id=&quot;demo&quot;&gt;</span><br><span class="line">JavaScript 能改变 HTML 元素的样式。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;script&gt;       //可以在body，也可以在head</span><br><span class="line">function myFunction()       //函数作用：捕获元素之后改变样式</span><br><span class="line">&#123;</span><br><span class="line">	x=document.getElementById(&quot;demo&quot;) // 找到元素  getElementById函数捕获id选择器</span><br><span class="line">	x.style.color=&quot;#ff0000&quot;;          // 改变样式</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;  //使用函数</span><br><span class="line">	</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-外部方式"><a href="#2-外部方式" class="headerlink" title="(2)外部方式"></a>(2)外部方式</h3><p>以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。外部 JavaScript 文件的文件扩展名是 .js。</p>
<p>导入方式：在 <code>&lt;script&gt;</code> 标签的 “src” 属性中设置该 .js 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-JavaScript输出"><a href="#3-JavaScript输出" class="headerlink" title="3.JavaScript输出"></a>3.JavaScript输出</h2><p>JavaScript 可以通过不同的方式来输出数据：<br>使用 window.alert() 弹出警告框。</p>
<p>使用 document.write() 方法将内容写到 HTML 文档中。</p>
<p>使用 innerHTML 写入到 HTML元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;demo&quot;).innerHTML=&quot;段落已修改。&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用 console.log() 写入到浏览器的控制台。</p>
<h2 id="4-JavaScript语法"><a href="#4-JavaScript语法" class="headerlink" title="4.JavaScript语法"></a>4.JavaScript语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var points = 10;     // Number 通过表达式字面量赋值</span><br><span class="line">var lastName = &quot;Johnson&quot;;   // String 通过字符串字面量赋值</span><br><span class="line">var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];    // Array  通过数组字面量赋值</span><br><span class="line">var person = &#123;firstName:&quot;John&quot;, lastName:&quot;Doe&quot;&#125;;  // Object 通过对象字面量赋值</span><br><span class="line">使用：对象是拥有属性和方法的数据。对象键值对的形式。</span><br><span class="line">name=person.lastname;</span><br><span class="line">name=person[&quot;lastname&quot;];</span><br></pre></td></tr></table></figure>

<p>JavaScript 是脚本语言，浏览器会在读取代码时，逐行地执行脚本代码。而对于传统编程来说，会在执行前对所有代码进行编译。</p>
<p>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。<br>引用数据类型：对象(Object)、数组(Array)、函数(Function)。<br>JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型。<br>JavaScript 只有一种数字类型。数字可以带小数点，也可以不带。</p>
<h2 id="5-JavaScript事件"><a href="#5-JavaScript事件" class="headerlink" title="5.JavaScript事件"></a>5.JavaScript事件</h2><p>HTML 事件是发生在 HTML 元素上的事情。<br>当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。<br>HTML 事件可以是浏览器行为，也可以是用户行为。<br>以下是 HTML 事件的实例：<br>HTML 页面完成加载<br>HTML input 字段改变时<br>HTML 按钮被点击</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;标题&lt;/title&gt; </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button onclick=&quot;displayDate()&quot;&gt;点这里&lt;/button&gt;  </span><br><span class="line">//事件，onclick属性对应了script里的函数，点击运行script里的函数</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function displayDate()&#123;</span><br><span class="line">	document.getElementById(&quot;demo&quot;).innerHTML=Date();</span><br><span class="line">&#125;      //写入html元素</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;  //id选择器找元素</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6-JavaScript数据类型"><a href="#6-JavaScript数据类型" class="headerlink" title="6.JavaScript数据类型"></a>6.JavaScript数据类型</h2><h3 id="1-字符串与对象"><a href="#1-字符串与对象" class="headerlink" title="(1)字符串与对象"></a>(1)字符串与对象</h3><p>var x = “John”;<br>var y = new String(“John”);<br>(x === y) // 结果为 false，因为 x 是字符串，y 是对象</p>
<p>两个数字相加，返回数字相加的和，如果数字与字符串相加，返回字符串</p>
<p>你可以使用 typeof 操作符来检测变量的数据类型。<br>typeof “John”                // 返回 string</p>
<h3 id="2-undefined-和-null-的区别"><a href="#2-undefined-和-null-的区别" class="headerlink" title="(2)undefined 和 null 的区别"></a>(2)undefined 和 null 的区别</h3><p>null 和 undefined 的值相等，但类型不等：<br>typeof undefined             // undefined<br>typeof null                  // object<br>null === undefined           // false<br>null == undefined            // true<br>在严格的比较运算中，=== 为恒等计算符，同时检查表达式的值与类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、定义</span><br><span class="line"> （1）undefined：是所有没有赋值变量的默认值，自动赋值。</span><br><span class="line"> （2）null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。</span><br><span class="line">2、何时使用null?</span><br><span class="line">当使用完一个比较大的对象时，需要对其进行释放内存时，设置为 null。</span><br><span class="line">3、null 与 undefined 的异同点是什么呢？</span><br><span class="line">共同点：都是原始类型，保存在栈中变量本地。</span><br><span class="line">不同点：</span><br><span class="line">（1）undefined——表示变量声明过但并未赋过值。</span><br><span class="line">它是所有未赋值变量默认值，例如：</span><br><span class="line">var a;    // a 自动被赋值为 undefined</span><br><span class="line">（2）null——表示一个变量将来可能指向一个对象。</span><br><span class="line">一般用于主动释放指向对象的引用，例如：</span><br><span class="line">var emps = [&#x27;ss&#x27;,&#x27;nn&#x27;];</span><br><span class="line">emps = null;     // 释放指向数组的引用</span><br><span class="line">4、延伸——垃圾回收站</span><br><span class="line">它是专门释放对象内存的一个程序。</span><br><span class="line"> （1）在底层，后台伴随当前程序同时运行；引擎会定时自动调用垃圾回收期；</span><br><span class="line"> （2）总有一个对象不再被任何变量引用时，才释放。</span><br></pre></td></tr></table></figure>

<h3 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="(3)类型转换"></a>(3)类型转换</h3><p>JavaScript 数据类型：<br>在 JavaScript 中有 6 种不同的数据类型：string、number、boolean、object、function、symbol<br>3 种对象类型：Object、Date、Array<br>2 个不包含任何值的数据类型：null、undefined</p>
<p>Number() 转换为数字， String() 转换为字符串， Boolean() 转换为布尔值。</p>
<h3 id="4-声明提升"><a href="#4-声明提升" class="headerlink" title="(4)声明提升"></a>(4)声明提升</h3><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。<br>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。<br>声明提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。<br>但是：只有声明会提升，初始化不会。</p>
<h2 id="7-正则表达式"><a href="#7-正则表达式" class="headerlink" title="7.正则表达式"></a>7.正则表达式</h2><p>正则表达式：使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。<br>搜索模式可用于文本搜索和文本替换。</p>
<p>正则表达式可用于所有文本搜索和文本替换的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var patt = /runoob/i</span><br><span class="line">实例解析：</span><br><span class="line">/runoob/i  是一个正则表达式。</span><br><span class="line">runoob  是一个正则表达式主体 (用于检索)。</span><br><span class="line">i  是一个修饰符 (搜索不区分大小写)。</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</span><br><span class="line">replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</span><br></pre></td></tr></table></figure>

<p>正则表达式修饰符：<br>i    执行对大小写不敏感的匹配。<br>g    执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。<br>m    执行多行匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</span><br><span class="line">var patt = /e/;</span><br><span class="line">patt.test(&quot;The best things in life are free!&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec() 方法用于检索字符串中的正则表达式的匹配。</span><br><span class="line">该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</span><br><span class="line">/e/.exec(&quot;The best things in life are free!&quot;);</span><br><span class="line">字符串中含有 &quot;e&quot;，所以该实例输出为:e</span><br></pre></td></tr></table></figure>

<h2 id="8-JavaScript错误"><a href="#8-JavaScript错误" class="headerlink" title="8.JavaScript错误"></a>8.JavaScript错误</h2><p>try 语句测试代码块的错误。<br>catch 语句处理错误。<br>throw 语句创建自定义错误。<br>finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现一个输入框，输入5-10之间数字，如果错误则报错，每次输入完自动清空输入框</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;不管输入是否正确，输入框都会再输入后清空。&lt;/p&gt;</span><br><span class="line">&lt;p&gt;请输入 5 ~ 10 之间的数字：&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;input id=&quot;demo&quot; type=&quot;text&quot;&gt;    //输入框</span><br><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点我&lt;/button&gt;  //按钮触发函数</span><br><span class="line"></span><br><span class="line">&lt;p id=&quot;p01&quot;&gt;&lt;/p&gt;    //用来输出错误信息的段落</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">  var message, x;</span><br><span class="line">  message = document.getElementById(&quot;p01&quot;);   //输出错误信息用</span><br><span class="line">  x = document.getElementById(&quot;demo&quot;).value;     //获得输入框的东西</span><br><span class="line">  try &#123;                                   //判断，抛出错误</span><br><span class="line">    if(x == &quot;&quot;) throw &quot;值是空的&quot;;</span><br><span class="line">    if(isNaN(x)) throw &quot;值不是一个数字&quot;;</span><br><span class="line">    x = Number(x);</span><br><span class="line">    if(x &gt; 10) throw &quot;太大&quot;;</span><br><span class="line">    if(x &lt; 5) throw &quot;太小&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  catch(err) &#123;</span><br><span class="line">    message.innerHTML = &quot;错误: &quot; + err + &quot;.&quot;;     //错误信息写入元素中</span><br><span class="line">  &#125;</span><br><span class="line">  finally &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).value = &quot;&quot;;  //清空输入框</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="9-JavaScript表单"><a href="#9-JavaScript表单" class="headerlink" title="9.JavaScript表单"></a>9.JavaScript表单</h2><p>HTML 表单验证可以通过 JavaScript 来完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现：输入一个东西，弹出新页表，提示输入的是什么</span></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function validateForm() &#123;       //进行验证的函数</span><br><span class="line">    var x = document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;</span><br><span class="line">    if (x == null || x == &quot;&quot;) &#123;</span><br><span class="line">        alert(&quot;需要输入名字。&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form name=&quot;myForm&quot; action=&quot;demo_form.php&quot;      //表单，有一些属性</span><br><span class="line">onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;</span><br><span class="line">名字: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;      //一个文本输入框</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;       //一个提交按钮</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建第一个VUE项目，入门级别</title>
    <url>/2021/08/19/myblog/%E5%89%8D%E7%AB%AF%E9%97%A8%E5%A4%96%E6%B1%89/%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAVUE%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h3 id="1-开发软件vscode"><a href="#1-开发软件vscode" class="headerlink" title="1.开发软件vscode"></a>1.开发软件vscode</h3><p>vscode特点：</p>
<ul>
<li>开源，免费；</li>
<li>自定义配置</li>
<li>集成git</li>
<li>智能提示强大</li>
<li>支持各种文件格式（html/jade/css/less/sass/xml）</li>
<li>调试功能强大</li>
<li>各种方便的快捷键</li>
<li>强大的插件扩展</li>
</ul>
<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>Debugger for Chrome：从VS Code调试在Google Chrome中运行的JavaScript代码。</p>
<p>beautify：格式化代码工具，美化Javascript，JSON，CSS，Sass，和HTML在Visual Studio代码。</p>
<p>Atuo Rename Tag：修改 html 标签，自动帮你完成头部和尾部闭合标签的同步修改。</p>
<p>中文（简体）语言包</p>
<p>Code Spell Checker：代码拼写检查器，一个与camelCase代码配合良好的基本拼写检查程序。此拼写检查程序的目标是帮助捕获常见的拼写错误，同时保持误报数量较低。 </p>
<p>vscode-icons：显示Visual Studio代码的图标，目前该插件已被vscode内部支持：”文件” -&gt; “首选项” -&gt; “文件图标主题”。 </p>
<p>guides：显示代码对齐辅助线，很好用。</p>
<p>filesize：在状态栏中显示当前文件大小，点击后还可以看到详细创建</p>
<p>Path Intellisense：可自动填充文件名。 </p>
<h3 id="2-入门"><a href="#2-入门" class="headerlink" title="2.入门"></a>2.入门</h3><ol>
<li><strong>HTML</strong> 定义了网页的内容</li>
<li><strong>CSS</strong> 描述了网页的布局</li>
<li><strong>JavaScript</strong> 控制了网页的行为</li>
<li><strong>Vue.js</strong>（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。<br>Vue 只关注视图层， 采用自底向上增量开发的设计。<br>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</li>
</ol>
<h3 id="3-开始一个vue项目"><a href="#3-开始一个vue项目" class="headerlink" title="3.开始一个vue项目"></a>3.开始一个vue项目</h3><h4 id="1）安装node环境"><a href="#1）安装node环境" class="headerlink" title="1）安装node环境"></a>1）安装node环境</h4><h5 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h5><p>简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>
<p>Node.js是一个让JavaScript运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言</p>
<p>类似于J2EE</p>
<blockquote>
<p>Java的三个版本 : JAVASE(标准版),JAVAEE(企业版),JAVAME(微型版).</p>
<p>java是一个平台。他包括了，java语言，java开发环境(jdk)。java有三个版本，j2se(标准版),j2ee(企业版),j2me(微型版)不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。j2EE是java的企业级开发版本，其实换句话说就是用来做web开发的java框架。javaEE通过设定统一的标准来解决web开发的问题，javaEE的接口，抽象类，规定了web开发所需要实现的流程。整个web的开发，有2层，第1层是服务器容器，比如tomcat，weblogic。他们在javaEE的规范下，实现套接字的连接，封装消息等等，第2层是业务，而这一层是你要做的，通过tomcat封装的消息，进行相应的业务处理。服务器容器的开发由大型的产商开发，而我们通常做的开发是在服务器容器上的业务开发，正是sun的javaEE统一了规范(比如用servlet)我们的业务代码，能和comcat进行很好的通讯。</p>
</blockquote>
<p>下载地址为：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<h5 id="npm简介"><a href="#npm简介" class="headerlink" title="npm简介"></a>npm简介</h5><p>npm：Node.js的包管理工具（package manager）大家都把自己开发的模块打包后放到npm官网上，如果要使用，</p>
<p>直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<p>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X</p>
<p>npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。</p>
<p>类似与MAVEN</p>
<p><code>npm install -g cnpm –registry=https://registry.npm.taobao.org</code>，即可安装npm镜像，以后再用到npm的地方直接用cnpm来代替就好了。</p>
<h4 id="2）搭建vue项目环境"><a href="#2）搭建vue项目环境" class="headerlink" title="2）搭建vue项目环境"></a>2）搭建vue项目环境</h4><p><strong>vue-cli简介</strong></p>
<p>vue-cli是vue官方提供的一个命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需一分钟即可启动带热重载、保存时静态检查以及可用于生产环境的构建配置的项目。</p>
<p>安装vue-cli：vue-cli是vue.js的脚手架，用于自动生成vue.js+webpack的项目模板，自动化前端项目工具</p>
<p>webpack是一个<strong>打包器（bundler）</strong>，它能将多个js文件打包成一个文件（其实不止能打包js文件，也能打包其他类型的文件，比如css文件，json文件等）。</p>
<p><code>npm install --global vue-cli</code></p>
<h4 id="2-5）centos下安装"><a href="#2-5）centos下安装" class="headerlink" title="2.5）centos下安装"></a>2.5）centos下安装</h4><p><code>sudo yum install -y nodejs</code></p>
<p><code>sudo yum install -y npm</code></p>
<p><code>npm install --global vue-cli</code>    //发生错误，无法成功安装</p>
<blockquote>
<p><code>npm config set strict-ssl false</code>   //绕过https</p>
<p>再sudo执行还是不行👋🏻  卡住了。。。</p>
<p>Yarn是facebook发布的一款取代npm的包管理工具。</p>
<p><code>sudo npm install -g yarn</code>  同样的错误：npm ERR! Error: CERT_UNTRUSTED</p>
</blockquote>
<p>挥之不去的错误：npm安装过不了</p>
<p><strong>转战MAC安装：</strong></p>
<blockquote>
<p>1.安装node.js(<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html">http://www.runoob.com/nodejs/nodejs-install-setup.html</a>)  node -v<br>2.安装npm：略  npm -v<br>3.安装cnpm：sudo npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>4.安装全局vue-cli脚手架,用于帮助搭建所需的模板框架：sudo cnpm install -g vue-cli</p>
</blockquote>
<h4 id="3-创建一个基于webpack模板的新项目"><a href="#3-创建一个基于webpack模板的新项目" class="headerlink" title="3)创建一个基于webpack模板的新项目"></a>3)创建一个基于webpack模板的新项目</h4><p>进入项目目录，创建一个基于webpack模板的新项目<br><code>vue init webpack myfirstvue</code></p>
<p>选择项目名字、项目描述、作者等等Vue build ==&gt; 打包方式，回车即可；</p>
<p>Install vue-router ==&gt; 是否要安装 vue-router</p>
<p>Use ESLint to lint your code ==&gt; 是否需要 js 语法检测 </p>
<p>Set up unit tests ==&gt; 是否安装 单元测试工具</p>
<p>Setup e2e tests with Nightwatch ==&gt; 是否需要 端到端测试工具 </p>
<p>顺便还安装了yarn</p>
<h4 id="4）进入项目，安装依赖"><a href="#4）进入项目，安装依赖" class="headerlink" title="4）进入项目，安装依赖"></a>4）进入项目，安装依赖</h4><p>cd myfirstvue 进入项目</p>
<p>安装成功后，项目文件夹中会多出一个目录：node_modules</p>
<h4 id="5）运行项目"><a href="#5）运行项目" class="headerlink" title="5）运行项目"></a>5）运行项目</h4><p>npm run dev  </p>
<p>运行效果：</p>
<p><img src="https://img2020.cnblogs.com/blog/2499596/202108/2499596-20210817150434095-1939209105.png"></p>
<h4 id="6）项目目录解读"><a href="#6）项目目录解读" class="headerlink" title="6）项目目录解读"></a>6）项目目录解读</h4><p>1、build：构建脚本目录</p>
<p>　　　　1）build.js  ==&gt; 生产环境构建脚本；``</p>
<p>　　　　2）check-versions.js  ==&gt; 检查npm，node.js版本；</p>
<p>　　　　3）utils.js  ==&gt; 构建相关工具方法；</p>
<p>　　　　4）vue-loader.conf.js  ==&gt; 配置了css加载器以及编译css之后自动添加前缀；</p>
<p>　　　　5）webpack.base.conf.js  ==&gt; webpack基本配置；</p>
<p>　　　　6）webpack.dev.conf.js  ==&gt; webpack开发环境配置；</p>
<p>　　　　7）webpack.prod.conf.js  ==&gt; webpack生产环境配置；</p>
<p>2、config：项目配置</p>
<p>　　　　1）dev.env.js  ==&gt; 开发环境变量；</p>
<p>　　　　2）index.js  ==&gt; 项目配置文件；</p>
<p>　　　　3）prod.env.js  ==&gt; 生产环境变量；</p>
<p>3、node_modules：npm 加载的项目依赖模块</p>
<p>4、src：这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：</p>
<p>　　　　1）assets：资源目录，放置一些图片或者公共js、公共css。这里的资源会被webpack构建；</p>
<p>　　　　2）components：组件目录，我们写的组件就放在这个目录里面；</p>
<p>　　　　3）router：前端路由，我们需要配置的路由路径写在index.js里面；</p>
<p>　　　　4）App.vue：根组件；</p>
<p>　　　　5）main.js：入口js文件；</p>
<p>5、static：静态资源目录，如图片、字体等。不会被webpack构建</p>
<p>6、index.html：首页入口文件，可以添加一些 meta 信息等</p>
<p>7、package.json：npm包配置文件，定义了项目的npm脚本，依赖包等信息``</p>
<p>8、README.md：项目的说明文档，markdown 格式</p>
<p>9、.xxxx文件：这些是一些配置文件，包括语法配置，git配置等</p>
<h4 id="7）项目改造"><a href="#7）项目改造" class="headerlink" title="7）项目改造"></a>7）项目改造</h4><p>1.在components目录下新建一个views目录，里面写我们的vue组件<br>  在views目录下新建First.vue</p>
<p>2.在router目录下的index.js里面配置路由路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Router from &#x27;vue-router&#x27;</span><br><span class="line">import HelloWorld from &#x27;@/components/HelloWorld&#x27;</span><br><span class="line">import first from &#x27;@components/views/first&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      name: &#x27;HelloWorld&#x27;,</span><br><span class="line">      component: HelloWorld</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: &#x27;/first&#x27;,</span><br><span class="line">      name: &#x27;first&#x27;,</span><br><span class="line">      component: first</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>3.template 写 html，script写 js，style写样式（运行会提示空格引号错误之类的，按要求修改即可）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&gt;</span><br><span class="line">  &lt;div class=&quot;first-app&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;first&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;welcome to firstapp&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- what --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>4.效果：</p>
<p><img src="https://img2020.cnblogs.com/blog/2499596/202108/2499596-20210817150350056-832764408.png"></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://www.cnblogs.com/hellman/p/10985377.html">https://www.cnblogs.com/hellman/p/10985377.html</a></p>
<p><a href="https://www.cnblogs.com/miller-star/p/6394760.html">https://www.cnblogs.com/miller-star/p/6394760.html</a></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础-vue</title>
    <url>/2021/08/23/myblog/%E5%89%8D%E7%AB%AF%E9%97%A8%E5%A4%96%E6%B1%89/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-Vue/</url>
    <content><![CDATA[<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><h3 id="1-CDN方法"><a href="#1-CDN方法" class="headerlink" title="(1)CDN方法"></a>(1)CDN方法</h3><p>在页面上以 CDN 包的形式导入。<br><code>&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;</code></p>
<blockquote>
<p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p>
<p>由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/vue/2.2.2/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>    </span><br><span class="line">//<span class="tag">&lt;<span class="name">div</span>&gt;</span> 标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。用 id 或 class 来标记 <span class="tag">&lt;<span class="name">div</span>&gt;</span>，那么该标签的作用会变得更加有效。</span><br><span class="line">//如果与 CSS 一同使用，<span class="tag">&lt;<span class="name">div</span>&gt;</span> 元素可用于对大的内容块设置样式属性。</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">//&#123;&#123; &#125;&#125; 用于输出对象属性和函数返回值。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,   <span class="comment">//id选择器</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;         <span class="comment">//输出什么东西？</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue.js!&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-使用npm方法"><a href="#2-使用npm方法" class="headerlink" title="(2)使用npm方法"></a>(2)使用npm方法</h3><p>npm run dev</p>
<p>Vue.js 提供一个官方命令行工具vue-cli，可用于快速搭建大型单页应用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">$ cnpm install --global vue-cli</span><br><span class="line"># 创建一个基于 webpack 模板的新项目</span><br><span class="line">$ vue init webpack my-project</span><br><span class="line"></span><br><span class="line">安装及运行：</span><br><span class="line">$ cd my-project</span><br><span class="line">$ cnpm install</span><br><span class="line">$ cnpm run dev</span><br><span class="line"></span><br><span class="line">项目打包：</span><br><span class="line">npm run build</span><br><span class="line">执行完成后，会在 Vue 项目下生成一个 dist 目录，一般包含 index.html 文件及 static 目录，static 目录包含了静态文件 js、css 以及图片目录 images。</span><br><span class="line">直接双击 dist/index.html 文件就可以在浏览器中看到效果了。</span><br></pre></td></tr></table></figure>

<h2 id="3-VUE项目"><a href="#3-VUE项目" class="headerlink" title="3.VUE项目"></a>3.VUE项目</h2><h3 id="1-项目目录"><a href="#1-项目目录" class="headerlink" title="(1)项目目录"></a>(1)项目目录</h3><table>
<thead>
<tr>
<th align="left">目录/文件</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">build</td>
<td align="left">项目构建(webpack)相关代码</td>
</tr>
<tr>
<td align="left">config</td>
<td align="left">配置目录，包括端口号等。我们初学可以使用默认的。</td>
</tr>
<tr>
<td align="left">node_modules</td>
<td align="left">npm 加载的项目依赖模块</td>
</tr>
<tr>
<td align="left">src</td>
<td align="left">这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等。components: 目录里面放了一个组件文件，可以不用。App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。main.js: 项目的核心文件。</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">静态资源目录，如图片、字体等。</td>
</tr>
<tr>
<td align="left">test</td>
<td align="left">初始测试目录，可删除</td>
</tr>
<tr>
<td align="left">.xxxx文件</td>
<td align="left">这些是一些配置文件，包括语法配置，git配置等。</td>
</tr>
<tr>
<td align="left">index.html</td>
<td align="left">首页入口文件，你可以添加一些 meta 信息或统计代码啥的。</td>
</tr>
<tr>
<td align="left">package.json</td>
<td align="left">项目配置文件。</td>
</tr>
<tr>
<td align="left">README.md</td>
<td align="left">项目的说明文档，markdown 格式</td>
</tr>
</tbody></table>
<p>app.vue:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 展示模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./assets/logo.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 导入组件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">&#x27;./components/Hello&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&#x27;app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    Hello</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 样式代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#app</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">font-family</span>: <span class="string">&#x27;Avenir&#x27;</span>, Helvetica, Arial, sans-serif;</span></span><br><span class="line"><span class="css">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span><br><span class="line"><span class="css">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span><br><span class="line"><span class="css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-template标签"><a href="#2-template标签" class="headerlink" title="(2)template标签"></a>(2)template标签</h3><p>使用 <code>&lt;template&gt;</code> 保留页面加载时隐藏的内容。使用 JavaScript 来显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;template 元素&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;单击下面的按钮，显示 template 元素中的隐藏内容。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;button onclick=&quot;showContent()&quot;&gt;显示隐藏的内容&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;     //点击按钮才会显示，JavaScript响应事件</span><br><span class="line">  &lt;h2&gt;Flower&lt;/h2&gt;</span><br><span class="line">  &lt;img src=&quot;/i/photo/flower.gif&quot; width=&quot;180&quot; height=&quot;180&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function showContent() &#123;</span><br><span class="line">  var temp = document.getElementsByTagName(&quot;template&quot;)[0];</span><br><span class="line">  var clon = temp.content.cloneNode(true);</span><br><span class="line">  document.body.appendChild(clon);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-vue应用"><a href="#3-vue应用" class="headerlink" title="(3)vue应用"></a>(3)vue应用</h3><p>每个 Vue 应用都需要通过实例化 Vue 来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  // 选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue 测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/vue/2.4.2/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vue_det&quot;</span>&gt;</span>   //块儿</span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>site : &#123;&#123;site&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>url : &#123;&#123;url&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Alexa : &#123;&#123;alexa&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 我们的数据对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> data = &#123; <span class="attr">site</span>: <span class="string">&quot;hello&quot;</span>, <span class="attr">url</span>: <span class="string">&quot;www.runoob.com&quot;</span>, <span class="attr">alexa</span>: <span class="number">10000</span>&#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;    <span class="comment">//vue应用</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#vue_det&#x27;</span>,    <span class="comment">//id选择器</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: data       <span class="comment">//数据，在外面</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 它们引用相同的对象！</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(vm.site === data.site) <span class="comment">// true</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">&quot;&lt;br&gt;&quot;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置属性也会影响到原始数据</span></span></span><br><span class="line"><span class="javascript">    vm.site = <span class="string">&quot;Runoob&quot;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(data.site + <span class="string">&quot;&lt;br&gt;&quot;</span>) <span class="comment">// Runoob</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ……反之亦然</span></span></span><br><span class="line"><span class="javascript">    data.alexa = <span class="number">1234</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(vm.alexa) <span class="comment">// 1234</span></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化。</p>
<h2 id="4-vscode运行html"><a href="#4-vscode运行html" class="headerlink" title="4.vscode运行html"></a>4.vscode运行html</h2><p>(1).新建.html文件</p>
<p>(2).安装open in browser插件</p>
<p>(3).html页面右键选择open in other browser</p>
<h2 id="5-vue项目不用localhost"><a href="#5-vue项目不用localhost" class="headerlink" title="5.vue项目不用localhost"></a>5.vue项目不用localhost</h2><p>改变config下index.js里的ip，也是本机的私有ip，公网内的其他ip可访问。前提：一个公网。</p>
<h2 id="6-项目解读"><a href="#6-项目解读" class="headerlink" title="6.项目解读"></a>6.项目解读</h2><p>main.js 像是加vue应用的。</p>
<p>.vue 里面有<code>&lt;template&gt;</code> <code>&lt;script&gt;</code> <code>&lt;style&gt;</code></p>
<p>首页入口文件：index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>myfirstvue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>项目入口文件：App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./assets/logo.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&#x27;App&#x27;</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#app</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">font-family</span>: <span class="string">&#x27;Avenir&#x27;</span>, Helvetica, Arial, sans-serif;</span></span><br><span class="line"><span class="css">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span><br><span class="line"><span class="css">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span><br><span class="line"><span class="css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ES6：全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。</p>
<p>ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p>
<h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><p>用于导出常量、函数、文件、模块等。</p>
<p>export可以有多个，export default只能有一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello.vue中：</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;HelloWorld&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;Welcome to Your Vue.js App&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7-vscode打开终端"><a href="#7-vscode打开终端" class="headerlink" title="7.vscode打开终端"></a>7.vscode打开终端</h3><p>ctrl+·（左上角esc下面的）</p>
<p>或：查看-&gt;终端</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>LFU缓存实现</title>
    <url>/2021/08/19/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LFU%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="LFU-缓存"><a href="#LFU-缓存" class="headerlink" title="LFU 缓存"></a>LFU 缓存</h3><p>回顾一下LRU：最近最久未使用。实现时采用双向链表+哈希表使得每次查询O1复杂度，哈希表中（key，双向链表节点（value）），查到之后，双向链表可以实现快速的删除操作，以及双向链表实现队列的效果。哈希就是为了get(key）快一些，而双向链表是为了put(key,value)的时候，调整顺序，以及满的时候淘汰，双向链表中存的只是value。</p>
<p>最不经常使用LFU：缓存满了之后，需要删除使用频率最小的内存，并且如果使用频率相同，需要删除插入时间最早的。</p>
<p>实现 LFUCache 类：<br>LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象<br>int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。<br>void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。</p>
<p>实现：双向链表+哈希表，原则：内存标记即key是唯一的，所以第一个哈希map：key–双向链表节点，第二个map：使用次数–第一次使用的节点</p>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>用链表顺序记录是用最少的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">get：查询</span></span><br><span class="line"><span class="comment">put：插入、删除</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">哈希表，维护 key，node</span></span><br><span class="line"><span class="comment">哈希表，维护 cnt，firstnode  //cnt是使用次数，firstnode是最久未使用的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由于多个节点的cnt可能相同，因此记录每个cnt的最前方元素节点，保证最久不用的节点依次位于后方</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">链表node&lt;cnt, value&gt;</span></span><br><span class="line"><span class="comment">其中，cnt需要降序排列，</span></span><br><span class="line"><span class="comment">- 有新的key时，插入到cnt=1的最前面，保证最后一位是“最不常用&amp;&amp;cnt=1中最久没使用“的。</span></span><br><span class="line"><span class="comment">更新 cnt，node，firstnode</span></span><br><span class="line"><span class="comment">- 删除时，删除cnt最小的，即，最后一位</span></span><br><span class="line"><span class="comment">更新 cnt，node，firstnode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> capacity;</span><br><span class="line">	list&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; nodeList; <span class="comment">//node&lt;cnt, value, key&gt;</span></span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator&gt; keyNodeMap;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator&gt; cntFirstNodeMap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印 list 和 map</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printAllData</span><span class="params">(string action)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = nodeList.<span class="built_in">begin</span>(); it != nodeList.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">			<span class="keyword">auto</span> vec = *it;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; vec[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;&#125;,  &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = keyNodeMap.<span class="built_in">begin</span>(); it != keyNodeMap.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">			<span class="keyword">int</span> key = it-&gt;first;</span><br><span class="line">			<span class="keyword">auto</span> vec = *(it-&gt;second);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;key: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; vec[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;&#125;,  &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = cntFirstNodeMap.<span class="built_in">begin</span>(); it != cntFirstNodeMap.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt = it-&gt;first;</span><br><span class="line">			<span class="keyword">auto</span> vec = *(it-&gt;second);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;cnt: &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; vec[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;&#125;,  &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LFUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!keyNodeMap.<span class="built_in">count</span>(key)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">auto</span> currNode = keyNodeMap[key];</span><br><span class="line">		<span class="keyword">int</span> currCnt = (*currNode)[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> value = (*currNode)[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">auto</span> firstNode = cntFirstNodeMap[currCnt];</span><br><span class="line">		<span class="keyword">int</span> newCnt = currCnt + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//若newCnt已存在，则放到全部newCnt之前，否在放到全部currCnt之前</span></span><br><span class="line">		<span class="keyword">if</span> (cntFirstNodeMap.<span class="built_in">count</span>(newCnt)) &#123; firstNode = cntFirstNodeMap[newCnt]; &#125;</span><br><span class="line">		<span class="comment">//更新list：插入</span></span><br><span class="line">		<span class="keyword">auto</span> newNode = nodeList.<span class="built_in">insert</span>(firstNode, &#123; newCnt, value, key &#125;);</span><br><span class="line">		<span class="comment">//更新keyNodeMap：替换</span></span><br><span class="line">		keyNodeMap[key] = newNode;</span><br><span class="line">		<span class="comment">//新的cnt，更新cntFirstNodeMap：替换</span></span><br><span class="line">		cntFirstNodeMap[newCnt] = newNode;</span><br><span class="line">		<span class="comment">//老的cnt，更新cntFirstNodeMap：若恰好为currNode，则更新or删除，否则不用动</span></span><br><span class="line">		<span class="keyword">if</span> (cntFirstNodeMap[currCnt] == currNode) &#123;</span><br><span class="line">			<span class="keyword">auto</span> it = currNode;</span><br><span class="line">			it++;</span><br><span class="line">			<span class="keyword">if</span> (it == nodeList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">				cntFirstNodeMap.<span class="built_in">erase</span>(currCnt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((*it)[<span class="number">0</span>] == currCnt) &#123;</span><br><span class="line">				cntFirstNodeMap[currCnt] = it;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="comment">//cnt变了，说明currCnt下，已经没有任何节点了</span></span><br><span class="line">				cntFirstNodeMap.<span class="built_in">erase</span>(currCnt);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//更新list：删除</span></span><br><span class="line">		nodeList.<span class="built_in">erase</span>(currNode);</span><br><span class="line">		<span class="comment">//printAllData(&quot;get&quot;);</span></span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">get</span>(key) != <span class="number">-1</span>) &#123;</span><br><span class="line">			(*keyNodeMap[key])[<span class="number">1</span>] = value;</span><br><span class="line">			<span class="comment">//printAllData(&quot;put(update)&quot;);</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//溢出删除</span></span><br><span class="line">		<span class="keyword">if</span> (nodeList.<span class="built_in">size</span>() == capacity) &#123;</span><br><span class="line">			<span class="keyword">auto</span> lastNode = --nodeList.<span class="built_in">end</span>();</span><br><span class="line">			<span class="keyword">int</span> cnt = (*lastNode)[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> value = (*lastNode)[<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> key = (*lastNode)[<span class="number">2</span>];</span><br><span class="line">			<span class="comment">//keyNodeMap：删除这个key</span></span><br><span class="line">			keyNodeMap.<span class="built_in">erase</span>(key);</span><br><span class="line">			<span class="comment">//cntFirstNodeMap：相同则删除，否则不变</span></span><br><span class="line">			<span class="keyword">if</span> (cntFirstNodeMap[cnt] == lastNode) cntFirstNodeMap.<span class="built_in">erase</span>(cnt);</span><br><span class="line">			<span class="comment">//nodeList：删除链表最后一个节点</span></span><br><span class="line">			nodeList.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//插入到 cnt=1 的最前面</span></span><br><span class="line">		<span class="keyword">auto</span> currNode = nodeList.<span class="built_in">end</span>();</span><br><span class="line">		<span class="keyword">if</span> (cntFirstNodeMap.<span class="built_in">count</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">			currNode = cntFirstNodeMap[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> newNode = nodeList.<span class="built_in">insert</span>(currNode, &#123; <span class="number">1</span>, value, key &#125;);</span><br><span class="line">		cntFirstNodeMap[<span class="number">1</span>] = newNode;</span><br><span class="line">		keyNodeMap[key] = newNode;</span><br><span class="line">		<span class="comment">//printAllData(&quot;put(add)&quot;);</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//LFUCache a; </span></span><br><span class="line">	<span class="comment">//定义了构造函数就没有默认构造函数里，在栈上创建出来的对象都有一个名字，比如 stu，使用指针指向它不是必须的。用.调用方法</span></span><br><span class="line">	LFUCache *lFUCache = <span class="keyword">new</span> <span class="built_in">LFUCache</span>(<span class="number">2</span>); <span class="comment">//定义对象</span></span><br><span class="line">	<span class="comment">//通过 new 创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，使用 new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。</span></span><br><span class="line">	lFUCache-&gt;<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">//因为上面定义的指针对象，所以-&gt;，不是指针对象用.</span></span><br><span class="line">	lFUCache-&gt;<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; lFUCache-&gt;<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;  <span class="comment">//key2对应的是1</span></span><br><span class="line">	lFUCache-&gt;<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; lFUCache-&gt;<span class="built_in">get</span>(<span class="number">2</span>) &lt;&lt; endl;  <span class="comment">//1已经被淘汰</span></span><br><span class="line">	cout &lt;&lt; lFUCache-&gt;<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>或是可以维护一个最小频次，每次移除一个节点的时候，需要移除最小频次的节点，每次增加时，也需要更新节点的频次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">get：查询</span></span><br><span class="line"><span class="comment">put：插入、删除</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">哈希表，维护 key，node</span></span><br><span class="line"><span class="comment">哈希表，维护 cnt，firstnode  //cnt是使用次数，firstnode是最久未使用的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由于多个节点的cnt可能相同，因此记录每个cnt的最前方元素节点，保证最久不用的节点依次位于后方</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个链表不需要相连，只是用它的节点</span></span><br><span class="line"><span class="comment">维护一个最小频次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">int</span> frenquency;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value, <span class="keyword">int</span> _frequency) :<span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">frenquency</span>(_frequency)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LFUCache</span>(<span class="keyword">int</span> _capacity) &#123;</span><br><span class="line">		capacity = _capacity;</span><br><span class="line">		minfreq = <span class="number">0</span>;</span><br><span class="line">		frequency_table.<span class="built_in">clear</span>();</span><br><span class="line">		key_table.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">		<span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">auto</span> node = it-&gt;second;</span><br><span class="line">		<span class="keyword">int</span> val = node-&gt;value;</span><br><span class="line">		<span class="keyword">int</span> freq = node-&gt;frenquency;</span><br><span class="line">		<span class="comment">//删除操作</span></span><br><span class="line">		frequency_table[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">		<span class="keyword">if</span> (frequency_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//记录freq频率的双链表没结点了</span></span><br><span class="line">			frequency_table.<span class="built_in">erase</span>(freq);</span><br><span class="line">			<span class="keyword">if</span> (minfreq == freq) minfreq++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//添加结点</span></span><br><span class="line">		frequency_table[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, val, freq + <span class="number">1</span>));</span><br><span class="line">		key_table[key] = frequency_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">		<span class="comment">//key表中找不到值，分缓存满和不满两种情况</span></span><br><span class="line">		<span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//缓存已经满的情况</span></span><br><span class="line">			<span class="keyword">if</span> (key_table.<span class="built_in">size</span>() == capacity)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">auto</span> it2 = frequency_table[minfreq].<span class="built_in">back</span>();</span><br><span class="line">				key_table.<span class="built_in">erase</span>(it2.key);</span><br><span class="line">				frequency_table[minfreq].<span class="built_in">pop_back</span>();</span><br><span class="line">				<span class="keyword">if</span> (frequency_table[minfreq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					frequency_table.<span class="built_in">erase</span>(minfreq);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//两种情况都要添加操作，所以合并在一起</span></span><br><span class="line">			frequency_table[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">			key_table[key] = frequency_table[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">			minfreq = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//如果表中存在，需要更新frequency的值</span></span><br><span class="line">			<span class="keyword">auto</span> node = it-&gt;second;</span><br><span class="line">			<span class="keyword">int</span> freq = node-&gt;frenquency;</span><br><span class="line">			<span class="comment">//删除操作</span></span><br><span class="line">			frequency_table[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">			<span class="keyword">if</span> (frequency_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//记录freq频率的双链表没结点了</span></span><br><span class="line">				frequency_table.<span class="built_in">erase</span>(freq);</span><br><span class="line">				<span class="keyword">if</span> (minfreq == freq) minfreq++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//添加结点</span></span><br><span class="line">			frequency_table[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, freq + <span class="number">1</span>));</span><br><span class="line">			key_table[key] = frequency_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> minfreq;</span><br><span class="line">	<span class="keyword">int</span> capacity;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;&gt;frequency_table;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;::iterator&gt;key_table;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//LFUCache a; </span></span><br><span class="line">	<span class="comment">//定义了构造函数就没有默认构造函数里，在栈上创建出来的对象都有一个名字，比如 stu，使用指针指向它不是必须的。用.调用方法</span></span><br><span class="line">	LFUCache *lFUCache = <span class="keyword">new</span> <span class="built_in">LFUCache</span>(<span class="number">2</span>); <span class="comment">//定义对象</span></span><br><span class="line">	<span class="comment">//通过 new 创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，使用 new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。</span></span><br><span class="line">	lFUCache-&gt;<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">//因为上面定义的指针对象，所以-&gt;，不是指针对象用.</span></span><br><span class="line">	lFUCache-&gt;<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; lFUCache-&gt;<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;  <span class="comment">//key2对应的是1</span></span><br><span class="line">	lFUCache-&gt;<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; lFUCache-&gt;<span class="built_in">get</span>(<span class="number">2</span>) &lt;&lt; endl;  <span class="comment">//1已经被淘汰</span></span><br><span class="line">	cout &lt;&lt; lFUCache-&gt;<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习与深度学习的区别</title>
    <url>/2022/01/09/myblog/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>机器学习—拥有找一个函数的能力，根据输出的不同，分为regression回归、分类classification，以及很少提及的结构化学习structured learning（输出图像，文本）。</p>
<p>1.找一个带有未知参数的函数：y=b+wx，b偏置，w权重，机器学习中，未知的参数是通过数据来学习的。带有未知参数的函数称为model模型。</p>
<p>2.从训练数据中定义Loss（损失），Loss是关于参数b、w的函数，用来判断一组参数值好还是不好。<br>用训练集计算误差，可以是绝对值误差MAE，也可以是均方误差MSE。<br>如果y值是基于概率分布的，一般采取cross-entropy交叉熵，可以绘制误差等高线图error surface。</p>
<p>3.优化，找一组最好的参数w，b使得误差最小。<br>Gradient Descent 梯度下降。举例先只有一个参数w，绘制横坐标为w对应的损失函数曲线，初始时取一个点，随机取的，也可以用遗传算法给出一个较优的模型初始参数。选定一个随机初始值，求该点的偏导值，即该点曲线切线的斜率。然后进行移动点，跨度多少取决于斜率大小，斜率越大，跨度越大，此外，还有一个η，称为learning rate 学习率，自己设定，η越大跨度越大，训练越快。机器学习中需要自己设定的值称为超参数hyperparameters。以此类推，求下一个点下下个点。停止的时机：看预设的迭代次数，或者某一组参数计算出的微分值刚好是0，则停止训练，是个局部最优，不保证全部最优解。</p>
<p>对模型的修改需要对问题的具体理解，考虑前七天比只考虑前一天的误差要小。x是前一天的，y是预测的后一天的。考虑前七天的话，就有七个w。训练数据集是已知的，测试数据集是本来假装不知道的，也就是要预测的y。</p>
<p>输入x乘权重，再加上一个偏置的模型，称为线性模型。</p>
<p>线性模型具有局限性，模型偏差。</p>
<p>有时是分段线性折线函数=常数+一些列的分段斜线。</p>
<p>有时是曲线：可以用分段线性折线逼近连续曲线，需要足够的切分。（也可以用max(0,斜线)叠加表示）</p>
<p>分段斜线可以用sigmoid函数来逼近。</p>
<p><img src="https://img-blog.csdnimg.cn/db4301aa58234ae881c7774fb1472f4f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_18,color_FFFFFF,t_70,g_se,x_16"></p>
<p>改变w，可以改变坡度。改变b可以左右移动。改变c可以改变高度。</p>
<p><img src="https://img-blog.csdnimg.cn/b57fe006fd424401b0976b630ed3331b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>来源：<a href="https://www.bilibili.com/video/BV1qP4y147PJ/?spm_id_from=333.788.recommend_more_video.-1">https://www.bilibili.com/video/BV1qP4y147PJ/?spm_id_from=333.788.recommend_more_video.-1</a></p>
<p>总结来讲：首先选择模型，线性模型或者复杂逼近曲线，最小化损失函数，用梯度下降法，选择初始值迭代计算进行逼近。</p>
<p>Sigmold函数和ReLU在机器学习中，称为激活函数。可以将激活函数过程重复几次，来优化模型。激活函数的部分叫做神经元，很多神经元组成神经网络。每一列神经元称为隐藏层，很多层影藏层形成深度学习。</p>
<p>AlexNet16层。VGG19层。GoogleNet22层。ResidualNet152层。并不是层数越多网络越深预测的效果就更好，会发生过拟合Overfitting。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.8.15 笔试记录</title>
    <url>/2021/08/19/myblog/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/2021.8.15%20%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>1.需要掌握以下图的深度优先遍历</p>
<p>2.信号量上执行正确的PV操作可有效避免多进程并发执行产生的与时间有关的错误。信号量S=0时，表示当前？</p>
]]></content>
      <categories>
        <category>笔经面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招面经</title>
    <url>/2021/10/31/myblog/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h3 id="虾皮-后端-一面-2021-7-18"><a href="#虾皮-后端-一面-2021-7-18" class="headerlink" title="虾皮-后端-一面-2021.7.18"></a>虾皮-后端-一面-2021.7.18</h3><p>1.redis数据类型的底层结构 set<br>2.hashmap底层结构<br>3.c++禁止拷贝构造<br>4.tcp三次握手四次挥手<br>5.四次挥手time_wait机制<br>6.http、ip、dns属于什么层<br>7.cpu调度算法<br>8.linux命令，看文件后几行，日志关键词查询<br>9.进程间通信 信号量<br>10.逻辑地址与物理地址映射<br>11.编程：翻转句子但不翻转单词</p>
<h3 id="字节-商业化后端-一面-2021-7-18"><a href="#字节-商业化后端-一面-2021-7-18" class="headerlink" title="字节-商业化后端-一面-2021.7.18"></a>字节-商业化后端-一面-2021.7.18</h3><p>1.redis分布式锁机制<br>2.redis数据类型使用场景<br>3.hashmap用红黑树优点是什么，map底层数据结构<br>4.vector和list底层实现原理<br>5.互斥锁底层原理，如何实现原子性<br>6.智力题：圆上取三点，构成锐角、直角、钝角三角形的概率？<br>7.编程：合并区间<br>8.编程：最长回文子串</p>
<h3 id="字节-商业化后端-二面-2021-7-18"><a href="#字节-商业化后端-二面-2021-7-18" class="headerlink" title="字节-商业化后端-二面-2021.7.18"></a>字节-商业化后端-二面-2021.7.18</h3><p>1.编程：给定一个多任务场景， 不同任务执行过程中是有相互依赖关系的；<br>输入： n 代表n个任务<br>输出： k代表k个依赖关系<br>输出： n个任务能够完成一次调度执行；<br>提示：用节点的入度，入度为0可以删掉。<br>2.redis如何保证原子性<br>3.redis事务<br>4.mysql避免死锁底层如何实现<br>5.tcp是保序的吗？seq、syn<br>6.五层模型都是干嘛的</p>
<h3 id="商汤scg-三面-2021-7-19"><a href="#商汤scg-三面-2021-7-19" class="headerlink" title="商汤scg-三面-2021.7.19"></a>商汤scg-三面-2021.7.19</h3><p>1.乐观锁的版本号机制如何实现<br>2.redis集群主从同步失败怎么办<br>3.网站打不开的原因，发散<br>4.聚簇索引和非聚簇索引，增量索引？<br>5.编程：岛屿数量<br>6.go结构体嵌套，new操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">type a struct &#123;</span><br><span class="line">    add string</span><br><span class="line">&#125;</span><br><span class="line">type b struct &#123;</span><br><span class="line">    *a</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    b := new(b)</span><br><span class="line">    b.add = &quot;add&quot;</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节-商业化后端-三面-2021-7-20"><a href="#字节-商业化后端-三面-2021-7-20" class="headerlink" title="字节-商业化后端-三面-2021.7.20"></a>字节-商业化后端-三面-2021.7.20</h3><p>1.编程：二叉树转化为双向链表<br>2.智力：老虎吃羊问题<br>3.redis索引原理<br>4.线程池实现考虑什么，伪代码<br>5.c++的锁<br>6.c++管理内存泄漏的方法<br>7.说说智能指针，几种的区别<br>8.单继承和多继承的虚函数表的区别<br>9.多态如何实现<br>10.IO多路复用<br>11.redis持久化</p>
<h3 id="字节-数据中台后端-一面-2021-7-29"><a href="#字节-数据中台后端-一面-2021-7-29" class="headerlink" title="字节-数据中台后端-一面-2021.7.29"></a>字节-数据中台后端-一面-2021.7.29</h3><p>1.redis持久化写硬盘，对内存操作有没有影响？<br>2.写硬盘的方法，怎么最快<br>3.mysql索引底层<br>4.数据库锁<br>5.select * from table where a between 10 and 20 for update；之后再插入一条20-20之间的数据，发生什么？<br>可重复读：不能插，解决了幻读。读未提交，能插入？<br>6.实现strncpy函数<br>7.二分查找<br>8.截断数组的查找</p>
<h3 id="字节-数据中台后端-二面-2021-8-2"><a href="#字节-数据中台后端-二面-2021-8-2" class="headerlink" title="字节-数据中台后端-二面-2021.8.2"></a>字节-数据中台后端-二面-2021.8.2</h3><p>1.redis单线程如何实现的<br>2.http输入url过程<br>3.http和https<br>4.评论系统数据库表设计<br>5.写代码，求一条评论的所有子评论个数<br>6.网络攻击手段，sql注入，怎么防止，把自己套圈子里了</p>
<h3 id="虾皮-后端-二面-2021-8-3"><a href="#虾皮-后端-二面-2021-8-3" class="headerlink" title="虾皮-后端-二面-2021.8.3"></a>虾皮-后端-二面-2021.8.3</h3><p>1.hashtable怎么实现的<br>2.c++ stl用过什么，数组与链表<br>3.二叉树路径-回溯算法<br>4.针对订单的安全id怎么生成</p>
<h3 id="阿里云-后端-二面-2021-8-3"><a href="#阿里云-后端-二面-2021-8-3" class="headerlink" title="阿里云-后端-二面-2021.8.3"></a>阿里云-后端-二面-2021.8.3</h3><p>1.个人云和企业云的区别的看法，toB和toC<br>2.发号器不需要做切流，下线吗？<br>    系统自保、准入条件、云计算：资源的池化、分割售卖、安全隔离、资源隔离、超卖、服务契约<br>3.哈希打散的id怎么生成？<br>4.雪花算法，时间回滚，机器不知道，不能识别，怎么办？<br>5.code：求相对路径</p>
<h3 id="商汤-hr面-2021-8-5"><a href="#商汤-hr面-2021-8-5" class="headerlink" title="商汤-hr面-2021.8.5"></a>商汤-hr面-2021.8.5</h3><p>1.性格缺点<br>2.选择公司最看重什么<br>3.对智慧交通看法</p>
<h3 id="360-后端一面-2021-8-6"><a href="#360-后端一面-2021-8-6" class="headerlink" title="360-后端一面-2021.8.6"></a>360-后端一面-2021.8.6</h3><p>1.平衡二叉树和红黑树，为什么用红黑树<br>2.服务器实例无法访问数据库怎么办，db不能平衡扩展<br>3.编程：扑克牌判断是不是顺子<br>4.udp怎么可靠</p>
<h3 id="虾皮-后端-hr面-2021-8-10"><a href="#虾皮-后端-hr面-2021-8-10" class="headerlink" title="虾皮-后端-hr面-2021.8.10"></a>虾皮-后端-hr面-2021.8.10</h3><p>1.如何看待加班<br>2.评价一下自己，他人眼中的你什么样的<br>3.有什么其他offer或者流程中<br>4.想要什么公司氛围<br>5.想去什么业务<br>6.为啥选后端</p>
<h3 id="腾讯-交通平台产品部-一面-2021-8-10"><a href="#腾讯-交通平台产品部-一面-2021-8-10" class="headerlink" title="腾讯-交通平台产品部-一面-2021.8.10"></a>腾讯-交通平台产品部-一面-2021.8.10</h3><p>1.有啥爱好？？？？？<br>2.推荐悬疑书？？？<br>3.手撕：一个字符串切片成字典里的字符串，回溯<br>4.unordered_set和set区别，实现方面<br>5.c++和go<br>6.set什么语法实现降序</p>
<h3 id="阿里-三面-凉经"><a href="#阿里-三面-凉经" class="headerlink" title="阿里-三面-凉经"></a>阿里-三面-凉经</h3><p>1.做过网络编程没有<br>2.一个程序运行，资源空间如何变化<br>3.拷问项目<br>4.为什么对边缘计算感兴趣<br>5.怎么看边缘计算<br>6.大致觉得没有网络相关的项目，没有可问的，问我自己认为有什么优点<br>7.大佬就是大佬，秒凉</p>
<h3 id="阿里-高德-后端-一面"><a href="#阿里-高德-后端-一面" class="headerlink" title="阿里-高德-后端-一面"></a>阿里-高德-后端-一面</h3><p>1.用过除redis、mysql之外的中间件吗<br>2.mysql innodb为什么用B+树<br>3.redis数据结构底层实现<br>4.redis集群怎么部署<br>5.设计模式了解哪些，平常用的<br>6.zookeeper优缺点<br>7.聚集索引和非聚集索引</p>
<h3 id="网易-AI-c-算法落地-一面"><a href="#网易-AI-c-算法落地-一面" class="headerlink" title="网易-AI-c++算法落地-一面"></a>网易-AI-c++算法落地-一面</h3><p>1.深挖项目<br>2.为什么不用高频？？高频-&gt;波长短-&gt;按说传输距离高，因为频率高衰减大<br>  说成了多普勒，开始深挖多普勒<br>3.手撕：1.最少跳跃次数 （用广度优先，没写过）换：2.最小编辑距离（ac）        </p>
<h3 id="渤海银行-提前批-软开-2021-8-29-笔试准备"><a href="#渤海银行-提前批-软开-2021-8-29-笔试准备" class="headerlink" title="渤海银行-提前批-软开-2021.8.29-笔试准备"></a>渤海银行-提前批-软开-2021.8.29-笔试准备</h3><p>渤海银行成立时间：</p>
<p>渤海企业文化：诚信、远见、开放、创新、关爱</p>
<p>品牌主张：一旦选择,终身相伴</p>
<h3 id="阿里高德-一面-笔试面"><a href="#阿里高德-一面-笔试面" class="headerlink" title="阿里高德-一面-笔试面"></a>阿里高德-一面-笔试面</h3><p>笔试构造什么数据结构，父子结构的，<br>分布式事务<br>CAP原则<br>一致性哈希<br>消息队列<br>限流算法</p>
<h3 id="网易有道AI-c-算法开发工程师-二面"><a href="#网易有道AI-c-算法开发工程师-二面" class="headerlink" title="网易有道AI-c++算法开发工程师-二面"></a>网易有道AI-c++算法开发工程师-二面</h3><p>深挖项目<br>手撕：给一个数组变成偶数位上都是偶数或是奇数位上都是奇数<br>手撕：二叉树回溯，求路径和</p>
<h3 id="阿里-高德-二面-凉经"><a href="#阿里-高德-二面-凉经" class="headerlink" title="阿里-高德-二面-凉经"></a>阿里-高德-二面-凉经</h3><p>上来自己的IDE共享屏幕手撕：多线程输出<br>手撕：最长无重复子串的长度<br>思考：相交链表找相交节点<br>数据库隔离级别如何实现<br>手里的offer，规划之类</p>
<h3 id="阿里-高德-三面"><a href="#阿里-高德-三面" class="headerlink" title="阿里-高德-三面"></a>阿里-高德-三面</h3><p>面试官还不错，上来问我以后用啥语言，跟我讲阿里的java生态<br>思考题：城市有公交站和地铁站，每个站有辐射面积，算城市交通的覆盖率。<br>聊聊面向对象三个特征<br>自己的优缺点<br>平常怎么提高效率的<br>有了解什么新技术吗？面试官讲了一通中国软件界的兼容问题<br>反问：学习java意见<br>1、学语言思想，《深入浅出java虚拟机》《java编程思想》学习语法<br>2、应用，java web spring mvc boot<br>数据库MYbrits，关系型数据库，分布式数据库H-base，分库分表，catch<br>RPC框架，分布式高并发高响应。</p>
<h3 id="渤海-一面"><a href="#渤海-一面" class="headerlink" title="渤海-一面"></a>渤海-一面</h3><p>java垃圾回收，sb了应该说一些的<br>hashmap负载因子<br>hashmap和hashtable<br>数据库存储引擎<br>写代码多少年了<br>redis持久化<br>重载和重写<br>异常处理，catch和finish，蒙了一些</p>
<h3 id="农行-测试-2021-9-13"><a href="#农行-测试-2021-9-13" class="headerlink" title="农行-测试-2021.9.13"></a>农行-测试-2021.9.13</h3><p>三道题，a了一点多道</p>
<h3 id="华为-通信算法-一面-2021-9-13"><a href="#华为-通信算法-一面-2021-9-13" class="headerlink" title="华为-通信算法-一面-2021.9.13"></a>华为-通信算法-一面-2021.9.13</h3><p>全程问项目论文，对于细节问的蛮多<br>本来2点开始，结果2.20才叫面试<br>三点10分还没结束，无奈最后的写一个框图的题写得草率。</p>
<h3 id="华为-通信算法-二面"><a href="#华为-通信算法-二面" class="headerlink" title="华为-通信算法-二面"></a>华为-通信算法-二面</h3><p>论文+项目<br>做一道题，关于似然等概率知识的，都忘光了</p>
<h3 id="华为-通信算法-主管面"><a href="#华为-通信算法-主管面" class="headerlink" title="华为-通信算法-主管面"></a>华为-通信算法-主管面</h3><p>论文，还可以</p>
<h3 id="农行-2021-9-14-凉经"><a href="#农行-2021-9-14-凉经" class="headerlink" title="农行-2021.9.14-凉经"></a>农行-2021.9.14-凉经</h3><p>c++连接数据库的方式<br>c++不能重载的运算符<br>c++创建进程的方式<br>创建线程的类<br>创建线程池的方式</p>
<h3 id="网易-总监面-2021-9-14"><a href="#网易-总监面-2021-9-14" class="headerlink" title="网易-总监面-2021.9.14"></a>网易-总监面-2021.9.14</h3><p>手撕求平方，精确到小数点后10位<br>手撕两个四边形面积的重叠面积/总面积<br>看我的论文？？？</p>
<h3 id="网易-hr面"><a href="#网易-hr面" class="headerlink" title="网易-hr面"></a>网易-hr面</h3><h3 id="阿里-hr面"><a href="#阿里-hr面" class="headerlink" title="阿里-hr面"></a>阿里-hr面</h3><p>介绍个项目，遇到的难点，如何解决<br>遇到过什么困难，如何化解</p>
]]></content>
      <categories>
        <category>笔经面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>实习面经</title>
    <url>/2021/12/29/myblog/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h3 id="阿里云一面"><a href="#阿里云一面" class="headerlink" title="阿里云一面"></a>阿里云一面</h3><p>自我介绍</p>
<p>挑个项目阐述一下，针对项目最难的一个问题，怎么解决的</p>
<p>TCP拥塞控制</p>
<p>100万台服务器找100台CPU利用率最高的</p>
<p>指针和引用的区别</p>
<p>多进程和多线程</p>
<p>100万个数据排序怎么控制内存</p>
<p>Linux熟悉吗</p>
<p>如何解决死锁</p>
<p>如果进来还有什么需要学习的</p>
<p>有什么问题</p>
<h3 id="阿里钉钉一面"><a href="#阿里钉钉一面" class="headerlink" title="阿里钉钉一面"></a>阿里钉钉一面</h3><p>面试官你好，思考了很久。可以用锁，但是平时偏底层的代码基本没写过，所以没写出来。</p>
<ol>
<li>读写锁</li>
</ol>
<p>public static void putIfAbsent(Vector vector, Object object) {<br>    synchronized(vector) {<br>        if (!vector.contains(object)) {<br>            vector.add(object);<br>        }<br>        else {<br>            System.out.println(“The vertor is contains the object of “ + object.toString());<br>        }<br>    }<br>}</p>
<ol>
<li>固定vector大小</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>struct和classs的区别，struct可以多态吗，可以继承吗</p>
</li>
<li><p>c++内存分配，举例</p>
</li>
<li><p>c++新特性</p>
</li>
<li><p>一个数据表如果量非常大，如何处理提高效率。</p>
</li>
<li><p>序列化和反序列化</p>
</li>
<li><p>目标：实现一个线程安全的vector<br>需求：<br>1、类似于std::vector的功能，比如push_back，insert，erase，size，clear，迭代功能等（按照自己的思路提供方法，比如你想提供哪些给别人用，就设计哪些方法）<br>2、要求能多线程安全<br>3、如果能跨平台则加分<br>备注：<br>1、考虑一下性能<br>2、可使用STL vector<br>3、需要单测</p>
<p>//.h内容<br>//.cpp内容</p>
</li>
</ol>
<h3 id="阿里钉钉二面"><a href="#阿里钉钉二面" class="headerlink" title="阿里钉钉二面"></a>阿里钉钉二面</h3><p>1.阐述项目，要比较清晰，半小时</p>
<p>2.静态转换和动态转换</p>
<p>3.c++内存分配，栈分配内存效率为什么高</p>
<p>4.操作系统如何管理内存</p>
<p>5.智能指针</p>
<h3 id="腾讯游戏客户端开发，一面挂"><a href="#腾讯游戏客户端开发，一面挂" class="headerlink" title="腾讯游戏客户端开发，一面挂"></a>腾讯游戏客户端开发，一面挂</h3><p>1.多重继承问题</p>
<p>2.虚析构函数</p>
<p>3.内存对齐问题</p>
<p>4.vector和list差别</p>
<p>5.list删除元素操作</p>
<p>6.erase函数用法</p>
<p>7.物理内存和虚拟内存的辨析</p>
<p>8.tcp和udp，http时tcp还是udp</p>
<h3 id="字节跳动测开面经，1面-2面-3面-hr面"><a href="#字节跳动测开面经，1面-2面-3面-hr面" class="headerlink" title="字节跳动测开面经，1面+2面+3面+hr面"></a>字节跳动测开面经，1面+2面+3面+hr面</h3><p>看了那么多大佬的面经，现在来回馈牛客啦。可能记录不全，当时不会的肯定记得，会的有些忘记了。几次面试问的问题也是有重复的。楼主语言是C++。字节面试体验非常不错。</p>
<p>每一面都有问到项目，跨专业的，跟计算机没啥关系，就不具体说了。</p>
<h4 id="1面，一小时10分钟"><a href="#1面，一小时10分钟" class="headerlink" title="1面，一小时10分钟"></a>1面，一小时10分钟</h4><p>1.线程与进程</p>
<p>2.TCP与UDP</p>
<p>3.指针与引用</p>
<p>4.new和malloc</p>
<p>5.C++与C</p>
<p>6.虚函数</p>
<p>7.浏览器输入URL发生什么</p>
<p>8.数据库三大范式</p>
<p>（一面问的比较八股，都是基础知识，操作系统，计算机网络，数据库都有问到）</p>
<p>9.测试用例设计，微信发朋友圈</p>
<p>10.对测试开发的理解</p>
<p>11.测试方法</p>
<p>手撕代码：有效的IP地址。</p>
<h4 id="2面，一个小时"><a href="#2面，一个小时" class="headerlink" title="2面，一个小时"></a>2面，一个小时</h4><p>1.HTTP和HTTPS</p>
<p>2.端口</p>
<p>3.static几种用法</p>
<p>4.inline内联函数</p>
<p>5.数组的sizeof</p>
<p>6.-1在计算机中是怎么存储的</p>
<p>7.堆和栈</p>
<p>手撕代码：题目忘记了，用排序sort做很简单，但是面试官说超出限制，就让我写了快排。</p>
<h4 id="3面，40分钟"><a href="#3面，40分钟" class="headerlink" title="3面，40分钟"></a>3面，40分钟</h4><p>1.事务</p>
<p>2.刷抖音后面变卡了，找原因</p>
<p>3.有限内存实现大量数据的排序，即外排</p>
<p>4.快排的时间复杂度</p>
<p>5.B+树</p>
<p>6.数据库索引，A索引andB索引能否生效</p>
<p>7.为什么不选开发</p>
<p>8.有哪些offer，在面哪些公司</p>
<p>9.对加班的看法</p>
<p>10.说说自己的优点和缺点</p>
<p>11.实习时间</p>
<p>有点意外，没有手撕代码。而且40分钟结束，楼主本来已经做好了面一个多小时的准备。最后反问的时候才知道这一面是交叉面。</p>
<h4 id="hr面，20分钟"><a href="#hr面，20分钟" class="headerlink" title="hr面，20分钟"></a>hr面，20分钟</h4><p>1.基本情况之类的</p>
<p>2.保研还是考研，本科成绩</p>
<p>3.其他offer</p>
<p>4.面试过程中有啥收获</p>
<p>5.对部门的了解</p>
<p>6.反问实习工资，说有档次？</p>
<p>许愿offer</p>
<h3 id="阿里钉钉二、三面"><a href="#阿里钉钉二、三面" class="headerlink" title="阿里钉钉二、三面"></a>阿里钉钉二、三面</h3><p>没问很多技术的问题，更多的是深挖思考，都是突然袭击。</p>
<p>第一个深挖的点是智能指针</p>
<p>第二个是实现线程安全的vector</p>
<p>手撕代码是字符串问题，不难，但是不能使用容器，有空间复杂度要求。</p>
<h3 id="美团-买菜部门-一面"><a href="#美团-买菜部门-一面" class="headerlink" title="美团-买菜部门-一面"></a>美团-买菜部门-一面</h3><p>美团技术栈是java，会问面试前了解过java吗，这时候即使了解一点点也别说了解，就说没学过，不然会问java的问题，答不上来gg。</p>
<p>HTTP为什么用TCP</p>
<p>HTTP的短连接和长连接，用了什么机制进行改善？</p>
<p>笔试的题目下去有没有再做？</p>
<p>快排时间复杂度是多少，为什么？</p>
<p>线程与进程的区别</p>
<p>多线程，线程安全举例，什么时候需要加锁，为什么加锁，举例</p>
<p>事务的特点</p>
<p>事务的隔离级别</p>
<p>可重复读指什么，怎么实现的？</p>
<p>什么是幻读？</p>
<p>手撕：字母组成的字符串a和字符串b，判断字符串a是否包含字符串b的所有字符，只要包含就行，不需要关心个数。用的26长度的数组代替set判断a中包含哪些字符，然后再遍历b，如果b中字符在数组中显示找不到，则不包含。时间复杂度On^2。</p>
<p>反问：什么部门，新兴部门吗？进去实习做什么？对实习生的培养计划？</p>
<h3 id="阿里-钉钉部门-HR面"><a href="#阿里-钉钉部门-HR面" class="headerlink" title="阿里-钉钉部门-HR面"></a>阿里-钉钉部门-HR面</h3><p>自我介绍</p>
<p>讲一个有挑战的事情</p>
<p>大学有啥实践工作</p>
<p>坚持最久的事情是什么？</p>
<p>在面其他什么公司</p>
<p>反问</p>
<h3 id="百度-C-开发-一面"><a href="#百度-C-开发-一面" class="headerlink" title="百度-C++开发-一面"></a>百度-C++开发-一面</h3><p>C++特点，与C相比，与其他语言相比</p>
<p>C++11新特性</p>
<p>多态，虚函数与纯虚函数</p>
<p>C++内存管理，堆和栈的区别</p>
<p>DNS属于哪一层，原理（不会）</p>
<p>七层模型说一下</p>
<p>数据库存储引擎区别</p>
<p>HTTP状态码各个数字开头代表什么</p>
<p>线程与进程的区别</p>
<p>进程间同步（不会）死锁，如何避免死锁？</p>
<p>Linux用过吗？用过什么指令，查看端口占用的指令用过吗</p>
<p>LInux的IO模型了解吗</p>
<p>手撕：删除链表的倒数第n个节点（1.先算节点个数，再删除。2.双指针，r指针先移动n）</p>
<h3 id="百度-C-二面"><a href="#百度-C-二面" class="headerlink" title="百度-C++-二面"></a>百度-C++-二面</h3><p>项目介绍，项目中的难点</p>
<p>C++虚函数和纯虚函数</p>
<p>C++模板，泛型编程，STL用过什么</p>
<p>多线程和多进程区别，多嘴说了单核多核，问了计算机组成原理的问题，CPU怎么组成的</p>
<p>单核上多线程和多进程区别</p>
<p>C++内存泄漏，如何排查</p>
<p>mysql会到什么程度</p>
<p>线程间通信方式</p>
<p>互斥锁和自旋锁</p>
<p>手撕：二叉树的层序遍历，需要自己构造二叉树。</p>
<h3 id="百度-C-三面"><a href="#百度-C-三面" class="headerlink" title="百度-C++-三面"></a>百度-C++-三面</h3><p>项目介绍</p>
<p>内存泄漏是第三次问了，怎么排查内存泄漏</p>
<p>看过开源的代码吗</p>
<p>问的技术问题不多，而且很多重复的</p>
<p>手撕：给了个中难度的，二叉搜索树，给一个值，返回大于这个值的最小的节点，就是大于这个值，但是最靠近这个值的节点。</p>
]]></content>
      <categories>
        <category>笔经面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>mac安装和配置java环境</title>
    <url>/2021/08/25/myblog/JAVA/MAC%E4%B8%8B%E5%AE%89%E8%A3%85java%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="MAC下java环境安装"><a href="#MAC下java环境安装" class="headerlink" title="MAC下java环境安装"></a>MAC下java环境安装</h1><h2 id="1-下载jdk8并且安装"><a href="#1-下载jdk8并且安装" class="headerlink" title="1.下载jdk8并且安装"></a>1.下载jdk8并且安装</h2><p><code>java -version</code>看一下有没有安装</p>
<p>若没有，<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<h2 id="2-配置java环境"><a href="#2-配置java环境" class="headerlink" title="2.配置java环境"></a>2.配置java环境</h2><p>我们如果要在terminal终端上使JAVA命令，还有让其实应用知道JDK1.8环境的存在，那我们还需要配置系统的环境变量。</p>
<p>访达中，打开资源库，打开java，下面有jdk目录。</p>
<p><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home</code>  右键打开终端</p>
<p>终端运行：<code>sudo vim/etc/profile</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home&quot;</span><br><span class="line">export JAVA_HOME</span><br><span class="line">CLASS_PATH=&quot;$JAVA_HOME/lib&quot;</span><br><span class="line">PATH=&quot;.$PATH:$JAVA_HOME/bin&quot;</span><br></pre></td></tr></table></figure>

<p><code>source /etc/profile  //使配置生效</code></p>
<p><code>echo $JAVA_HOME //得到配置的路径，说明配置成功</code></p>
<h2 id="3-vim一个java程序"><a href="#3-vim一个java程序" class="headerlink" title="3.vim一个java程序"></a>3.vim一个java程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件名需要跟java文件中的类名一致！</span><br><span class="line">public class helloworld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">javac helloworld.java   //生成.class字节码文件</span><br><span class="line">java helloworld    //运行</span><br></pre></td></tr></table></figure>

<h3 id="4-java-IDE"><a href="#4-java-IDE" class="headerlink" title="4.java IDE"></a>4.java IDE</h3><p>官网下载：<a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a></p>
<p>下载破解包，保存在百度云中了。</p>
<p>安装IDEA，在注册页面，选择 Evaluate for free，点击 Evaluate 试用软件</p>
<p>将下载的破解文件夹中的 jetbrains-agent.jar 文件拖动到软件内，然后点击 Restart 重启软件</p>
<p>重启完成之后，如果弹出了激活方式，选择 Activation code，没有弹出则不用管，复制破解文件中的 Activation code，然后选择激活，重启软件</p>
<p>重启软件，在 Get Help 中点击 About ，可以查看激活情况</p>
<p><strong>不得行</strong></p>
<p>更新：<a href="https://www.jianshu.com/p/bbc7cd207a85">https://www.jianshu.com/p/bbc7cd207a85</a></p>
<h3 id="5-用idea的第一个java程序"><a href="#5-用idea的第一个java程序" class="headerlink" title="5.用idea的第一个java程序"></a>5.用idea的第一个java程序</h3><p>![image-20210823173916506](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210823173916506.png)</p>
<p>右键运行。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mac安装和配置maven</title>
    <url>/2021/08/25/myblog/JAVA/MAC%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEMaven/</url>
    <content><![CDATA[<h1 id="MAC安装和配置Maven"><a href="#MAC安装和配置Maven" class="headerlink" title="MAC安装和配置Maven"></a>MAC安装和配置Maven</h1><h2 id="1-Maven简介"><a href="#1-Maven简介" class="headerlink" title="1.Maven简介"></a>1.Maven简介</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">背景：开发A项目，A项目中的一些功能依赖于B项目中的某些类，那么如何维系这种依赖关系？需要用哪个项目中的哪些类，也就是用别人写好了的功能代码，导入jar包即可。所以这里也如此，可以将B项目打成jar包，然后在A项目的Library下导入B的jar文件，这样，A项目就可以调用B项目中的某些类了。如果在开发过程中，发现B中的bug，则必须将B项目修改好，并重新将B打包并对A项目进行重编译操作</span><br></pre></td></tr></table></figure>

<p>Maven是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具。</p>
<p>Maven的核心功能便是合理叙述项目间的依赖关系，通俗点讲，就是通过pom.xml文件的配置获取jar包，而不用手动去添加jar包。</p>
<p>由于Maven仓库中所有的JAR都有其自己的坐标，该坐标告诉Maven它的组ID，构件ID，版本，打包方式等等， 因此Maven项目可以方便的进行依赖版本管理。</p>
<h2 id="2-安装和配置Maven"><a href="#2-安装和配置Maven" class="headerlink" title="2.安装和配置Maven"></a>2.安装和配置Maven</h2><p>下载地址： <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
<p>![image-20210824144100726](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210824144100726.png)</p>
<p>我下载在了<code>/Library/ApacheMaven</code></p>
<p><code>vim ~/.bash_profile</code>  //配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export M=&quot;/Library/ApacheMaven&quot;  //根据自己放在哪个目录</span><br><span class="line">export PATH=&quot;$M/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p><code>source ~/.bash_profile</code>     //使配置生效</p>
<p><code>mvn -v</code>   //查看版本</p>
<p>或者，可以直接<code>brew install maven</code></p>
<h3 id="下载远程仓库到本地"><a href="#下载远程仓库到本地" class="headerlink" title="下载远程仓库到本地"></a>下载远程仓库到本地</h3><p>maven 就像是一个大仓库，里面是很多的jar包，我们需要的时候就去里面拿，所以这就涉及到一个 ‘‘本地仓库’’（不能需要什么再去网上下载吧，速度有时候很慢的）,那么咱们就得先把这些jar包下载到咱们本地方便使用，<br>默认请况下，这个本地仓库会在/user/name/.m2下面（name 是你的用户名）。为了方便，把本地仓库改在Maven安装目录下。</p>
<p>打开安装目录下的conf目录下的<code>settings.xml</code><br>加入<code>&lt;localRepository&gt;/Library/ApacheMaven/repository &lt;/localRepository&gt;</code></p>
<p>输入<code>mvn help:system</code></p>
<p>![image-20210824175620786](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210824175620786.png)</p>
<p>多了一个repository文件夹，这就是咱们从远程仓库下载到本地仓库的文件。</p>
<h2 id="3-创建Maven项目"><a href="#3-创建Maven项目" class="headerlink" title="3.创建Maven项目"></a>3.创建Maven项目</h2><h3 id="a-使用命令行创建Maven项目"><a href="#a-使用命令行创建Maven项目" class="headerlink" title="a.使用命令行创建Maven项目"></a>a.使用命令行创建Maven项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=cn.xuanliu.helloword -DartifactId=helloworld -Dpackage=cn.cxuanliu.helloword -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-quickstart</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mvn</code>:表示使用的是maven命令。</li>
<li><code>archetype:generate</code>:表示使用generate这个插件为我们的maven项目自动生成一个maven骨架，即我们项目的工程结构。后边跟的是该插件为我们创建工程结构所需要的一连串的参数。</li>
<li><code>-DgroupId</code>:标识项目的坐标元素之一，项目包名，可以是：域名的反写+项目名。</li>
<li><code>-DartifactId</code>:标识项目的坐标元素之一，它的值为我们的项目名。我这里指定我要生成的项目名为helloword。</li>
<li><code>-Dpackage</code>:标识项目的坐标元素之一,这里值就跟DgroupId的值保持一致即可。此属性在命令行中可选。</li>
<li><code>-Dversion</code>:指定版本号。此属性在命令行中可选</li>
<li><code>-DarchetypeArtifactId</code>:表示我们生成的工程结构为哪一种，这里的属性值为<code>maven-archetype-quickstart</code>表示生成工程目录结构为quickstart的结构。其值还可以为<code>maven-archetype-webapp</code>表示生成的工程目录结构为webapp的结构。</li>
</ul>
<p>![image-20210824155803431](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210824155803431.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目录解读：在maven项目的开发中，所有的源代码放在文件夹 /src/main/java/下, 所有的单元测试代码放入 /src/test/java/。</span><br><span class="line">pom.xml 描述了整个项目的信息</span><br></pre></td></tr></table></figure>

<h3 id="b-使用IDEA创建Maven项目"><a href="#b-使用IDEA创建Maven项目" class="headerlink" title="b.使用IDEA创建Maven项目"></a>b.使用IDEA创建Maven项目</h3><p><code>Create New Project</code>，选择<code>Maven</code>，勾选<code>Create from archetype</code></p>
<p><img src="https://img2018.cnblogs.com/blog/1068501/201809/1068501-20180914191722384-1695467171.png" alt="img"></p>
<p>写<code>Maven</code>的坐标，“groupId”，“artifactId”，以及“version”，其中groupId是公司域名的反写，而artifactId是项目名或模块名，version就是该项目或模块所对应的版本号。</p>
<p>![image-20210824174243856](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210824174243856.png)</p>
<p>![image-20210824180029943](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210824180029943.png)</p>
<p>maven会自动下载maven依赖，当所有的都自动完成后，创建的maven项目结构如下所示： </p>
<p>![image-20210824180441439](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210824180441439.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）在大多数情况下，把项目的主代码放到 src/main/java 目录下（遵循Maven约定），如果没有其他的配置，Maven在运行时将自动搜寻该目录下的主代码。</span><br><span class="line">（2）为了使项目的结构保持清晰，所以IDEA自动创建了 test 文件，将主代码和测试代码分别放到了独立的目录中。</span><br><span class="line">（3）pom.xml为Maven的核心配置文件，它的全称为（Project Object Model，项目对象模型），我们在使用Maven的时候也通常在这个pom .xml 中配置。</span><br></pre></td></tr></table></figure>

<h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml:"></a>pom.xml:</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>    <span class="comment">&lt;!-- xml头，指定xml文档的版本信息和编码方式 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;project&gt;为所有pom.xml的根元素，声明了一些POM相关的命名空间及xsd元素，</span></span><br><span class="line"><span class="comment">  这些元素不是pom.xml中必须添加的，但是使用这些属性可以使第三方工具，</span></span><br><span class="line"><span class="comment">  如IDE中的xml编辑器帮助开发者快速编辑POM。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;modeVersion&gt; 指定了当前POM模板的版本 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liuxuan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="comment">&lt;!-- &lt;groupId&gt; 定义了该项目属于哪个项目组 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ideamaven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   <span class="comment">&lt;!-- &lt;&lt;artifactId&gt;定义了当前Maven项目在项目组的唯一一个ID,项目名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="comment">&lt;!--&lt;version&gt;定义了Hello Maven项目当前的版本号 1.0-SNAPSHOT 为IDEA默认的初始版本号 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>在没有实际的java代码时，我们就可以完整的创建一个Maven项目的pom.xml，这说明了Maven可以使项目对象模型最大程度的与代码相独立，这充分体现了解耦的原则和理念！为开发者节省了时间，大大缩短了项目开发周期。在项目开发到稳定期时，升级版本时，开发者可以不需要修改实际的 java 代码，而是只修改pom.xml，这一特点使Maven被广泛的使用。</p>
<h2 id="4-编写主代码"><a href="#4-编写主代码" class="headerlink" title="4.编写主代码"></a>4.编写主代码</h2><p><strong>项目主代码和测试代码不同，主代码会被打包到最终的构件中，而测试代码只在运行测试时用到，不会被打包。</strong></p>
<p><strong>在src/main/java中创建文件com/feiyu/web/helloworld/helloWorld.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello liuxuan&#x27;s Maven!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> hello().sayHello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右键运行。</p>
<p>目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---pom.xml　　　　核心配置，项目根下</span><br><span class="line">---src</span><br><span class="line">　　---main　　　　　　</span><br><span class="line">　　　   ---java　　　　java源码目录</span><br><span class="line">　　     ---resources　  java配置文件目录</span><br><span class="line">　　---test</span><br><span class="line">　　　　　---java　　　　测试源码目录</span><br><span class="line">　　　　　---resources　  测试配置目录</span><br><span class="line">---target    输出目录</span><br></pre></td></tr></table></figure>

<h2 id="5-Maven仓库"><a href="#5-Maven仓库" class="headerlink" title="5.Maven仓库"></a>5.Maven仓库</h2><p>Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。</p>
<p>Maven 仓库有三种类型：</p>
<ul>
<li>本地（local）</li>
<li>中央（central）</li>
<li>远程（remote）</li>
</ul>
<h3 id="a-本地仓库"><a href="#a-本地仓库" class="headerlink" title="a.本地仓库"></a>a.本地仓库</h3><p>第一次执行 maven 命令的时候才被创建。运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</p>
<p>默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/respository/ 的仓库目录。</p>
<p>可以修改默认位置，改变settings.xml中的配置。<br><code>&lt;localRepository&gt;C:/MyLocalRepository&lt;/localRepository&gt;</code></p>
<h3 id="b-中央仓库"><a href="#b-中央仓库" class="headerlink" title="b.中央仓库"></a>b.中央仓库</h3><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。</p>
<p>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。</p>
<p>中央仓库的关键概念：</p>
<ul>
<li>这个仓库由 Maven 社区管理。</li>
<li>不需要配置。</li>
<li>需要通过网络才能访问。</li>
</ul>
<p>要浏览中央仓库的内容，maven 社区提供了一个 URL：<a href="http://search.maven.org/#browse%E3%80%82%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%EF%BC%8C%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%8F%AF%E4%BB%A5%E6%90%9C%E7%B4%A2%E6%89%80%E6%9C%89%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BA%93%E3%80%82">http://search.maven.org/#browse。使用这个仓库，开发人员可以搜索所有可以获取的代码库。</a></p>
<h3 id="c-远程仓库"><a href="#c-远程仓库" class="headerlink" title="c.远程仓库"></a>c.远程仓库</h3><p>中央仓库是一些常用的库？远程仓库是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p>
<h3 id="d-Maven依赖搜索顺序"><a href="#d-Maven依赖搜索顺序" class="headerlink" title="d.Maven依赖搜索顺序"></a>d.Maven依赖搜索顺序</h3><ul>
<li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li>
<li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li>
<li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li>
<li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li>
</ul>
<h3 id="e-更换Maven阿里云仓库"><a href="#e-更换Maven阿里云仓库" class="headerlink" title="e.更换Maven阿里云仓库"></a>e.更换Maven阿里云仓库</h3><p>Maven根目录下，conf文件夹下setting.xml文件，mirrors节点上修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">  &lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">  &lt;/mirror&gt;</span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：pom.xml文件里添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;repositories&gt;  </span><br><span class="line">        &lt;repository&gt;  </span><br><span class="line">            &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">            &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  </span><br><span class="line">            &lt;releases&gt;  </span><br><span class="line">                &lt;enabled&gt;true&lt;/enabled&gt;  </span><br><span class="line">            &lt;/releases&gt;  </span><br><span class="line">            &lt;snapshots&gt;  </span><br><span class="line">                &lt;enabled&gt;false&lt;/enabled&gt;  </span><br><span class="line">            &lt;/snapshots&gt;  </span><br><span class="line">        &lt;/repository&gt;  </span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6-Maven命令"><a href="#6-Maven命令" class="headerlink" title="6.Maven命令"></a>6.Maven命令</h2><p><code>maven -version   Maven版本及控制信息</code></p>
<p><code>mvn archetype:create  -DgroupId=   DartifactId=   构建java项目</code>   </p>
<p><code>mvn archetype:create  -DgroupId=   DartifactId=   -DarchetypeArtifactId=maven-archetype-webapp ls创建web项目</code></p>
<p><code>mvn compile     编译源代码</code>     </p>
<p><code>mvn test-compile    编译测试代码</code></p>
<p><code>mvn clean   打包前清理掉之前有过打包的文件夹target</code></p>
<p><code>mvn package  打包，package包括了编译、打包这两步</code>    </p>
<p>![image-20210825113016694](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210825113016694.png)</p>
<p><code>mvn install   将打包好的jar包部署到本地，放到本地仓库</code> </p>
<h2 id="7-运行jar包"><a href="#7-运行jar包" class="headerlink" title="7.运行jar包"></a>7.运行jar包</h2><p><code>java -jar ideamaven-1.0-SNAPSHOT.jar</code></p>
<p>问题：<code>ideamaven-1.0-SNAPSHOT.jar中没有主清单属性</code></p>
<p>解决：找不到<code>main</code>方法，需要在<code>pom.xml</code>配置<code>main</code>方法的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--  添加main方法   --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2.1&lt;/version&gt;</span><br><span class="line">  &lt;executions&gt;</span><br><span class="line">    &lt;execution&gt;</span><br><span class="line">      &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">      &lt;goals&gt;</span><br><span class="line">        &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">      &lt;/goals&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;transformers&gt;</span><br><span class="line">          &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">            &lt;!-- 在这里指定入口类 --&gt;</span><br><span class="line">            &lt;mainClass&gt;com.liuxuan.hello&lt;/mainClass&gt;</span><br><span class="line">          &lt;/transformer&gt;</span><br><span class="line">        &lt;/transformers&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/execution&gt;</span><br><span class="line">  &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p>mvn打包和jar包运行问题未解决。</p>
<p>问题：<code>Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.8.0:compile (default-compile) on project ideamaven: Compilation failure</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://console.cloud.baidu-int.com/devops/icode/repos/baidu/netdisk/platform-idproducter/reviews/18480257/files/base...latest/service/create_service.go">https://console.cloud.baidu-int.com/devops/icode/repos/baidu/netdisk/platform-idproducter/reviews/18480257/files/base...latest/service/create_service.go</a></p>
<p><a href="https://blog.csdn.net/wfy2695766757/article/details/81189291">https://blog.csdn.net/wfy2695766757/article/details/81189291</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>spring入门案例</title>
    <url>/2021/08/25/myblog/JAVA/Spring%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="Spring入门案例"><a href="#Spring入门案例" class="headerlink" title="Spring入门案例"></a>Spring入门案例</h1><h2 id="0-java基础"><a href="#0-java基础" class="headerlink" title="0.java基础"></a>0.java基础</h2><h3 id="a-java版本"><a href="#a-java版本" class="headerlink" title="a.java版本"></a>a.java版本</h3><p>Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。</p>
<p>Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。</p>
<blockquote>
<p>Java的三个版本 : JAVASE(标准版),JAVAEE(企业版),JAVAME(微型版).</p>
<p>java是一个平台。他包括了，java语言，java开发环境(jdk)。java有三个版本<br>j2se(标准版),j2ee(企业版),j2me(微型版)<br>不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。<br>j2EE是java的企业级开发版本，其实换句话说就是用来做web开发的java框架。javaEE通过设定统一的标准来解决web开发的问题，javaEE的接口，抽象类，规定了web开发所需要实现的流程。整个web的开发，有2层，第1层是服务器容器，比如tomcat，weblogic。他们在javaEE的规范下，实现套接字的连接，封装消息等等，第2层是业务，而这一层是你要做的，通过tomcat封装的消息，进行相应的业务处理。服务器容器的开发由大型的产商开发，而我们通常做的开发是在服务器容器上的业务开发，正是sun的javaEE统一了规范(比如用servlet)我们的业务代码，能和comcat进行很好的通讯。</p>
</blockquote>
<p>J2SE是标准版本，J2ME是手机方向的，J2EE是网站开发方向的。</p>
<blockquote>
<p>从JDK 5.0开始 J2EE 改名为 java EE，J2SE 改名为 java SE，J2ME 改名成 java ME.java EE 是java的企业版，主要面向web应用，尤其是企业级开发</p>
</blockquote>
<h3 id="b-jdk版本"><a href="#b-jdk版本" class="headerlink" title="b.jdk版本"></a>b.jdk版本</h3><p>Java Development Kit（JDK）是太阳微系统针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。</p>
<p>作为Java语言的SDK，普通用户并不需要安装JDK来运行Java程序，而只需要安装JRE（Java Runtime Environment）。而程序开发者必须安装JDK来编译、调试程序。</p>
<p>JDK是个Java开发的工具包，Java是门编程语言。</p>
<p>JDK8或者JDK1.8是由于自从JDK1.5/JDK5命名方式改变后遗留的新旧命令方式问题。所以JDK8或者JDK1.8也是同一个东西。</p>
<blockquote>
<p>JDK1.4 正则表达式，异常链，NIO，日志类，XML解析器，XLST转换器<br>JDK1.5 自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环<br>JDK1.6 提供动态语言支持、提供编译API和卫星HTTP服务器API，改进JVM的锁，同步垃圾回收，类加载<br>JDK1.7 提供GI收集器、加强对非Java语言的调用支持（JSR-292,升级类加载架构<br>JDK8 Lambda 表达式、方法引用、默认方法、新工具、Stream API、Date Time API 、Optional 类、Nashorn, JavaScript 引擎<br>JDK9 1、集合加强；2、私有接口方法；3、垃圾收集机制；4、I/O流加强；5、JShell工具<br>JDK10 1、局部变量类型推断；2、线程本地握手；3、GC改进和内存管理；<br>JDK11 1、字符串加强；2、HttClient Api；3、用于 Lambda 参数的局部变量语法；4、ZGC<br>JDK12 1、Switch Expressions；2、Shenandoah GC；<br>JDK13 1、switch优化更新；2、文本块升级；3、重新实现旧版套接字API；4、核心库/java.util中：I18N；5、取消使用未使用的内存<br>JDK14 1、switch优化变更为最终版；2、垃圾回收相关；3、instanceof的模式匹配（预览版）；4、删除了安全库java.security.acl API；5、货币格式（优化）<br>JDK15</p>
</blockquote>
<h2 id="1-Spring简介"><a href="#1-Spring简介" class="headerlink" title="1.Spring简介"></a>1.Spring简介</h2><p>Spring是一个开源框架，Spring是2003年兴起的轻量级java开发框架，它是为了解决企业级开发的复杂性而创建的。Spring的用途不仅限于服务器端的开发，从简单性、可测试性、低耦合的角度而言任何java应用都可以在spring中受益。</p>
<p>简单的来说Spring就是轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。</p>
<blockquote>
<p>javaBean：<br>符合一定规范编写的Java类，不是一种技术，而是一种规范。针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其他的程序员或者框架使用。这些约定包括：getXXX，setXXX，isXXX，addXXX。</p>
</blockquote>
<h3 id="Spring解决什么："><a href="#Spring解决什么：" class="headerlink" title="Spring解决什么："></a>Spring解决什么：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当客户端向服务器发出请求时，服务器把得到的请求发送给控制器Servlet，而在Servlet中需要创建Service对象来调用业务层相关功能(故说控制器层Servlet依赖于业务层Service),而在Service中又需要创建数据库层DAO对象来对数据库进行操作(故说业务层Service依赖于数据库层DAO)。</span><br><span class="line"></span><br><span class="line">针对上述问题，需要考虑：1.Servlet、Service以及Dao对象的创建时间、创建数量。2.Servlet、Service以及Dao之间的依赖关系。</span><br><span class="line"></span><br><span class="line">spring：</span><br><span class="line">用来处理对象的创建、以及对象之间依赖关系的一个开发框架。它打破了我们传统开发的观念，我们不再需要像以前那样在具体的类中创建具体的对象，而是将对象的创建交给它去完成。</span><br></pre></td></tr></table></figure>

<p>非侵入式设计：引入了框架，对现有的类结构没有影响。</p>
<h3 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h3><p>Inversion On Control，简称IOC。对象的创建交给外部容器自动完成，这个就叫做控制反转。(有控制反转就有控制正转，控制正转:对象的创建由我们自己创建)</p>
<p>依赖注入dependency injection,简称DI，用于处理对象间的依赖关系。</p>
<p><strong>二者区别:</strong><br>控制反转(IOC):解决对象创建的问题，(对象的创建交给别人)。<br>依赖注入(DI):在创建完对象后，对象关系的处理就是依赖注入，(通过set方法依赖注入。)</p>
<h3 id="AOP面向切面"><a href="#AOP面向切面" class="headerlink" title="AOP面向切面"></a>AOP面向切面</h3><p>面向切面编程。切面，简单来说可以理解为一个类，由很多重复代码形成的类。切面举例:事务、日志、权限。</p>
<h2 id="2-Mac下spring配置"><a href="#2-Mac下spring配置" class="headerlink" title="2.Mac下spring配置"></a>2.Mac下spring配置</h2><p>配置Spring不管在哪个环境下都是大同小异，下载Spring-framework，解压缩，然后导入使用的项目即可。</p>
<p>spring3.x与jdk1.7兼容，spring4.x与jdk1.8才兼容，IDEA默认下的JDK使用1.8版本。</p>
<blockquote>
<p>直接通过IDEA创建项目选择spring模版<br>发现：没有spring模板，打开设置-&gt;plugins-&gt;搜索spring assistant-&gt;安装后重启</p>
<p>依然没有，没法了</p>
</blockquote>
<p>![image-20210825183129555](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210825183129555.png)</p>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>Spring Boot 是 Pivotal 团队在 Spring 的基础上提供的一套全新的开源框架，其目的是为了简化 Spring 应用的搭建和开发过程。Spring Boot 去除了大量的 XML 配置文件，简化了复杂的依赖管理。</p>
<p>Spring Boot 具有 Spring 一切优秀特性，Spring 能做的事，Spring Boot 都可以做，而且使用更加简单，功能更加丰富，性能更加稳定而健壮。随着近些年来微服务技术的流行，Spring Boot 也成了时下炙手可热的技术。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》面向对象</title>
    <url>/2021/11/08/myblog/JAVA/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B/</url>
    <content><![CDATA[<h2 id="Java开发入门"><a href="#Java开发入门" class="headerlink" title="Java开发入门"></a>Java开发入门</h2><p>Java是由Sun公司于1995年开发的可编写跨平台应用软件、完全面向对象的程序设计语言。2009年被Oracle公司收购。</p>
<h3 id="Java三个技术平台"><a href="#Java三个技术平台" class="headerlink" title="Java三个技术平台"></a>Java三个技术平台</h3><p>针对不同的开发市场，Sun公司将Java划分为三个技术平台。</p>
<p>（1）Java SE：（standard edition）Java平台标准版，为开发普通桌面和商务应用程序提供的解决方案，是三个平台中最核心的部分，Java EE和Java ME都是从Java SE的基础上发展而来，Java SE包括Java最核心的类库，如集合、IO、数据库连接及网络编程。</p>
<p>（2）Java EE：（enterprise edition）平台企业版，为开发企业级应用程序提供的解决方案，包括Servlet、JSP、JavaBean、EJB、Web Service等。用来做web开发的java框架。</p>
<p>（3）Java ME：（micro edition）平台微型版，为开发电子消费产品和嵌入式设备提供的解决方案，用于微型数字电子设备上软件程序的开发，例如家用电器增加智能化控制和联网功能，未手机增加游戏和通讯录管理功能。此外，还提供HTTP等协议，为移动电话提供Client/Server方式访问Internet，提供无线交流。</p>
<p>不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。</p>
<p>J2SE是标准版本，J2ME是手机方向的，J2EE是网站开发方向的。</p>
<h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><ul>
<li>简单易用：丢弃了c++中的：操作符重载、多继承、自动强制类型转换、不使用指针而是引用，提供自动分配和回收内存空间。</li>
<li>安全可靠：Java通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。</li>
<li>跨平台：通过JVM虚拟机在不同的操作系统上允许Java程序。</li>
<li>面向对象：将一切事物都看成对象，类、接口、继承。只支持类之间的单继承，支持接口之间的多继承，支持类与接口之间的实现机制（implements）。java全面支持动态绑定，c++只对虚函数使用动态绑定。</li>
<li>支持多线程：内置了多线程控制，可使用户程序并发执行。</li>
</ul>
<h3 id="JDK-gt-JRE-gt-JVM"><a href="#JDK-gt-JRE-gt-JVM" class="headerlink" title="JDK&gt;JRE&gt;JVM"></a><strong>JDK&gt;JRE&gt;JVM</strong></h3><p><strong>JVM</strong> ：（Java Virtual Machine）， Java 虚拟机。它只认识 xxx.class 类型的文件，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。jvm 是 Java 能够跨平台的核心。</p>
<p><strong>JRE</strong> ：（Java Runtime Environment），Java 运行时环境。主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。普通用户只需要JRE进行运行已经编译好的java程序，而不需要开发。</p>
<p><strong>JDK</strong> ：（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe（编译 java 源码的编译器 javac），java.exe（java运行工具），jar.exe（java打包工具），java文档生成工具 等很多 java 程序调试和分析的工具。</p>
<p>1996年推出jdk1.0，随后到1.5改变命名方式，jdk1.5=jdk5.2017年jdk9，2018年jdk10.但是并不稳定。目前最多运用jdk8.</p>
<p>安装jdk时，安装开发工具（包括javac.exe、java.exe等，以及一个专用JRE环境），源代码（Java所有核心类库的源代码），公共JRE相当于多装一个JRE在其他路径，所以不需要。</p>
<p>JDK=JRE(JVM+JAVA基本类库)+开发工具</p>
<h3 id="JDK目录"><a href="#JDK目录" class="headerlink" title="JDK目录"></a>JDK目录</h3><ul>
<li>bin目录：存放一些可执行程序，如javac.exe（java编译器）、java.exe（java运行工具）、jar.exe（打包工具）、javadoc.exe（文档生成工具）等。</li>
<li>db目录：纯java实现的支持JDBC4.0所有规范的小型数据库。</li>
<li>include目录：由于JDK是通过C和C++实现的，因此在启动时引入一些C语言的头文件，该目录就是存放这些头文件的。</li>
<li>jre目录：Java运行时环境的根目录，，包括java虚拟机、运行时的类包、java应用启动器以及一个bin目录，不包括开发环境中的开发工具。</li>
<li>lib目录：java类库或库文件，是开发工具使用的归档包文件。</li>
</ul>
<blockquote>
<p>javac.exe：编译器工具，将java文件编译成可执行的java字节码文件.class</p>
<p>java.exe：java运行工具，会启动一个java虚拟机进程，专门负责运行字节码文件</p>
</blockquote>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>目的：在任何位置都能够编译和运行java程序。</p>
<p>配置：PATH：用于告知操作系统去指定路径寻找JDK，CLASSPATH：告知JDK去指定路径查找类文件(.class文件)</p>
<p>当在命令窗口中运行一个可执行文件时，操作系统首先会在当前目录下寻找是否存在该文件，如果不存在，会在PATH环境变量中定义的路径下寻找这个文件。</p>
<h3 id="java运行机制"><a href="#java运行机制" class="headerlink" title="java运行机制"></a>java运行机制</h3><p>.java文件，</p>
<p>使用javac.exe即java编译器进行编译，</p>
<p>.class文件，</p>
<p>使用java命令开启Java虚拟机运行程序，java虚拟机首先将编译好的字节码文件加载到内存（类加载，由类加载器完成），然后虚拟机通过java解析器对加载到内存中的java类进行解释执行，</p>
<p>机器码文件，</p>
<p>计算机运行机器码文件。</p>
<blockquote>
<p>java程序是由java虚拟机负责解释执行的，而不是操作系统，因此跨平台。</p>
</blockquote>
<h3 id="类包"><a href="#类包" class="headerlink" title="类包"></a>类包</h3><p>import导包：import 包名.类名  /  import 包名.*</p>
<p>java的核心类主要放在java包及其子包下。java扩展的大部分类在javax包及其子包下。</p>
<p>java.util：java的大量工具类、集合类，如Arrays、List、Set等</p>
<p>java.net：java网络编程相关的类和接口</p>
<p>java.io：java输入输出相关类和接口</p>
<p>java.awt：构建图形界面GUI的类和接口</p>
<p>java.sql：数据库编程</p>
<h2 id="Java编程基础"><a href="#Java编程基础" class="headerlink" title="Java编程基础"></a>Java编程基础</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行//  多行/*  */</p>
<p>文档注释：对某个类或类中的方法进行系统性解释说明。开发人员可使用JDK提供的javadoc工具将文档注释提取出来生成一份API帮助文档。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*  content</span><br><span class="line">*  content</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>包名：一律小写<br>类名、接口名：首字母大写<br>常量名：都大写下划线连接<br>变量名和方法名：一个单词首字母小写，后面首字母大写</p>
<h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>八种基本数据类型：<br>byte：是8位、有符号的，以二进制补码表示的整数；-128~127；<br>short：16位<br>int：32位<br>long：64位，所赋的值超过int的取值范围，则需要加L，long num=10000000L;<br>float：单精度32位，小数默认为double类型，因此定义float型需要在后面加f/F<br>double：双精度64位<br>boolean：布尔<br>char：字符，2个字节</p>
<p>引用数据类型：<br>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型。<br>所有引用类型的默认值都是null，表示没有指向任何对象。</p>
<p><code>char c=&#39;a&#39;</code> 和 <code>char c=97</code>一样。因为可以将char变量赋值为0-65535范围内的整数，计算机将整数自动转化为对应的字符。</p>
<h3 id="变量的类型转换"><a href="#变量的类型转换" class="headerlink" title="变量的类型转换"></a>变量的类型转换</h3><p>（1）自动类型转换（隐式类型转换）：将一个类型取值范围小的数值直接赋值给另一个取值范围大的数据类型变量。大壶装小壶。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte b=3;</span><br><span class="line">int x=b;</span><br><span class="line">double y=x;</span><br></pre></td></tr></table></figure>

<p>（2）强制类型转换（显式类型转换）：目标类型取值范围小于源类型。小壶装大壶。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte a;</span><br><span class="line">int b=298;</span><br><span class="line">a=(byte)b;   //结果a会变成42</span><br></pre></td></tr></table></figure>

<p>强制类型转换中可能丢失精度，例如int占用4个字节，而byte占用1个字节，298变二进制后只留下最低的八位。</p>
<p>（3）表达式类型自动提升：byte、short、char类型的变量在运算期间类型会自动提示为int类型，然后进行运算，因此在最后获得结果时需要强制类型转换。</p>
<p>（4）在使用+=、-=、*=等运算符时，强制类型转换会自动完成。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>整形常量：二进制0b/0B开头，八进制0开头，十六进制0x/0X开头。</p>
<p>null：表示对象的引用为空。</p>
<p>需要用final关键字定义常量：<br><code>final int a=0</code></p>
<p>转义符<br>\r  回车符<br>\n  换行符<br>\t  制表符<br>\b  退格符，backspace<br>\后加&#39;或&quot;或\表示本身</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选，可以不break而继续执行。</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选，最后才看</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义的三种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">剖析：<span class="keyword">int</span>[] nums;  nums变量的类型是<span class="keyword">int</span>[]。</span><br><span class="line">nums会占用一块内存单元，nums=<span class="keyword">new</span> <span class="keyword">int</span>[]; 表示创建数组，并将数组的内存地址赋值给变量nums。在程序运行期间可以用变量nums来引用数组.</span><br></pre></td></tr></table></figure>

<p>多维数组：<code>String[][] str = new String[3][4];</code></p>
<p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>对数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">Arrays.sort(arr,<span class="number">1</span>,<span class="number">4</span>);  左闭右开</span><br></pre></td></tr></table></figure>

<h2 id="面向对象（上）"><a href="#面向对象（上）" class="headerlink" title="面向对象（上）"></a>面向对象（上）</h2><p>面向对象是把构成问题的事物按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。</p>
<p>封装：将对象的属性和行为封装起来。</p>
<p>继承：描述类与类之间的关系，使得无须重新编写原有类的情况下对原有类的功能进行扩展。</p>
<p>多态：一个类中定义的属性和功能被其他类继承后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现出的多种不同行为特征。</p>
<p>类是对象的抽象，共同特征作为属性（成员变量），共同行为作为类的方法（成员方法）。对象是类的实例。</p>
<p>创建对象：<code>Person p=new Person();</code></p>
<p>第一步：<code>Person p;</code> 声明一个Person类型的变量p</p>
<p>第二步：<code>=new Person();</code>创建Person对象，并将Person对象在内存中的地址赋值给变量p，这样变量p便持有了对象的引用。</p>
<p>内存中，p变量存对象的地址，在栈内存，p是一个引用，指向真正的对象。对象创建在堆内存。</p>
<blockquote>
<p>栈内存：存放基本类型的变量和对象的引用变量。</p>
<p>堆内存：存放new创建的对象和数组。</p>
</blockquote>
<p>创建好对象后，可以通过对象的引用来访问对象的所有成员。对象引用.对象成员</p>
<p>也可以使用创建的对象本身来引用对象成员：<code>new Person().成员</code>。由于没有对象引用的存在，在完成一个对象成员的访问后，该对象变成垃圾对象。<strong>当对象没有被任何变量所引用就会变成垃圾。</strong></p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>访问控制级别由小到大：private→default→protected→public</p>
<ul>
<li>private（当前类访问级别）：该成员只能被该类的其他成员访问，其他类无法直接访问。</li>
<li>default（包访问级别）：不使用任何访问控制修饰符的话，就是default，表示这个类或者类的成员只能被本包中的其他类访问。</li>
<li>protected（子类访问级别）：成员能被同一包内的其他类访问，也能被不同包下该类的子类访问。</li>
<li>public（公共访问级别）：该类或类的成员能被所有的类访问，不管是否在同一包中。</li>
</ul>
<blockquote>
<p>如果一个java源文件中定义的所有类都没有public修饰符，那么这个源文件的文件名可以是一切合法的文件名。</p>
<p>如果java源文件中定义了一个public修饰的类，则源文件名必须与public修饰的类的类名一致。</p>
</blockquote>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类的封装，是指将对象的属性隐藏在对象内部，设为private级别，不允许外部程序直接访问对象的内部信息，而通过类内public的方法（setxxx，getxxx）实现对内部信息的操作及访问。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>在实例化对象的同时为这个对象的属性进行赋值，可以通过构造方法来实现。</p>
<p>构造方法需要满足的三个条件：方法名与类名相同、在方法名的前面没有返回值类型的声明、方法中不能使用return返回一个值但是可以单独return来结束方法。</p>
<p>构造方法的重载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line">    TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java中每个类都至少有一个构造方法，如果一个类中没有显示地定义构造方法，系统会自动为这个类创建一个无参构造方法。但是一旦自己定义了有参的构造方法，系统将不再提供无参的构造方法。</p>
<blockquote>
<p>疑问：构造方法用来在实例化对象的时候为对象的成员变量赋值，而在定义类的时候，可以声明变量（不赋值）也可以定义变量（赋值），那么定义了变量之后，实例化对象，是给对象的成员赋初值了吗？应该是吧</p>
</blockquote>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>关键字this用来指代当前对象，用来在方法中访问对象的其他成员。</p>
<ul>
<li>通过this关键字调用成员变量，解决与局部变量名称冲突的问题。</li>
<li>通过this关键字调用成员方法。</li>
<li>通过this关键字调用构造函方法，构造方法是在实例化对象时被java虚拟机自动调用的，但是可以<strong>在一个构造方法中</strong>用<code>this(参数);</code>的形式来调用其他的构造方法。注意：只能在构造方法中用，且必须是构造方法中的第一条语句，且只能出现一次，而且不能在两个构造方法中相互调用。</li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>（1）静态变量</p>
<p>类内的数据成员被一个类的所有实例对象所共享时使用，例如学校学生的学校名。不必要在每个对象占用的空间中都声明这个对象，而是在对象之外的空间中声明一个变量供所有对象来共享。</p>
<p>注意：static关键字只能用于修饰成员变量，不能用于修饰局部变量。</p>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String schoolName;</span><br><span class="line">&#125;</span><br><span class="line">main函数中：</span><br><span class="line">Student.schoolName=<span class="string">&quot;daxue&quot;</span>;</span><br><span class="line">Student stu1=<span class="keyword">new</span> Student();</span><br><span class="line">使用： stu1.schoolName</span><br></pre></td></tr></table></figure>

<p>（2）静态方法</p>
<p>希望在不创建对象的情况下就可以调用某个方法时使用。</p>
<p>访问方式：<code>类名.方法</code>    或    <code>实例对象名.方法</code></p>
<p>注意：在一个静态方法中只能访问用static修饰的成员，原因在于没有没sttaic修饰的成员需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象。</p>
<blockquote>
<p>思考：一个文件中可以有多个类，文件名叫public的类的名字，类内可以有public static main函数，有main函数的类得是public的?</p>
<p>static 的成员函数，只能访问static的成员（函数或变量），public static main函数中可以创建其他类的对象，然后访问其他非static类的成员。</p>
</blockquote>
<p>（3）静态代码块</p>
<p>static{…}  在类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块也只执行一次。通常使用静态代码块对类的成员变量进行初始化。第一次实例化对象时会加载类。</p>
<h2 id="面向对象（下）"><a href="#面向对象（下）" class="headerlink" title="面向对象（下）"></a>面向对象（下）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>is a的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类在继承父类的时候，会自动拥有父类所有公共的成员。</p>
<p>java中只支持单继承，不允许多继承，一个类只能有一个直接父类。</p>
<h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>不能使用比父类中重写的方法更严格的访问权限，如父类的访问权限是public，子类方法不能是private。</p>
<p>也可以重新定义父类的属性。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>子类重写父类方法或重新定义父类属性后，子类对象无法直接访问他们，因此，用super访问。<code>super.成员变量/成员方法</code></p>
<p>还可以用super关键字来调用父类的构造方法。<code>super([参数1,参数2]);</code>但是，只能出现在子类构造方法的第一行，且只能出现一次。</p>
<p>注意：子类的构造方法中一定会调用父类的某个构造方法，可以通过super指定。如果没有super，则会默认调用父类无参的构造方法。因此，如果父类只定义了有参的构造方法，系统不给默认无参构造方法，就会出错。因此需要在父类添加无参构造方法，或者子类指定调用父类有参构造方法。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>java中的Object类是所有类的父类，每个类都直接或间接地继承自该类，称为超类、基类、或根类。Object类中有一些自定义的方法。</p>
<p><code>对象名.toString()  </code>返回对象的字符串表示。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>不可更改，最终的意思。</p>
<p>（1）修饰类：不能被继承。</p>
<p>（2）修饰方法：不能被子类重写</p>
<p>（3）修饰变量：常量，只能被赋值一次。</p>
<p>final修饰的成员变量，必须在声明的同时进行赋值。</p>
<p>final修饰的局部变量，可以先声明，再进行一次赋值。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>例如在定义Animal类时，shout()方法无法明确表示，java提供抽象方法来使得其无需提供方法的具体实现。</p>
<p>抽象方法：<code>public abstract void shout();</code>没有大括号</p>
<p>包含抽象方法的类一定是抽象类，class前加abstract，但是抽象类中可以不包含抽象方法。</p>
<p>抽象类不能被实例化，只能创建子类，并在子类中实现抽象类中的抽象方法。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种特殊的抽象类，它不包含普通方法，内部所有方法都是抽象方法。</p>
<p>JDK8中对接口进行了重新定义，接口中除了抽象方法外，可以有default修饰的默认方法，static修饰的静态方法，这两种方法都允许有方法体。</p>
<p>用interface修饰，可以extends多个接口。接口内部可以有final常量，定义常量时必须进行初始化赋值。</p>
<p>小提示：定义常量时<code>public static final</code>可省略，定义方法时<code>public abstract</code>可省略</p>
<p>调用静态方法：<code>接口名.方法名</code></p>
<p>调用抽象方法和默认方法需要通过接口实现类的实例对象来调用。默认方法不需要子类中实现。</p>
<p><code>public interface Hockey extends Sports, Event</code>   接口的多继承</p>
<p>一个类可以在继承一个类的同时实现多个接口：<code>public class 类名 extends 类名 implements 接口1，接口2</code>  ，extend需要在前面</p>
<blockquote>
<p>注意：如果一个类通过implement实现接口，如果该类是抽象类，则可以实现接口中的部分抽象方法，如果不是抽象类，则需要实现接口中的所有抽象方法。</p>
</blockquote>
<p>总结：类继承类（只能继承一个类，但同时可以实现多个接口），接口继承接口（可一次继承多个接口），类实现接口（可一次实现多个接口）</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指一个类中定义的属性和方法被其他类继承或重写后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现的多种不同形态。</p>
<p>把子类对象直接赋值给父类引用变量时，程序只有在运行时才知道该引用变量具体代表哪个子类对象。</p>
<h3 id="对象的类型转换"><a href="#对象的类型转换" class="headerlink" title="对象的类型转换"></a>对象的类型转换</h3><p>子类对象当作父类类型使用：向上转型</p>
<p><code>Animal an1=new Cat();</code>   不需要任何显示声明，但是不能通过父类变量去调用子类特有的方法。</p>
<p>要想使用子类特有的方法，需要将本质为Cat类型的an1对象由Animal类型向下转型为Cat类型。</p>
<p><code>Cat cat=(Cat)an1;</code> 就可以用cat变量来调用子类特有方法了。</p>
<p><code>instanceof</code>关键字，用来判断一个对象是否为某个类或接口的实例或子类实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Animal an1=new Cat();</span><br><span class="line">if(an1 instanceof Cat)&#123;</span><br><span class="line">    Cat cat=(Cat)an1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>java中允许一个类的内部定义类，这样的类叫内部类。内部类所在类叫外部类。根据内部类的位置、修饰符、定义方式的不同分为四种。</p>
<p>（1）成员内部类</p>
<p>像成员变量、成员方法一样的存在，在成员内部类中，可以访问外部类的所有成员。在外部类中，可以访问成员内部类的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部类访问内部类的成员：</span><br><span class="line">Inner inner = new Inner();</span><br><span class="line">inner.成员</span><br><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer out = new Outer();  创建外部类对象</span><br><span class="line">Outer.Inner in = new Inner();   创建内部类对象</span><br></pre></td></tr></table></figure>

<p>（2）局部内部类</p>
<p>也叫方法内部类，是定义在某个方法内的，有效范围仅限于方法内部。</p>
<p>局部内部类可以访问外部类所有成员，而只有在包含局部内部类的方法中才可以访问内部类的成员。</p>
<p>（3）静态内部类</p>
<p>使用static关键字修饰的成员内部类，静态内部类只能访问外部类的静态成员.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer.Inner inner = new Outer.Inner();</span><br><span class="line">inner.成员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般在刷题时，定义Solution类，类内定义成员方法实现算法。测试时，定义另一个类，类内main函数中输入输出，然后定义对象<code>Solution s = new Solution();</code>通过对象访问算法方法。</p>
</blockquote>
<p>（4）匿名内部类</p>
<p>在java中调用某个方法时，如果该方法的参数是一个接口类型，除了可以传入一个参数接口实现类，还可以使用匿名内部类实现接口来作为该方法的参数。</p>
<p>匿名内部类就是没有名称的内部类，在调用包含有接口类型参数的方法时，通常为了简化代码，不会创建一个接口的实现类作为方法参数传入，而是直接通过匿名内部类的形式传入一个接口类型参数，在匿名内部类中直接完成方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义动物类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String name=<span class="string">&quot;maomao&quot;</span>;</span><br><span class="line">		<span class="comment">//定义匿名内部类作为参数传递给animalShout方法</span></span><br><span class="line">		animalShout(<span class="keyword">new</span> Animal()&#123;</span><br><span class="line">		    <span class="comment">//匿名内部类中实现shout方法</span></span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">		    	<span class="comment">//JDK8开始，局部内部类、匿名内部类可以访问非final的局部变量</span></span><br><span class="line">		    	System.out.println(name+“喵喵”)；</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;)；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义静态方法animalShout(),接收接口类型参数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">animalShout</span><span class="params">(Animal an)</span></span>&#123;</span><br><span class="line">		an.shout(); <span class="comment">//调用传入对象的shout()方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分两步：</p>
<p>第一步 <code>animalShout(new Animal()&#123;&#125;)</code> 参数位置创建一个实例对象，表示创建的对象为Animal的子类实例，该子类是匿名的。</p>
<p>第二步<code>&#123;&#125;</code>中编写匿名子类的实现代码。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda 表达式，也可称为<strong>闭包</strong>，它是推动 Java 8 发布的最重要新特性。它使用一个清晰简洁的表达式来表达一个接口。</p>
<p>匿名内部类存在一个问题：如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然冗余。</p>
<p>Lambda表达式针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br><span class="line">可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</span><br><span class="line">可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</span><br><span class="line">可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</span><br><span class="line">可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，return可省略</span><br></pre></td></tr></table></figure>

<p>上面的例子，用lambda表达式来做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animalShout(()-&gt;System.out.println(name+“喵喵”);)</span><br></pre></td></tr></table></figure>

<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>Lambda表达式可以实现匿名内部类的功能，但是局限在于接口中只有一个抽象方法时才能使用Lambda表达式代替匿名内部类。</p>
<p>因为Lambda表达式是基于函数式接口实现的，函数式接口就是只有一个抽象方法的接口。</p>
<p>JDK8中专门为函数式接口引入@FunctionalInterface注解，显示地标识接口是一个函数式接口，如果不是编译器就会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculate</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		showSum(<span class="number">10</span>, <span class="number">20</span>, (x,y)-&gt;x+y);  <span class="comment">//实现方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建参数为接口的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Calculate cu)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;和为：&quot;</span>+cu.sum(x, y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式的引用形式"><a href="#Lambda表达式的引用形式" class="headerlink" title="Lambda表达式的引用形式"></a>Lambda表达式的引用形式</h3><p>Lambda表达式的主体只有一条语句时，程序可通过<code>：：</code>的语法格式来引用方法和构造器。本质是对Lambda表达式的主体部分已存在的方法进行直接引用。</p>
<p>相当于calc方法需要实现，而又现成的abs方法可以用。</p>
<p>（1）类名引用普通方法/静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculate</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含静态方法的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&lt;<span class="number">0</span>)  <span class="keyword">return</span> -num;</span><br><span class="line">		<span class="keyword">else</span>  <span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAbs</span><span class="params">(<span class="keyword">int</span> num, Calculate cu)</span></span>&#123;</span><br><span class="line">		System.out.println(cu.calc(num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, n-&gt;Math.abs(n));</span><br><span class="line">		<span class="comment">//使用方法引用</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, Math::abs);  类名::类静态方法/普通方法名</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）对象名引用方法</p>
<p>也可以通过实例化对象的名称来对其方法进行引用。是普通方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math ma = new Math();</span><br><span class="line">printAbs(-10, n-&gt;ma.abs(n));</span><br><span class="line">printAbs(-10,ma::abs);</span><br></pre></td></tr></table></figure>

<p>（3）构造器引用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">buildPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个Person类，并添加有参构造方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(String name, PersonBuilder bu)</span></span>&#123;</span><br><span class="line">		System.out.println(bu.buildPerson(name).getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式   ()-&gt;new 类名()</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, name-&gt;<span class="keyword">new</span> Person(name));</span><br><span class="line">		<span class="comment">//使用方法引用    类名::new</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, Person::<span class="keyword">new</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>java语言引入了异常，以异常类的形式对正常情况进行封装。</p>
<p>异常类都继承自java.lang.Throwable类。</p>
<p>Throwable有两个直接子类Error和Exception。</p>
<p>其中Error称为错误类，代表Java运行时产生的系统内部错误或资源耗尽的错误，如系统崩溃、虚拟机错误。</p>
<p>Exception类称为异常类，标识程序本身可以处理的错误，异常处理都是针对该类及其子类。RuntimeException表示运行时异常，其他表示编译时异常。</p>
<p>Throwable类中常用的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String getMessage()</span><br><span class="line">返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</span><br><span class="line">public void printStackTrace()</span><br><span class="line">打印toString()结果和栈层次到System.err，即错误输出流。</span><br><span class="line">public Throwable getCause()</span><br><span class="line">返回一个Throwable 对象代表异常原因。</span><br></pre></td></tr></table></figure>

<p>运行时异常是在程序运行时由Java虚拟机自动进行捕获处理的。例如数组越界。</p>
<h3 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在除法方法中：</span><br><span class="line">try&#123;</span><br><span class="line">   可能发生异常的语句</span><br><span class="line">&#125;catch(Exception类或其子类 e1)&#123;</span><br><span class="line">   对捕获的异常进行相应的处理</span><br><span class="line">   System.out.println(&quot;异常：&quot;+e1.getMessage());</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	无论程序是否异常都会执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try{}中的代码块发生异常，系统会将这个异常的信息封装成一个异常对象，传递给catch(){}代码块，catch代码块需要一个参数指明它所能接收的异常类型，必须是Exception类或其子类。</p>
<p>finally{}中的代码不受return语句和程序异常的影响，可以用来完成必须要做的事，例如释放系统资源、关闭线程池等。但是在try…catch…代码块中执行了<code>System.exit(0)</code>语句的话，finally不会执行，因为<code>System.exit(0)</code>表示退出当前的java虚拟机。</p>
<h3 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h3><p>用于将异常从当前方法中抛出，throws写在方法声明的后面，后跟声明方法中发生异常的类型，这种做法叫做方法申明抛出一个异常。一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int divide(int x, int y) throws Exception&#123;</span><br><span class="line">	int res=x/y;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了throws后，还需要再出现异常的代码（main中）处使用try…catch…代码块进行捕获处理。</p>
<h3 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h3><p>throw用于方法体内，并且抛出的是一个异常类对象。</p>
<p>通过throw关键字抛出异常后，还需要try…catch…或throws关键字对异常进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void deposit(double amount) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">  if(判断)&#123;</span><br><span class="line">      throw new Exception(&quot;异常&quot;); //可以用来指示异常信息</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throw抛出异常对象，然后通过throws关键字抛出异常，最后通过try…catch…语句捕获异常。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>java允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类。在构造方法中使用super()语句调用Exception的构造方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 	<span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();  <span class="comment">//调用无参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(message);  <span class="comment">//调用有参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>java提供垃圾回收机制（Java GC），虚拟机会自动回收垃圾对象所占用的内存空间。</p>
<p>当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分为三种：</p>
<p>（1）可用状态：对象被创建后，有一个以上的引用变量引用它，那么这个对象在程序中将处于可用状态，程序可以通过引用变量来调用该对象的实例变量和方法。</p>
<p>（2）可恢复状态：程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。系统准备回收，回收之前会调用可恢复状态对象的<code>finalize()</code>方法进行资源清理。如果在调用<code>finalize()</code>方法之前重新使一个引用变量引用该对象，则这个对象会再次变为可用对象。</p>
<p>（3）不可用状态：调用<code>finalize()</code>方法后，对象进入不可用状态，内存被清理。</p>
<blockquote>
<p>一个对象在失去引用成为垃圾后，会暂时保存在内存中，垃圾堆积到一定程度时，java虚拟机会启动垃圾回收器将这些垃圾对象从内存中释放，也就说回收的时机无法把握。</p>
</blockquote>
<p>强制系统进行垃圾回收的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.gc();</span><br><span class="line">或：</span><br><span class="line">Runtime.getRuntime().gc();</span><br></pre></td></tr></table></figure>

<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>当一个对象在内存中被释放时，它的<code>finalize()</code>方法会自动调用，<code>finalize()</code>方法是定义在Object类中的实例方法，方法原型：</p>
<p><code>protected void finalize() throws Throwable&#123;&#125;</code></p>
<p>任何java类都可以重写Object类的<code>finalize()</code>方法，在该方法中清理对象占用的资源。重写实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">	public void finalize()&#123;</span><br><span class="line">		System.out.println(&quot;d&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》之网络编程</title>
    <url>/2021/12/02/myblog/JAVA/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="IP地址和端口号"><a href="#IP地址和端口号" class="headerlink" title="IP地址和端口号"></a>IP地址和端口号</h2><p>IPv4由四个字节大小的二进制数来表示，通常写成十进制形式，每个数在0-255之间。</p>
<p>IPv6使用16个字节表示IP地址。</p>
<p>最初设计互联网时，为了便于寻址以及层次化构造网络，每个IP地址由两部分组成，即”网络.主机”，网络部分表示其属于互联网的哪一个网络，是网络的地址编码，主机部分表示其属于该网络中的哪一台主机，是网络中一个主机的地址编码，二者是主从关系。</p>
<p>IP地址分为五类：常用的是A.B.C类：</p>
<p>①A类地址：第一段网络地址，其余三段主机地址，范围是1.0.0.0 – 127.255.255.255。</p>
<p>②B类地址：前两段网络地址，其余两段主机地址，范围是128.0.0.0 – 191.255.255.255。</p>
<p>③C类地址：前三段网络地址，最后一段主机地址，范围是192.0.0.0 – 223.255.255.255。</p>
<p>另外，还有一个本地回环地址127.0.0.1，指本机地址，改地址一般用来测试使用，例如：ping 127.0.0.1 用来测试本机TCP/IP协议是否正常。</p>
<p>端口号用来访问目标计算机中的某个应用程序。计算机中，不同的应用程序是通过端口号来区分的，端口号是用两个字节（16位二进制数）表示的，取值范围是：0 ~ 65535。其中，0 ~ 1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一些应用或服务所占用。</p>
<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>JDK中提供了一个与IP地址相关的InetAddress类，该类用于封装一个IP地址，并提供一系列与IP地址有关的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getByName(String host);  <span class="comment">//获取表示指定主机的InetAddress对象</span></span><br><span class="line">getLocalHost()      <span class="comment">//获取本机的InetAddress对象，InetAddress.getLocalHost()</span></span><br><span class="line">getHostName()     <span class="comment">//InetAddress对象.getHostName  获取主机名，返回String</span></span><br><span class="line">isReachable(<span class="keyword">int</span> timeout)   <span class="comment">//InetAddress对象.isReachable，判断在限定时间内指定的IP地址是否可以访问，返回boolean</span></span><br><span class="line">getHostAddress()    <span class="comment">//InetAddress对象.getHostAddress，获取字符串格式的原始IP地址，返回String</span></span><br></pre></td></tr></table></figure>

<p><code>getHostName</code>获取某个主机的域名，如果InetAddress对象是通过主机名创建的，则将返回该主机名；否则根据IP地址反向查找对应的主机名，如果找到则将其返回，否则返回IP地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: InetAddress类使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 12:52</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAdd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取本机InetAddress对象</span></span><br><span class="line">        InetAddress local = InetAddress.getLocalHost();  <span class="comment">//相当于 InetAddress.getByName(&quot;localhost&quot;);</span></span><br><span class="line">        <span class="comment">//获取主机名为&quot;www.baidu.com&quot;的InetAddress对象</span></span><br><span class="line">        InetAddress remote = InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;InetAddress对象：&quot;</span>+local);</span><br><span class="line">        System.out.println(<span class="string">&quot;本机ip：&quot;</span>+local.getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;百度ip：&quot;</span>+remote.getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;3s内是否可访问百度：&quot;</span>+remote.isReachable(<span class="number">3000</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;本机主机名：&quot;</span>+local.getHostName());</span><br><span class="line">        System.out.println(<span class="string">&quot;百度主机名：&quot;</span>+remote.getHostName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问：为什么一定要throws异常。</p>
</blockquote>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><p>UDP：user datagram protocol 用户数据报协议</p>
<p>TCP：transmission control protocol 传输控制协议</p>
<p>UDP：无连接通信协议，数据的发送端和接收端不建立逻辑连接。发送端不会确认接收端是否存在，接收端也不会向发送端反馈是否收到数据。消耗资源小，通信效率高，延迟小。用于音频、视频传输。但是不保证数据的完整性。</p>
<p>TCP：传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，必须明确客户端与服务端，保证两台计算机之间可靠无差错的数据传输。</p>
<h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><p>UDP通信过程相当于在两个码头之间通过集装箱发送货物。JDK中提供一个DatagramPacket类，该类的实例对象相当于一个集装箱，用于封装UDP通信中发送或者接收的数据。DatagramSocket类，该类的实例对象相当于码头，用于发送和接收DatagramPacket数据报。</p>
<h3 id="DatagramPacket"><a href="#DatagramPacket" class="headerlink" title="DatagramPacket"></a>DatagramPacket</h3><p>创建发送端和接收端的DatagramPacket对象时，使用的构造方法有所不同。接收端的构造方法只需要接收一个字节数组来存放接收到的数据。发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定接收端IP地址和端口号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length)   用于接收端，指定字节数组和数据的大小</span><br><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)   增加一个偏移量，从该位置开始发送</span><br><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length, InetAddress add, <span class="keyword">int</span> port)   用于发送端，指定字节数组和数据的大小，必须的目标ip和端口</span><br><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, InetAddress add, <span class="keyword">int</span> port)   增加一个偏移量，从该位置开始发送</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意传入的是InetAddress对象，而不是String形式的ip地址。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramPacket对象.getAddress()  得到InetAddress对象，发送端的得到的是接收端的</span><br><span class="line">DatagramPacket对象.getPort()  返回<span class="keyword">int</span>端口号，发送端返回接收端的</span><br><span class="line">DatagramPacket对象.getData()  返回接收/发送的数据，发送的返回发送的，返回<span class="keyword">byte</span>[]类型</span><br><span class="line">DatagramPacket对象.getLength() 返回<span class="keyword">int</span>接收/发送的数据长度</span><br></pre></td></tr></table></figure>

<h3 id="DatagramSocket"><a href="#DatagramSocket" class="headerlink" title="DatagramSocket"></a>DatagramSocket</h3><p>用于创建发送端和接收端对象，创建发送端和接收端DatagramSocket对象时，使用的构造方法不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket(<span class="keyword">int</span> port)  用于发送端，在创建发送端DatagramSocket对象时，可以不指定端口号，系统进行分配，也可以指定。用于接收端，必须指定端口号。</span><br><span class="line">DatagramSocket(<span class="keyword">int</span> port, InetAddress addr)  指定端口号外，还指定了ip地址，用于计算机上有多块网卡，明确规定数据通过哪块网卡向外发送或接收。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket对象.receive(DatagramPacket p)   用于接收DatagramPacket数据报，在接收到数据之前会一直处于阻塞状态，如果发送消息的长度比数据报长，则消息会被截取。</span><br><span class="line">DatagramSocket对象.send(DatagramPacket p)   用于发送DatagramPacket数据报，其中应该包含发送的数据、长度、接收端ip、端口号</span><br><span class="line">DatagramSocket对象.close()   关闭当前socket，通知驱动程序释放为这个socket保留的资源。</span><br></pre></td></tr></table></figure>

<h3 id="UDP实现"><a href="#UDP实现" class="headerlink" title="UDP实现"></a>UDP实现</h3><p>通信时，需要接收端程序先运行，才能避免因发送端发送的数据无法接收而造成的数据丢失。</p>
<p>接收端程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: UDP接收端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 19:41</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个指定端口号为8900的接收端DatagramSocket对象</span></span><br><span class="line">        DatagramSocket server = <span class="keyword">new</span> DatagramSocket(<span class="number">8900</span>);</span><br><span class="line">        <span class="comment">//定义一个长度为1024的字节数组，用于接收数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//定义一个DatagramPacket数据报对象，用于封装接收的数据</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收数据&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;   <span class="comment">//使得一直循环接收</span></span><br><span class="line">            <span class="comment">//等待接收数据，在没有接收到之前处于阻塞状态</span></span><br><span class="line">            server.receive(packet);</span><br><span class="line">            <span class="comment">//调用DatagramPacket的方法获得接收到的信息，并转换成字符串形式</span></span><br><span class="line">            String str = <span class="keyword">new</span> String(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">            System.out.println(packet.getAddress()+<span class="string">&quot;:&quot;</span>+packet.getPort()+<span class="string">&quot;发送消息：&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送端程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: UDP发送端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 20:25</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个指定端口号3000的发送端DatagramSocket对象</span></span><br><span class="line">        DatagramSocket client = <span class="keyword">new</span> DatagramSocket(<span class="number">3000</span>); <span class="comment">//可以不指定端口</span></span><br><span class="line">        <span class="comment">//定义要发送的数据</span></span><br><span class="line">        String str = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">        System.out.println(Arrays.toString(str.getBytes()));</span><br><span class="line">        <span class="comment">//定义一个DatagramPacket数据报对象，封装发送端信息以及发送地址</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(str.getBytes(),</span><br><span class="line">                str.getBytes().length, InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">8900</span>);  <span class="comment">//这个一定要与接收端程序设置一样</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开始发送数据...&quot;</span>);</span><br><span class="line">        client.send(packet);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>byte[]数组，里面存的是数字，编解码变为字符串。</p>
<p>疑问：byte是1字节，8bit，char是2字节，如何对应？</p>
<p>一个字符等于几个字节？</p>
<p>不同的字符所占的字节是不同的。</p>
<p>ASCII码：</p>
<p>一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。如一个ASCII码就是一个字节。</p>
<p>UTF-8编码：</p>
<p>一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。</p>
<p>Unicode编码：</p>
<p>一个英文等于两个字节，一个中文（含繁体）等于两个字节。</p>
<p>GBK编码：</p>
<p>中文占两个字节，英文占1个字节。</p>
</blockquote>
<p>UDP程序在发送数据时是一次性全部封装到<code>DatagramPacket</code>数据报中进行统一发送的，然而<code>DatagramPacket</code>数据报一次性允许封装的数据量是有限度的，理论最大值是：65507个字节（IP数据报的最大限制65535字节减去IP首部的20字节和UDP首部的8字节）。但是许多平台实际的最大限制是8192字节（8K）。</p>
<blockquote>
<p>检查计算机使用的端口：netstat -anb</p>
<p>报错：netstat: option requires an argument – p</p>
<p>在Mac上正确使用的方法是：即-f需要加上地址族，-p需要加上协议TCP或者UDP等</p>
<p>a）如果需要查询inet，netstat -anvf inet</p>
<p> b）如果需要查询TCP， netstat -anvp tcp</p>
<p> b）如果需要查询UDP，netstat -anvp udp   </p>
<p>netstat -anvp tcp |grep 10001</p>
</blockquote>
<h3 id="小项目-聊天程序"><a href="#小项目-聊天程序" class="headerlink" title="小项目-聊天程序"></a>小项目-聊天程序</h3><p>模拟qq中两个用户一对一聊天，通过多线程实现发送端和接收端功能。</p>
<p>主机程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 聊天程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 21:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRoom1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;输入本机端口号：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> serverPort = sc.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;输入目标计算机端口号：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> targetPort = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;聊天服务启动！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建聊天程序收发平台DatagramSocket对象</span></span><br><span class="line">            DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(serverPort);</span><br><span class="line">            <span class="comment">//启动信息接收端和发送端程序</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChatReceiver(socket), <span class="string">&quot;接收端服务&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChatSender(socket, targetPort), <span class="string">&quot;发送服务&quot;</span>).start();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SocketException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 接收端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 22:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatReceiver</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要有DatagramSocket对象</span></span><br><span class="line">    <span class="keyword">private</span> DatagramSocket server;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatReceiver</span><span class="params">(DatagramSocket server)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//定义一个DatagramPacket数据报对象，用于封装接收的数据</span></span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">            System.out.println(<span class="string">&quot;等待接收数据&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;   <span class="comment">//使得一直循环接收</span></span><br><span class="line">                <span class="comment">//等待接收数据，在没有接收到之前处于阻塞状态</span></span><br><span class="line">                server.receive(packet);</span><br><span class="line">                <span class="comment">//调用DatagramPacket的方法获得接收到的信息，并转换成字符串形式</span></span><br><span class="line">                String str = <span class="keyword">new</span> String(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;收到&quot;</span>+packet.getAddress()+<span class="string">&quot;:&quot;</span>+packet.getPort()+<span class="string">&quot;发送的数据：&quot;</span>+str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 发送端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 22:14</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatSender</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要有DatagramSocket对象</span></span><br><span class="line">    <span class="keyword">private</span> DatagramSocket client;</span><br><span class="line">    <span class="comment">//还需要目标端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> targetPort;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatSender</span><span class="params">(DatagramSocket client, <span class="keyword">int</span> targetPort)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.targetPort = targetPort;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                String data = sc.nextLine();</span><br><span class="line">                <span class="keyword">byte</span>[] buf = data.getBytes();</span><br><span class="line">                <span class="comment">//这里需要目标ip地址，以及目标端口号</span></span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length,</span><br><span class="line">                        InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), targetPort);</span><br><span class="line">                <span class="comment">//127.0.0.1 和 localhost 一样，都是本机</span></span><br><span class="line">                client.send(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于端口号有点乱：</p>
<p>发送端：DatagramSocket中可指定也可不指定端口号。DatagramPacket一定要指定接收端的ip和接收端接收端口。</p>
<p>接收端：DatagramSocket一定要指定接收端口，DatagramPacket里面不需要ip和端口。</p>
<p>在上面的UDP实现中，发送和接收的端口号不同。是单向的。</p>
<p>这个聊天程序中，模拟两个主机，一个主机的发送和接收的端口是一样的，所以一个主机发送和接收的socket一样。但是两个目标主机的端口要对应上。是双向的。</p>
</blockquote>
<h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><p>UDP只有发送端和接收端，不区分客户端和服务器端，计算机之间可以任意地发送数据。</p>
<p>TCP严格区分客户端和服务器端，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不会主动连接客户端。</p>
<p>JDK提供ServerSocket类表示服务器端，Socket类表示客户端。通信时，首先创建代表服务器端的ServerSocket对象，开启一个服务，并等待客户端的连接；然后创建Socket对象代表客户端，向服务器端发出连接请求。服务器端响应请求，两者建立连接后正式进行通信。</p>
<h3 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h3><p>java.net包中，表示服务器端，需要自己端口号，构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>ServerSocket()   <span class="comment">//没有指定端口号，不能直接使用，需要bind(SocketAddress endpoint)方法将其绑定到指定端口号。</span></span><br><span class="line"><span class="number">2.</span>ServerSocket(<span class="keyword">int</span> port)   <span class="comment">//指定端口，如果参数是0，系统会分配一个未被占用的端口号，并不常用，因为客户端需要知道端口号。（最常用）</span></span><br><span class="line"><span class="number">3.</span>ServerSocket(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog)  <span class="comment">//backlog表示在服务器忙时，可与之保持连接请求的等待客户端数量。默认50。</span></span><br><span class="line"><span class="number">4.</span>ServerSocket(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog, InetAddress bindAddr)  <span class="comment">//在多网卡情况下使用，指定使用服务器的哪个ip</span></span><br></pre></td></tr></table></figure>

<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket对象.accept()   <span class="comment">//等待与客户端的连接，与客户端连接之前一直处于阻塞状态，如果有连接就返回与之连接的客户端Socket对象</span></span><br><span class="line">ServerSocket对象.getInetAddress()   <span class="comment">//返回一个InetAddress对象，表示ServerSocket绑定的ip</span></span><br><span class="line">ServerSocket对象.isClosed()   <span class="comment">//返回boolean，判断ServerSocket对象是否为关闭状态</span></span><br><span class="line">ServerSocket对象.bind（SocketAddress endpoint）  <span class="comment">//无返回，将ServerSocket对象绑定到指定ip和端口</span></span><br></pre></td></tr></table></figure>

<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>用于实现TCP客户端程序，需要目标ip和端口号（本机端口号呢？），构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Socket()  <span class="comment">//没有指定ip和端口号，不能直接使用，需要调用connect(SocketAddress endpoint)方法完成与指定服务器端的连接，参数endpoint封装了ip地址和端口号。</span></span><br><span class="line"><span class="number">2.</span>Socket(String host, <span class="keyword">int</span> port)   <span class="comment">//host表示一个字符串类型的ip地址</span></span><br><span class="line"><span class="number">3.</span>Socket(InetAddress add, <span class="keyword">int</span> port)   <span class="comment">//add封装ip</span></span><br></pre></td></tr></table></figure>

<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Socket对象.getPort()  <span class="comment">//返回int，获得Socket连接的远程服务器的端口号</span></span><br><span class="line"><span class="number">2.</span>Socket对象.getLocalAddress()   <span class="comment">//返回Socket对象绑定的本地ip</span></span><br><span class="line"><span class="number">3.</span>Socket对象.close()  <span class="comment">//无返回，关闭Socket连接，关闭之前，先关闭所有输入输出流</span></span><br><span class="line"><span class="number">4.</span>Socket对象.getInputStream()  <span class="comment">//返回一个InputStream类型的输入流对象。服务器端的Socket调用，用于获取来自客户端发送的数据。客户端的Socket调用，用于获取来自服务端发送的数据。</span></span><br><span class="line"><span class="number">5.</span>Socket对象.getOutputStream()  <span class="comment">//返回一个OutputStream类型的输出流对象。服务器端的Socket调用，用于向客户端发送数据。客户端的Socket调用，用于向服务端发送数据。</span></span><br></pre></td></tr></table></figure>

<p>当客户端与服务端建立连接后，数据是以I/O流的形式进行交互的。</p>
<p>输入流和输出流的方法都是Socket对象调用的，无论客户端还是服务器端中，都有Socket对象。输入流用来获取输入到本机的数据，read方法。输出流用来向另一台输出数据，write方法。</p>
<h3 id="TCP实现"><a href="#TCP实现" class="headerlink" title="TCP实现"></a>TCP实现</h3><p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TCP服务器端实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-03 11:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建指定端口号的服务端ServerSocket对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">7788</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//调用accept方法开始接收数据</span></span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;accept返回，连接成功。&quot;</span>);</span><br><span class="line">            <span class="comment">//向客户端发送数据，write方法</span></span><br><span class="line">            OutputStream os = client.getOutputStream();</span><br><span class="line">            <span class="comment">//向客户端发送数据，用客户端的输出流</span></span><br><span class="line">            os.write((<span class="string">&quot;我是服务端。&quot;</span>).getBytes());</span><br><span class="line">            <span class="comment">//模拟交互耗时</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="comment">//关闭流和Socket连接</span></span><br><span class="line">            os.close();</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client（Socket类型的对象）用于表示客户端，通过该对象可以获取与客户端关联的输出流并向客户端发送信息。</p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.SocketHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TCP客户端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-03 13:01</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个Socket并连接到指定的服务端</span></span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">7788</span>);</span><br><span class="line">        <span class="comment">//获取输入到本机的数据，并打印，用read方法</span></span><br><span class="line">        InputStream is = client.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(buf);</span><br><span class="line">        <span class="keyword">while</span>(len!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</span><br><span class="line">            len = is.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流和Socket连接</span></span><br><span class="line">        is.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，一台主机两个端口分别服务端和客户端，服务端等待连接，客户端连接成功后，服务端知道了自己输出连接成功。然后服务端向客户端传输我是服务端，客户端并没有向服务端传输。服务端 –&gt; 客户端。   服务端需要指定端口号，客户端需要指定要连接的目标的ip和端口号（和服务端端口号一样）。客户端不需要自己的端口号？系统自己给客户端端口。</p>
<p>以上涉及到IO操作。</p>
<h3 id="多线程的TCP网络程序"><a href="#多线程的TCP网络程序" class="headerlink" title="多线程的TCP网络程序"></a>多线程的TCP网络程序</h3><p>上面的实现是：一个客户端程序请求服务器端时，服务器端会结束阻塞状态，完成程序的运行。实际上，服务器端程序允许多个应用程序访问，服务器端都是多线程的。</p>
<p>服务器端为每个客户端创建一个对应的Socket对象，并且开启一个新线程使两个Socket建立专线进行通信。</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.threadtcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 多线程TCP服务端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-03 20:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建指定端口号的服务端ServerSocket对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">7789</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//调用accept方法开始接收数据</span></span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            <span class="comment">//针对每个客户端请求创建一个线程进行连接管理</span></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> port = client.getPort();</span><br><span class="line">                    System.out.println(<span class="string">&quot;与端口号为&quot;</span>+port+<span class="string">&quot;的客户端连接成功！&quot;</span>);</span><br><span class="line">                    OutputStream os = client.getOutputStream();</span><br><span class="line">                    <span class="comment">//向客户端发送数据，用输出流（不应该用服务端的输出流吗？）</span></span><br><span class="line">                    os.write((<span class="string">&quot;我是服务端，服务端向你问好。&quot;</span>).getBytes());</span><br><span class="line">                    <span class="comment">//模拟交互耗时</span></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;结束与客户端数据交互。&quot;</span>);</span><br><span class="line">                    <span class="comment">//关闭流和Socket连接</span></span><br><span class="line">                    os.close();</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//执行线程类，与客户端进行数据交互</span></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端程序没变，搞三个客户端进行测试。同样只是服务端向客户端发送数据。</p>
<h3 id="小项目-文件上传"><a href="#小项目-文件上传" class="headerlink" title="小项目-文件上传"></a>小项目-文件上传</h3><p>实现客户端向服务端发送图片，服务端接收图片并保存。略。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Spring实战》笔记</title>
    <url>/2021/12/23/myblog/JAVA/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="springboot在idea的RunDashboard如何显示出来"><a href="#springboot在idea的RunDashboard如何显示出来" class="headerlink" title="springboot在idea的RunDashboard如何显示出来"></a>springboot在idea的RunDashboard如何显示出来</h3><p>运用spring cloud框架基于spring boot构建微服务，一般需要启动多个应用程序，在idea开发工具中，多个同时启动的应用需要在RunDashboard运行仪表盘中可以更好的管理，但有时候idea中的RunDashboard窗口没有显示出来，也找不到直接的开启按钮。</p>
<p>选择Edit Configurations，在运行配置窗口，选择一条springboot的运行配置，然后点击上方的复制按钮进行复制副本，复制完成之后，点击OK确定按钮，然后在屏幕右下角可以看到一个弹框提示，点击弹框右下角的向下的小箭头，展开弹框详情信息，然后点击Show run configurations in Run Dashboard，在Run Dashboard中可以看到当前所有的启动配置，直接点击可以方便的启动和停止。</p>
<p>以上方法还没有显示出来的话，则可以通过修改idea的workspace.xml的方式来快速打开Run Dashboard窗口。</p>
<p>打开workspace.xml文件之后，找到component为RunDashboard的节点处，然后在component标签里添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;option name=&quot;configurationTypes&quot;&gt;</span><br><span class="line">   &lt;set&gt;</span><br><span class="line">​    &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt;</span><br><span class="line">   &lt;/set&gt;</span><br><span class="line">  &lt;/option&gt;</span><br></pre></td></tr></table></figure>

<p>最后保存即可，保存完成之后立即自动弹出Run Dashboard窗口了。</p>
<h3 id="Taco商店"><a href="#Taco商店" class="headerlink" title="Taco商店"></a>Taco商店</h3><p>路径、领域类、控制器、控制器返回的是表单。控制器也可重定向到另一个路径。每个控制器类处理一个路径，一个路径可以处理get、post，一次可以有不同的方法。表单post请求到控制器。</p>
<p>目前的领域类：taco、order、ingredient</p>
<p>控制类：designcontrol、ordercontrol</p>
<p>表单：home、design、order</p>
<h3 id="第二章调试"><a href="#第二章调试" class="headerlink" title="第二章调试"></a>第二章调试</h3><p>1.只有home，只显示主页。</p>
<p>2.有design，显示design页面，没有表单验证，配料是自己写的，点了submit错误了，405 Request method ‘POST’ not supported。</p>
<p>3.加post方法，重定向（跳转）到订单处理控制器，显示order页面，注意ordercontrol里也是一个get一个post。</p>
<p>4.添加表单验证，两个领域类添加规则，两个控制类的post提交表单方法进行验证，两个表单也要做相应变化，加span。（不加@ModelAttribute(“design”) 是错的，只是designcontrol，另外，空白框旁的true/false不知道哪来的，）。</p>
<p>5.使用视图控制器，删除homecontrol，修改homecontroltest。</p>
<h3 id="第三章中"><a href="#第三章中" class="headerlink" title="第三章中"></a>第三章中</h3><p>两个方法3.1和3.2是并列的，可以用这个两种方法，JDBC和JPA，JPA比JDBC简单。</p>
<p>3.1中，ingredient库插入数据比较简单，只插入一个库，但是taco和order比较难，都有两个库要插入，插入一个库之后需要获得一个id才能插入第二个库，3.1.4具体持久化方法中提供了两种方法，第二种比第一种简单。</p>
<p>对于ingredient，需要预插入数据。</p>
<p>对designcontrol、ordercontrol的修改，第一在于构造方法将数据库注入到控制器中，第二在于post方法提交表单需要将数据存入数据库。</p>
<p>其中涉及到session，用于保存在会话中的 order 属性，并且可以<strong>跨多个请求使用</strong>。因为存入order数据库的数据里有taco相关的数据，需要session暂存一下。</p>
<h3 id="第三章第一节JDBC调试"><a href="#第三章第一节JDBC调试" class="headerlink" title="第三章第一节JDBC调试"></a>第三章第一节JDBC调试</h3><p><code>lsof -i:8080</code>查看端口占用   关闭进程 <code>kill pid</code></p>
<p>1.为领域类taco、order添加id和日期。</p>
<p>2.pom.xml里添加jdbc、h2依赖</p>
<p>3.关于ingredient的改变：data文件夹下ingredientrepo接口和jdbcingredientrepo类，类下find方法和save方法。改造DesignTacoController的构造方法和showDesignForm，将固定配料改为从数据库中读取配料。</p>
<p>4.写表，预加载数据，schema.sql  data.sql</p>
<p>5.设置TacoRepository、OrderRepository接口</p>
<p>6.关于taco，jdbc实现的JdbcTacoRepository类。designtacocontrol中持久化的过程，构造函数为post方法添加一个参数。改造post函数，添加持久化到数据库的过程。还要一个taco和order方法。order领域类内添加一个adddesign方法。</p>
<p>7.关于order的改变，使用SimpleJdbcInsert方法，实现JdbcOrderRepository类，ordercontrol中的持久化过程，构造函数和post函数做改变。</p>
<h3 id="错误记录1"><a href="#错误记录1" class="headerlink" title="错误记录1"></a>错误记录1</h3><p>错误输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error starting ApplicationContext. To display the conditions report re-run your application with <span class="string">&#x27;debug&#x27;</span> enabled.</span><br><span class="line"><span class="number">2021</span>-<span class="number">12</span>-<span class="number">27</span> <span class="number">13</span>:<span class="number">46</span>:<span class="number">56.526</span> ERROR <span class="number">1306</span> --- [  restartedMain] o.s.boot.SpringApplication               : Application run failed</span><br></pre></td></tr></table></figure>

<p>这个问题是因为在pom文件里面加入了mybatis（某）模块 却没有在config配置里面增加mybatis（它）的上下文导致启动报错的<br>starting ApplicationContext. To display the conditions report re-run your application with ‘debug’ enabled（这句话其实已经说得很明白了 在启动的时候 上下文错误 导致启动失败）<br>在配置文件里面加上mybatis的配置就行了</p>
<p>但是不知道说的配置文件是什么，尝试注释掉不用的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jetbrains<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>没用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;jdbcIngredientRepository&#x27;</span><br></pre></td></tr></table></figure>

<p> 这个问题一般是mapper里面的SQL语句写错了。可能是本来select，却写成了insert</p>
<p>找了半天，原来是schema.sql文件中语句的错误。</p>
<p>干！！！是因为复制过来有无效空格，没显示错误。</p>
<h3 id="错误记录2"><a href="#错误记录2" class="headerlink" title="错误记录2"></a>错误记录2</h3><p>也不知哪一步有问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">12</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">40</span>:<span class="number">36.800</span> ERROR <span class="number">1822</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">6</span>] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() <span class="keyword">for</span> servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.NullPointerException: <span class="keyword">null</span></span><br><span class="line">	at tacos.data.JdbcTacoRepository.saveTacoInfo(JdbcTacoRepository.java:<span class="number">51</span>) ~[classes/:na]</span><br><span class="line">	at tacos.data.JdbcTacoRepository.save(JdbcTacoRepository.java:<span class="number">28</span>) ~[classes/:na]</span><br></pre></td></tr></table></figure>

<p>在提交taco的时候，就会有500错误。</p>
<p>表单html文件就需要修改的，tomorrow看下表单做啥变化了。再换一下外面的文件，看是不是就能正常。</p>
<p>只是有一个design变成了taco，从数据库中拿配料种类，难道表单不需要连接数据库或者是控制器吗？？？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to convert property value of type java.lang.String to required type java.util.List for property ingredients; nested exception is java.lang.IllegalStateException: Cannot convert value of type java.lang.String to required type tacos.Ingredient for property ingredients[0]: no matching editors or conversion strategy found</span><br><span class="line"></span><br><span class="line">将java.lang.String类型的属性值转换为所需类型java.util.List属性成分失败;java.lang.IllegalStateException:不能转换java.lang.String类型的值到所需类型tacos。属性成分[0]的成分:没有找到匹配的编辑器或转换策略</span><br></pre></td></tr></table></figure>

<p>1.designcontrol和ordercontrol两个控制器，需要加session，<code>@SessionAttributes(&quot;order&quot;)</code></p>
<p>2.原来的pom.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Taco Cloud Example<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jetbrains<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xml-apis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xml-apis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.04<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.bytebuddy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>byte-buddy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>替换了视图控制器、表单、pom文件，才变对的。</p>
<h3 id="第三章第二节JPA调试"><a href="#第三章第二节JPA调试" class="headerlink" title="第三章第二节JPA调试"></a>第三章第二节JPA调试</h3><p>1.在pom.xml中添加依赖starter<br>疑问：add … to classpath 是什么意思，往pom里添加依赖吗？</p>
<p>问题：</p>
<p><img src="https://img-blog.csdnimg.cn/4da10c38ab5a41329f7d2cebdc2e1e93.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p><code>Dependency &#39;org.springframework.boot:spring-boot-starter-data-jpa:2.6.1&#39; not found </code></p>
<p>案例中的代码无configuration。<code>错误: 找不到或无法加载主类 tacos.TacoCloudApplication</code></p>
<p>2.库接口定义</p>
<p>3.可自动实现，可自定义实现</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>《Spring实战》</title>
    <url>/2021/12/15/myblog/JAVA/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B/</url>
    <content><![CDATA[<p>本书介绍如何使用Spring和Spring Boot开发基于Web、数据库作为后端的Java应用。如何与其他应用进行集成，使用反应式类型进行编程，以及将应用拆分成离散的微服务。最后如何准备应用的部署。</p>
<p>Spring5.0和Spring Boot2.0</p>
<h1 id="第一章-Spring起步"><a href="#第一章-Spring起步" class="headerlink" title="第一章 Spring起步"></a>第一章 Spring起步</h1><h2 id="什么是spring"><a href="#什么是spring" class="headerlink" title="什么是spring"></a>什么是spring</h2><p>spring支持：面向云的由微服务组成的应用，反应式编程，致力于通过非阻塞操作提供更好的扩展性并提升性能。通过spring boot简化自己的开发模型。</p>
<p>Spring 的核心是一个 <em>容器（container）</em>，通常称为 <em>Spring 应用程序上下文</em>，用于创建和管理应用程序组件。这些组件（或 bean）在 Spring 应用程序上下文中连接在一起以构成一个完整的应用程序，就像将砖、灰浆、木材、钉子、管道和电线绑在一起以组成房屋。</p>
<p>将 bean 连接在一起的行为是基于一种称为 <em>依赖注入</em>（dependency injection，DI）的模式。组件不会再去创建它所依赖的组件并管理它们的生命周期，使用依赖注入的应用依赖于单独的实体（容器）来创建和维护所有的组件，并将其注入到需要它们的bean中。通常通过构造函数参数或属性访问器方法完成此操作。总结：应用组件通过Spring的应用上下文来进行管理并实现互相注入。</p>
<p>距离：商品服务需要依赖于库存服务，库存服务需要注入到商品服务。</p>
<p>①从历史上看，引导 Spring 应用程序上下文将 bean 连接在一起的方式是使用一个或多个 XML 文件，这些文件描述了组件及其与其他组件的关系。例如，以下 XML 声明两个 bean，一个 <code>InventoryService bean</code> 和一个 <code>ProductService bean</code>，然后通过构造函数参数将 <code>InventoryService</code> 注入到 <code>ProductService</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;inventoryService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.example.InventoryService&quot;</span> /&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;productService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.example.ProductService&quot;</span> &gt;</span><br><span class="line">    &lt;constructor-arg ref=<span class="string">&quot;inventoryService&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>②但是，在最新版本的 Spring 中，基于 Java 的配置更为常见。以下基于 Java 的配置类等效于 XML 配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InventoryService <span class="title">inventoryService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InventoryService();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductService <span class="title">productService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductService(inventoryService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Configuration</code> 注释向 Spring 表明这是一个配置类，它将为 Spring 应用程序上下文提供 beans。 配置的类方法带有 <code>@Bean</code> 注释，指示它们返回的对象应作为 beans 添加到应用程序上下文中（默认情况下，它们各自的 bean IDs 将与定义它们的方法的名称相同）。</p>
<p>与基于 XML 的配置相比，基于 Java 的配置具有多个优点，包括更高的类型安全性和改进的可重构性。即使这样，仅当 Spring 无法自动配置组件时，才需要使用 Java 或 XML 进行显式配置。</p>
<p>③自动配置起源于 Spring 技术，即 <em>自动装配</em> 和 <em>组件扫描</em>。借助组件扫描，Spring 可以自动从应用程序的类路径中发现组件，并将其创建为 Spring 应用程序上下文中的 bean。通过自动装配，Spring 能够自动为组件注入它们所依赖的其他bean。</p>
<p>最近，随着 Spring Boot 的推出，自动配置的优势已经远远超出了组件扫描和自动装配。Spring Boot 是 Spring 框架的扩展，它提供了多项生产力增强功能。这些增强功能中最著名的就是 <em>自动配置</em>，在这种配置中，Spring Boot 可以根据类路径中的条目、环境变量和其他因素，合理地猜测需要配置哪些组件，并将它们装配在一起。</p>
<p>Spring Boot 自动配置大大减少了构建应用程序所需的显式配置（无论是 XML 还是 Java）的数量。</p>
<h2 id="初始化Spring应用程序"><a href="#初始化Spring应用程序" class="headerlink" title="初始化Spring应用程序"></a>初始化Spring应用程序</h2><p>使用 Spring、Spring Boot 以及各种相关的库和框架，创建一个在线应用程序。</p>
<p>依靠 Spring Initializr 来引导应用程序的创建。Spring Initializr 既是一个基于浏览器的 Web 应用程序，又是一个 REST API，它们可以生成一个基本的 Spring 项目结构，可以使用所需的任何功能充实自己。 使用 Spring Initializr 的几种方法如下：</p>
<p>1.从 Web 应用程序 <a href="http://start.spring.io/">http://start.spring.io</a> 创建<br>2.使用 curl 命令从命令行创建<br>3.使用 Spring Boot 命令行接口从命令行创建<br>4.使用 Spring Tool Suite 创建一个新项目的时候<br>5.使用 IntelliJ IDEA 创建一个新项目的时候<br>6.使用 NetBeans 创建一个新项目的时候</p>
<h3 id="使用Intellij-IDEA初始化项目"><a href="#使用Intellij-IDEA初始化项目" class="headerlink" title="使用Intellij IDEA初始化项目"></a>使用Intellij IDEA初始化项目</h3><p>File -&gt; new -&gt; Project -&gt; Spring Initializr -&gt; next。</p>
<p>type选Maven Project -&gt; next。（和maven的构建规范有关，Maven pom.xml）</p>
<p>展示项目依赖页，依赖是按照分类来组织的，已经选中的依赖将会在最右侧。选择依赖：devtools、lombok、web、thymeleaf -&gt; next。</p>
<p>输入项目名称和存放位置。finish</p>
<p>项目从Initializr下载并加载到工作空间中。加载和构建完成，就可以开发应用功能了。</p>
<h3 id="Spring项目目录"><a href="#Spring项目目录" class="headerlink" title="Spring项目目录"></a>Spring项目目录</h3><p>典型的Maven或Gradle项目结构，应用源码在src/main/java中，测试代码在src/test/java中，非java资源在src/main/resources。</p>
<p><code>mvnw</code> 和 <code>mvnw.cmd</code> —— 这些是 Maven 包装器脚本。即使你的计算机上没有安装 Maven，也可以使用这些脚本构建项目。</p>
<p><code>pom.xml</code> —— 这是 Maven 构建规范。</p>
<p><code>TacoCloudApplication.java</code> —— 这是引导项目的 Spring Boot 主类。稍后，我们将在这节详细介绍。</p>
<p><code>application.properties</code> —— 该文件最初为空，但提供了一个可以指定配置属性的地方。我们将在本章中对此文件进行一些修改，但在第 5 章中将详细介绍配置属性。</p>
<p><code>static</code> —— 在此文件夹中，可以放置要提供给浏览器的任何静态内容（图像、样式表、JavaScript 等），最初为空。</p>
<p><code>templates</code> —— 在此文件夹中，放置用于向浏览器呈现内容的模板文件。最初为空，但很快会添加 Thymeleaf 模板。</p>
<p><code>TacoCloudApplicationTests.java</code> —— 这是一个简单的测试类，可确保成功加载 Spring 应用程序上下文。开发应用程序时，将添加更多的测试。</p>
<h4 id="构建规范pom-xml"><a href="#构建规范pom-xml" class="headerlink" title="构建规范pom.xml"></a>构建规范pom.xml</h4><p>填写 Initializr 表单时，指定使用 Maven 构建项目。因此，Spring Initializr 给了一个 pom.xml 文件，该文件已经填充了所做的选择。</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring boot插件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;excludes&gt;</span><br><span class="line">                    &lt;exclude&gt;</span><br><span class="line">                        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">                    &lt;/exclude&gt;</span><br><span class="line">                &lt;/excludes&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;packaging&gt;</code>选择将应用程序构建为可执行的 JAR 文件，而不是 WAR 文件。毕竟，传统的 Java web 应用程序被打包为 WAR 文件，而 JAR 文件是库和偶尔使用的桌面 UI 应用程序的首选打包方式。虽然 WAR 文件非常适合部署到传统的 Java 应用服务器，但是它们并不适合大多数云平台。尽管一些云平台（如 Cloud Foundry）能够部署和运行 WAR 文件，但是所有的 Java 云平台都能够运行可执行的 JAR 文件。因此，Spring Initializr 默认为 JAR 打包。</p>
<p><code>&lt;parent&gt;</code> 元素，指定项目将 <code>spring-boot-starter-parent</code> 作为它的父 POM。除此之外，这个父 POM 还为 Spring 项目中常用的几个库提供依赖项管理。对于父 POM 覆盖的那些库，不必指定版本，因为它是从父 POM 继承的。</p>
<p><code>&lt;dependencies&gt;</code> 元素下声明了三个依赖项。前两个看起来应该比较熟悉。它们直接对应于在单击 Spring Tool Suite 新建项目向导中的 Finish 按钮之前选择的 Web 和 Thymeleaf 依赖项。第三个依赖项提供了许多有用的测试功能，你不必选中包含它的方框，因为 Spring Initializr 假定你将编写测试。</p>
<p>Spring Boot starter 依赖项的特殊之处在于，它们本身通常没有任何库代码，而是间接地引入其他库。这些 starter 依赖提供了三个主要的好处：</p>
<ul>
<li>构建的文件将会小得多，也更容易管理，因为不需要对每一个可能需要的库都声明一个依赖项。</li>
<li>可以根据它们提供的功能来考虑需要的依赖关系，而不是根据库名来考虑。如果正在开发一个 web 应用程序，那么将添加 web starter 依赖项，而不是一个编写 web 应用程序的各个库的清单。</li>
<li>不用担心 library 版本问题。可以相信的是，对于给定版本的 Spring Boot，可间接地引入的库的版本将是兼容的，只需要考虑使用的是哪个版本的 Spring Boot。</li>
</ul>
<p>最后，构建规范以 Spring Boot 插件结束。这个插件执行一些重要的功能：</p>
<ul>
<li>提供了一个 Maven 编译目标，让你能够使用 Maven 运行应用程序。</li>
<li>确保所有的依赖库都包含在可执行的 JAR 文件中，并且在运行时类路径中可用。</li>
<li>在 JAR 文件中生成一个 manifest 文件，将引导类（在本书例子中是 <code>TacoCloudApplication</code>）声明为可执行 JAR 的主类。</li>
</ul>
<h4 id="引导应用TacoCloudApplication"><a href="#引导应用TacoCloudApplication" class="headerlink" title="引导应用TacoCloudApplication"></a>引导应用TacoCloudApplication</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TacoCloudApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TacoCloudApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@SpringBootApplication</code> 注释清楚地表明这是一个 Spring 引导应用程序。<code>@SpringBootApplication</code> 是一个组合了其他三个注释的复合应用程序：</p>
<p>（1）<code>@SpringBootConfiguration</code> —— 指定这个类为配置类。尽管这个类中还没有太多配置，但是如果需要，可以将 Javabased Spring Framework 配置添加到这个类中。实际上，这个注释是<code>@Configuration</code> 注释的一种特殊形式。</p>
<p>（2）<code>@EnableAutoConfiguration</code> —— 启用 Spring 自动配置。稍后我们将详细讨论自动配置。现在，要知道这个注释告诉 Spring Boot 自动配置它认为需要的任何组件。</p>
<p>（3）<code>@ComponentScan</code> —— 启用组件扫描。这允许你声明其他带有 <code>@Component</code>、<code>@Controller</code>、<code>@Service</code> 等注释的类，以便让 Spring 自动发现它们并将它们注册为 Spring 应用程序上下文中的组件。</p>
<p><code>TacoCloudApplication</code> 的另一个重要部分是 <code>main()</code> 方法。这个方法将在执行 JAR 文件时运行。在大多数情况下，这种方法是样板代码；编写的每个 Spring 引导应用程序都有一个类似或相同的方法（尽管类名不同）。</p>
<p><code>main()</code> 方法调用 SpringApplication 类上的静态 <code>run()</code> 方法，该方法执行应用程序的实际引导，创建<code>Spring</code> 应用程序上下文。传递给 <code>run()</code> 方法的两个参数是一个配置类和命令行参数。虽然传递给 <code>run()</code> 的配置类不必与引导类相同，但这是最方便、最典型的选择。</p>
<p>你可能不需要更改引导类中的任何内容。对于简单的应用程序，你可能会发现在引导类中配置一两个其他组件很方便，但是对于大多数应用程序，最好为任何没有自动配置的东西创建一个单独的配置类。</p>
<h4 id="测试应用TacoCloudApplicationTests"><a href="#测试应用TacoCloudApplicationTests" class="headerlink" title="测试应用TacoCloudApplicationTests"></a>测试应用TacoCloudApplicationTests</h4><p>测试是软件开发的一个重要部分。认识到这一点后，Spring Initializr 提供了一个测试类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TacoCloudApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中的一个测试方法是空的。尽管如此，这个测试类确实执行了必要的检查，以确保 Spring 应用程序上下文能够成功加载。如果做了任何阻止创建 Spring 应用程序上下文的更改，则此测试将失败，这样你就可以通过解决问题来应对。</p>
<p>还要注意用 <code>@RunWith(SpringRunner.class)</code> 注释的类。<code>@RunWith</code> 是一个 JUnit 注释，提供了一个测试运行器来引导 JUnit 运行测试用例。请将清单 1.3 看作是对它的基准应用程序测试，即将插件应用到 JUnit 以提供自定义测试行为。在本例中，JUnit 被赋予了 SpringRunner，这是一个由 Spring 提供的测试运行程序，它提供了创建一个 Spring 应用程序上下文的功能，以供测试运行。</p>
<p>尽管 <code>@RunWith(SpringRunner.class)</code> 和 <code>@SpringBootTest</code> 的任务是加载用于测试的 Spring 应用程序上下文，但是如果没有任何测试方法，它们将没有任何事情要做。即使没有任何断言或任何类型的代码，这个空的测试方法也会调用两个注释完成它们的工作，并加载 Spring 应用程序上下文。如果运行过程中有任何问题，测试就会失败。</p>
<h2 id="编写Spring应用程序"><a href="#编写Spring应用程序" class="headerlink" title="编写Spring应用程序"></a>编写Spring应用程序</h2><p>添加到 Taco Cloud 应用程序的第一个功能是主页，当添加主页，将创建两个代码构件：</p>
<ul>
<li>一个处理主页请求的控制器类</li>
<li>一个视图模板，定义了主页的外观</li>
</ul>
<p>因为测试很重要，所以还将编写一个简单的测试类来测试主页。但首先…来写这个控制器。</p>
<h3 id="处理web请求"><a href="#处理web请求" class="headerlink" title="处理web请求"></a>处理web请求</h3><p>Spring 附带了一个强大的 web 框架，称为 Spring MVC。Spring MVC 的核心是控制器的概念，这是一个处理请求并使用某种信息进行响应的类。对于面向浏览器的应用程序，控制器的响应方式是可选地填充模型数据并将请求传递给视图，以生成返回给浏览器的 HTML。</p>
<p>现在，将编写一个简单的控制器类来处理根路径的请求（例如 <code>/</code>），并将这些请求转发到主页视图，而不填充任何模型数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Controller</code> 注释的主要目的是将该类识别为组件扫描的组件。由于 <code>HomeController</code> 是用 <code>@Controller</code> 注释的，因此 Spring 的组件扫描会自动发现它，并在 Spring 应用程序上下文中创建一个 <code>HomeController</code> 实例作为 bean。</p>
<p>实际上，其他一些注释（包括 <code>@Component</code>、<code>@Service</code> 和 <code>@Repository</code>）的用途与 <code>@Controller</code> 类似。你可以用任何其他的注解来有效地注释 <code>HomeController</code>，它仍然可以工作。但是，选择 <code>@Controller</code> 更能描述该组件在应用程序中的角色。</p>
<p><code>home()</code> 方法与控制器方法一样简单。它使用 <code>@GetMapping</code> 进行注释，以指示如果接收到根路径 <code>/</code> 的 HTTP GET 请求，则此方法应该处理该请求。除了返回 <code>home</code> 的 <code>String</code> 值外，它什么也不做。此值被解释为视图的逻辑名称。如何实现该视图取决于几个因素，但是因为 Thymeleaf 在类路径中，所以可以使用 Thymeleaf 定义该模板。</p>
<h3 id="Thymeleaf模板引擎"><a href="#Thymeleaf模板引擎" class="headerlink" title="Thymeleaf模板引擎"></a>Thymeleaf模板引擎</h3><p>为什么不是 JSP？为什么不是 FreeMarker？</p>
<p>模板名称由逻辑视图名称派生而来，它的前缀是 /templates/，后缀是 .html。模板的结果路径是 /templates/home.html。因此，需要将模板放在项目的 /src/main/resources/templates/home.html 中。</p>
<p>为了保持主页简洁，它做的只是欢迎用户访问网站。程序显示了定义 Taco Cloud 主页的基本 Thymeleaf 模板。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span><br><span class="line">      xmlns:th=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Taco Cloud&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;Welcome to...&lt;/h1&gt;</span><br><span class="line">        &lt;img th:src=<span class="string">&quot;@&#123;/images/TacoCloud.png&#125;&quot;</span>/&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;img&gt;</code> 标记使用一个 Thymeleaf 的 th:src 属性和一个 @{…} 表达式引用具有上下文相对路径的图片。这意味着 Taco Cloud 标志图片也必须驻留在项目的 /src/main/resources/static/images/TacoCloud.png 中。</p>
<h3 id="测试控制器"><a href="#测试控制器" class="headerlink" title="测试控制器"></a>测试控制器</h3><p>在对 HTML 页面的内容进行断言时，测试 web 应用程序可能比较棘手。幸运的是，Spring 提供了一些强大的测试支持，使测试 web 应用程序变得很容易。就主页而言，将编写一个与主页本身复杂度相当的测试。你的测试将对根路径 <code>/</code> 执行一个 HTTP GET 请求并期望得到一个成功的结果，其中视图名称为 home，结果内容包含短语 “Welcome to…”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.containsString;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(HomeController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHomePage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            .andExpect(status().isOk())</span><br><span class="line">            .andExpect(view().name(<span class="string">&quot;home&quot;</span>))</span><br><span class="line">            .andExpect(content().string(containsString(<span class="string">&quot;Welcome to...&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HomeControllerTest</code> 使用 <code>@WebMvcTest</code> 注释，而不是 <code>@SpringBootTest</code> 标记。这是 Spring Boot 提供的一个特殊测试注释，它安排测试在 Spring MVC 应用程序的上下文中运行。更具体地说，在本例中，它安排 <code>HomeController</code> 在 Spring MVC 中注册，这样你就可以对它进行请求。</p>
<p><code>@WebMvcTest</code> 还为测试 Spring MVC 提供了 Spring 支持。虽然可以让它启动服务器，但模拟 Spring MVC 的机制就足以满足你的目的了。测试类被注入了一个 <code>MockMvc</code> 对象中，以此用来测试来驱动模型。</p>
<p><code>testHomePage()</code> 方法定义了要对主页执行的测试。它从 <code>MockMvc</code> 对象开始，执行针对 <code>/</code>（根路径）的 HTTP GET 请求。该请求规定了下列期望值：</p>
<ul>
<li>响应应该有一个HTTP 200（OK）状态。</li>
<li>视图应该有一个合理的主页名称。</li>
<li>呈现的视图应该包含 “Welcome to…”</li>
</ul>
<p>如果在 <code>MockMvc</code> 对象执行请求之后，这些期望中的任何一个都没有满足，那么测试就会失败。但是控制器和视图模板是为了满足这些期望而编写的，所以测试应该能够通过，或者至少能够通过一些表示测试通过的绿色提示。</p>
<p>控制器写好了，视图模板创建好了，测试通过了。看来你已经成功地实现了主页。</p>
<h3 id="构建并运行应用"><a href="#构建并运行应用" class="headerlink" title="构建并运行应用"></a>构建并运行应用</h3><p>Spring Boot Dashboard 的便利功能可以帮助你在 IDE 中运行应用程序。<strong>Spring Boot Dashboard</strong> （指示板，仪表盘）显示为一个选项卡，通常位于 IDE 窗口的左下方。</p>
<blockquote>
<p>如何在idea中启动Spring Boot Dashboard：<a href="https://jingyan.baidu.com/article/ce4366495a1df73773afd3d3.html">https://jingyan.baidu.com/article/ce4366495a1df73773afd3d3.html</a></p>
</blockquote>
<p>当应用程序启动时，将在控制台中看到一些 Spring ASCII 图飞过，然后看到一些日志条目描述应用程序启动时的步骤。在停止日志记录之前，将看到一个日志条目，其中说 Tomcat 在 port(s): 8080 (http) 上启动，这意味着已经准备好将 web 浏览器指向主页，以查看结果。</p>
<p>等一下，Tomcat 启动？何时将应用程序部署到 Tomcat？</p>
<p>Spring Boot 应用程序倾向于裹挟所有需要的东西，而不需要部署到某个应用服务器。你从未将应用程序部署到 Tomcat… 其实 Tomcat 是应用程序的一部分！(将在 1.3.6 小节中详细描述 Tomcat 如何成为应用程序的一部分的。)</p>
<p>现在应用程序已经启动，将 web 浏览器指向 <a href="http://localhost:8080/">http://localhost:8080</a>（或单击 Spring Boot Dashboard 中地球仪样子的按钮)。</p>
<p>同一共有网下，可以通过ip访问到。<code>ifconfig en0</code></p>
<p><img src="https://img-blog.csdnimg.cn/15e1c5c2492e4dbdb6f01e76bdd87b00.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h3 id="Spring-Boot-DevTools"><a href="#Spring-Boot-DevTools" class="headerlink" title="Spring Boot DevTools"></a>Spring Boot DevTools</h3><p>在初始化项目时将其作为依赖项进行选择。Spring Boot DevTools作为一个依赖项出现在生成的 pom.xml 文件中。Spring Boot Dashboard 甚至显示项目已经启用了 DevTools。但是什么是 DevTools，它能为您做什么？</p>
<p>DevTools 为 Spring 开发人员提供了一些方便的开发同步工具。这些是：</p>
<ul>
<li>当代码更改时自动重启应用程序</li>
<li>当以浏览器为目标的资源（如模板、JavaScript、样式表等）发生变化时，浏览器会自动刷新</li>
<li>自动禁用模板缓存</li>
<li>如果 H2 数据库正在使用，则在 H2 控制台中构建</li>
</ul>
<p>（1）自动重启应用程序</p>
<p>（2）自动刷新浏览器和禁用模板缓存</p>
<p>（3）内置的H2控制台</p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>以下是构建基于 Spring 的 Taco Cloud 应用程序的步骤：</p>
<ol>
<li>使用 Spring Initializr 创建了一个初始项目结构。</li>
<li>写了一个控制器类来处理主页请求。</li>
<li>定义了一个视图模板来呈现主页。</li>
<li>写了一个简单的测试类来检验上诉工作。</li>
</ol>
<p>控制器类中的两行代码，而视图模板中没有 Spring 的特定代码。尽管测试类的大部分都使用了 Spring 的测试支持，但是在测试上下文中，它的侵入性似乎要小一些。</p>
<p>这是使用 Spring 开发的一个重要好处。可以关注于满足应用程序需求的代码，而不是满足框架的需求。尽管确实需要不时地编写一些特定于框架的代码，但这通常只是代码库的一小部分。如前所述，Spring （以及 Spring Boot）可以被认为是 <em>无框架的框架</em>。</p>
<p>这到底是怎么回事？Spring 在幕后做了什么来确保您的应用程序需求得到满足？为了理解 Spring 在做什么，让我们从构建规范开始。</p>
<p>在 pom.xml 文件中，声明了对 Web 和 Thymeleaf 启动器的依赖。这两个依赖关系带来了一些其他的依赖关系，包括：</p>
<ul>
<li>Spring MVC 框架</li>
<li>嵌入式 Tomcat</li>
<li>Thymeleaf 和 Thymeleaf 布局方言</li>
</ul>
<p>它还带来了 Spring Boot 的自动配置库。当应用程序启动时，Spring Boot 自动配置自动检测这些库并自动执行：</p>
<ul>
<li>在 Spring 应用程序上下文中配置 bean 以启用 Spring MVC</li>
<li>将嵌入式 Tomcat 服务器配置在 Spring 应用程序上下文中</li>
<li>为使用 Thymeleaf 模板呈现 Spring MV C视图，配置了一个 Thymeleaf 视图解析器</li>
</ul>
<p>简而言之，自动配置完成了所有繁重的工作，让你专注于编写实现应用程序功能的代码。</p>
<h2 id="俯瞰Spring风景线"><a href="#俯瞰Spring风景线" class="headerlink" title="俯瞰Spring风景线"></a>俯瞰Spring风景线</h2><p>Spring Initializr Web表单里提供了100多个可选的依赖项。</p>
<h3 id="Spring核心框架"><a href="#Spring核心框架" class="headerlink" title="Spring核心框架"></a>Spring核心框架</h3><p>Spring 核心框架是 Spring 领域中其他一切的基础。它提供了核心容器和依赖注入框架。但它也提供了一些其他的基本特性。</p>
<p>其中包括 Spring MVC 和 Spring web 框架。已经了解了如何使用 Spring MVC 编写控制器类来处理 web 请求。但是，还没有看到的是，Spring MVC 也可以用于创建产生非 HTML 输出的 REST API。将在第 2 章深入研究 Spring MVC，然后在第 6 章中讨论如何使用它来创建 REST API。</p>
<p>Spring 核心框架还提供了一些基本数据持久性支持，特别是基于模板的 JDBC 支持。将在第 3 章中看到如何使用 JdbcTemplate。</p>
<p>在 Spring 的最新版本（5.0.8）中，添加了对响应式编程的支持，包括一个新的响应式 web 框架 —— Spring WebFlux，它大量借鉴了 Spring MVC。将在第 3 部分中看到 Spring 的响应式编程模型，并在第 10 章中看到 Spring WebFlux。</p>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>已经看到了 Spring Boot 的许多好处，包括启动依赖项和自动配置。在本书中我们确实会尽可能多地使用 Spring Boot，并避免任何形式的显式配置，除非绝对必要。但除了启动依赖和自动配置，Spring Boot 还提供了一些其他有用的特性：</p>
<ul>
<li>Actuator 提供了对应用程序内部工作方式的运行时监控，包括端点、线程 dump 信息、应用程序健康状况和应用程序可用的环境属性。</li>
<li>灵活的环境属性规范。</li>
<li>在核心框架的测试辅助之外，还有额外的测试支持。</li>
</ul>
<p>此外，Spring Boot 提供了一种基于 Groovy 脚本的替代编程模型，称为 Spring Boot CLI（命令行界面）。使用 Spring Boot CLI，可以将整个应用程序编写为 Groovy 脚本的集合，并从命令行运行它们。我们不会在 Spring Boot CLI 上花太多时间，但是当它适合我们的需要时，我们会接触它。</p>
<p>Spring Boot 已经成为 Spring 开发中不可或缺的一部分；我无法想象开发一个没有它的 Spring 应用程序。因此，本书采用了以 Spring Boot 为中心的观点，当我提到 Spring Boot 正在做的事情时，你可能会发现我在使用 Spring 这个词。</p>
<h3 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h3><p>尽管 Spring 核心框架提供了基本的数据持久性支持，但 Spring Data 提供了一些非常惊人的功能：将应用程序的数据存储库抽象为简单的 Java 接口，同时当定义方法用于如何驱动数据进行存储和检索的问题时，对方法使用了命名约定。</p>
<p>更重要的是，Spring Data 能够处理几种不同类型的数据库，包括关系型（JPA）、文档型（Mongo）、图型（Neo4j）等。在第 3 章中，将使用 Spring Data 来帮助创建 Taco Cloud 应用程序的存储库。</p>
<h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><p>应用程序安全性一直是一个重要的主题，而且似乎一天比一天重要。幸运的是，Spring 在 Spring security 中有一个健壮的安全框架。</p>
<p>Spring Security 解决了广泛的应用程序安全性需求，包括身份验证、授权和 API 安全性。尽管 Spring Security 的范围太大，本书无法恰当地涵盖，但我们将在第 4 章和第 12 章中讨论一些最常见的用例。</p>
<h3 id="Spring-Integration-和-Spring-Batch"><a href="#Spring-Integration-和-Spring-Batch" class="headerlink" title="Spring Integration 和 Spring Batch"></a>Spring Integration 和 Spring Batch</h3><p>在某种程度上，大多数应用程序将需要与其他应用程序集成，甚至需要与同一应用程序的其他组件集成。为了满足这些需求，出现了几种应用程序集成模式。Spring Integration 和 Spring Batch 为基于 Spring 的应用程序提供了这些模式的实现。</p>
<p>Spring Integration 解决了实时集成，即数据在可用时进行处理。相反，Spring Batch 解决了批量集成的问题，允许在一段时间内收集数据，直到某个触发器（可能是一个时间触发器）发出信号，表示该处理一批数据了。将在第 9 章中研究 Spring Batch 和 Spring Integration。</p>
<h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><p>在我写这篇文章的时候，应用程序开发领域正在进入一个新时代，在这个时代中，我们不再将应用程序作为单个部署单元来开发，而是将由几个称为 <em>微服务</em> 的单个部署单元组成应用程序。</p>
<p>微服务是一个热门话题，解决了几个实际的开发和运行时问题。然而，在这样做的同时，他们也带来了自己的挑战。这些挑战都将由 Spring Cloud 直接面对，Spring Cloud 是一组用 Spring 开发云本地应用程序的项目。</p>
<p>Spring Cloud 覆盖了很多地方，这本书不可能涵盖所有的地方。我们将在第 13、14 和 15 章中查看 Spring Cloud 的一些最常见的组件。关于 Spring Cloud 的更完整的讨论，我建议看看 John Carnell 的 Spring Microservices in Action（Manning, 2017, <a href="http://www.manning.com/books/spring-microservices-in-action%EF%BC%89%E3%80%82">www.manning.com/books/spring-microservices-in-action）。</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>Spring 的目标是让开发人员轻松应对挑战，比如创建 web 应用程序、使用数据库、保护应用程序和使用微服务。</p>
</li>
<li><p>Spring Boot 构建在 Spring 之上，简化了依赖管理、自动配置和运行时监控，让 Spring 变得更加简单。</p>
</li>
<li><p>Spring 应用程序可以使用 Spring Initializr 进行初始化，它是基于 web 的，并且在大多数 Java 开发环境中都支持它。</p>
</li>
<li><p>在 Spring 应用程序上下文中，组件（通常称为 bean）可以用 Java 或 XML 显式地声明，可以通过组件扫描进行发现，也可以用 Spring Boot 进行自动配置。</p>
</li>
</ul>
<h1 id="第二章-开发Web应用"><a href="#第二章-开发Web应用" class="headerlink" title="第二章 开发Web应用"></a>第二章 开发Web应用</h1><p>使用 Spring 构建的应用程序将执行各种操作，包括处理数据、从数据库中读取信息以及与其他应用程序进行交互。但是应用程序用户得到的第一印象来自于用户界面。在许多应用程序中，UI 界面是在浏览器中显示的 web 应用程序。</p>
<p>在第 1 章中，创建了第一个 Spring MVC 控制器来显示应用程序主页。但是 Spring MVC 能做的远不止简单地显示静态内容。在本章中，将开发 Taco Cloud 应用程序的第一个主要功能 —— 设计自定义 Taco 的能力。在此过程中，将深入研究 Spring MVC，并了解如何显示模型数据和处理表单输入。</p>
<h2 id="展示信息"><a href="#展示信息" class="headerlink" title="展示信息"></a>展示信息</h2><p>在 Spring web 应用程序中，获取和处理数据是控制器的工作。视图的工作是将数据渲染成 HTML 并显示在浏览器中。将创建以下组件来支持 Taco 创建页面，使得用户可以自选配料：</p>
<ul>
<li>一个定义玉米卷成分特性的领域类</li>
<li>一个 Spring MVC 控制器类，它获取成分信息并将其传递给视图</li>
<li>一个视图模板，在用户的浏览器中呈现一个成分列表</li>
</ul>
<h3 id="构建领域类"><a href="#构建领域类" class="headerlink" title="构建领域类"></a>构建领域类</h3><p>在编写控制器和视图之前，让我们先确定表示配料的域类型。这将为开发 web 组件奠定基础。</p>
<p>应用程序的域是它所处理的主题领域 —— 影响应用程序理解的思想和概念。在 Taco Cloud 应用程序中，领域包括 Taco 设计、组成这些设计的成分、客户和客户下的 Taco 订单等对象。首先，我们将关注玉米饼配料。</p>
<p>在领域中，玉米饼配料是相当简单的对象。每一种都有一个名称和一个类型，这样就可以在视觉上对其进行分类（蛋白质、奶酪、酱汁等）。每一个都有一个 ID，通过这个 ID 可以轻松、明确地引用它。下面的成分类定义了需要的域对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ingredient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个普通的 Java 域类，定义了描述一个成分所需的三个属性。对于程序 中定义的 <code>Ingredient</code> 类，最不寻常的事情可能是它似乎缺少一组常用的 getter 和 setter 方法，更不用说像 <code>equals()</code>、<code>hashCode()</code>、<code>toString()</code> 等有用的方法。</p>
<p>在清单中看不到它们，部分原因是为了节省空间，但也因为使用了一个名为 Lombok 的出色库，它会在运行时自动生成这些方法。实际上，类级别的 <code>@Data</code> 注释是由 Lombok 提供的，它告诉 Lombok 生成所有缺少的方法，以及接受所有<code>final</code>属性作为参数的构造函数。通过使用 Lombok，可以让 <code>Ingredient</code> 的代码保持整洁。</p>
<p>Lombok 不是一个 Spring 库，但是它非常有用，没有它我很难开发。当我需要在一本书中保持代码示例简短明了时，它就成了我的救星。</p>
<p>要使用 Lombok，需要<strong>将其作为依赖项添加到项目</strong>中。如果正在使用 Spring Tool Suite，只需右键单击 pom.xml 文件并从 Spring 上下文菜单选项中选择 Edit Starters 即可。在第 1 章（图 1.4）中给出的依赖项的相同选择将出现，这样就有机会添加或更改所选的依赖项。找到 Lombok 选项，确保选中，然后单击 OK；Spring Tool Suite 将自动将其添加到构建规范中。</p>
<p>或者，可以使用 pom.xml 中的以下条目手动添加它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;<span class="keyword">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>此依赖项将在开发时提供 Lombok 注释（如 <code>@Data</code>），并在运行时提供自动方法生成。但是还需要<strong>在 IDE 中添加 Lombok 作为扩展</strong>，否则 IDE 将会报错缺少方法和没有设置的最终属性。请访问 <a href="https://projectlombok.org/%EF%BC%8C%E4%BB%A5%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E5%9C%A8">https://projectlombok.org/，以了解如何在</a> IDE 中安装 Lombok。</p>
<p>你会发现 Lombok 非常有用，但它是可选的。如果不希望使用它，或是不需要它来开发 Spring 应用程序，那么请随意手动编写那些缺少的方法。继续……我将等待。完成后，将添加一些控制器来处理应用程序中的 web 请求。</p>
<blockquote>
<p>笔记：IDEA如何为pom.xml导入依赖？</p>
<p><a href="https://www.jb51.net/article/193912.htm">https://www.jb51.net/article/193912.htm</a></p>
<p>虽然项目里本身就有，不知道reimport是不是真的有效果，没有找到重新选择依赖的方法。</p>
</blockquote>
<blockquote>
<p>笔记：在 IDE 中添加 Lombok 作为扩展？</p>
<p>Lombok是一个可以通过简单的注解形式来帮助我们简化消除一些必须有但显得很臃肿的Java代码的工具，通过使用对应的注解，可以在编译源码的时候生成对应的方法。</p>
<p>1.plugin中下载lombok插件  <a href="https://www.jb51.net/article/214041.htm">https://www.jb51.net/article/214041.htm</a></p>
<p>2.配置一下，enable annotation processing 启用注释处理  <a href="https://blog.csdn.net/xiaoxiamimm/article/details/113882655">https://blog.csdn.net/xiaoxiamimm/article/details/113882655</a></p>
<p>3.pom.xml中添加lombok依赖</p>
</blockquote>
<h3 id="创建控制器类"><a href="#创建控制器类" class="headerlink" title="创建控制器类"></a>创建控制器类</h3><p>控制器是 Spring MVC 框架的主要参与者。它们的主要工作是处理 HTTP 请求，或者将请求传递给视图以呈现 HTML（浏览器显示），或者直接将数据写入响应体（RESTful）。在本章中，将重点讨论使用视图为 web 浏览器生成内容的控制器的类型。在第 6 章中，我们将讨论如何在 REST API 中编写处理请求的控制器。</p>
<p>对于 Taco Cloud 应用程序，需要一个简单的控制器来执行以下操作，一个显示配料的控制器：</p>
<ul>
<li>处理请求路径为 <code>/design</code> 的 HTTP GET 请求</li>
<li>构建成分列表</li>
<li>将请求和成分数据提交给视图模板，以 HTML 的形式呈现并发送给请求的 web 浏览器</li>
</ul>
<p>下面的 DesignTacoController 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.web;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Valid;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Errors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient.Type;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTacoController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showDesignForm</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        List&lt;Ingredient&gt; ingredients = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;FLTO&quot;</span>, <span class="string">&quot;Flour Tortilla&quot;</span>, Type.WRAP),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;COTO&quot;</span>, <span class="string">&quot;Corn Tortilla&quot;</span>, Type.WRAP),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;GRBF&quot;</span>, <span class="string">&quot;Ground Beef&quot;</span>, Type.PROTEIN),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;CARN&quot;</span>, <span class="string">&quot;Carnitas&quot;</span>, Type.PROTEIN),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;TMTO&quot;</span>, <span class="string">&quot;Diced Tomatoes&quot;</span>, Type.VEGGIES),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;LETC&quot;</span>, <span class="string">&quot;Lettuce&quot;</span>, Type.VEGGIES),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;CHED&quot;</span>, <span class="string">&quot;Cheddar&quot;</span>, Type.CHEESE),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;JACK&quot;</span>, <span class="string">&quot;Monterrey Jack&quot;</span>, Type.CHEESE),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;SLSA&quot;</span>, <span class="string">&quot;Salsa&quot;</span>, Type.SAUCE),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;SRCR&quot;</span>, <span class="string">&quot;Sour Cream&quot;</span>, Type.SAUCE)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Type[] types = Ingredient.Type.values();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            model.addAttribute(type.toString().toLowerCase(),</span><br><span class="line">                filterByType(ingredients, type));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;design&quot;</span>, <span class="keyword">new</span> Taco());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provided by &#x27;aexiaosong&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Ingredient&gt; <span class="title">filterByType</span><span class="params">(List&lt;Ingredient&gt; ingredients, Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ingredients.stream().filter(x -&gt; x.getType().equals(type)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Slf4j，它是 Lombok 提供的注释，在运行时将自动生成类中的 SLF4J（Java 的简单日志门面，<a href="https://www.slf4j.org/%EF%BC%89%E8%AE%B0%E5%BD%95%E5%99%A8%E3%80%82%E8%BF%99%E4%B8%AA%E9%80%82%E5%BD%93%E7%9A%84%E6%B3%A8%E9%87%8A%E5%85%B7%E6%9C%89%E4%B8%8E%E6%98%BE%E5%BC%8F%E5%9C%B0%E5%9C%A8%E7%B1%BB%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A5%E4%B8%8B%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%88%E6%9E%9C%EF%BC%9A">https://www.slf4j.org/）记录器。这个适当的注释具有与显式地在类中添加以下行相同的效果：</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.Logger log = </span><br><span class="line">       org.slf4j.LoggerFactory.getLogger(DesignTacoController.class);</span><br></pre></td></tr></table></figure>

<p>@Controller。此注释用于将该类标识为控制器并将其标记为组件扫描的候选对象，以便 Spring 将发现该类并在 Spring 应用程序上下文中自动创建 DesignTacoController 实例作为 bean。</p>
<p>@RequestMapping 注释在类级应用时，指定该控制器处理的请求的类型。在本例中，它指定 DesignTacoController 将处理路径以 <code>/design</code> 开头的请求。</p>
<p>@GetMapping 与类级别的 @RequestMapping 配对使用，指定何时接收 <code>/design</code> 的 HTTP GET 请求，showDesignForm() 将用来处理请求。@GetMapping 是一个相对较新的注释，是在 Spring 4.3 中引入的。在 Spring 4.3 之前，可能使用了一个方法级别的 @RequestMapping 注释作为替代<code>@RequestMapping(method=RequestMethod.GET) </code>。</p>
<p>showDesignForm() 方法将处理请求，让我们来看看方法体，看看它是如何工作的。该方法的大部分构造了一个成份对象列表。这个列表现在是硬编码的。当我们讲到第 3 章的时候，你会从数据库中找到玉米饼的原料列表。一旦准备好了原料列表，接下来的几行 showDesignForm() 将根据原料类型过滤该列表。然后将成分类型列表作为属性添加Model对象上，这个对象是以参数的形式传递给 showDesignForm() 方法的。Model 是一个对象，它在控制器和负责呈现数据的视图之间传输数据。最后，放置在 Model 类属性中的数据被复制到 servlet 响应属性中，视图可以在其中找到它们。showDesignForm() 方法最后返回 “design”，这是将用于向浏览器呈现 Model 的视图的逻辑名称。</p>
<p>DesignTacoController 真的开始成形了。如果您现在运行应用程序并将您的浏览器指向 <code>/design</code> 路径，DesignTacoController 的 showDesignForm() 将被占用，它从存储库中获取数据并将其放在 Model 中，然后将请求传递给视图。但是因为还没有定义视图，所以请求会发生可怕的转变，导致 HTTP 404（Not Found）错误。为了解决这个问题，让我们将注意力转移到视图上，其中的数据将用 HTML 进行修饰，并在用户的 web 浏览器中显示。</p>
<h3 id="设计视图"><a href="#设计视图" class="headerlink" title="设计视图"></a>设计视图</h3><p>控制器创建完成后，就该开始设计视图了。Spring 为定义视图提供了几个很好的选项，包括 JavaServer Pages（JSP）、Thymeleaf、FreeMarker、Mustache 和基于 Groovy 的模板。现在，我们将使用 Thymeleaf，这是我们在第 1 章开始项目时所做的选择。</p>
<p>像 Thymeleaf 这样的视图库被设计成与任何特定的 web 框架解耦。因此，他们不知道 Spring 的模型抽象，并且无法处理控制器放置在模型中的数据。但是它们可以处理 servlet 请求属性。因此，在 Spring 将请求提交给视图之前，它将模型数据复制到请求属性中，而 Thymeleaf 和其他视图模板选项可以随时访问这些属性。</p>
<p>Thymeleaf 模板只是 HTML 与一些额外的元素属性，指导模板在渲染请求数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Taco Cloud<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/styles.css&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Design your taco!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/images/TacoCloud.png&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;design&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;wraps&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Designate your wrap:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;wrap&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;proteins&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Pick your protein:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;protein&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cheeses&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Choose your cheese:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;cheese&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;veggies&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Determine your veggies:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;veggies&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sauces&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Select your sauce:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;sauce&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Name your taco creation:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;name&#125;&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span>&gt;</span>Submit your taco<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，对于每种类型的配料，都要重复 <code>&lt;div&gt;</code> 片段。还包括一个提交按钮和一个字段，用户可以在其中命名他们的创建。</p>
<p>值得注意的是，完整的模板包括 Taco Cloud 图标图片和一个指向样式表的 <code>&lt;link&gt;</code> 引用。在这两种情况下，Thymeleaf 的 <code>@&#123;&#125;</code> 操作符被用来产生一个上下文相关路径的静态工件，它们正在引用。正如在第 1 章中了解到的，Spring 启动应用程序中的静态内容是从类路径根目录的 /static 目录提供的。</p>
<p>现在控制器和视图已经完成，可以启动应用程序了。运行 Spring Boot 应用程序有许多方法。在第 1 章中，展示了如何运行这个应用程序，首先将它构建到一个可执行的 JAR 文件中，然后使用 <code>java -jar</code> 运行这个 JAR。展示了如何使用 <code>mvn spring-boot:run</code> 从构建中直接运行应用程序。</p>
<p>无论如何启动 Taco Cloud 应用程序，一旦启动，使用浏览器访问 <a href="http://localhost:8080/design%E3%80%82%E5%BA%94%E8%AF%A5%E7%9C%8B%E5%88%B0%E7%B1%BB%E4%BC%BC%E5%9B%BE">http://localhost:8080/design。应该看到类似图</a> 2.2 的页面。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><blockquote>
<p>笔记：IDEA自动import？</p>
<p>打开 IDEA 的首选项，找到 Editor | General | Auto Import。勾选上 <code>Add unambiguous imports on the fly</code> 和 <code>Optimize imports on the fly (for current project)</code>。</p>
</blockquote>
<p>出现问题：Springboot项目javax.validation找不到：</p>
<p>使用方法：<a href="https://www.jb51.net/article/185660.htm">https://www.jb51.net/article/185660.htm</a></p>
<p>找不到包：<a href="https://www.cnblogs.com/keadd/p/13652629.html">https://www.cnblogs.com/keadd/p/13652629.html</a></p>
<p>未解决，注释Taco类部分行。</p>
<p>运行不正确，应该是design.html中代码的问题，无法显示网页。</p>
<p>添加了一个webconfig.java文件，依然不行。</p>
<p>运行网上代码，是可以的。</p>
<h2 id="处理表单提交"><a href="#处理表单提交" class="headerlink" title="处理表单提交"></a>处理表单提交</h2><p>第一章显示taco首页，第二章显示配料选取页/design，服务端指定可选的配料，传递给客户端，客户端访问design页面通过get请求。客户端选择之后，需要进行表单提交，post请求，传递回服务端，路径相同，都是design。</p>
<p>需要在该 POST 请求的接收端上有一个控制器处理程序方法。需要在 DesignTacoController 中编写一个新的处理程序方法来处理 <code>/design</code> 接口的 POST 请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processDesign</span><span class="params">(Taco design)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Save the taco design...</span></span><br><span class="line">    <span class="comment">// We&#x27;ll do this in chapter 3</span></span><br><span class="line">    log.info(<span class="string">&quot;Processing design: &quot;</span> + design);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/orders/current&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当应用到 processDesign() 方法时，@PostMapping 与类级别 @RequestMapping 相协调，以表明 processDesign() 应该处理 <code>/design</code> 接口的 POST 请求。这正是需要处理的一个玉米饼艺术家提交的作品。</p>
<p>该方法需要传递一个Taco对象，里面包含了配料和名字等，方法中对taco对象进行处理。在第 3 章中，将添加一些持久性逻辑，将提交的 Taco 保存到数据库中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taco</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ingredients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Taco 是一个简单的 Java 域对象，具有两个属性。与 Ingredient 类似，Taco 类也使用 @Data 进行注释，以便在运行时自动生成基本的 JavaBean 方法。</p>
<p>与 showDesignForm() 方法一样，processDesign() 通过返回一个 String 结束。与 showDesignForm() 类似，返回的值指示将显示给用户的视图。但是不同的是，从 processDesign() 返回的值的前缀是 “redirect:”，表示这是一个重定向视图。更具体地说，它表明在 processDesign() 完成之后，用户的浏览器应该被重定向到相对路径 /order/current。</p>
<p>意思是重定向到另一个路径？ /order/current 相当于是/design一样的路径，因此需要用 @Controller、@RequestMapping 和 @GetMapping创建一个控制器。</p>
<p>展现订单表单的控制器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package tacos.web;</span><br><span class="line">​</span><br><span class="line">import javax.validation.Valid;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.validation.Errors;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import tacos.Order;</span><br><span class="line">​</span><br><span class="line">@Slf4j</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/orders&quot;)</span><br><span class="line">public class OrderController &#123;</span><br><span class="line">    @GetMapping(&quot;/current&quot;)</span><br><span class="line">    public String orderForm(Model model) &#123;</span><br><span class="line">        model.addAttribute(&quot;order&quot;, new Order());</span><br><span class="line">        return &quot;orderForm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Lombok 的 @Slf4j 注释在运行时创建一个 SLF4J Logger 对象。稍后，将使用这个 Logger 来记录提交的订单的详细信息。</p>
<p>类级别的 @RequestMapping 指定该控制器中的任何请求处理方法都将处理路径以 /orders 开头的请求。当与方法级 @GetMapping 结合使用时，它指定 orderForm() 方法将处理 /orders/current 的 HTTP GET 请求。</p>
<p>至于 orderForm() 方法本身，它非常简单，只返回 orderForm 的逻辑视图名。在第 3 章中，一旦有了把创建的 taco 持久化到数据库的方法，将重新访问该方法并修改它，以使用 taco 对象的列表填充模型，这些对象将按顺序放置。</p>
<p>orderForm 视图由一个名为 orderForm.html 的 Thymeleaf 模板提供，如下面显示的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Taco Cloud<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/styles.css&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/orders&#125;&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;order&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Order your taco creations!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/images/TacoCloud.png&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/design&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;another&quot;</span>&gt;</span>Design another taco<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#fields.hasErrors()&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;validationError&quot;</span>&gt;</span></span><br><span class="line">                    Please correct the problems below and resubmit.</span><br><span class="line">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Deliver my taco masterpieces to...<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;name&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;street&quot;</span>&gt;</span>Street address: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;street&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;city&quot;</span>&gt;</span>City: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;city&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;state&quot;</span>&gt;</span>State: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;state&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;zip&quot;</span>&gt;</span>Zip code: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;zip&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Here&#x27;s how I&#x27;ll pay...<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;ccNumber&quot;</span>&gt;</span>Credit Card #: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;ccNumber&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;ccExpiration&quot;</span>&gt;</span>Expiration: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;ccExpiration&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;ccCVV&quot;</span>&gt;</span>CVV: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;ccCVV&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit order&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>&lt;form&gt; </code>标记与design 中使用的 <code>&lt;form&gt; </code>标记不同，因为它还指定了一个表单操作。如果没有指定操作，表单将向呈现表单的相同 URL 提交 HTTP POST 请求。但是在这里，指定表单应该提交到 /orders（使用 Thymeleaf 的 <code>@&#123;…&#125;</code> 操作符作为上下文相关路径）。</p>
<blockquote>
<p>与design提交的post不同，那个url一样，而这个url本来是order/current，应该变为order。</p>
</blockquote>
<p>因此，需要添加另外一个方法到 OrderController 类中，去处理 /orders 接口的 POST 请求。在进行到下一章之前，还没有办法将订单持久化，因此在这里简化它 —— 类似于在下一个程序清单中看到的内容。</p>
<blockquote>
<p>重定向到订单，显示订单页，订单表单中，有订单提交，post请求，需要一个控制器。返回首页。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">public String processOrder(Order order) &#123;</span><br><span class="line">    log.info(&quot;Order submitted: &quot; + order);</span><br><span class="line">    return &quot;redirect:/&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 processOrder() 方法来处理提交的订单时，它将获得一个 order 对象，其属性绑定到提交的表单字段。Order 非常像 Taco，是一个相当简单的类，它携带订单信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Digits;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Pattern;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.CreditCardNumber;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="keyword">private</span> String zip;</span><br><span class="line">    <span class="keyword">private</span> String ccNumber;</span><br><span class="line">    <span class="keyword">private</span> String ccExpiration;</span><br><span class="line">    <span class="keyword">private</span> String ccCVV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="校验表单输入"><a href="#校验表单输入" class="headerlink" title="校验表单输入"></a>校验表单输入</h2><p>执行表单验证的一种方法是在 processDesign() 和 processOrder() 方法中加入一堆 if/then 块，检查每个字段以确保它满足适当的验证规则。但是这样做会很麻烦，并且难于阅读和调试。</p>
<p>幸运的是，Spring 支持 Java’s Bean Validation API（也称为 JSR-303；<a href="https://jcp.org/en/jsr/detail?id=303%EF%BC%89%E3%80%82%E8%BF%99%E4%BD%BF%E5%BE%97%E5%A3%B0%E6%98%8E%E9%AA%8C%E8%AF%81%E8%A7%84%E5%88%99%E6%AF%94%E5%9C%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%98%BE%E5%BC%8F%E5%9C%B0%E7%BC%96%E5%86%99%E5%A3%B0%E6%98%8E%E9%80%BB%E8%BE%91%E6%9B%B4%E5%AE%B9%E6%98%93%E3%80%82%E4%BD%BF%E7%94%A8">https://jcp.org/en/jsr/detail?id=303）。这使得声明验证规则比在应用程序代码中显式地编写声明逻辑更容易。使用</a> Spring Boot，不需要做任何特殊的事情来将验证库添加到项目中，因为 Validation API 和 Validation API 的 Hibernate 实现作为Spring Boot web 启动程序的临时依赖项自动添加到了项目中。</p>
<p>要在 Spring MVC 中应用验证，需要这样做：</p>
<ul>
<li>对要验证的类声明验证规则：特别是 Taco 类。</li>
<li>指定验证应该在需要验证的控制器方法中执行，具体来说就是：DesignTacoController 的 processDesign() 方法和 OrderController 的 processOrder() 方法。</li>
<li>修改表单视图以显示验证错误。</li>
</ul>
<h3 id="声明验证规则"><a href="#声明验证规则" class="headerlink" title="声明验证规则"></a>声明验证规则</h3><p>对于 Taco 类，希望确保 name 属性不是空的或 null 的，并且所选配料列表中至少有一项。下面的程序清单显示了一个更新后的 Taco 类，它使用 @NotNull 和 @Size 来声明这些验证规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taco</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(min=5, message=&quot;Name must be at least 5 characters long&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Size(min=1, message=&quot;You must choose at least 1 ingredient&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ingredients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当涉及到对提交玉米饼订单进行验证声明时，必须对 Order 类应用注解。对于地址的属性，只需要确保用户没有留下任何空白字段。对于这一点，将使用 Hibernate Validator 的 @NotBlank 注解。</p>
<p>支付领域的验证是一个比较奇特的存在。你不仅需要确保 ccNumber 属性不为空，还要确保它包含的是一个有效的信用卡号码的值。该 ccExpiration 属性必须符合 MM/YY（两位数的年/月）格式。而 ccCVV 属性必须是一个三位的数字。为了实现这种验证，需要使用一些其他的 Java Bean Validation API 注释，同时需要从 Hibernate Validator 集合中借用一些验证注解。下面程序清单列出了验证 Order 类所需要的改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Digits;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Pattern;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.CreditCardNumber;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;Name is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;Street is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;City is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;State is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;Zip code is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String zip;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CreditCardNumber(message=&quot;Not a valid credit card number&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ccNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pattern(regexp=&quot;^(0[1-9]|1[0-2])([\\/])([1-9][0-9])$&quot;,</span></span><br><span class="line"><span class="meta">             message=&quot;Must be formatted MM/YY&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ccExpiration;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Digits(integer=3, fraction=0, message=&quot;Invalid CVV&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ccCVV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，ccNumber 属性用 @CreditCardNumber 进行了注释。该注释声明属性的值必须是通过 Luhn 算法（<a href="https://en.wikipedia.org/wiki/Luhn_algorithm%EF%BC%89%E6%A3%80%E6%9F%A5%E8%BF%87%E7%9A%84%E6%9C%89%E6%95%88%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%8F%B7%E3%80%82%E8%BF%99%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E7%94%A8%E6%88%B7%E5%87%BA%E9%94%99%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%85%E6%84%8F%E9%94%99%E8%AF%AF%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%8F%B7%E7%A0%81%E5%AE%9E%E9%99%85%E4%B8%8A%E8%A2%AB%E5%88%86%E9%85%8D%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B8%90%E6%88%B7%EF%BC%8C%E6%88%96%E8%AF%A5%E5%B8%90%E6%88%B7%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E4%BA%A4%E6%98%93%E3%80%82">https://en.wikipedia.org/wiki/Luhn_algorithm）检查过的有效信用卡号。这可以防止用户出错的数据和故意错误的数据，但不能保证信用卡号码实际上被分配到一个帐户，或该帐户可以用于交易。</a></p>
<p>不幸的是，没有现成的注释来验证 ccExpiration 属性的 MM/YY 格式。我已经应用了 @Pattern 注释，为它提供了一个正则表达式，以确保属性值符合所需的格式。</p>
<p>最后，用 @Digits 注释 ccCVV 属性，以确保值恰好包含三个数字。</p>
<p>所有的验证注释都包含一个消息属性，该属性定义了如果用户输入的信息不符合声明的验证规则的要求时将显示给用户的消息。</p>
<h3 id="表单绑定时执行校验"><a href="#表单绑定时执行校验" class="headerlink" title="表单绑定时执行校验"></a>表单绑定时执行校验</h3><p>上一节在领域类中制定了验证规则，现在需要重新修改每个控制器，让表单在POST提交至对应的控制器方法时执行对应的校验。</p>
<p>要验证提交的 Taco，需要将 Java Bean Validation API 的 @Valid 注释添加到 DesignTacoController 的 processDesign() 方法的 Taco 参数中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processDesign</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@ModelAttribute(&quot;design&quot;)</span> Taco design, Errors errors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Save the taco design...</span></span><br><span class="line">    <span class="comment">// We&#x27;ll do this in chapter 3</span></span><br><span class="line">    log.info(<span class="string">&quot;Processing design: &quot;</span> + design);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/orders/current&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Valid 注释告诉 Spring MVC 在提交的 Taco 对象绑定到提交的表单数据之后，以及调用 processDesign() 方法之前，对提交的 Taco 对象执行验证。如果存在任何验证错误，这些错误的详细信息将在传递到 processDesign() 的错误对象中捕获。processDesign() 的前几行查询 Errors 对象，询问它的 hasErrors() 方法是否存在任何验证错误。如果有，该方法结束时不处理 Taco，并返回 “design” 视图名，以便重新显示表单。</p>
<p>要对提交的 Order 对象执行验证，还需要对 OrderController 的 processOrder() 方法进行类似的更改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processOrder</span><span class="params">(<span class="meta">@Valid</span> Order order, Errors errors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;orderForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    log.info(<span class="string">&quot;Order submitted: &quot;</span> + order);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这两种情况下，如果没有验证错误，则允许该方法处理提交的数据。如果存在验证错误，则请求将被转发到表单视图，以便用户有机会纠正其错误。</p>
<h3 id="显示验证错误"><a href="#显示验证错误" class="headerlink" title="显示验证错误"></a>显示验证错误</h3><p>前面会在传入控制器之前进行验证，验证有误，则返回之前页面。</p>
<p>但是用户如何知道哪些错误需要改正呢？除非调出表单上的错误，否则用户将只能猜测如何成功提交表单。</p>
<p>Thymeleaf 通过 fields 属性及其 <code>th:errors</code> 属性提供了对 Errors 对象的便捷访问。例如，要在信用卡号字段上显示验证错误，可以添加一个 <code>&lt;span&gt; </code>元素，该元素将这些错误引用用于订单模板，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;ccNumber&quot;</span>&gt;Credit Card #: &lt;/label&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> th:field=<span class="string">&quot;*&#123;ccNumber&#125;&quot;</span>/&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;validationError&quot;</span></span><br><span class="line">      th:<span class="keyword">if</span>=<span class="string">&quot;$&#123;#fields.hasErrors(&#x27;ccNumber&#x27;)&#125;&quot;</span></span><br><span class="line">      th:errors=<span class="string">&quot;*&#123;ccNumber&#125;&quot;</span>&gt;CC Num Error&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>除了可以用来设置错误样式以引起用户注意的 class 属性外，<span> 元素还使用 <code>th:if</code> 属性来决定是否显示 <span>。fields 属性的 hasErrors() 方法检查 ccNumber 字段中是否有任何错误。如果有错误，<span> 将被渲染。</span></span></span></p>
<p><code>th:errors</code> 属性引用 ccNumber 字段，并且假设该字段存在错误，它将用验证消息替换 <span> 元素的占位符内容。</span></p>
<h2 id="使用视图控制器"><a href="#使用视图控制器" class="headerlink" title="使用视图控制器"></a>使用视图控制器</h2><p>到目前为止，已经为 Taco Cloud 应用程序编写了三个控制器。尽管每个控制器在应用程序的功能上都有不同的用途，但它们几乎都遵循相同的编程模型：</p>
<ul>
<li>它们都用 @Controller 进行了注释，以表明它们是控制器类，应该由 Spring 组件扫描自动发现，并在 Spring 应用程序上下文中作为 bean 进行实例化。</li>
<li>除了 HomeController 之外，所有的控制器都在类级别上使用 @RequestMapping 进行注释，以定义控制器将处理的基本请求模式。</li>
<li>它们都有一个或多个方法，这些方法都用 @GetMapping 或 @PostMapping 进行了注释，以提供关于哪些方法应该处理哪些请求的细节。</li>
</ul>
<p>即将编写的大多数控制器都将遵循这种模式。但是，如果一个控制器足够简单，不填充模型或流程输入（就像 HomeController 一样），那么还有另一种定义控制器的方法。请查看下一个程序清单，了解如何声明视图控制器 —— 一个只将请求转发给视图的控制器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.web;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 @WebConfig 最值得注意的是它实现了 WebMvcConfigurer 接口。WebMvcConfigurer 定义了几个配置 Spring MVC 的方法。尽管它是一个接口，但它提供了所有方法的默认实现，因此只需覆盖所需的方法。在本例中，覆盖了 addViewControllers() 方法。</p>
<p>addViewControllers() 方法提供了一个 ViewControllerRegistry，可以使用它来注册一个或多个视图控制器。在这里，在注册表上调用 addViewController()，传入 “/”，这是视图控制器处理 GET 请求的路径。该方法返回一个 ViewControllerRegistration 对象，在该对象上立即调用 setViewName() 来指定 home 作为应该转发 “/” 请求的视图。</p>
<p>就像这样，已经能够用配置类中的几行代码替换 HomeController。现在可以删除 HomeController，应用程序的行为应该与以前一样。惟一需要做的其他更改是重新访问第 1 章中的 HomeControllerTest，从 @WebMvcTest 注释中删除对 HomeController 的引用，这样测试类就可以无错误地编译了。</p>
<p>这里，已经创建了一个新的 WebConfig 配置类来存放视图控制器声明。但是任何配置类都可以实现 WebMvcConfigurer 并覆盖 addViewController() 方法。例如，可以将相同的视图控制器声明添加到引导 TacoCloudApplication 类中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TacoCloudApplication</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TacoCloudApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过扩展现有的配置类，可以避免创建新的配置类，从而降低项目工件数量。但是我倾向于为每种配置（web、数据、安全性等等）创建一个新的配置类，保持应用程序引导配置的简洁。</p>
<p>说到视图控制器，更一般地说，是控制器将请求转发给的视图。</p>
<h2 id="视图模板库"><a href="#视图模板库" class="headerlink" title="视图模板库"></a>视图模板库</h2><p>一般来说，可以选择想要的视图模板库，将其作为依赖项添加到构建中，然后开始在 /templates 目录中（在 Maven 或 Gradl 构建项目的 src/main/resources 目录下）编写模板。Spring Boot 将检测选择的模板库，并自动配置所需的组件来为 Spring MVC 控制器提供视图。</p>
<p>已经在 Taco Cloud 应用程序中用 Thymeleaf 实现了这一点。在第 1 章中，在初始化项目时选择了 Thymeleaf 复选框。这导致 Spring Boot 的 Thymeleaf starter 被包含在 pom.xml 文件中。当应用程序启动时，Spring Boot 自动配置会检测到 Thymeleaf 的存在，并自动配置 Thymeleaf bean。现在要做的就是开始在 /templates 中编写模板。</p>
<p>如果希望使用不同的模板库，只需在项目初始化时选择它，或者编辑现有的项目构建以包含新选择的模板库。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Spring 提供了一个强大的 web 框架，称为 Spring MVC，可以用于开发 Spring 应用程序的 web 前端。</li>
<li>Spring MVC 是基于注解的，可以使用 @RequestMapping、@GetMapping 和 @PostMapping 等注解来声明请求处理方法。</li>
<li>大多数请求处理方法通过返回视图的逻辑名称来结束，例如一个 Thymeleaf 模板，请求（以及任何模型数据）被转发到该模板。</li>
<li>Spring MVC 通过 Java Bean Validation API 和 Hibernate Validator 等验证 API 的实现来支持验证。</li>
<li>视图控制器可以用来处理不需要模型数据或处理的 HTTP GET 请求。</li>
<li>除了 Thymeleaf，Spring 还支持多种视图选项，包括 FreeMarker、Groovy Templates 和 Mustache。</li>
</ul>
<h1 id="第三章-使用数据"><a href="#第三章-使用数据" class="headerlink" title="第三章 使用数据"></a>第三章 使用数据</h1><p>本章内容：</p>
<ul>
<li>使用 Spring JdbcTemplate</li>
<li>使用 SimpleJdbcInsert 插入数据</li>
<li>使用 Spring Data 声明 JPA repositories</li>
</ul>
<p>在 Taco Cloud 应用程序中，需要能够维护关于 ingredients、tacos 和 orders 的信息。如果没有一个数据库来存储这些信息，应用程序将无法比在第 2 章中开发的应用程序取得更大的进展。</p>
<p>在本章中，将向 Taco Cloud 应用程序添加数据持久化操作。首先使用 Spring 对 JDBC（Java Database Connectivity）的支持来消除样板代码。然后，将重新使用 JPA（Java Persistence API）处理数据存储库，从而消除更多代码。</p>
<p>在处理关系数据时，Java 开发人员有多个选择。两个最常见的选择是 JDBC 和 JPA。Spring 通过抽象支持这两种方式，这使得使用 JDBC 或 JPA 比不使用 Spring 更容易。</p>
<h2 id="使用-JDBC-读写数据"><a href="#使用-JDBC-读写数据" class="headerlink" title="使用 JDBC 读写数据"></a>使用 JDBC 读写数据</h2><p>Spring JDBC 支持起源于 JdbcTemplate 类。JdbcTemplate 提供了一种方法，通过这种方法，开发人员可以对关系数据库执行 SQL 操作，与通常使用 JDBC 不同的是，这里不需要满足所有的条件和样板代码。</p>
<p>在没有 JdbcTemplate 的情况下用 Java 执行一个简单的查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">findOne</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement statement = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection = dataSource.getConnection();</span><br><span class="line">        statement = connection.prepareStatement(</span><br><span class="line">            <span class="string">&quot;select id, name, type from Ingredient&quot;</span>);</span><br><span class="line">        statement.setString(<span class="number">1</span>, id);</span><br><span class="line">        resultSet = statement.executeQuery();</span><br><span class="line">        Ingredient ingredient = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(resultSet.next()) &#123;</span><br><span class="line">            ingredient = <span class="keyword">new</span> Ingredient(</span><br><span class="line">                resultSet.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">                resultSet.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">                Ingredient.Type.valueOf(resultSet.getString(<span class="string">&quot;type&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ingredient;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// ??? What should be done here ???</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询语句被创建连接、创建语句和通过关闭连接、语句和结果集来清理的代码所包围。</p>
<p>更糟糕的是，在创建连接或语句或执行查询时，可能会出现许多问题。这要求捕获一个 SQLException，这可能有助于（也可能无助于）找出问题出在哪里或如何解决问题。</p>
<p>SQLException 是一个被检查的异常，它需要在 catch 块中进行处理。但是最常见的问题，如未能创建到数据库的连接或输入错误的查询，不可能在 catch 块中得到解决，可能会重新向上抛出以求处理。相反，要是考虑使用 JdbcTemplate 的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> JdbcTemplate jdbc;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">findOne</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jdbc.queryForObject(</span><br><span class="line">        <span class="string">&quot;select id, name, type from Ingredient where id=?&quot;</span>,</span><br><span class="line">        <span class="keyword">this</span>::mapRowToIngredient, id);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">private</span> Ingredient <span class="title">mapRowToIngredient</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ingredient(</span><br><span class="line">        rs.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">        rs.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">        Ingredient.Type.valueOf(rs.getString(<span class="string">&quot;type&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有创建任何语句或连接。而且，在方法完成之后，不会对那些对象进行任何清理。最后，这样做不会存在任何在 catch 块中不能处理的异常。剩下的代码只专注于执行查询（调用 JdbcTemplate 的 queryForObject() 方法）并将结果映射到 Ingredient 对象（在 mapRowToIngredient() 方法中）。</p>
<h3 id="为域适配持久化"><a href="#为域适配持久化" class="headerlink" title="为域适配持久化"></a>为域适配持久化</h3><p>在将对象持久化到数据库时，通常最好有一个惟一标识对象的字段。Ingredient 类已经有一个 id 字段，但是需要向 Taco 和 Order 添加 id 字段。还需要向每个对象添加一个字段，以捕获保存对象的日期和时间。</p>
<p>新的taco：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taco</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date createdAt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的order：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date placedAt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为使用 Lombok 在运行时自动生成访问器方法，所以除了声明 id 和 createdAt 属性外，不需要做任何事情。它们将在运行时根据需要生成适当的 getter 和 setter 方法。</p>
<h3 id="使用-JdbcTemplate"><a href="#使用-JdbcTemplate" class="headerlink" title="使用 JdbcTemplate"></a><strong>使用 JdbcTemplate</strong></h3><p>在开始使用 JdbcTemplate 之前，需要将它添加到项目类路径中。这很容易通过添加 Spring Boot 的 JDBC starter 依赖来实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还需要一个存储数据的数据库。出于开发目的，嵌入式数据库足矣。我喜欢 H2 嵌入式数据库，所以我添加了以下依赖进行构建：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>写一个获取和保存 Ingredient 数据的存储库：</strong></em></p>
<h4 id="（1）定义-JDBC-数据库接口"><a href="#（1）定义-JDBC-数据库接口" class="headerlink" title="（1）定义 JDBC 数据库接口"></a>（1）定义 JDBC 数据库接口</h4><p>Ingredient repository 需要执行以下操作：</p>
<ul>
<li>查询所有的 Ingredient 使之变成一个 Ingredient 的集合对象</li>
<li>通过它的 id 查询单个 Ingredient</li>
<li>保存一个 Ingredient 对象</li>
</ul>
<p>以下 IngredientRepository 接口以方法声明的方式定义了这三种操作：<strong>每一个库一个单独接口文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientRepository</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Iterable&lt;Ingredient&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Ingredient <span class="title">findOne</span><span class="params">(String id)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Ingredient <span class="title">save</span><span class="params">(Ingredient ingredient)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）使用-JdbcTemplate-编写具体操作，读取"><a href="#（2）使用-JdbcTemplate-编写具体操作，读取" class="headerlink" title="（2）使用 JdbcTemplate 编写具体操作，读取"></a>（2）使用 JdbcTemplate 编写具体操作，读取</h4><p>编写一个使用 JdbcTemplate 来查询数据库的 IngredientRepository 的实现。<strong>每一个库一个具体操作类文件，方法代表查询插入等。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcIngredientRepository</span> <span class="keyword">implements</span> <span class="title">IngredientRepository</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbc;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcIngredientRepository</span><span class="params">(JdbcTemplate jdbc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbc = jdbc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JdbcIngredientRepository 使用 @Repository 进行了注解。这个注解是 Spring 定义的少数几个原型注解之一，包括 @Controller 和 @Component。通过使用 @Repository 对 JdbcIngredientRepository 进行注解，这样它就会由 Spring 组件在扫描时自动发现，并在 Spring 应用程序上下文中生成 bean 实例。</p>
<p>当 Spring 创建 JdbcIngredientRepository bean 时，通过 @Autowired 注解将 JdbcTemplate 注入到 bean 中。构造函数将 JdbcTemplate 分配给一个实例变量，该变量将在其他方法中用于查询和插入数据库。谈到那些其他方法，让我们来看看 findAll() 和 findOne() 的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Ingredient&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jdbc.query(<span class="string">&quot;select id, name, type from Ingredient&quot;</span>,</span><br><span class="line">              <span class="keyword">this</span>::mapRowToIngredient);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">findOne</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jdbc.queryForObject(</span><br><span class="line">        <span class="string">&quot;select id, name, type from Ingredient where id=?&quot;</span>,</span><br><span class="line">        <span class="keyword">this</span>::mapRowToIngredient, id);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">private</span> Ingredient <span class="title">mapRowToIngredient</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ingredient(</span><br><span class="line">        rs.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">        rs.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">        Ingredient.Type.valueOf(rs.getString(<span class="string">&quot;type&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>findAll() 和 findOne() 都以类似的方式使用 JdbcTemplate。期望返回对象集合的 findAll() 方法使用了 JdbcTemplate 的 query() 方法。query() 方法接受查询的 SQL 以及 Spring 的 RowMapper 实现，以便将结果集中的每一行映射到一个对象。findAll() 还接受查询中所需的所有参数的列表作为它的最后一个参数。但是，在本例中，没有任何必需的参数。</p>
<p>findOne() 方法只期望返回单个成分对象，因此它使用 JdbcTemplate 的 queryForObject() 方法而不是 query()。queryForObject() 的工作原理与 query() 非常相似，只是它返回的是单个对象，而不是对象列表。在本例中，它给出了要执行的查询、一个 RowMapper 和要获取的 Ingredient 的 id，后者用于代替查询 SQL 中 的 <code>?</code>。</p>
<p>findAll() 和 findOne() 的 RowMapper 参数作为 mapRowToIngredient() 方法的方法引用。当使用 JdbcTemplate 作为显式 RowMapper 实现的替代方案时，使用 Java 8 的方法引用和 lambda 非常方便。但是，如果出于某种原因，想要或是需要一个显式的 RowMapper，那么 findOne() 的以下实现将展示如何做到这一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">findOne</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jdbc.queryForObject(</span><br><span class="line">        <span class="string">&quot;select id, name, type from Ingredient where id=?&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> RowMapper&lt;Ingredient&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Ingredient <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Ingredient(</span><br><span class="line">                    rs.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">                    rs.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">                    Ingredient.Type.valueOf(rs.getString(<span class="string">&quot;type&quot;</span>)));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）插入一行数据"><a href="#（3）插入一行数据" class="headerlink" title="（3）插入一行数据"></a>（3）插入一行数据</h4><p>JdbcTemplate 的 update() 方法可用于在数据库中写入或更新数据的任何查询。</p>
<p>使用JdbcTemplate插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">save</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">    jdbc.update(</span><br><span class="line">        <span class="string">&quot;insert into Ingredient (id, name, type) values (?, ?, ?)&quot;</span>,</span><br><span class="line">        ingredient.getId(),</span><br><span class="line">        ingredient.getName(),</span><br><span class="line">        ingredient.getType().toString());</span><br><span class="line">    <span class="keyword">return</span> ingredient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为没有必要将 ResultSet 数据映射到对象，所以 update() 方法要比 query() 或 queryForObject() 简单得多。它只需要一个包含 SQL 的字符串来执行，以及为任何查询参数赋值。在本例中，查询有三个参数，它们对应于 save() 方法的最后三个参数，提供了 Ingredient 的 id、name 和 type。</p>
<p>完成了 JdbcIngredientRepository后，现在可以将其注入到 DesignTacoController 中，并使用它来提供一个 Ingredient 对象列表，而不是使用硬编码的值（正如第 2 章中所做的那样）。DesignTacoController 的变化如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTacoController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IngredientRepository ingredientRepo;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DesignTacoController</span><span class="params">(IngredientRepository ingredientRepo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientRepo = ingredientRepo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showDesignForm</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        List&lt;Ingredient&gt; ingredients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ingredientRepo.findAll().forEach(i -&gt; ingredients.add(i));</span><br><span class="line">        Type[] types = Ingredient.Type.values();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            model.addAttribute(type.toString().toLowerCase(),</span><br><span class="line">                               filterByType(ingredients, type));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>showDesignForm() 方法的第 2 行现在调用了注入的 IngredientRepository 的 findAll() 方法。findAll() 方法从数据库中提取所有 Ingredient，然后将它们对应到到模型的不同类型中。</p>
<h3 id="写表并预加载数据"><a href="#写表并预加载数据" class="headerlink" title="写表并预加载数据"></a>写表并预加载数据</h3><p>在开始从查询中引用的 Ingredient 表读取数据之前，应该创建这个表并写一些 Ingredient 数据进去。</p>
<p>除了 Ingredient 表之外，还需要一些保存订单和设计信息的表。也就是要定义数据库数据规则。create语句。</p>
<p><img src="https://img-blog.csdnimg.cn/f285480b152f4c6bb537a8b6dc309f46.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<ul>
<li>Ingredient - 保存着原料信息</li>
<li>Taco - 保存着关于 taco 设计的重要信息</li>
<li>Taco_Ingredient - 包含 Taco 表中每一行的一个或多行数据，将 Taco 映射到该 Taco 的 Ingredient（如果一个taco有多个配料，就插入多行）</li>
<li>Taco_Order - 保存着重要的订单细节</li>
<li>Taco_Order_Tacos - 包含 Taco_Order 表中的每一行的一个或多行数据，将 Order 映射到 Order 中的Tacos</li>
</ul>
<p>创建表的sql语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Ingredient (</span><br><span class="line">    id <span class="type">varchar</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">25</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    type <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Taco (</span><br><span class="line">    id <span class="keyword">identity</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    createdAt <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Taco_Ingredients (</span><br><span class="line">    taco <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    ingredient <span class="type">varchar</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Taco_Ingredients <span class="keyword">add</span> <span class="keyword">foreign</span> key (taco) <span class="keyword">references</span> Taco(id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Taco_Ingredients <span class="keyword">add</span> <span class="keyword">foreign</span> key (ingredient) <span class="keyword">references</span> Ingredient(id);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Taco_Order (</span><br><span class="line">    id <span class="keyword">identity</span>,</span><br><span class="line">    deliveryName <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    deliveryStreet <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    deliveryCity <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    deliveryState <span class="type">varchar</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    deliveryZip <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    ccNumber <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    ccExpiration <span class="type">varchar</span>(<span class="number">5</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    ccCVV <span class="type">varchar</span>(<span class="number">3</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    placedAt <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Taco_Order_Tacos (</span><br><span class="line">    tacoOrder <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    taco <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Taco_Order_Tacos <span class="keyword">add</span> <span class="keyword">foreign</span> key (tacoOrder) <span class="keyword">references</span> Taco_Order(id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Taco_Order_Tacos <span class="keyword">add</span> <span class="keyword">foreign</span> key (taco) <span class="keyword">references</span> Taco(id);</span><br></pre></td></tr></table></figure>

<p>最大的问题是把这个模式定义放在哪里。事实证明，Spring Boot 回答了这个问题。</p>
<p>如果有一个名为 schema.sql 的文件。在应用程序的类路径根目录下执行 sql，然后在应用程序启动时对数据库执行该文件中的 SQL。因此，应该将定义数据库 的内容写入一个名为 schema.sql 的文件中，然后放在项目的 src/main/resources 文件夹下。</p>
<p>还需要用一些 Ingredient 数据来预加载数据库。幸运的是，Spring Boot 还将执行一个名为 data.sql 的文件，这个文件位于根路径下。因此，可以使用 src/main/resources/data.sql 中的预加载数据库程序中的 insert 语句来加载包含 Ingredient 数据的数据库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Taco_Order_Tacos;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Taco_Ingredients;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Taco;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Taco_Order;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Ingredient;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;FLTO&#x27;</span>, <span class="string">&#x27;Flour Tortilla&#x27;</span>, <span class="string">&#x27;WRAP&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;COTO&#x27;</span>, <span class="string">&#x27;Corn Tortilla&#x27;</span>, <span class="string">&#x27;WRAP&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;GRBF&#x27;</span>, <span class="string">&#x27;Ground Beef&#x27;</span>, <span class="string">&#x27;PROTEIN&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;CARN&#x27;</span>, <span class="string">&#x27;Carnitas&#x27;</span>, <span class="string">&#x27;PROTEIN&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;TMTO&#x27;</span>, <span class="string">&#x27;Diced Tomatoes&#x27;</span>, <span class="string">&#x27;VEGGIES&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;LETC&#x27;</span>, <span class="string">&#x27;Lettuce&#x27;</span>, <span class="string">&#x27;VEGGIES&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;CHED&#x27;</span>, <span class="string">&#x27;Cheddar&#x27;</span>, <span class="string">&#x27;CHEESE&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;JACK&#x27;</span>, <span class="string">&#x27;Monterrey Jack&#x27;</span>, <span class="string">&#x27;CHEESE&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;SLSA&#x27;</span>, <span class="string">&#x27;Salsa&#x27;</span>, <span class="string">&#x27;SAUCE&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;SRCR&#x27;</span>, <span class="string">&#x27;Sour Cream&#x27;</span>, <span class="string">&#x27;SAUCE&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>以上只开发了 Ingredient 数据的存储库，还需要继续编写用于持久化 Taco、Order 的存储库和相应的数据。</p>
<h3 id="具体持久化方法"><a href="#具体持久化方法" class="headerlink" title="具体持久化方法"></a>具体持久化方法</h3><p>到此，已经了解了如何使用 JdbcTemplate 向数据库写入数据。JdbcIngredientRepository 中的 save() 方法使用 JdbcTemplate 的 update() 方法将 Ingredient 对象保存到数据库中。</p>
<p>虽然这是第一个很好的例子，但是它可能有点太简单了。保存数据可能比 JdbcIngredientRepository 所需要的更复杂。使用 JdbcTemplate 保存数据的两种方法包括：</p>
<ul>
<li>直接使用 update() 方法</li>
<li>使用 SimpleJdbcInsert 包装类</li>
</ul>
<p>让我们首先看看，当持久话需求比保存一个 Ingredient 所需要的更复杂时，如何使用 update() 方法。</p>
<h4 id="使用-JdbcTemplate-保存数据"><a href="#使用-JdbcTemplate-保存数据" class="headerlink" title="使用 JdbcTemplate 保存数据"></a>使用 JdbcTemplate 保存数据</h4><p>目前，Taco 和 Order 存储库需要做的惟一一件事是保存它们各自的对象。为了保存 Taco 对象，TacoRepository 声明了一个 save() 方法，接口如下所示：OrderRepository接口 也声明了一个 save() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TacoRepository</span> </span>&#123;</span><br><span class="line">    <span class="function">Taco <span class="title">save</span><span class="params">(Taco design)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="function">Order <span class="title">save</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存一个 Taco 设计需要将与该 Taco 关联的 Ingredient 保存到 Taco_Ingredient 表中。同样，保存 Order 也需要将与 Order 关联的 Taco 保存到 Taco_Order_Tacos 表中。这使得保存 Taco 和 Order 比 保存 Ingredient 更有挑战性。</p>
<p>要实现 TacoRepository，需要一个 save() 方法，该方法首先保存基本的 Taco 设计细节（例如，名称和创建时间），然后为 Taco 对象中的每个 Ingredient 在 Taco_Ingredients 中插入一行。下面的程序显示了完整的 JdbcTacoRepository 类。</p>
<p>使用 JdbcTemplate 实现 TacoRepository：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.sql.Types;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.PreparedStatementCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.PreparedStatementCreatorFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.support.GeneratedKeyHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.support.KeyHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTacoRepository</span> <span class="keyword">implements</span> <span class="title">TacoRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcTacoRepository</span><span class="params">(JdbcTemplate jdbc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbc = jdbc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Taco <span class="title">save</span><span class="params">(Taco taco)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> tacoId = saveTacoInfo(taco);</span><br><span class="line">        taco.setId(tacoId);</span><br><span class="line">        <span class="keyword">for</span> (Ingredient ingredient : taco.getIngredients()) &#123;</span><br><span class="line">            saveIngredientToTaco(ingredient, tacoId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taco;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">saveTacoInfo</span><span class="params">(Taco taco)</span> </span>&#123;</span><br><span class="line">        taco.setCreatedAt(<span class="keyword">new</span> Date());</span><br><span class="line">        PreparedStatementCreator psc = <span class="keyword">new</span> PreparedStatementCreatorFactory(</span><br><span class="line">            <span class="string">&quot;insert into Taco (name, createdAt) values (?, ?)&quot;</span>,</span><br><span class="line">            Types.VARCHAR, Types.TIMESTAMP</span><br><span class="line">        ).newPreparedStatementCreator(</span><br><span class="line">            Arrays.asList(</span><br><span class="line">                taco.getName(),</span><br><span class="line">                <span class="keyword">new</span> Timestamp(taco.getCreatedAt().getTime())));</span><br><span class="line"></span><br><span class="line">        KeyHolder keyHolder = <span class="keyword">new</span> GeneratedKeyHolder();</span><br><span class="line">        jdbc.update(psc, keyHolder);</span><br><span class="line">        <span class="keyword">return</span> keyHolder.getKey().longValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveIngredientToTaco</span><span class="params">(Ingredient ingredient, <span class="keyword">long</span> tacoId)</span> </span>&#123;</span><br><span class="line">        jdbc.update(</span><br><span class="line">            <span class="string">&quot;insert into Taco_Ingredients (taco, ingredient) &quot;</span> +<span class="string">&quot;values (?, ?)&quot;</span>,</span><br><span class="line">            tacoId, ingredient.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>save() 方法首先调用私有的 saveTacoInfo() 方法，然后使用该方法返回的 Taco id 调用 saveIngredientToTaco()，它保存每个配料。在 Taco 中插入一行时，需要知道数据库生成的 id，以便在每个 Ingredient 中引用它。保存 Ingredient 数据时使用的 update() 方法不能获得生成的 id，因此这里需要一个不同的 update() 方法。</p>
<p>需要的 update() 方法接受 PreparedStatementCreator 和 KeyHolder。KeyHolder 将提供生成的 Taco id，但是为了使用它，还必须创建一个 PreparedStatementCreator。创建 PreparedStatementCreator 非常重要。首先创建一个 PreparedStatementCreatorFactory，为它提供想要执行的 SQL，以及每个查询参数的类型。然后在该工厂上调用 newPreparedStatementCreator()，在查询参数中传递所需的值以生成 PreparedStatementCreator。通过使用 PreparedStatementCreator，可以调用 update()，传入 PreparedStatementCreator 和 KeyHolder（在本例中是 GeneratedKeyHolder 实例）。update() 完成后，可以通过返回 keyHolder.getKey().longValue() 来返回 Taco id。</p>
<p>回到 save() 方法，循环遍历 Taco 中的每个成分，调用 saveIngredientToTaco() 方法。saveIngredientToTaco() 方法使用更简单的 update() 形式来保存对到Taco_Ingredient 表中。</p>
<p>TacoRepository 剩下所要做的就是在 DesignTacoController 中进行持久化操作，将订单保存到数据库中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTacoController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IngredientRepository ingredientRepo;</span><br><span class="line">    <span class="keyword">private</span> TacoRepository designRepo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DesignTacoController</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IngredientRepository ingredientRepo,</span></span></span><br><span class="line"><span class="params"><span class="function">        TacoRepository designRepo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientRepo = ingredientRepo;</span><br><span class="line">        <span class="keyword">this</span>.designRepo = designRepo;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数包含一个 IngredientRepository 和一个TacoRepository。它将这两个变量都赋值给实例变量，以便它们可以在 showDesignForm() 和 processDesign() 方法中使用。</p>
<p>新的 processDesign() 方法，保存 Taco 设计并链接到 Order：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTacoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute(name = &quot;order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Order();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute(name = &quot;taco&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Taco <span class="title">taco</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Taco();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processDesign</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Valid</span> Taco design, Errors errors,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@ModelAttribute</span> Order order)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Taco saved = designRepo.save(design);</span><br><span class="line">        order.addDesign(saved);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/orders/current&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> DesignTacoController 使用 @SessionAttributes(“order”) 进行了注解，并且在 order() 方法上有一个新的注解 @ModelAttribute。与 taco() 方法一样，order() 方法上的 @ModelAttribute 注解确保在模型中能够创建 Order 对象。但是与 <strong>session</strong> 中的 Taco 对象不同，这里<strong>需要在多个请求间显示订单，因此可以创建多个 Taco 并将它们添加到订单中</strong>。类级别的 @SessionAttributes 注解指定了任何模型对象，比如应该保存在会话中的 order 属性，并且可以<strong>跨多个请求使用</strong>。</p>
<p>taco 设计的实际处理发生在 processDesign() 方法中，除了 Taco 和 Errors 对象外，该方法现在还接受 Order 对象作为参数。Order 参数使用 @ModelAttribute 进行注解，以指示其值应该来自模型，而 Spring MVC 不应该尝试给它绑定请求参数。</p>
<p>在检查验证错误之后，processDesign() 使用注入的 TacoRepository 来保存 Taco。然后，<strong>它将 Taco 对象添加到保存于 session 中 Order 对象中</strong>。实际上，Order 对象仍然保留在 session 中，直到用户完成并提交 Order 表单才会保存到数据库中。此时，OrderController 需要调用 OrderRepository 的实现来保存订单。下面来写一下这个实现。</p>
<h4 id="使用-SimpleJdbcInsert-保存数据"><a href="#使用-SimpleJdbcInsert-保存数据" class="headerlink" title="使用 SimpleJdbcInsert 保存数据"></a>使用 SimpleJdbcInsert 保存数据</h4><p>在保存订单方面，也存在类似的情况。不仅必须将订单数据保存到 Taco_Order 表中，还必须引用 Taco_Order_Tacos 表中的每个 taco。但是不是使用繁琐的 PreparedStatementCreator, 而是使用SimpleJdbcInsert， SimpleJdbcInsert 是一个包装了 JdbcTemplate 的对象，它让向表插入数据的操作变得更容易。</p>
<p>首先创建一个 JdbcOrderRepository，它是 OrderRepository 的一个实现。但是在编写 save() 方法实现之前，让我们先关注构造函数，在构造函数中，将创建两个 SimpleJdbcInsert 实例，用于将值插入 Taco_Order 和 Taco_Order_Tacos 表中。下面的程序清单显示了 JdbcOrderRepository（没有 save() 方法）。从 JdbcTemplate 创建一个 SimpleJdbcTemplate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.simple.SimpleJdbcInsert;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimpleJdbcInsert orderInserter;</span><br><span class="line">    <span class="keyword">private</span> SimpleJdbcInsert orderTacoInserter;</span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcOrderRepository</span><span class="params">(JdbcTemplate jdbc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderInserter = <span class="keyword">new</span> SimpleJdbcInsert(jdbc)</span><br><span class="line">            .withTableName(<span class="string">&quot;Taco_Order&quot;</span>)</span><br><span class="line">            .usingGeneratedKeyColumns(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.orderTacoInserter = <span class="keyword">new</span> SimpleJdbcInsert(jdbc)</span><br><span class="line">            .withTableName(<span class="string">&quot;Taco_Order_Tacos&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 JdbcTacoRepository 一样，JdbcOrderRepository 也通过其构造函数注入了 JdbcTemplate。但是，构造函数并没有将 JdbcTemplate 直接分配给一个实例变量，而是使用它来构造两个 SimpleJdbcInsert 实例。</p>
<p>第一个实例被分配给 orderInserter 实例变量，它被配置为使用 Taco_Order 表，并假定 id 属性将由数据库提供或生成。分配给 orderTacoInserter 的第二个实例被配置为使用 Taco_Order_Tacos 表，但是没有声明如何在该表中生成任何 id。</p>
<p>构造函数还创建 ObjectMapper 实例，并将其分配给实例变量。尽管 Jackson 用于 JSON 处理，但稍后将看到如何重新使用它来帮助保存订单及其关联的 tacos。</p>
<p>现在让我们看看 save() 方法如何使用 SimpleJdbcInsert 实例。下一个程序清单显示了 save() 方法，以及几个用于实际工作的 save() 委托的私有方法。</p>
<p>使用 SimpleJdbcInsert 插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">save</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    order.setPlacedAt(<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">long</span> orderId = saveOrderDetails(order);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line"></span><br><span class="line">    List&lt;Taco&gt; tacos = order.getTacos();</span><br><span class="line">    <span class="keyword">for</span> (Taco taco : tacos) &#123;</span><br><span class="line">        saveTacoToOrder(taco, orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">saveOrderDetails</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Map&lt;String, Object&gt; values = objectMapper.convertValue(order, Map.class);</span><br><span class="line">    values.put(<span class="string">&quot;placedAt&quot;</span>, order.getPlacedAt());</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">long</span> orderId = orderInserter.executeAndReturnKey(values).longValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> orderId;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveTacoToOrder</span><span class="params">(Taco taco, <span class="keyword">long</span> orderId)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; values = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    values.put(<span class="string">&quot;tacoOrder&quot;</span>, orderId);</span><br><span class="line">    values.put(<span class="string">&quot;taco&quot;</span>, taco.getId());</span><br><span class="line"></span><br><span class="line">    orderTacoInserter.execute(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>save() 方法实际上并不保存任何东西。它定义了保存订单及其关联 Taco 对象的流，并将持久性工作委托给 saveOrderDetails() 和 saveTacoToOrder()。</p>
<p>SimpleJdbcInsert 有两个执行插入的有用方法：execute() 和 executeAndReturnKey()。两者都接受 Map&lt;String, Object&gt;，其中 Map 键对应于数据插入的表中的列名，映射的值被插入到这些列中。</p>
<p>通过将 Order 中的值复制到 Map 的条目中，很容易创建这样的 Map。但是 Order 有几个属性，这些属性和它们要进入的列有相同的名字。因此，在 saveOrderDetails() 中，我决定使用 Jackson 的 ObjectMapper 及其 convertValue() 方法将 Order 转换为 Map。这是必要的，否则 ObjectMapper 会将 Date 属性转换为 long，这与 Taco_Order 表中的 placedAt 字段不兼容。</p>
<p>随着 Map 中填充完成订单数据，我们可以在 orderInserter 上调用 executeAndReturnKey() 方法了。这会将订单信息保存到 Taco_Order 表中，并将数据库生成的 id 作为一个 Number 对象返回，调用 longValue() 方法将其转换为从方法返回的 long 值。</p>
<p>saveTacoToOrder() 方法要简单得多。不是使用 ObjectMapper 将对象转换为 Map，而是创建 Map 并设置适当的值。同样，映射键对应于表中的列名。对 orderTacoInserter 的 execute() 方法的简单调用就能执行插入操作。</p>
<p>现在可以将 OrderRepository 注入到 OrderController 中并开始使用它。下面的程序清单显示了完整的 OrderController，包括因使用注入的 OrderRepository 而做的更改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.web;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.validation.Valid;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Errors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.SessionAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.support.SessionStatus;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line"><span class="keyword">import</span> tacos.data.OrderRepository;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/orders&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderController</span><span class="params">(OrderRepository orderRepo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderRepo = orderRepo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/current&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">orderForm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;orderForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processOrder</span><span class="params">(<span class="meta">@Valid</span> Order order, Errors errors,</span></span></span><br><span class="line"><span class="params"><span class="function">                               SessionStatus sessionStatus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;orderForm&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        orderRepo.save(order);</span><br><span class="line">        sessionStatus.setComplete();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了将 OrderRepository 注入控制器之外，OrderController 中惟一重要的更改是 processOrder() 方法。在这里，表单中提交的 Order 对象（恰好也是在 session 中维护的 Order 对象）通过注入的 OrderRepository 上的 save() 方法保存。</p>
<p>一旦订单被保存，就不再需要它存在于 session 中了。事实上，如果不清除它，订单将保持在 session 中，包括其关联的 tacos，下一个订单将从旧订单中包含的任何 tacos 开始。因此需要 processOrder() 方法请求 SessionStatus 参数并调用其 setComplete() 方法来重置会话。</p>
<p>所有的 JDBC 持久化代码都准备好了。现在，可以启动 Taco Cloud 应用程序并进行测试。你想要多少 tacos 和多少 orders 都可以。</p>
<p>可能还会发现在数据库中进行挖掘是很有帮助的。因为使用 H2 作为嵌入式数据库，而且 Spring Boot DevTools 已经就位，所以应该能够用浏览器访问 <a href="http://localhost:8080/h2-console">http://localhost:8080/h2-console</a> 来查看 H2 控制台。虽然需要确保 JDBC URL 字段被设置为 JDBC:h2:mem:testdb，但是默认的凭证应该可以让你进入。登录后，应该能够对 Taco Cloud 模式中的表发起查询。</p>
<p>Spring 的 JdbcTemplate 和 SimpleJdbcInsert 使得使用关系数据库比普通 JDBC 简单得多。但是可能会发现 JPA 使它更加简单。3.2将展示JPA如何使用 Spring 数据使数据持久化更加容易。</p>
<h2 id="使用-Spring-Data-JPA-读写数据"><a href="#使用-Spring-Data-JPA-读写数据" class="headerlink" title="使用 Spring Data JPA 读写数据"></a>使用 Spring Data JPA 读写数据</h2><p>Spring Data 项目是一个相当大的伞形项目，几个子项目组成，其中大多数子项目关注于具有各种不同数据库类型的数据持久化。一些最流行的 Spring 数据项目包括：</p>
<ul>
<li>Spring Data JPA* - 针对关系数据库的持久化</li>
<li><em>Spring Data Mongo</em> - 针对 Mongo 文档数据库的持久化</li>
<li><em>Spring Data Neo4j</em> - 针对 Neo4j 图形数据库的持久化</li>
<li><em>Spring Data Redis</em> - 针对 Redis 键值存储的持久化</li>
<li><em>Spring Data Cassandra</em> - 针对 Cassandra 数据库的持久化</li>
</ul>
<p>Spring Data 为所有这些项目提供的最有意思和最有用的特性之一是能够<strong>基于存储库规范接口自动创建存储库</strong>。</p>
<p>为了了解 Spring Data 是如何工作的，需要将本章前面介绍的基于 jdbc 的存储库替换为 Spring Data JPA 创建的存储库。但是首先，需要将 Spring Data JPA 添加到项目构建中。</p>
<h3 id="添加Spring-Data-JPA依赖"><a href="#添加Spring-Data-JPA依赖" class="headerlink" title="添加Spring Data JPA依赖"></a>添加<strong>Spring Data JPA</strong>依赖</h3><p>Spring Data JPA 可用于具有 JPA starter 的 Spring Boot 应用程序。这个 starter 依赖不仅带来了 Spring Data JPA，还包括 Hibernate 作为 JPA 的实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="对领域类添加注解成为实体"><a href="#对领域类添加注解成为实体" class="headerlink" title="对领域类添加注解成为实体"></a>对领域类添加注解成为实体</h3><p>在创建存储库方面，Spring Data 做了一些惊人的事情。但不幸的是，在使用 JPA 映射注解域对象时，它并没有太大的帮助。需要打开 Ingredient、Taco 和 Order 类，并添加一些注解。首先是 Ingredient 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ingredient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了将其声明为 JPA 实体，必须使用 @Entity 注解。它的 id 属性必须使用 @Id 进行注解，以便将其指定为惟一标识数据库中实体的属性。</p>
<p>除了特定于 JPA 的注解之外，还在类级别上添加了 @NoArgsConstructor 注解。JPA 要求实体有一个无参构造函数，所以 Lombok 的 @NoArgsConstructor 实现了这一点。但是要是不希望使用它，可以通过将 access 属性设置为 AccessLevel.PRIVATE 来将其设置为私有。因为必须设置 final 属性，所以还要将 force 属性设置为 true，这将导致 Lombok 生成的构造函数将它们设置为 null。</p>
<p>还添加了一个 @RequiredArgsConstructor。@Data 隐式地添加了一个必需的有参构造函数，但是当使用 @NoArgsConstructor 时，该构造函数将被删除。显式的 @RequiredArgsConstructor 确保除了私有无参数构造函数外，仍然有一个必需有参构造函数。</p>
<p>Taco类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.ManyToMany;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.OneToMany;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PrePersist;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taco</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(min=5, message=&quot;Name must be at least 5 characters long&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date createdAt;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ManyToMany(targetEntity=Ingredient.class)</span></span><br><span class="line">    <span class="meta">@Size(min=1, message=&quot;You must choose at least 1 ingredient&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Ingredient&gt; ingredients;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createdAt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.createdAt = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 Ingredient 一样，Taco 类现在使用 @Entity 注解，其 id 属性使用 @Id 注解。因为依赖于数据库自动生成 id 值，所以还使用 @GeneratedValue 注解 id 属性，指定自动策略。</p>
<p>要声明 Taco 及其相关 Ingredient 列表之间的关系，可以使用 @ManyToMany 注解 ingredient 属性。一个 Taco 可以有很多 Ingredient，一个 Ingredient 可以是很多 Taco 的一部分。</p>
<p>还有一个新方法 createdAt()，它用 @PrePersist 注解。将使用它将 createdAt 属性设置为保存 Taco 之前的当前日期和时间。</p>
<p>Order类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.ManyToMany;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.OneToMany;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PrePersist;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Digits;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Pattern;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.CreditCardNumber;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;Taco_Order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date placedAt;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ManyToMany(targetEntity=Taco.class)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Taco&gt; tacos = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDesign</span><span class="params">(Taco design)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tacos.add(design);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">placedAt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.placedAt = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 Order 的更改与对 Taco 的更改非常相似。但是在类级别有一个新的注解：@Table。这指定订单实体应该持久化到数据库中名为 Taco_Order 的表中。</p>
<p>尽管可以在任何实体上使用这个注解，但它对于 Order 是必需的。没有它，JPA 将默认将实体持久化到一个名为 Order 的表中，但是 Order 在 SQL 中是一个保留字，会导致问题。</p>
<h3 id="声明-JPA-repository接口"><a href="#声明-JPA-repository接口" class="headerlink" title="声明 JPA repository接口"></a>声明 JPA repository接口</h3><p>在存储库的 JDBC 版本中，显式地声明了希望 repository 提供的方法。但是使用 Spring Data，扩展 CrudRepository 接口。例如，这是一个新的 IngredientRepository 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Ingredient</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CrudRepository 为 CRUD（创建、读取、更新、删除）操作声明了十几个方法。注意，它是参数化的，第一个参数是存储库要持久化的实体类型，第二个参数是实体 id 属性的类型。对于 IngredientRepository，参数应该是 Ingredient 和 String 类型。</p>
<p>定义 TacoRepository：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TacoRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Taco</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IngredientRepository 和 TacoRepository 之间唯一显著的区别是对于 CrudRepository 的参数不同。在这里，它们被设置为 Taco 和 Long 去指定 Taco 实体（及其 id 类型）作为这个 respository 接口的持久化单元。最后，同样的更改可以应用到 OrderRepository：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Order</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有了这三个 repository，可能认为需要为这三个 repository 编写实现，还包括每种实现的十几个方法。但这就是 Spring Data JPA 优秀的地方 —— 不需要编写实现！当应用程序启动时，Spring Data JPA 会动态地自动生成一个实现。这意味着 repository 可以从一开始就使用。只需将它们注入到控制器中，就像在基于 JDBC 的实现中所做的那样。</p>
<p>CrudRepository 提供的方法非常适合用于实体的通用持久化。但是如果有一些基本持久化之外的需求呢？让我们看看如何自定义 repository 来执行域特有的查询。</p>
<h3 id="自定义-JPA-repository实现"><a href="#自定义-JPA-repository实现" class="headerlink" title="自定义 JPA repository实现"></a>自定义 JPA repository实现</h3><p>想象一下，除了 CrudRepository 提供的基本 CRUD 操作之外，还需要获取投递给指定邮政编码的所有订单。事实证明，通过在 OrderRepository 中添加以下方法声明可以很容易地解决这个问题：</p>
<p><code>List&lt;Order&gt; findByDeliveryZip(String deliveryZip);</code></p>
<p>在生成 repository 实现时，Spring Data 检查存储库接口中的任何方法，解析方法名称，并<strong>尝试在持久化对象的上下文中理解方法的用途</strong>（在本例中是 Order）。本质上，Spring Data 定义了一种小型的领域特定语言（DSL），其中持久化细节用 repository 中的方法签名表示。</p>
<p>让我们考虑另一个更复杂的例子。假设需要查询在给定日期范围内投递给指定邮政编码的所有订单。在这种情况下，当添加到 OrderRepository 时，下面的方法可能会被证明是有用的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Order&gt; <span class="title">readOrdersByDeliveryZipAndPlacedAtBetween</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    String deliveryZip, Date startDate, Date endDate)</span></span>;</span><br></pre></td></tr></table></figure>

<p><em><strong><u>自动识别方法名猜测功能，方法命名约定</u></strong></em></p>
<p>虽然命名约定对于相对简单的查询很有用，但是对于更复杂的查询，不需要太多的想象就可以看出方法名称可能会失控。在这种情况下，可以随意将方法命名为任何想要的名称，并使用 @Query 对其进行注解，以显式地指定调用方法时要执行的查询，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;Order o where o.deliveryCity=&#x27;Seattle&#x27;&quot;)</span></span><br><span class="line"><span class="function">List&lt;Order&gt; <span class="title">readOrdersDeliveredInSeattle</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul>
<li>JdbcTemplate 大大简化了 JDBC 的工作。</li>
<li>当需要知道数据库生成的 id 时，可以同时使用 PreparedStatementCreator 和 KeyHolder。</li>
<li>为了方便执行数据插入，使用 SimpleJdbcInsert。</li>
<li>Spring Data JPA 使得 JPA 持久化就像编写存储库接口一样简单。</li>
</ul>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》之GUI</title>
    <url>/2021/11/26/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BGUI/</url>
    <content><![CDATA[<p>GUI：Graphical User Interface 图形用户接口。用来提供给用户操作的图像界面的接口。</p>
<p>java针对GUI设计提供了一些基本的图形用户接口开发工具，如AWT、Swing、JavaFX。</p>
<p>AWT是sun公司最早推出的一套API，组件种类有限，无法实现GUI设计的全部功能。</p>
<h2 id="Swing概述"><a href="#Swing概述" class="headerlink" title="Swing概述"></a>Swing概述</h2><p>早期JDK1.0发布时，就为GUI开发提供了一套基础类库（AWT），即抽象窗口工具包。AWT需要牺牲功能来实现平台无关性。因此，Sun公司对AWT进行改进，提出Swing组件，提供更加丰富的组件和功能，来满足GUI设计的一切需求。</p>
<p>Swing是一组轻量级组件，由Java语言开发，同时底层以AWT为基础。Swing并不是AWT的替代品，而是在原有的AWT的基础上进行补充和改进。</p>
<p>Swing组件的所有类都继承自Container类，然后根据GUI开发的功能扩展了两个主要分支：容器分支（Window窗口和Panel面板）和组件分支。</p>
<p>容器分支是为了实现图形用户界面窗口容器而设计的。</p>
<p>组件分支是为了实现向容器中填充数据、元素以及人机交互组件等功能。</p>
<p>Swing组件类中常用的顶级容器类包括：JApplet、JFrame和JDialog。常用的组件类：AbstractButton类及其子类就是用来定义按钮常见行为的工具类，JTextComponent类及其子类就是用来定义文本内容编辑区域的工具类。</p>
<h2 id="JavaFX概述"><a href="#JavaFX概述" class="headerlink" title="JavaFX概述"></a>JavaFX概述</h2><p>JavaFX同Swing一样，都用于处理图形用户界面，是一个强大的图形和多媒体处理工具包集合，允许开发者设计、创建、测试、调试和部署富客户端程序，并且和Java一样具有跨平台特性。</p>
<p>Sun公司于2008年推出JavaFX，来弥补Java在桌面应用程序的缺陷。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》IO</title>
    <url>/2021/11/25/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BIO%E6%B5%81/</url>
    <content><![CDATA[<h2 id="I-O流概述"><a href="#I-O流概述" class="headerlink" title="I/O流概述"></a>I/O流概述</h2><p>java中将不同输入输出设备之间的数据传输抽象表述为“流”。</p>
<p>分类1：根据操作的数据单位不同，分为字节流和字符流。</p>
<p>分类2：根据传输方向，分为输入流和输出流。输入流只能从流中读取数据，而不能写入数据；输出流只能向流中写入数据，而不能从中读取数据。</p>
<p>分类3：根据流的功能不同，分为节点流和处理流。节点流被称为低级流，指可以从一个特定的I/O设备读写数据的流，它只能直接连接数据源，进行数据的读写操作。处理流也被称为高级流，用于对一个已存在的节点流进行连接和封装，通过封装后的流来实现流的读写能力。当使用处理流时，程序不会直接连接到实际的数据源，而是连接在已存在的流之上。</p>
<p>java中的I/O流主要定义在java.io包中，该包有四个顶级类，都是抽象类，是所有流类型的父类。</p>
<p><img src="https://img-blog.csdnimg.cn/f17ecff43e2a4f498e1b845d0fe6c7f7.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>计算机中，所有文件都是二进制（字节）形式存在的。JDK提供了<code>InputStream</code>和<code>OutputStream</code>。字节输入流：从源设备经流中走向程序。字节输出流：从程序输出经流中走向目标。输入输出是相对程序而言的，输入到输出到的意思。</p>
<h3 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h3><p>针对文件的读写，有两个类：<code>FileInputStream</code>和<code>FileOutputStream</code>。</p>
<p><code>FileInputStream</code>是<code>InputStream</code>的子类，由于从文件读取数据是重复的操作，因此需要通过循环语句来实现数据的持续读取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//创建一个文件字节输入流来读取文件</span></span><br><span class="line">		FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">		<span class="comment">//定义int变量</span></span><br><span class="line">		<span class="keyword">int</span> b=<span class="number">0</span>; </span><br><span class="line">		<span class="comment">//通过循环读取文件，当返回值为-1结束循环</span></span><br><span class="line">		<span class="keyword">while</span>((b=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.println(b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如内容为hello，字符占一个字节，因此显示的是这五个字节所对应的ASCII码值。</p>
<p><code>FileOutputStream</code>负责将数据写入文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//创建一个文件字节输出流来写文件</span></span><br><span class="line">		FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">		<span class="comment">//定义一个字符串</span></span><br><span class="line">		String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">		<span class="comment">//将字符串转换为字节数组进行写入操作</span></span><br><span class="line">		out.write(str.getBytes());</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若文件已存在，则会首先将文件中内容擦空，再写入。</p>
<p>若想追加内容：<code>FileOutputStream out = new FileOutputStream(&quot;out.txt&quot;, true);</code></p>
<p>I/O流在进行数据读写时，会出现异常，上述代码使用throws将异常抛出。但是一旦遇到I/O异常，close方法无法执行，流对象所占用的系统资源将不能释放。因此通常将关闭流的操作写在finally代码块中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(in!=<span class="keyword">null</span>)  in.close();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(out!=<span class="keyword">null</span>)  out.close();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a>文件的拷贝</h3><p>通过输入流来读取文件中的数据，并通过输出流将数据写入新文件。</p>
<p>定义一次输出流创建一个文件，定义之后多次写入，都是追加的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;source/src.jpg&quot;</span>)</span><br><span class="line">		FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;target/src.jpg&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>((b=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			out.write(b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间为：&quot;</span>+(endTime-beginTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节流的缓冲区"><a href="#字节流的缓冲区" class="headerlink" title="字节流的缓冲区"></a>字节流的缓冲区</h3><p>一个字节一个字节地拷贝，需要频繁操作文件，因此构建一个字节数组作为临时缓冲区。可以一次性读写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;source/src.jpg&quot;</span>);</span><br><span class="line">		FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;target/src.jpg&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>((len=in.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//通过变量len记住读入数组的字节数，len表示读取字节的数目</span></span><br><span class="line">			out.write(buffer, <span class="number">0</span>, len); <span class="comment">//从buffer的0位置开始写入len个字节</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间为：&quot;</span>+(endTime-beginTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>read方法内无东西时，表示从输入流读取一个8位的字节，把它转换为0-255的整数，并返回这个整数，当没有可用字节时，将返回-1。</p>
<p>read方法内是byte数组时，表示读取若干字节，并将其保存到指定的字节数组中，返回整数表示读取的字节的数目。</p>
<p>write方法内，一个int表示写入一个字节，一个字节数组表示写入字节数组中的所有字节，也可以写入指定数目字节。</p>
<p>输出流的flush()方法表示将输出缓冲区（通常是字节数组）中的数据强制写入目标设备，此过程称为刷新。</p>
</blockquote>
<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>I/O包中提供了两个带缓冲的字节流，分别为<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>，它们的构造方法中分别接收<code>InputStream</code>和<code>OutputStream</code>类型的参数作为对象。再读写数据时提供缓冲功能。</p>
<p>其实就像是上一节的系统实现。</p>
<p>关系：源设备—字节流—字节缓冲流—应用程序—字节缓冲流—字节流—目标设备</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;source/src.jpg&quot;</span>));</span><br><span class="line">		BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;target/src.jpg&quot;</span>));</span><br><span class="line">		<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>((len=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			out.write(len)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间为：&quot;</span>+(endTime-beginTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓冲流对象内部都定义了一个大小为8192的字节数组。读写都是到一个字节数组中，充当缓冲。</p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>Reader是字符输入流，用于从某个源设备读取字符。Writer是字符输出流。用于向某个目标设备写入字符。</p>
<p>输入输出是相对程序而言的，输入到输出到的意思。读和写是读到程序和从程序中写出的意思。</p>
<h3 id="字符流操作文件"><a href="#字符流操作文件" class="headerlink" title="字符流操作文件"></a>字符流操作文件</h3><p>从文件读取字符用字符输入流FileReader。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;reader.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((b=fileReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.print((<span class="keyword">char</span>)b)</span><br><span class="line">		&#125;</span><br><span class="line">		fileReader.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read返回的是int类型，因此要获得字符需要强制类型转换。</p>
<p>向文件中写入字符用FileWriter类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		FileWriter fileWriter = <span class="keyword">new</span> FileWriter(<span class="string">&quot;writer.txt&quot;</span>);</span><br><span class="line">		fileWriter.write(<span class="string">&quot;你好,\r\n&quot;</span>);</span><br><span class="line">		fileWriter.write(<span class="string">&quot;世界。\r\n&quot;</span>);</span><br><span class="line">		fileWriterr.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入文件，如果文件已存在则先清空，项追加的话，则构造时后面加true。</p>
<p>与字节流类似，这里也可以加字符流缓冲区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>[] buff=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((len=fileReader.read(buff))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	fileWriter.write(buff, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>字符流也提供了带缓冲区的字符缓冲流，<code>BufferedReader</code>和<code>BufferedWriter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	    <span class="comment">//创建字符输入缓冲流对象</span></span><br><span class="line">	    BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;read.txt&quot;</span>));</span><br><span class="line">	    <span class="comment">//创建字符输出缓冲流对象</span></span><br><span class="line">	    BufferedWriter out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;write.txt&quot;</span>));</span><br><span class="line">	    String str = <span class="keyword">null</span>;</span><br><span class="line">	    <span class="keyword">while</span>((str=in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	    	out.write(str);</span><br><span class="line">	    	out.newLine();</span><br><span class="line">	    &#125;</span><br><span class="line">	    in.close();</span><br><span class="line">	    out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BufferedReader</code>的readLine()方法，用于一次读取一行文本。</p>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>JDK中提供了两个类实现字节流转换为字符流。</p>
<p>字节输入流转变为字符输入流：<code>InputStreamReader</code></p>
<p>字节输出流转变为字符输出流：<code>OutputStreamWriter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建字节输入流，获取源文件</span></span><br><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line"><span class="comment">//将字节输入流对象转换为字符输入流对象</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line"><span class="comment">//创建字符输入缓冲流对象</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建字节输出流，指定目标文件</span></span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;write.txt&quot;</span>);</span><br><span class="line"><span class="comment">//将字节输出流对象转换为字符输出流对象</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamReader(out);</span><br><span class="line"><span class="comment">//创建字符输出缓冲流对象</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问，不明白意义何在，文件时字节码文件，程序侧用字符流有何益处。</p>
</blockquote>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>通过I/O流可以对文件的内容进行读写操作，但是对文件本身进行一些常规操作，例如创建、删除、重命名等，JDK提供了一个File类。</p>
<p>File类用于封装一个路径，可以是绝对路径，也可以是相对路径。该类主要用于文件和目录的创建、文件的查找和文件的删除等。</p>
<p>File对象代表磁盘中实际存在的文件和目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String dirname = <span class="string">&quot;/java&quot;</span>;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(dirname);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/文件夹名称：&quot;</span>+f1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/文件夹大小：&quot;</span>+f1.length()+<span class="string">&quot;bytes&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (f1.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Directory of &quot;</span> + dirname);</span><br><span class="line">            String s[] = f1.list();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">                File f = <span class="keyword">new</span> File(dirname + <span class="string">&quot;/&quot;</span> + s[i]);</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; is a directory&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; is a file&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(dirname + <span class="string">&quot; is not a directory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;是否成功删除：&quot;</span>+f1.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历某个目录下的所有文件，用list方法，除了上面的方法外，还可以采用数组工具类Arrays的stream方法进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">String[] fileNames = file.list();</span><br><span class="line">Arrays.stream(fileNames).forEach(f-&gt;System.out.println(f));</span><br></pre></td></tr></table></figure>

<p>若是想要获得指定类型的文件，例如.txt文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向list传入lambda表达式形式的参数，进行过滤。</span></span><br><span class="line">String[] fileNames=file.list((dir,name)-&gt;name.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br><span class="line">Arrays.stream(fileNames).forEach(f-&gt;System.out.println(f));</span><br></pre></td></tr></table></figure>

<p>若是要遍历所有文件及目录，包括子目录下的文件。使用listFiles方法返回的是一个File对象数组。进行递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;路径&quot;</span>);</span><br><span class="line">        func(file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历目录及其子目录方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        File[] listFiles=file.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File files:listFiles)&#123;</span><br><span class="line">            <span class="keyword">if</span>(files.isDirectory())&#123;</span><br><span class="line">                func(files);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：java中的删除文件是通过java虚拟机直接删除的，而不走回收站。</p>
</blockquote>
<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>不属于流类，但具有读写文件数据的功能，可以随机从文件的任何位置开始执行读写数据的操作。</p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>程序在运行过程中，需要将一些数据永久地保存到磁盘上，而数据在java中都是保存在对象当中的，如何将对象中的数据保存到磁盘上，就用java中的对象序列化。</p>
<p>对象的序列化（Serializable）是指将一个Java对象转换为一个I/O流中字节序列的过程。可以使内存中的Java对象转换成与平台无关的二进制流。</p>
<p>将I/O流中的字节序列恢复为Java对象的过程–反序列化。</p>
<p>整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
<p>想让对象序列化，那么这个对象所在的类必须是可序列化的，必须实现Serializable或Externalizable两个接口之一。Externalizable性能好但是编程复杂，因此大部分采用Serializable。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">      e.name = <span class="string">&quot;Reyan Ali&quot;</span>;</span><br><span class="line">      e.address = <span class="string">&quot;Phokka Kuan, Ambehta Peer&quot;</span>;</span><br><span class="line">      e.SSN = <span class="number">11122333</span>;</span><br><span class="line">      e.number = <span class="number">101</span>;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         FileOutputStream fileOut =</span><br><span class="line">         <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/tmp/employee.ser&quot;</span>);</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">         out.writeObject(e);</span><br><span class="line">         out.close();</span><br><span class="line">         fileOut.close();</span><br><span class="line">         System.out.printf(<span class="string">&quot;Serialized data is saved in /tmp/employee.ser&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">      &#123;</span><br><span class="line">          i.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      Employee e = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/employee.ser&quot;</span>);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">         e = (Employee) in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line">         fileIn.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">      &#123;</span><br><span class="line">         i.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ClassNotFoundException c)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">         c.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Deserialized Employee...&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);</span><br><span class="line">      System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address);</span><br><span class="line">      System.out.println(<span class="string">&quot;SSN: &quot;</span> + e.SSN);</span><br><span class="line">      System.out.println(<span class="string">&quot;Number: &quot;</span> + e.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。</p>
<p>注意，readObject() 方法的返回值被转化成 Employee 引用。</p>
<p>当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>从JDK1.4开始，java提供了一系列改进的用于处理输入输出的新功能，被称为NIO（New I/O）。</p>
<p>NIO采用内存映射文件的方式来处理输入输出，将文件或文件的一段区域映射到内存中，像访问内存一样来访问文件。</p>
<p>标准的IO中使用字节流和字符流，NIO中，使用通道Channel和缓冲区Buffer。数据总是从通道读入缓冲区，或从缓冲区写入通道。</p>
<p>Buffer可以看成是一个容器，本质是一个数组缓冲区，读入或写出到Channel中的所有对象都先放在Buffer中。</p>
<p>Channel是对传统的输入输出的模拟，所有的数据都通过通道流的形式传输。</p>
<p>Selector选择器，用于监听多个通道的事件（例如连接打开、数据到达）主要用于多线程处理。</p>
<h2 id="NIO-2"><a href="#NIO-2" class="headerlink" title="NIO.2"></a>NIO.2</h2><p>JDK7引入新的I/O API，提供全面的文件输入输出以及文件系统的访问与支持，并且新增java.nio.file包及其子包，提供基于异步Channel的输入输出。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》之JDBC</title>
    <url>/2021/11/27/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BJDBC/</url>
    <content><![CDATA[<p>实际开发中，项目中的数据是存储在数据库中的，Java对数据库的操作提供了一套可以执行SQL语句的API，即JDBC。</p>
<h2 id="JDBC概念"><a href="#JDBC概念" class="headerlink" title="JDBC概念"></a>JDBC概念</h2><p>JDBC（java database connectivity，Java数据库连接）是一套用于执行SQL语句的Java API。应用程序通过该API连接到关系型数据库，并使用SQL语句来完成对数据库中数据的增删改查。</p>
<p>JDBC要求各个数据库厂商按照统一的规范来提供数据库驱动，在程序中由JDBC和具体的数据库驱动联系，使得应用程序不必直接与底层数据库交互，使得代码的通用性更强。</p>
<p>JDBC在应用程序与数据库之间起到一个桥梁作用。当应用程序使用JDBC访问特定的数据库时，只需要通过不同的数据库驱动与其对应的数据库进行连接，连接后即可对该数据库进行相应的操作。</p>
<h2 id="JDBC常用API"><a href="#JDBC常用API" class="headerlink" title="JDBC常用API"></a>JDBC常用API</h2><p>JDBC的API主要位于java.sql包中，定义了一系列访问数据库的接口和类。</p>
<h3 id="Driver接口"><a href="#Driver接口" class="headerlink" title="Driver接口"></a>Driver接口</h3><p>是所有JDBC驱动程序必须实现的接口，专门提供给数据库厂商使用。</p>
<h3 id="DriverManager类"><a href="#DriverManager类" class="headerlink" title="DriverManager类"></a>DriverManager类</h3><p>用于加载JDBC驱动并创建与数据库的连接。在加载数据库驱动时，通常使用Class类的静态方法forName()来实现。参数是数据库驱动类所对应的字符串。</p>
<h3 id="Connection接口"><a href="#Connection接口" class="headerlink" title="Connection接口"></a>Connection接口</h3><p>代表Java程序和数据库的连接对象，只有获得该连接对象后，才能访问数据库，并操作数据表。</p>
<h3 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h3><p>用于执行静态的SQL语句，并返回一个结果对象。</p>
<p>Statement接口对象可以通过Connection实例的createStatement()方法获得，该方法把静态的SQL语句发送到数据库中编译执行，然后返回数据库的处理结果。</p>
<h3 id="PreparedStatement接口"><a href="#PreparedStatement接口" class="headerlink" title="PreparedStatement接口"></a>PreparedStatement接口</h3><p>使用Statement接口操作SQL语句会过于繁琐，并且存在安全隐患，因此，JDBC提供了扩展的PreparedStatement接口。是Statement的子接口，用于执行预编译的SQL语句，可以使用占位符？来替代参数，然后通过setXXX()方法为SQL语句的参数赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql=<span class="string">&quot;insert into users(is,name,email) values(?,?,?)&quot;</span>;</span><br><span class="line">PreparedStatement prestmt = conn.preparedStatement(sql);</span><br><span class="line">prestmt.setInt(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">prestmt.setString(<span class="number">2</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">prestmt.setObject(<span class="number">3</span>,<span class="string">&quot;111@1.com&quot;</span>);  <span class="comment">//通用方法？</span></span><br><span class="line">prestmt.executeUpdate();</span><br></pre></td></tr></table></figure>

<h3 id="ResultSet接口"><a href="#ResultSet接口" class="headerlink" title="ResultSet接口"></a>ResultSet接口</h3><p>用于保存JDBC执行查询时返回的结果集，结果集封装在一个逻辑表格中。接口内部有一个指向表格数据行的游标（或指针），ResultSet对象初始化时，游标在第一行之前。调用next()方法，游标移动到下一行，若下一行没有数据，则返回false。</p>
<p>应用程序中使用next方法作为while循环的条件来迭代ResultSet结果集。</p>
<p>getXXX方法用于获取指定的数据，可以用索引（从1开始）也可用字段的名称来获取。</p>
<p>例如第1列字段名为id，字段类型int，可以用getInt(“id”)或getInt(1)获得该列的值。</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="第一步：加载数据库驱动"><a href="#第一步：加载数据库驱动" class="headerlink" title="第一步：加载数据库驱动"></a><em>第一步：加载数据库驱动</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <span class="comment">//加载mysql数据库的驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);   <span class="comment">//加载Oracle数据库的驱动</span></span><br></pre></td></tr></table></figure>

<h3 id="第二步：获取数据库连接"><a href="#第二步：获取数据库连接" class="headerlink" title="第二步：获取数据库连接"></a><em>第二步：获取数据库连接</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(String url, String user, String pwd);</span><br></pre></td></tr></table></figure>

<p>连接数据库的url需要遵循固定写法：</p>
<p><code>jdbc:mysql://hostname:port/databasename</code></p>
<p>mysql指MySQL数据库，hostname指主机的名称（如果数据库在本机上，hostname可以为localhost或127.0.0.1。如果在其他机器上，那么hostname为所要连接机器的IP地址。port指端口号，mysql默认端口号为3306，databasename指的是mysql中相应数据库的名字。</p>
<h3 id="第三步：通过Connection对象获取Statement对象"><a href="#第三步：通过Connection对象获取Statement对象" class="headerlink" title="第三步：通过Connection对象获取Statement对象"></a><em>第三步：通过Connection对象获取Statement对象</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br></pre></td></tr></table></figure>

<p>也可以用PreparedStatement。</p>
<h3 id="第四步：使用Statement执行SQL语句"><a href="#第四步：使用Statement执行SQL语句" class="headerlink" title="第四步：使用Statement执行SQL语句"></a><em>第四步：使用Statement执行SQL语句</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execute(String sql);  用于执行任意sql语句</span><br><span class="line">executeQuery(String sql);   执行查询操作，返回一个ResultSet结果集对象</span><br><span class="line">executeUpdate(String sql);  执行insert、update、delete会返回受sql语句影响的行数，执行create、alter返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line">ResultSet rs=stmt.executeQuery(sql);</span><br></pre></td></tr></table></figure>

<h3 id="第五步：操作ResultSet结果集"><a href="#第五步：操作ResultSet结果集" class="headerlink" title="第五步：操作ResultSet结果集"></a><em>第五步：操作ResultSet结果集</em></h3><h3 id="第六步：关闭连接，释放资源"><a href="#第六步：关闭连接，释放资源" class="headerlink" title="第六步：关闭连接，释放资源"></a><em>第六步：关闭连接，释放资源</em></h3><p>顺序为：ResultSet、Statement、Connection。为了保证在异常情况下也能关闭资源，用try…catch的finally代码块统一关闭资源。</p>
<h2 id="第一个JDBC程序"><a href="#第一个JDBC程序" class="headerlink" title="第一个JDBC程序"></a>第一个JDBC程序</h2><h3 id="数据库建表"><a href="#数据库建表" class="headerlink" title="数据库建表"></a>数据库建表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database jdbc;</span><br><span class="line">show databases;</span><br><span class="line">use jdbc;</span><br><span class="line">create table test_table(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    name varchar(40),</span><br><span class="line">    sex varchar(2),</span><br><span class="line">    birthday date</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看表结构： desc test_table;</span><br><span class="line">查看建表语句：show create table test_table;</span><br></pre></td></tr></table></figure>

<p>如果出现中文乱码的情况，是因为MySQL数据库默认使用UTF-8编码格式，而命令行窗口默认使用的是GBK编码格式，所以执行带有中文数据的插入语句会出现解析错误。需要执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set character_set_client=gbk;</span><br><span class="line">set character_set_results=gbk;</span><br></pre></td></tr></table></figure>

<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into test_table(name, sex, birthday)</span><br><span class="line">values(&#x27;jade&#x27;,&#x27;男&#x27;,&#x27;2000-1-1&#x27;),(&#x27;marry&#x27;,&#x27;女&#x27;,&#x27;1999-2-21&#x27;),(&#x27;james&#x27;,&#x27;男&#x27;,&#x27;2010-2-3&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="新建项目，导入数据库驱动"><a href="#新建项目，导入数据库驱动" class="headerlink" title="新建项目，导入数据库驱动"></a>新建项目，导入数据库驱动</h3><p>IDE下正常创建一个项目，右键新建一个文件夹，取名libs。</p>
<p>下载Mysql驱动文件：<a href="https://dev.mysql.com/downloads/connector/j/%EF%BC%8C%E9%80%89%E6%8B%A9platform">https://dev.mysql.com/downloads/connector/j/，选择platform</a> independent，下载 <strong>ZIP Archive</strong>。直接No thanks, just start my download.  复制到libs文件夹下。</p>
<p>把jar包添加到项目里，类似eclipse的add to build path功能，file – project structure – modules – dependencies – 加号 – 第一项–添加jar包 – apply。</p>
<h3 id="编写JDBC程序"><a href="#编写JDBC程序" class="headerlink" title="编写JDBC程序"></a>编写JDBC程序</h3><p>src下新建包com.liuxuan.jdbc。创建类Test。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.parser.JSONParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: JDBCdemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: jdbc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-27 22:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.加载数据库驱动 com.mysql.jdbc.Driver 多加了cj</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2.通过DriverManager获取数据库连接</span></span><br><span class="line">            String url = <span class="string">&quot;jdbc:mysql://localhost:3306/jdbc&quot;</span>;</span><br><span class="line">            String username = <span class="string">&quot;liuxuan&quot;</span>;</span><br><span class="line">            String password = <span class="string">&quot;jade&quot;</span>;</span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">            <span class="comment">//3.通过Connection对象获取Statement对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4.使用Statement执行SQL语句</span></span><br><span class="line">            String sql = <span class="string">&quot;select * from test_table&quot;</span>;</span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="comment">//5.操作ResultSet结果集</span></span><br><span class="line">            System.out.println(<span class="string">&quot;id  |  name  |  sex  &quot;</span></span><br><span class="line">                            +<span class="string">&quot;  birthday  &quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String sex = rs.getString(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">                Date birthday = rs.getDate(<span class="string">&quot;birthday&quot;</span>);</span><br><span class="line">                System.out.println(id+<span class="string">&quot;  |  &quot;</span>+name+<span class="string">&quot;  |  &quot;</span></span><br><span class="line">                                +sex+<span class="string">&quot;  |  &quot;</span>+birthday);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//6.关闭连接，释放资源</span></span><br><span class="line">            <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;rs.close();&#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;stmt.close();&#125;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;conn.close();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》之多线程</title>
    <url>/2021/11/30/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>在程序设计中，多线程就是指一个应用程序中有多条并发执行的线索，每条线索称为一个线程，它们交替执行，彼此间可以进行通信。</p>
<h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>在一个操作系统中，每个独立执行的程序都可称为一个进程。</p>
<p>在多任务操作系统中，表面上看是支持进程并发执行的，但实际上并不是在同一时刻运行的。计算机的应用程序都是由CPU执行的，一个CPU在某个时间点只能执行一个进程，操作系统能在极短的时间内在不同的进程之间进行切换，所以给人以同时执行多个程序的感觉。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>多线程看似是同时并发执行的，其实是和进程一样，也是由CPU控制并轮流执行的，只不过CPU运行速度非常快。</p>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>在Java中，可以通过三种方式来实现多线程</p>
<p>1.继承Thread类，重写run()方法。</p>
<p>2.实现Runnable接口，重写run()方法。</p>
<p>3.实现Callable接口，重写call()方法，并使用Future来获取call()方法的返回结果。</p>
<h3 id="Thread类实现多线程"><a href="#Thread类实现多线程" class="headerlink" title="Thread类实现多线程"></a>Thread类实现多线程</h3><p>Thread类是java.lang包下的一个线程类，用来实现Java多线程。</p>
<p>第一步：创建一个Thread线程类的子类（子线程），同时重写Thread类的run()方法。</p>
<p>第二步：创建该子类的实例对象，并通过调用start()方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义一个继承Thread线程类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建子线程有参构造方法,name是线程名字</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写Thread类的run()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i++,<span class="number">5</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()</span><br><span class="line">							+<span class="string">&quot;的run方法在运行&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//2.创建MyThread1实例对象</span></span><br><span class="line">		MyThread1 thread1 = <span class="keyword">new</span> MyThread1(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		<span class="comment">//调用start方法启动线程</span></span><br><span class="line">		thread1.start();</span><br><span class="line">		MyThread1 thread2 = <span class="keyword">new</span> MyThread1(<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">		<span class="comment">//调用start方法启动线程</span></span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>currentThread()是Thread类的静态方法，用来获取当前线程对象，getName方法用来获取线程名称。</p>
<p>结果是：两个线程实例交互运行。</p>
<h3 id="Runnable接口实现多线程"><a href="#Runnable接口实现多线程" class="headerlink" title="Runnable接口实现多线程"></a>Runnable接口实现多线程</h3><p>Thread类实现多线程的局限性：因为Java只支持类的单继承，如果某个类已经继承了其他父类，就无法再继承Thread类来实现多线程。因此，考虑通过实现Runnable接口来实现多线程。</p>
<p>第一步：创建一个Runnable接口的实现类，同时重写接口中的run方法。</p>
<p>第二步：创建Runnable接口的实现类对象。</p>
<p>第三步：使用Thread有参构造方法创建线程实例，并将Runnable接口的实现类的实例对象作为参数传入。</p>
<p>第四步：调用线程实例的start方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义一个实现Runnable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">//重写run方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i++,<span class="number">5</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()</span><br><span class="line">							+<span class="string">&quot;的run方法在运行&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//2.创建Runnable接口实现类的实例对象</span></span><br><span class="line">		MyThread2 myThread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">		<span class="comment">//3.使用Thread(Runnable target, String name)构造方法创建线程对象</span></span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(myThread2, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		<span class="comment">//4.调用线程对象的start方法启动线程</span></span><br><span class="line">		thread1.start();</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(myThread2, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable接口中只有一个抽象的run方法，该接口属于JDK8中定义的函数式接口，在使用中可以直接通过Lambda表达式的方式简洁地实现线程实例。</p>
<h3 id="Callable接口实现多线程"><a href="#Callable接口实现多线程" class="headerlink" title="Callable接口实现多线程"></a>Callable接口实现多线程</h3><p>Thread类和Runnable接口实现多线程，重写run方法，由于该方法没有返回值，因此无法从多个线程中获取返回结果。因此，JDK5开始，java提供了一个Callable接口，来满足这种既能创建多线程又可以有返回值的需求。</p>
<p>与Runnable不同，这次传入Thread类有参构造方法的是Runnable接口的子类FutureTask对象作为参数，对象中封装了带有返回值的Callable接口实现类。</p>
<p>第一步：创建一个Callable接口的实现类，同时重写Callable接口的call方法</p>
<p>第二步：创建Callable接口的实现类对象。</p>
<p>第三步：通过FutureTask线程结果处理类的有参构造方法来封装Callable接口实现类对象。</p>
<p>第四步：使用参数为FutureTask类对象的Thread有参构造方法创建Thread线程实例。</p>
<p>第五步：调用线程实例的start方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.cocurrent.*;</span><br><span class="line"><span class="comment">//1.定义一个实现Callable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//重写call方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i++,<span class="number">5</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()</span><br><span class="line">							+<span class="string">&quot;的run方法在运行&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">														ExecutionException</span>&#123;</span><br><span class="line">		<span class="comment">//2.创建Callable接口的实现类对象</span></span><br><span class="line">		MyThread3 myThread3 = <span class="keyword">new</span> MyThread3();</span><br><span class="line">		<span class="comment">//3.使用FutureTask封装Callable接口</span></span><br><span class="line">		FutureTask&lt;Object&gt;ft1 = <span class="keyword">new</span> FutureTask&lt;&gt;(myThread3);</span><br><span class="line">		<span class="comment">//4.使用Thread()构造方法创建线程对象</span></span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(ft1, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		<span class="comment">//5.启动线程</span></span><br><span class="line">		thread1.start();</span><br><span class="line">		FutureTask&lt;Object&gt;ft2 = <span class="keyword">new</span> FutureTask&lt;&gt;(myThread3);</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(ft2, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		thread2.start();</span><br><span class="line">		<span class="comment">//通过FutureTask对象的方法管理返回值</span></span><br><span class="line">		System.out.println(<span class="string">&quot;thread1返回结果：&quot;</span>+ft1.get());</span><br><span class="line">		System.out.println(<span class="string">&quot;thread2返回结果：&quot;</span>+ft2.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask类用来封装和管理返回结果，直接父接口是RunnableFuture，RunnableFuture接口是实现自Runnable接口和Future接口。</p>
<p>Future接口时JDK5提供的用来管理线程执行返回结果的，共有五个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> 参数)</span>   <span class="comment">//由于取消任务，参数为true表示可以取消正在执行的任务</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span>    <span class="comment">//判断是否被取消成功</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span>    <span class="comment">//判断任务是否已经完成</span></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span>     <span class="comment">//获取执行结果，这个方法会发生阻塞，一直等到任务执行完毕才返回执行结果</span></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> time, TumeUnit unit)</span>  <span class="comment">//由于在指定时间内获取执行结果</span></span></span><br></pre></td></tr></table></figure>

<h3 id="三种方法的对比分析"><a href="#三种方法的对比分析" class="headerlink" title="三种方法的对比分析"></a>三种方法的对比分析</h3><p>Callable接口的方法有返回值，并且可以声明抛出异常。</p>
<p>若是想要多个线程共享一个数据，则由于继承Thread的方法需要创建多个子类的线程对象，无法共享类内的private变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MyThread1().start();</span><br><span class="line"><span class="keyword">new</span> MyThread1().start();</span><br></pre></td></tr></table></figure>

<p>创建多线程时，如果没有通过构造方法指定线程名称，则系统会默认生成线程名称。</p>
<p>为了确保多个线程共享一个数据，用Runnable接口实现，程序只创建一个类的对象，而是创建多个thread类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread2 myThread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line"><span class="keyword">new</span> Thread(myThread2, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(myThread2, <span class="string">&quot;线程2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>因此，Runnable接口或Callable接口实现多线程相比于继承Thread类来说，好处在于：</p>
<p>（1）适合多个线程处理同一个共享资源的情况，体现面向对象设计思想。</p>
<p>（2）避免Java单继承的局限，若类已继承某父类，则还可以实现接口。</p>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>main方法中创建并启动几个新线程后，主线程随之结束，但是，虽然主线程结束了，但整个Java程序并未结束，对java程序来说，只要还有前台线程在运行，这个进程就不会结束。如果一个进程中只有后台线程运行，这个进程就会结束。</p>
<p>新创建的线程默认是前台线程，如果某个线程对象在启动之前调用了setDaemon(true)语句，这个线程就变成一个后台线程。</p>
<p>判断是否是后台线程：<code>th.isDaemon()</code></p>
<p><code>th.setDaemon(true);   thread.start();  </code>  //一定是在start启动之前</p>
<p>整个进程结束，JVM会通知后台线程结束，由于后台线程从接收指令到做出响应，需要一定的时间，结束后台进程会有一定的延迟。</p>
<h2 id="线程的生命周期及状态转换"><a href="#线程的生命周期及状态转换" class="headerlink" title="线程的生命周期及状态转换"></a>线程的生命周期及状态转换</h2><p>在Java中，任何对象都有生命周期，线程也不例外，Thread对象创建完成时，线程的生命周期便开始了，当执行完毕或抛出异常或错误时，生命周期便结束。</p>
<p><img src="https://img-blog.csdnimg.cn/ca388386e5024a2d9bdcc74eafa835bc.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p><em><strong>新建状态</strong></em>：创建一个线程对象后，仅仅由JVM为其分配了内存，没有表现出任何线程的动态特征。</p>
<p><em><strong>就绪状态</strong></em>：线程对象调用start方法之后，等待JVM调度，此时并未运行。</p>
<p><em><strong>运行状态</strong></em>：线程对象获得JVM调度，如果存在多个CPU，则允许多个线程并行运行。</p>
<p><em><strong>阻塞状态</strong></em>：线程运行过程中，发出I/O请求时，该线程进入阻塞状态。当线程运行过程中获取同步锁时，却被另一个线程获取，此时JVM把当前线程存到对象的锁池中，该线程进入阻塞状态。此时，JVM不会给线程分配CPU，直到线程重新进入就绪状态，才有机会转换到运行状态。</p>
<p><em><strong>等待状态</strong></em>：当处于运行状态的线程调用了限制的方法后，如wait()方法、join()方法，当前线程进入等待状态。<br>处于等待状态的线程无法立即争夺CPU使用权，需要等待其他线程执行特定的操作后，才有机会再次争夺，将等待状态变为运行状态。<br><code>wait()</code>方法：等待其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法，来唤醒当前等待中的线程。<br><code>join()</code>方法：必须等待其他加入的线程终止。</p>
<p><em><strong>定时等待状态</strong></em>：类似等待状态，执行<code>sleep(long millis)、wait(long timeout)、join(long millis)</code>等方法。必须等待其他相关线程执行完特定操作<strong>或</strong>限时时间结束后，才有机会再次争夺CPU，进入运行状态。</p>
<p><em><strong>终止状态</strong></em>：线程的run()方法或者call()方法执行完毕，或线程抛出一个未捕获的异常（Exception）、错误（Error），线程进入终止状态。一旦进入终止状态，线程将不再拥有运行的资格，也不能再转换到其他状态，生命周期结束。</p>
<h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><p>Java虚拟机会按照特定的机制为程序中的每个线程分配CPU的使用权，这种机制叫做线程的调度。</p>
<p>计算机中线程的调度有两种模型：<br>1、分时模型：所有线程轮流获得CPU的使用权，并且平均分配每个线程占用的CPU时间片。<br>2、抢占式调度模式：让可运行池中所有就绪状态的线程争抢CPU的使用权，优先级高的线程获得CPU概率更大。</p>
<p>Java虚拟机默认采用抢占式调度模式，特定需求下需要改变模式，由程序自己来控制CPU的调度。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>线程的优先级用1-10之间的整数来表示，数字越大优先级越高。除了直接用数字外，还可用Thread类中提供的三个静态常量表示线程的优先级。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//用lambda表达式创建线程？</span></span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;正在输出i+&quot;</span>+i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;优先级较低的线程&quot;</span>);</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;正在输出j+&quot;</span>+j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;优先级较高的线程&quot;</span>);</span><br><span class="line">		<span class="comment">//设置线程的优先级</span></span><br><span class="line">		th1.setPriority(Thread.MIN_PRIORITY);  <span class="comment">//MIN=1 NORM=5  MAX=10</span></span><br><span class="line">		th2.setPriority(<span class="number">10</span>);</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p>将正在执行的线程暂停，将CPU使用权让给其他线程，这是可以使用静态方法sleep(long millis)，该方法使得线程进入休眠等待状态（阻塞），这样其他线程就可以得到执行的机会。sleep(long millis)方法会声明抛出InterruptedException异常，因此在调动该方法时应该捕获异常，或者声明抛出异常。休眠时间结束后，线程才会转换到就绪状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;正在输出i+&quot;</span>+i);</span><br><span class="line">				<span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span>&#123;</span><br><span class="line">						<span class="comment">//在该线程执行过程中进入睡眠状态，让其他线程先执行</span></span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;正在输出j+&quot;</span>+j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h3><p><code>Thread.yield();</code> 使当前正在运行的线程暂停，但不会阻塞该线程，只是将线程转换成就绪状态，让线程的调度器重新调度一次。Thread的yield方法，在线程类实现内使用。</p>
<p>相当于让占着CPU的线程让步，交出CPU，大家重新抢占一次，因此，也有可能自己再抢到。</p>
<h3 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h3><p>当某个线程a中调用其他线程b的join方法时，线程a将被阻塞，线程b插队优先执行，直到线程b执行完成后，线程a才会完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;输入：&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">		<span class="comment">//创建线程</span></span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1(), <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		th1.start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;输入&quot;</span>+i);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">				th1.join();  <span class="comment">//th1插队执行，main阻塞，在th1执行完才会继续执行</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除join无参数的线程插队方法外，Thread还提供了带有时间参数的线程插队方法<code>join(long millis)</code>。表示需要等待插队的线程执行指定时间后，才可以继续执行其他线程。</p>
<p>mian函数本身也算是一个主线程。</p>
<h2 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h2><p>多线程同步：限制某个资源在同一时刻只能被一个线程访问。</p>
<p>Runnable接口实现多线程，适合多个线程处理同一个共享资源的情况。但是共享的时候会出现线程安全的问题。</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>Java提供了线程同步机制，当多个线程使用同一共享资源时，可以将<strong>处理共享资源的操作代码</strong>放置在一个使用synchronized关键字来修饰的代码块中，这段代码块被称作同步代码块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	<span class="comment">//操作共享资源代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock是一个锁对象，是同步代码块的关键。当线程执行同步代码块时，首先会检查锁对象的标志位，默认情况下标志位为1，此时线程会执行同步代码块，同时将锁对象的标志位置为0。当一个新的线程执行到这段同步代码块时，由于锁对象的标志位为0，新线程会发生阻塞，等锁对象的标志位被置为1，新线程才能进入同步代码块执行其中的代码。（好比公共电话亭，前一个打完出来，后面的人才能进去）。</p>
<p>同步代码块中的锁对象可以是任意类型的对象，但多个线程共享的锁对象必须是相同的。锁对象的创建代码不能放在run()方法中，否则每个线程运行到run()方法都会创建一个新对象，这样每个线程都会有一个不同的锁，每个锁有自己的标志位，无法同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 多线程模拟售票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-30 13:15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SaleThread saleThread = <span class="keyword">new</span> SaleThread();</span><br><span class="line">        <span class="comment">//创建并开启4个线程，模拟四个售票窗口</span></span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaleThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();  <span class="comment">//定义任意一个对象，用作同步代码块的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);  <span class="comment">//模拟售票耗时过程</span></span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                +<span class="string">&quot;正在发售第&quot;</span>+tickets--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个文件中可以有多个class类，但只能有一个含mian函数的类，并且文件名需要和含main函数的类的名字相同。</p>
</blockquote>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>在方法前面也可以使用synchronized关键字来修饰，被修饰的方法为同步方法，它能实现和同步代码块同样的功能。</p>
<p><code>[修饰符] synchronized 返回值类型 方法名(参数)&#123;&#125;</code></p>
<p>被synchronized修饰的方法在某一时刻只允许一个线程访问，访问该方法的其他线程都会发生阻塞，直到当前线程访问完毕后，其他线程才有机会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同步方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-30 13:47</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_Thread1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SaleThread1 saleThread = <span class="keyword">new</span> SaleThread1();</span><br><span class="line">        <span class="comment">//创建并开启4个线程，模拟四个售票窗口</span></span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaleThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;    <span class="comment">//在run方法中调用synchronized修饰的同步方法</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            saleTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);  <span class="comment">//模拟售票耗时过程</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                    +<span class="string">&quot;正在发售第&quot;</span>+tickets--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块的锁是自己定义的任意类型的对象。同步方法的锁是当前调用该方法的对象，也就是this指向的对象。同步方法被所有线程所共享，方法所在的对象相对于所有线程来说是唯一的，从而保证了锁的唯一性。当一个线程执行该方法，其他的线程就不能进入该方法。</p>
<p>有时，需要同步的方法是静态方法，静态方法不需要创建对象就可用类名调用，静态同步方法的锁是该方法所在类的class对象，该对象可以直接用<code>类名.class</code>的方式来获取。</p>
<p>同步代码块和同步方法：解决了多线程访问共享数据时的线程安全问题，即加锁来使同一时间只有一个线程执行。</p>
<p>弊端：线程在执行同步代码时每次都会判断锁的状态，消耗资源，效率较低。</p>
<h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><p>synchronized同步代码块和同步方法使用一种封闭式的锁机制，但是它无法中断一个正在等候获得锁的线程，也无法通过轮询得到锁。</p>
<p>JDK5开始，java提供了一个功能更强大的Lock锁，Lock锁与synchronized隐式锁在功能上基本相同，最大的优势在于Lock锁可以让某个线程在持续获取同步锁失败后返回，不再继续等待，使用起来更加灵活。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Lock锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-30 14:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tset_Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockThread saleThread = <span class="keyword">new</span> LockThread();</span><br><span class="line">        <span class="comment">//创建并开启4个线程，模拟四个售票窗口</span></span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//定义一个lock锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lo = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            lo.lock();</span><br><span class="line">            <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);  <span class="comment">//模拟售票耗时过程</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            +<span class="string">&quot;正在发售第&quot;</span>+tickets--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    lo.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Lock</code>接口的实现类：<code>ReentrantLock</code>。</p>
<p>还有<code>tryLock()</code>方法用来判断某个线程锁是否可用。</p>
<blockquote>
<p>注意：不管是同步代码块、同步方法还是同步锁，锁对象都是几个线程共享的，不能在run方法中定义，都是在run方法之外定义。同步方法中，只创建一个对象，一个对象代表锁对象。</p>
</blockquote>
<h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>两个线程都需要对方所占用的锁，但是都无法释放自己所拥有的锁。</p>
<h2 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h2><p>控制多个线程按照一定的顺序轮流执行，此时就需要让线程间进行通信，保证线程任务的协调进行。</p>
<p>Java在Object类中提供了<code>wait()、notify()、notifyAll()</code>等方法用于解决线程间的通信问题。所有类都是Object类的子类或间接子类，因此任何类都可直接用这些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span>  <span class="comment">//使当前线程进入等待状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span>  <span class="comment">//唤醒此同步锁上等待的第一个调用wait()方法的线程</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span>  <span class="comment">//唤醒此同步锁上调用wait()方法的所有线程</span></span></span><br></pre></td></tr></table></figure>

<p>这些方法的调用者都是<strong>同步锁对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程间通信</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-30 15:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread_Commu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个集合类，模拟存储生产的商品</span></span><br><span class="line">        List&lt;Object&gt; goods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录线程执行前统一的起始时间start</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//创建一个生产者线程，由于生产商品并存入商品集合</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis()-start&lt;=<span class="number">1000</span>)&#123;  <span class="comment">//控制执行时间</span></span><br><span class="line">                <span class="comment">//使用synchronized关键字同步商品生产和消费</span></span><br><span class="line">                <span class="keyword">synchronized</span> (goods)&#123;</span><br><span class="line">                    <span class="comment">//有商品就让生产者等待</span></span><br><span class="line">                    <span class="keyword">if</span>(goods.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            goods.wait();</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//生产者继续生产商品</span></span><br><span class="line">                        num++;</span><br><span class="line">                        goods.add(<span class="string">&quot;商品&quot;</span>+num);</span><br><span class="line">                        System.out.println(<span class="string">&quot;生产商品&quot;</span>+num);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis()-start&lt;=<span class="number">1000</span>)&#123;  <span class="comment">//控制执行时间</span></span><br><span class="line">                <span class="comment">//使用synchronized关键字同步商品生产和消费</span></span><br><span class="line">                <span class="keyword">synchronized</span> (goods)&#123;</span><br><span class="line">                    <span class="comment">//商品不足就唤醒生产者进行生产</span></span><br><span class="line">                    <span class="keyword">if</span>(goods.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        goods.notifyAll();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//继续消费商品</span></span><br><span class="line">                        num++;</span><br><span class="line">                        goods.remove(<span class="string">&quot;商品&quot;</span>+num);</span><br><span class="line">                        System.out.println(<span class="string">&quot;消费商品&quot;</span>+num);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">        <span class="comment">//同时启动生产者和消费者两个线程，并统一执行100ms时间</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，实现供需有序、均衡，按照先生产后消费的顺序轮流执行。</p>
<p>注意：wait函数中，可有时间，时间到了，也可以自动唤醒处于等待状态的线程。唤醒的方式：其他线程notify唤醒 或 时间到。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>前面的多线程中，复杂任务会频繁手动式地创建、管理线程，线程对象使用了大量的内存，在大规模应用中，创建、分配和释放多线程对象会产生大量内存管理开销。为此，Java提供了线程池来创建多线程，进一步优化线程管理。</p>
<h3 id="Executor接口实现线程池管理"><a href="#Executor接口实现线程池管理" class="headerlink" title="Executor接口实现线程池管理"></a>Executor接口实现线程池管理</h3><p>从JDK5开始，java.util.concurrent包下增加了Executor接口及其子类，允许使用线程池技术来管理线程并发问题。</p>
<p>Executor接口提供一个常用的ExecutorService子接口，通过该子接口可以方便地管理线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-01 12:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.定义一个实现Runnable接口或者Callable接口的实现类，同时重写run()或者call()方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread4</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1.1重写Callable接口的call()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++&lt;<span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                              +<span class="string">&quot;的call()方法在运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread_Pool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">//2.创建Runnable接口或者Callable接口的实现类对象</span></span><br><span class="line">        MyThread4 myth = <span class="keyword">new</span> MyThread4();</span><br><span class="line">        <span class="comment">//3.使用Executors线程执行器类创建可扩展的线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//4.将Callable接口实现类对象提交到线程池进行管理</span></span><br><span class="line">        Future&lt;Object&gt;res1 = executor.submit(myth);</span><br><span class="line">        Future&lt;Object&gt;res2 = executor.submit(myth);</span><br><span class="line">        <span class="comment">//5.关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="comment">//对于有返回值的线程任务，获取执行结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;thread-1返回结果：&quot;</span>+res1.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;thread-2返回结果：&quot;</span>+res2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池executor系统给名字pool-1.该线程池中管理有两个默认生成名称的线程thread-1和thread-2.</p>
<p>线程池通过Executors的newCachedThreadPool方法创建，Executors是JDK5增加的线程执行器工具类，提供四种方法创建线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newCachedThreadPool()    创建一个可扩展线程池的执行器。适合由于启动许多短期任务的应用程序。</span><br><span class="line">newFixedThreadPool(<span class="keyword">int</span> n)     创建固定线程数量线程池的执行器。</span><br><span class="line">newSingleThreadExecutor()     创建一个只执行一个任务的单线程</span><br><span class="line">newScheduledThreadPool(<span class="keyword">int</span> size)    创建一个定长线程池，支持定时及周期性任务执行。</span><br></pre></td></tr></table></figure>

<h3 id="CompletableFuture类实现线程池管理"><a href="#CompletableFuture类实现线程池管理" class="headerlink" title="CompletableFuture类实现线程池管理"></a>CompletableFuture类实现线程池管理</h3><p>使用Callable接口实现多线程时，会用到FutureTask类对线程执行结果进行管理和获取，该类获取结果时是通过阻塞或者轮询的方式，消耗过多资源。</p>
<p>JDK8增加了一个强大的函数式异步编程辅助类CompletableFuture，该类同时实现了Future接口和CompletionStage接口（Java8增加的线程任务完成结果接口），可以简化异步编程。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》类与集合</title>
    <url>/2021/11/17/myblog/JAVA/%E3%80%8AJava%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E3%80%8B%E7%B1%BB%E4%B8%8E%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="java中的常用类"><a href="#java中的常用类" class="headerlink" title="java中的常用类"></a>java中的常用类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String类的几种初始化方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>使用字符串常量直接初始化一个String对象</span><br><span class="line">String ss = <span class="keyword">null</span>;  初始化为空</span><br><span class="line">String ss = “”;  初始化为空字符串</span><br><span class="line">String ss = “abc”;  初始化为abc</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>使用String的构造方法初始化字符串对象</span><br><span class="line">String ss = <span class="keyword">new</span> String();  初始化为空字符串</span><br><span class="line">String ss = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);  初始化为abc</span><br><span class="line"><span class="comment">//根据指定字符数组创建字符串</span></span><br><span class="line"><span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String ss = <span class="keyword">new</span> String(ch);</span><br></pre></td></tr></table></figure>

<p>String类基本操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;abcdefghigk&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;字符串长度：&quot;</span>+s.length());</span><br><span class="line"><span class="comment">//字符串是.length()，数组是.length</span></span><br><span class="line">System.out.println(<span class="string">&quot;字符串第i个字符：&quot;</span>+s.charAt(i));</span><br><span class="line">System.out.println(<span class="string">&quot;字符c第一次出现的位置：&quot;</span>+s.indexOf(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;字符c最后一次出现的位置：&quot;</span>+s.lastIndexOf(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;子字符串第一次出现的位置：&quot;</span>+s.indexOf(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;子字符串最后一次出现的位置：&quot;</span>+s.lastIndexOf(<span class="string">&quot;ab&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>字符串的转换操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="comment">//字符串转换为字符数组：</span></span><br><span class="line"><span class="keyword">char</span>[] ch=s.toCharArray();</span><br><span class="line">System.out.println(<span class="string">&quot;int值转换为string类型：&quot;</span>+String.valueOf(<span class="number">100</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;字符串转换为大写：&quot;</span>+s.toUpperCase());</span><br></pre></td></tr></table></figure>

<p>字符串的替换和去除空格操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;  a b &quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;去除字符串两端空格后的结果：&quot;</span>+s.trim());</span><br><span class="line"><span class="comment">//用字符串替换操作完成去除空格</span></span><br><span class="line">System.out.println(<span class="string">&quot;去除字符串所有空格后的结果：&quot;</span>+s.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>replace()方法是可以替换子字符串的。</p>
<p>字符串的判断操作：返回boolean类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;Starter&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否以字符串St开头：&quot;</span>+s.startWith(<span class="string">&quot;St&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否以字符串er结尾：&quot;</span>+s.endWith(<span class="string">&quot;er&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否包含ar：&quot;</span>+s.contains(<span class="string">&quot;ar&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否为空：&quot;</span>+s.isEmpty());</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否相等：&quot;</span>+s.equals(<span class="string">&quot;St&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="和equals"><a href="#和equals" class="headerlink" title="==和equals()"></a>==和equals()</h4><p> ==对于基本类型和引用类型 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同</li>
<li>引用类型：比较的是引用（对象的内存地址）是否相同，string是引用类型。</li>
</ul>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，<strong>把它变成了值比较。</strong></p>
<p>在String类中，重写了父类Object中的equals()方法。把它变成了<strong>值比较</strong>。</p>
<p>==和equals()方法不同，equals方法用来比较两个字符串中的字符值是否相等，==方法用于比较两个字符串对象的内存地址是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String x = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String y = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">x==y  (<span class="keyword">true</span>)  x.equals(y)  (<span class="keyword">true</span>)</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">String m = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">z==m  (<span class="keyword">false</span>)  z.equals(m)  (<span class="keyword">true</span>)</span><br><span class="line">x==z  (<span class="keyword">false</span>)  x.equals(z)  (<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>字符串的截取与分割：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;2021-11-11&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;截取：&quot;</span>+s.substring(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//结果为11-24  左闭右开原则，从下标5开始截取</span></span><br><span class="line">System.out.println(<span class="string">&quot;截取：&quot;</span>+s.substring(<span class="number">5</span>,<span class="number">7</span>));</span><br><span class="line"><span class="comment">//结果为11</span></span><br><span class="line">String[] sArray=s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="comment">//将字符串按照某个字符进行分割，变为字符串数组</span></span><br></pre></td></tr></table></figure>

<p>java中，String类是final类型的，所以使用String类定义的字符串是一个常量，它一旦创建，内容和长度不可改变。</p>
<h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>类似一个字符容器，在其中添加和删除字符时，操作的都是这个字符容器，不会产生新的StringBuffer对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(<span class="string">&quot;abc&quot;</span>);   <span class="comment">//添加字符串，始终是添加到缓冲区的末尾</span></span><br><span class="line">sb.insert(<span class="number">3</span>,<span class="string">&quot;de&quot;</span>);   <span class="comment">//在3的前面插入，变为abcde</span></span><br><span class="line">sb.setCharAt(<span class="number">2</span>,<span class="string">&#x27;f&#x27;</span>);  <span class="comment">//修改指定位置字符，变为abfde</span></span><br><span class="line">sb.replace(<span class="number">3</span>,<span class="number">5</span>,<span class="string">&quot;gh&quot;</span>);  <span class="comment">//左闭右开替换指定位置字符串或字符</span></span><br><span class="line">System.out.println(sb.reverse());   <span class="comment">//字符串翻转结果</span></span><br><span class="line">sb.delete(<span class="number">3</span>,<span class="number">7</span>);   <span class="comment">//左闭右开删除</span></span><br><span class="line">sb.deleteCharAt(<span class="number">2</span>);   <span class="comment">//删除指定位置字符</span></span><br><span class="line">sb.delete(<span class="number">0</span>,sb.length());   <span class="comment">//清空缓冲区</span></span><br></pre></td></tr></table></figure>

<h3 id="String和StringBuffer区别"><a href="#String和StringBuffer区别" class="headerlink" title="String和StringBuffer区别"></a>String和StringBuffer区别</h3><p>（1）String类定义的字符串是常量，一旦创建后，内容和长度都是无法改变的。StringBuffer类表示字符容器，其内容和长度可以随时修改。</p>
<p>（2）String类重写了Object类的equals()方法，而StringBuffer类没有重写Object类的equals方法，依然表示内存地址相同？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String s2=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2));   <span class="comment">//结果为true</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb1=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">StringBuffer sb2=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(sb1.equals(sb2));   <span class="comment">//结果为false</span></span><br></pre></td></tr></table></figure>

<p>（3）String类对象可以用操作符+进行连接，而StringBuffer类对象之间不能。</p>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>除了使用StringBuffer外，JDK1.5之后提供了StringBuilder类，同样可以操作字符串。</p>
<p>不同之处在于，StringBuffer是线程安全的，而StringBuilder没有实现线程安全功能，所以性能略高。因此，一般创建一个内容可变的字符串对象，应该优先考虑StringBuilder类。</p>
<p>StringBuilder类的方法和StringBuffer类一样。</p>
<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>System类定义了一些与系统相关的属性和方法，它所提供的属性和方法都是静态的，可以直接使用System类进行调用（不用创建对象进行调用）。</p>
<h4 id="getProperties-方法"><a href="#getProperties-方法" class="headerlink" title="getProperties()方法"></a>getProperties()方法</h4><p>用于获取当前系统的全部属性，该方法返回一个Properties对象，其中封装了系统的所有属性，这些属性以键值对的形式存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemPropertiesDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//获取系统所有属性</span></span><br><span class="line">		Properties pro = System.getProperties();</span><br><span class="line">		<span class="comment">//获取所有系统属性的key，返回set对象</span></span><br><span class="line">        Set&lt;String&gt;proName=pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span>(String key:proName)&#123;</span><br><span class="line">            <span class="comment">//获取key（属性名）对应的属性值</span></span><br><span class="line">            String value=System.getProperty(key);</span><br><span class="line">            System.out.println(key+<span class="string">&quot;-&gt;&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h4><p>currentTimeMillis()方法返回一个long类型的值，表示当前时间与1970年1月1日0点0分0秒之间的时间差，单位毫秒。</p>
<h4 id="arraycopy-方法"><a href="#arraycopy-方法" class="headerlink" title="arraycopy()方法"></a>arraycopy()方法</h4><p>用于将一个数组中的元素快速拷贝到另一个数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=&#123;<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>,<span class="number">104</span>,<span class="number">105</span>,<span class="number">106</span>&#125;;  <span class="comment">//源数组</span></span><br><span class="line"><span class="keyword">int</span>[] b=&#123;<span class="number">201</span>,<span class="number">202</span>,<span class="number">203</span>,<span class="number">204</span>,<span class="number">205</span>&#125;;   <span class="comment">//目标数组</span></span><br><span class="line">System.arraycopy(a,<span class="number">2</span>,b,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//最终b变为103，104，105，106，205</span></span><br></pre></td></tr></table></figure>

<p>以上例子中，从a数组索引为2的元素开始拷贝，并且拷贝4个元素存放在目标数组中索引为0的位置。</p>
<p>注意：进行数组拷贝时，一定要保证源数组类型和目标数组类型一致，截取的长度不能超过源数组界限，也不能超过目标数组可以容纳的个数。</p>
<h4 id="gc-方法和exit-int-status-方法"><a href="#gc-方法和exit-int-status-方法" class="headerlink" title="gc()方法和exit(int status)方法"></a>gc()方法和exit(int status)方法</h4><p>gc()方法用于启动java的垃圾回收器，并对内存中的垃圾对象进行回收。</p>
<p>exit(int status)用于终止当前正在运行的java虚拟机，参数表示当前发生的异常状态，一般指定0，表示正常退出，否则表示异常终止。</p>
<h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p>Runtime类用于表示Java虚拟机运行时的状态，用于封装Java虚拟机进程，因此可以通过该类的实例对象来获取当前虚拟机的相关信息。</p>
<p>每次使用java命令启动java虚拟机时都会对应一个Runtime实例，并且只有一个实例，应用程序会通过该实例与其运行时的环境相连。应用程序不能创建自己的Runtime实例，若想在程序中获得一个Runtime实例，可以通过getRuntime()方法获取与之相关的Runtime对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime(); <span class="comment">//获取java程序关联的运行时对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;处理器个数：&quot;</span>+rt.availableProcessors()); <span class="comment">//单位个</span></span><br><span class="line">System.out.println(<span class="string">&quot;空闲内存大小：&quot;</span>+rt.freeMemory()); <span class="comment">//单位字节</span></span><br><span class="line">System.out.println(<span class="string">&quot;最大可用内存大小：&quot;</span>+rt.maxMemory()); <span class="comment">//单位字节</span></span><br></pre></td></tr></table></figure>

<h4 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec()方法"></a>exec()方法</h4><p>该方法用于执行一个DOS命令，实现和在终端中输入DOS命令同样的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime();</span><br><span class="line">rt.exec(<span class="string">&quot;notepad.exe&quot;</span>)   <span class="comment">//打开记事本</span></span><br></pre></td></tr></table></figure>

<p>exec()方法返回一个Process对象，该对象表示操作系统的一个进程，通过Process对象可对产生的新进程进行管理，如关闭destroy()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime();</span><br><span class="line">Process pr = rt.exec(<span class="string">&quot;notepad.exe&quot;</span>)   <span class="comment">//打开记事本</span></span><br><span class="line"><span class="comment">//程序休眠3s</span></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">pr.destroy();   <span class="comment">//关闭进程</span></span><br></pre></td></tr></table></figure>

<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>Math类是一个工具类，主要用于完成复杂的数学运算，如求绝对值，三角函数，指数运算等。其构造方法被定义为private，因此无法创建Math类的对象。</p>
<p>Math类的多有方法都是静态方法，可以直接通过类名来调用它们。</p>
<p>除静态方法外，Math类中还有两个静态常量PI和E，分别表示Π和e。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.abs(-1);</span><br><span class="line">Math.sin/tan/cos(2.0);</span><br><span class="line">Math.sqrt(4);  //求平方根</span><br><span class="line">Math.cbrt(9);  //求立方根</span><br><span class="line">Math.pow(2,2);  //幂次运算</span><br><span class="line">Math.ceil(1.2);  //大于参数的最小整数，返回double类型的数</span><br><span class="line">Math.floor(1.2);  //小于参数的最大整数，返回double类型的数</span><br><span class="line">Math.round(1.2);  //四舍五入的整数，返回int类型的数</span><br><span class="line">Math.max(1,2);</span><br><span class="line">Math.min(1,2);</span><br><span class="line">Math.random();   //生成一个大于等于0.0小于1.0的随机值</span><br></pre></td></tr></table></figure>

<h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><p>在JDK的java.util包中，有一个Random类，可以在指定的取值范围内随机产生数字。</p>
<p>Random类有两个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random()   无参构造，通过它创建的Random实例对象每次使用的种子随机，因此每个对象所产生的随机数不同。</span><br><span class="line">Random(<span class="keyword">long</span> seed)  有参构造，使用种子创建伪随机数生成器，当seed相同时，每次实例化Random对象会生成相同的随机数</span><br></pre></td></tr></table></figure>

<p>Random类的各种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">r.nextBoolean()    随机的<span class="keyword">boolean</span></span><br><span class="line">r.nextDouble()   <span class="keyword">double</span>类型的随机数</span><br><span class="line">r.nextFloat()  <span class="keyword">float</span>类型的随机数</span><br><span class="line">r.nextInt()   <span class="keyword">int</span>类型的随机数</span><br><span class="line">r.nextInt(<span class="number">10</span>)  <span class="number">0</span>到<span class="number">10</span>之间<span class="keyword">int</span>类型的随机数</span><br><span class="line">r.nextLong()   <span class="keyword">long</span>型随机数</span><br></pre></td></tr></table></figure>

<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>虽然Java是面向对象的编程语言，但它所包含的8种基本数据类型却不支持面向对象的编程机制（没有属性和方法）。Java之所以提供这8种基本数据类型，是为了方便常规数据的处理。但是在Java种，很多类的方法都需要接收引用类型的对象，此时就无法将一个基本数据类型的值传入。</p>
<p>为了解决这一问题，JDK提供了一系列的包装类，通过包装类可以将基本数据类型的值包装为引用数据类型的对象。</p>
<table>
<thead>
<tr>
<th align="center">byte</th>
<th align="center">Byte</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<p>包装类和基本数据类型在转换时，引入了自动装箱和自动拆箱</p>
<p>装箱：将基本数据类型的变量赋给对应的包装类变量（对象）。</p>
<p><code>int a=20;    Integer b=a;</code></p>
<p>拆箱：将包装类对象类型直接赋给一个对应的基本数据类型变量。</p>
<p><code>int c=b</code></p>
<p>此外，Java还提供了其他方法来支持基本数据类型、基本数据包装类以及字符串之间的相互转换。</p>
<p>（1）String类的valueOf()方法，将八种基本数据类型转化为字符串类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num=123;</span><br><span class="line">String s=String.valueOf(num);</span><br></pre></td></tr></table></figure>

<p>（2）包装类的valueOf()方法，既可以实现装箱，也可以实现将内容匹配的字符串转换为对应的包装类（除Character包装类）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num=123;</span><br><span class="line">Integer in=Integer.valueOf(num);</span><br><span class="line">String s=&quot;123&quot;;</span><br><span class="line">Integer in2=Integer.valueOf(s);</span><br></pre></td></tr></table></figure>

<p>（3）通过包装类的有参构造方法将基本数据类型转换为包装类（装箱），也可以将字符串转换为包装类（除Character包装类）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num=123;</span><br><span class="line">Integer in=new Integer(num);</span><br><span class="line">String s=&quot;123&quot;;</span><br><span class="line">Integer in2=new Integer(s);</span><br></pre></td></tr></table></figure>

<p>（4）通过包装类的静态方法parseXxx()方法将字符串转换为对应的基本数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s=&quot;123&quot;;</span><br><span class="line">int num=Integer.parseInt(s);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>凡是类名.方法名的，都是静态static方法</p>
</blockquote>
<p>（5）包装类都重写了Object类中的toString方法，将包装类转换为字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer in=new Integer(123);</span><br><span class="line">//Integer in=Integer.valueOf(123);</span><br><span class="line">String s=in.toString();</span><br></pre></td></tr></table></figure>

<p>注意：包装类的<code>valueOf(String s)</code>和<code>parseInt(String s)</code> 中，参数s不能为null，而且需要和解析对应。</p>
<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>JDK中的java.util包中，提供了一个Date类用来表示日期和时间，该类在JDK1.0时已经开始使用。JDK8中有两个构造方法可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date()  <span class="comment">//用来创建当前日期时间的Date对象。</span></span><br><span class="line">Date date1=<span class="keyword">new</span> Date();  <span class="comment">//Sat Jan 11:09:21 CST 2021</span></span><br><span class="line">Date(<span class="keyword">long</span> date)  <span class="comment">//用于创建指定时间的Date对象，date是1970.1.1.0.0.0以来的毫秒数，即时间戳</span></span><br><span class="line">Date date2=<span class="keyword">new</span> Date(System.currentTimeMillis()+<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//Sat Jan 11:09:22 CST 2021</span></span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>Calendar类用于完成日期和时间字段的操作，可以通过特定方法设置和读取日期的特定部分。</p>
<p>Calendar类是一个抽象类，不可以被实例化，在程序中需要调用静态方法getInstance()来得到一个Calendar对象，然后才能调用其相应的方法。</p>
<blockquote>
<p>疑问？抽象类创建对象，这是什么操作？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar ca = Calendar.getInstance();</span><br><span class="line"><span class="keyword">int</span> year=ca.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> month=ca.get(Calendar.MONTH)+<span class="number">1</span>;  <span class="comment">//注意月份0-11，需要加1</span></span><br><span class="line"><span class="keyword">int</span> date=ca.get(Calendar.DATE);</span><br><span class="line"><span class="keyword">int</span> hour=ca.get(Calendar.HOUR);</span><br><span class="line"><span class="keyword">int</span> minute=ca.get(Calendar.MINUTE);</span><br><span class="line"><span class="keyword">int</span> second=ca.get(Calendar.SECOND);</span><br></pre></td></tr></table></figure>

<p>添加和修改时间的功能可以通过add和set方法实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar ca = Calendar.getInstance();</span><br><span class="line">ca.set(2021.11.11);   //设置指定日期</span><br><span class="line">ca.add(Calendar.DATE,100);  //为指定日期增加时间</span><br><span class="line">输出时间依然需要用get方法来获取年月日。</span><br></pre></td></tr></table></figure>

<p>Calendar有两种解释日历字段的模式，容错模式和非容错模式，容错模式下，月是12是可以接受的。默认容错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar ca = Calendar.getInstance();</span><br><span class="line">ca.set(Calendar.MONTH, 13);  //不会报错</span><br><span class="line">//开启non-lenient非容错模式</span><br><span class="line">ca.setLenient(false);</span><br><span class="line">ca.set(Calendar.MONTH, 13);  //会报错</span><br></pre></td></tr></table></figure>

<p>Date和Calendar对象之间的转化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(ca.getTime());  //Calendar的getTime方法返回一个表示Calendar时间值的Date对象。</span><br><span class="line">setTime(Date date)</span><br><span class="line">Calendar ca = setTime(date);  //Calendar的setTime方法接收一个Date对象，将Date对象表示的时间值设置给Calendar对象。</span><br></pre></td></tr></table></figure>

<h3 id="JDK8的日期和时间类"><a href="#JDK8的日期和时间类" class="headerlink" title="JDK8的日期和时间类"></a>JDK8的日期和时间类</h3><p>为了满足更多的需求，JDK8比之前的版本增加了一个java.time包，在该包下包含了更多日期和时间操作类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、Clock类</span><br><span class="line">Clock cl = Clock.systemUTC();</span><br><span class="line">获取UTC时区转换的当前时间： cl.instance()</span><br><span class="line">获取UTC时区转换的毫秒数： cl.millis()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>Duration类</span><br><span class="line">Duration du = Duration.ofDays(<span class="number">1</span>);</span><br><span class="line">一天等于多少小时：  du.toHours()</span><br><span class="line">一天等于多少分钟：  du.toMinutes()</span><br><span class="line">一天等于多少秒：  du.toMillis()</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>Instant类</span><br><span class="line">Instant in = Instant.now();</span><br><span class="line">UTC时区的当前时间：in</span><br><span class="line">当前时间一小时后的时间：in.plusSeconds(<span class="number">3600</span>)</span><br><span class="line">当前时间一小时前的时间：in.minusSeconds(<span class="number">3600</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>LocalDate</span><br><span class="line">LocalDate lo = LocalDate.now();</span><br><span class="line">从默认时区的系统时钟获得当前日期：lo</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>LocalTime</span><br><span class="line">LocalDate lo = LocalDate.now();</span><br><span class="line">从默认时区的系统时钟获得当前时间：lo</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span>LocalDateTime</span><br><span class="line">LocalDateTime lo = LocalDateTime.now();</span><br><span class="line">从默认时区的系统时钟获得当前日期和时间：lo</span><br><span class="line">当前的日期和时间加上<span class="number">1</span>天<span class="number">3</span>小时<span class="number">30</span>分钟：</span><br><span class="line">LocalDateTime time = LocalDateTime.plusDays(<span class="number">1</span>).plusHours(<span class="number">3</span>).plusMinutes(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>Year、YearMonth、MonthDay</span><br><span class="line">当前年份：Year ye = Year.now();</span><br><span class="line">当前年月：YearMonth ym = YearMonth.now();</span><br><span class="line">当前月日：MonthDay md = MonthDay.now();</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>获取系统默认时区</span><br><span class="line">ZoneId zi = ZoneId.systemDefault();</span><br></pre></td></tr></table></figure>

<p>注意，clock.instant()和Instant.now()获取的时间都是默认使用UTC时区（世界协调时间，世界标准时间），比中国标准时间CST早八小时。</p>
<h3 id="格式化类"><a href="#格式化类" class="headerlink" title="格式化类"></a>格式化类</h3><h4 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h4><p>使用Date类时，程序打印Date对象所输出的当前时间都是英文格式输出的，要想以中文的格式输出，就需要DateFormat类。</p>
<p>DateFormat类专门用于将日期格式化为字符串或者将用特定格式显示的日期字符串转换为一个Date对象。</p>
<p>DateFormat类是一个抽象类，不能被直接实例化，但它提供了一系列的静态方法来获取DateFormat类的实例对象，并能调用其他相应的方法进行操作。</p>
<p>定义了四种静态方法用于获取DateFormat类的实例对象，它们分别对日期或者时间部分进行格式化。</p>
<blockquote>
<p>疑问。</p>
</blockquote>
<p>在DateFormat类中还定义了许多常量，其中四个常量值是用于作为参数传递给方法的，包括FULL、LONG、MEDIUM、SHORT。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Date对象</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">//1.当前日期的完整格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">DateFormat fullFormat = DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(fullFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.当前日期的长格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">DateFormat longFormat = DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(longFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.当前日期时间的普通格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">DateFormat mediumFormat = DateFormat.getDateTimeInstance(DateFormat.MEDIUM);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(mediumFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.当前日期时间的短格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">DateFormat shortFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(shortFormat.format(date));</span><br></pre></td></tr></table></figure>

<p>DateFormat类中还有parse(String source)方法，能够将一个字符串解析为Date对象，但是它要求字符串必须符合日期/时间的格式要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建普通格式的DateFormat对象</span></span><br><span class="line">DateFormat dt1 = DateFormat.getDateInstance();</span><br><span class="line"><span class="comment">//创建Long格式的DateFormat对象</span></span><br><span class="line">DateFormat dt2 = DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义日期格式的字符串</span></span><br><span class="line">String s1 = <span class="string">&quot;2021-11-11&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;2021年11月11日&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出对应格式的字符串解析为Date对象后的结果</span></span><br><span class="line">System.out.println(dt1.parse(s1));</span><br><span class="line">System.out.println(dt2.parse(s2));</span><br></pre></td></tr></table></figure>

<h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><p>DateFormat类中parse方法将字符串解析为日期时，需要固定格式，不灵活。</p>
<p>SimpleDateFormat类是DateFormat类的子类，可以使用new关键字创建实例对象。在创建实例对象时，构造方法需要接收一个表示日期格式模板的字符串参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;Gyyyy年MM月dd日：今年时yyyy年的第D天，星期：E&quot;</span>);    <span class="comment">//创建对象</span></span><br><span class="line"><span class="comment">//按SimpleDateFormat对象的日期模板格式化Date对象</span></span><br><span class="line">System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br></pre></td></tr></table></figure>

<p>上面是将一个Date时间对象转换为指定格式字符串形式。</p>
<p>SimpleDateFormat类也可以将一个指定格式字符串解析为Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd&quot;</span>);    <span class="comment">//创建对象,并指定日期格式</span></span><br><span class="line">String s = <span class="string">&quot;2021/11/11&quot;</span>;</span><br><span class="line"><span class="comment">//将字符串解析为Date对象</span></span><br><span class="line">System.out.println(sdf.parse(s));</span><br></pre></td></tr></table></figure>

<h4 id="DateTimeFormatter类"><a href="#DateTimeFormatter类" class="headerlink" title="DateTimeFormatter类"></a>DateTimeFormatter类</h4><p>除DateFormat类以及SimpleDateFormat类，JDK8在java.time.format包下还提供了一个DateTimeFormatter类，该类也是格式化类，相当于DateFormat类以及SimpleDateFormat类的合体，它不仅可以将日期时间类型转换为字符串，还可以将字符串解析成日期、时间对象。</p>
<p>1.字符串转换成日期时间类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStringT0LocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// String --&gt; LocalDate</span></span><br><span class="line">        <span class="comment">//使用模式字符串创建DateTimeFormatter格式器</span></span><br><span class="line">        LocalDate localDate = LocalDate.parse(<span class="string">&quot;2019-12-07&quot;</span>);</span><br><span class="line">　　　　　DateTimeFormatter pattern = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);		　　　　　　    </span><br><span class="line">　　　　　System.out.println(LocalDate.parse(<span class="string">&quot;2019-10-09&quot;</span>).format(pattern));</span><br><span class="line">　　　　　</span><br><span class="line">        <span class="comment">// String --&gt; LocalTime</span></span><br><span class="line">        LocalTime localTime = LocalTime.parse(<span class="string">&quot;07:43:53&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String --&gt;LocalDateTime</span></span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>); <span class="comment">// 12小时</span></span><br><span class="line">　　　　 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); <span class="comment">// 24小时              LocalDate localDate = LocalDate.parse(&quot;2019-12-07 07:43:53&quot;,formatter);</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        System.out.println(localTime);</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.日期时间类型转换成字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLocalDateToString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//localDate --&gt; String </span></span><br><span class="line">        <span class="comment">//使用常量创建DateTimeFormatte</span></span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        String format1 = localDate.format(DateTimeFormatter.BASIC_ISO_DATE);    <span class="comment">//yyyyMMdd</span></span><br><span class="line">        String format2 = localDate.format(DateTimeFormatter.ISO_DATE);            <span class="comment">//yyyy-MM-dd</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.LocalTime  --&gt; String</span></span><br><span class="line">        LocalTime localTime = LocalTime.now();</span><br><span class="line">        String format3 = localTime.format(DateTimeFormatter.ISO_TIME);            <span class="comment">//20:19:22.42</span></span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;hh:mm:ss&quot;</span>);</span><br><span class="line">        String format4 = localTime.format(formatter);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.LocalDateTime  --&gt; String        </span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        String format5 = localDateTime.format(formatter2);</span><br><span class="line">        </span><br><span class="line">        System.out.println(format1);</span><br><span class="line">        System.out.println(format2);</span><br><span class="line">        System.out.println(format3);</span><br><span class="line">        System.out.println(format4);</span><br><span class="line">        System.out.println(format5);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>数组的长度不可变，因此为了保存数目不确定的对象，Java提供了一系列特殊的类，统称集合，集合可以存储任意类型的对象，并且长度可变。</p>
<h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><p>Java中的集合就像一个容器，专门用来存储Java对象（实际上是对象的引用），这些对象可以是任意的数据类型，并且长度可变。这些集合类都位于java.util包中。</p>
<p>集合类按照其存储结构可以分为两大类：单列集合Collection，双列集合Map。</p>
<p>（1）Collection：单列集合的根接口，用于存储一系列符合某种规律的元素。Collection集合有两个重要的子接口，分别是List和Set。List集合特点：元素有序，可重复。Set集合特点：元素无序，不可重复。List接口的主要实现类：ArrayList、LinkedList。Set接口的主要实现类：HashSet、TreeSet。</p>
<p>（2）Map：双列集合的根接口，用于存储具有键值映射关系的元素。Map接口的主要实现类：HashMap、TreeMap。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2017af8f90a9dff713a5fa908b990a05.png" alt="image-20211113111401531"></p>
<p>虚线是接口类型，实线是实现类。</p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地将实现了List接口的对象称为List集合。</p>
<p>在List集合中<strong>允许出现重复</strong>的元素，所有的元素以一种线性方式进行存储，在程序中可以通过索引来访问集合中的指定元素，另外，List集合<strong>元素有序</strong>，即元素的存入顺序和取出顺序一致。</p>
<h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><p>ArrayList是程序中最常见的一种集合。在ArrayList内部封装了一个长度可变的数组对象，当存入的元素超过数组长度时，ArrayList会在内存中分配一个更大的数组来存储这些元素，因此ArrayList可以看作是一个长度可变的数组。</p>
<p>正是由于ArrayList内部的数据存储结构是数组形式，在增加和删除指定位置的元素时，会创建新的数组，效率比较低，因此不适合做大量的增删操作。但是在遍历和查找元素时显得非常高效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList集合</span></span><br><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line">lis.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">长度： lis.size();</span><br><span class="line">查询： lis.get(i);</span><br></pre></td></tr></table></figure>

<p>注意：在使用ArrayList集合时并没有显式地指定集合中存储什么类型的元素，会产生安全隐患，涉及到泛型安全机制的问题。</p>
<h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><p>ArrayList查询时速度很快，增删时效率较低，因此另一个实现类：LinkedList。</p>
<p>该集合内部包含两个Node类型的first和last属性维护一个双向循环链表，链表中的每一个元素都使用引用的方式记住它的前一个元素和后一个元素，从而可以将所有的元素彼此连接起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList lik = <span class="keyword">new</span> LinkedList();</span><br><span class="line">lik.add(<span class="string">&quot;bb&quot;</span>);   <span class="comment">//添加元素</span></span><br><span class="line">lik.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">lik.offer(<span class="string">&quot;dd&quot;</span>);  <span class="comment">//向集合尾部追加元素</span></span><br><span class="line">lik.push(<span class="string">&quot;aa&quot;</span>);  <span class="comment">//向集合头部添加元素</span></span><br><span class="line">System.out.println(lik);   <span class="comment">//输出集合中的元素</span></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line">Object obj = lik.peek();   <span class="comment">//获取集合第一个元素</span></span><br><span class="line">System.out.println(obj);</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">lik.removeFirst();   <span class="comment">//删除集合第一个元素</span></span><br><span class="line">lik.pollLast();   <span class="comment">//删除集合最后一个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="Collection集合遍历"><a href="#Collection集合遍历" class="headerlink" title="Collection集合遍历"></a>Collection集合遍历</h3><h4 id="Iterator遍历集合"><a href="#Iterator遍历集合" class="headerlink" title="Iterator遍历集合"></a>Iterator遍历集合</h4><p>Iterator接口是Java集合框架中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用来存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被叫做迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList集合</span></span><br><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line">lis.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="comment">//获取Iterator对象</span></span><br><span class="line">Iterator it = lis.iterator();</span><br><span class="line"><span class="comment">//判断集合中是否存在下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(it.hashNext())&#123;</span><br><span class="line">	Object obj = it.next();  <span class="comment">//获取ArrayList集合中的元素</span></span><br><span class="line">	System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素。</p>
<p>在调用Iterator的next()方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，第一次调用迭代器的next()方法后，迭代器的索引指向第一个元素并将该元素返回。</p>
<p>注意：在使用Iterator迭代器对集合中的元素进行迭代时，如果调用了集合对象的remove()方法去删除元素，会出现异常。因为集合中删除了元素会导致迭代器预期的迭代次数发生变化，导致迭代器的结果不准确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(it.hashNext())&#123;</span><br><span class="line">	Object obj = it.next();  <span class="comment">//获取ArrayList集合中的元素</span></span><br><span class="line">	System.out.println(obj);</span><br><span class="line">	<span class="keyword">if</span>(<span class="string">&quot;aa&quot;</span>.equals(obj))&#123;</span><br><span class="line">		lis.remove(obj);  <span class="comment">//删除集合元素</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法一：在删除后用break退出。</p>
<p>解决方法二：使用迭代器本身的删除方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(&quot;aa&quot;.equals(obj))&#123;</span><br><span class="line">	it.remove();   //删除集合元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用迭代器对象的remove()方法删除元素导致的迭代次数变化，对迭代器对象本身来讲是可预知的。</p>
<h4 id="foreach遍历集合"><a href="#foreach遍历集合" class="headerlink" title="foreach遍历集合"></a>foreach遍历集合</h4><p>JDK5开始提供，是一种简洁的for循环，也称增强for循环，用于遍历数组或集合中的元素。会自动遍历容器中的每个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span>(Object obj:lis)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在foreach循环遍历集合和数组时，只能访问集合中的元素，不能对其中的元素进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String[] str = &#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String s:str)&#123;</span><br><span class="line">	s=<span class="string">&quot;aa&quot;</span>;   <span class="comment">//改变对string数组没效果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有效果是因为代码中<code>s=&quot;aa&quot;;</code>只是将临时变量s指向一个新的字符串，和数组中的元素没有关系。</p>
<p>而在普通的for循环中，可以通过索引来进行修改。</p>
<h4 id="JDK8的forEach遍历集合"><a href="#JDK8的forEach遍历集合" class="headerlink" title="JDK8的forEach遍历集合"></a>JDK8的forEach遍历集合</h4><p>在JDK8中，根据Lambda表达式特性，增加了一个<code>forEach(Consumer action)</code>方法来遍历集合，该方法需要一个函数式接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line">lis.forEach(obj-&gt;System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj))</span><br></pre></td></tr></table></figure>

<p>该方法传递的是一个Lambda表达式形式书写的函数式接口。forEach方法在执行时会自动遍历集合元素并将元素逐个传递给Lambda表达式的形参。</p>
<p>除此之外，JDK8还为Iterator迭代器对象增加了forEachRemaining(Consumer action)方法来进行遍历，同样需要一个函数式接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Iterator it = lis.iterator();</span><br><span class="line">it.forEachRemianing(obj-&gt;System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：本节对lList集合遍历的方法，对单列集合Collection进行遍历，因此对Set集合也适用。</p>
</blockquote>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>习惯性地将实现了Set接口的对象称为Set集合。Set集合中的元素<strong>无序</strong>（指存入的顺序和一起输出的顺序是否一致），并且会以某种规则保证存入的<strong>元素不出现重复</strong>。Set接口主要有两个实现类：HashSet、TreeSet。</p>
<p>HashSet是根据对象的哈希值来确定元素在集合中的存储的位置，因此具有良好的存取和查找性能。</p>
<p>TreeSet是以二叉树的方式来存储元素，它可以实现对集合中的元素进行排序。</p>
<h4 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h4><p>HashSet是Set接口的一个实现类，元素不可重复且无序。</p>
<p>保重不重复：当向HashSet集合中添加一个元素时，即调用HashSet集合的add()方法，首先调用当前存入元素的hashCode()方法获得对象的哈希值，然后根据对象的哈希值计算出一个存储位置：如果该位置上没有元素，则直接将元素存入；如果该位置上有元素存在，则会调用equals()方法让当前存入的元素依次和该位置上的元素进行比较。如果返回的结果为false就将该元素存入集合；返回的结果为true则说明有重复元素，就将该元素舍弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet se = <span class="keyword">new</span> HashSet();</span><br><span class="line">se.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">se.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="comment">//遍历输出Set集合的元素</span></span><br><span class="line">set.forEach(obj-&gt;System.out.println(obj));</span><br></pre></td></tr></table></figure>

<p>为了保证HashSet的正常工作，在存入对象时，需要重写Object类中的hashCode()和equals()方法。String类已经默认重写了<code>hashCode()</code>和<code>equals()</code></p>
<p>如果将开发者自定义的类型对象存入HashSet，需要重写<code>hashCode()</code>和<code>equals()</code>，改为值比较，否则没重写的<code>equals()</code>方法认为两个值相同的引用变量所引用的对象地址不同，认为是两个不同的对象，达不到去重的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String id, String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id=id;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写toString()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id+<span class="string">&quot;:&quot;</span>+name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写hashCode方法，根据id判定</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id.hashCode();  <span class="comment">//返回id属性的哈希值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写equals方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="comment">//this表示该对象，判断是否为同一对象，如果是则true相同</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断对象是否为Student类型，如果不是，返回false</span></span><br><span class="line">		<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将对象强制转换为Student类型</span></span><br><span class="line">		Student stu = (Student)obj;</span><br><span class="line">		<span class="comment">//根据id值是否相等</span></span><br><span class="line">		<span class="keyword">boolean</span> b = <span class="keyword">this</span>.id.equals(stu.id);</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h4><p>TreeSet内部采用平衡二叉树存储元素，这样的结构保证TreeSet集合中没有重复的元素，并且可以对元素进行排序（和Set的无序无关）。左子树小于根节点，右子树大于根节点。当插入一个元素时，首先与顶层元素进行比较，小于左边，大于右边，直到最后一个叶子节点，如果和叶子节点一样，则将该重复元素去掉。否则小于左边，大于右边。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet ts = <span class="keyword">new</span> TreeSet();</span><br><span class="line">ts.add(<span class="number">3</span>);</span><br><span class="line">ts.add(<span class="number">9</span>);</span><br><span class="line">ts.add(<span class="number">1</span>);</span><br><span class="line">ts.add(<span class="number">21</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ts集合：&quot;</span>+ts);  <span class="comment">//输出为[1,3,9,21]有序</span></span><br><span class="line">首元素： ts.first()  <span class="comment">//1</span></span><br><span class="line">尾元素： ts.last()   <span class="comment">//21</span></span><br><span class="line"><span class="comment">//比较并获取元素</span></span><br><span class="line">ts.floor(<span class="number">9</span>)  <span class="comment">//集合中小于或等于9的最大一个元素 9</span></span><br><span class="line">ts.higher(<span class="number">10</span>)  <span class="comment">//集合中大于10的最小元素 21</span></span><br><span class="line">删除并返回第一个元素： </span><br><span class="line">Object first = ts.pollFirst();</span><br><span class="line">删除并返回最后一个元素： </span><br><span class="line">Object last = ts.pollLast();</span><br></pre></td></tr></table></figure>

<p>集合中元素添加顺序无论如何，最后都会按一定顺序排列。因为平衡二叉树，每次插入都会与其他元素进行比较，最后插入有序的对象序列中。</p>
<p>集合中的元素在进行比较时，都会调用<code>compareTo()</code>方法，该方法是<code>Comparable</code>接口中定义的，因此要想对集合中的元素进行排序，就必须实现<code>Comparable</code>接口。Java中大多数类都实现了<code>Comparable</code>接口，并默认实现接口中的<code>compareTo()</code>方法，如Integer、Double、String等。</p>
<p>实际开发中，对自定义类型的数据没有实现<code>Comparable</code>接口，无法直接在TreeSet集合中进行排序操作。因此，Java提供了两种TreeSet的排序规则：自然排序、定制排序。默认情况下采用自然排序。</p>
<p>（1）自然排序</p>
<p>自然排序要求向TreeSet集合中存储的元素所在类必须实现<code>Comparable</code>接口，并重写<code>compareTo()</code>方法。然后TreeSet集合就会对该类型元素使用<code>compareTo()</code>方法进行比较，默认升序排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义Teacher类实现Comparable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name+<span class="string">&quot;:&quot;</span>+age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写compareTo方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		Teacher s = (Teacher)obj;</span><br><span class="line">		<span class="comment">//定义比较方式，先比较年龄age，再比较name,升序</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.age-s.age&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.age-s.age==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(s.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）定制排序</p>
<p>通过在创建TreeSet集合时就自定义一个比较器来对元素进行定制排序。自定义的类型数据中无需实现Comparable接口，并且可以按照自己的想法进行排序。</p>
<p>例子：按照集合中字符串的长度进行定制排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="comment">//定义比较器实现Comparator接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object obj1, Object obj2)</span></span>&#123;</span><br><span class="line">		String s1=(String)obj1;</span><br><span class="line">		String s2=(String)obj2;</span><br><span class="line">		<span class="keyword">int</span> temp=s1.length()-s2.length();</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="comment">//法1.创建集合时，传入Comparator接口实现定制排序</span></span><br><span class="line">		TreeSet ts=<span class="keyword">new</span> TreeSet(<span class="keyword">new</span> MyComparator());</span><br><span class="line">		ts.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		ts.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">		ts.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">		System.out.println(ts);</span><br><span class="line">	<span class="comment">//法2.创建集合时，使用Lambda表达式定制排序，无序上面的MyComparator</span></span><br><span class="line">		TreeSet ts2=<span class="keyword">new</span> TreeSet((obj1,obj2)-&gt;&#123;</span><br><span class="line">			String s1=(String)obj1;</span><br><span class="line">			String s2=(String)obj2;</span><br><span class="line">			<span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">		&#125;);</span><br><span class="line">		ts2.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		ts2.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">		ts2.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">		System.out.println(ts2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map接口是一种双列集合，包含键对象key和值value，键和值对象之间存在一种映射，一对一的，一个key对应唯一一个value，键对象key不可重复。</p>
<h4 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h4><p>HahMap集合存储键值映射关系，该集合的键和值允许为空，但键不能重复，且集合中的元素是<strong>无序的</strong>。</p>
<p>HashMap底层：哈希表结构=数组+链表。数组是HashMap的主体结构，链表则是为了解决哈希值冲突而存在的分支结构。因此HashMap对元素的增删改查表现出的效率都很高。</p>
<p>水平方向上数组的长度称为HashMap集合的容量（capacity），竖直方向每个元素对应的链表结构称为一个桶（bucket），每个桶的位置在集合中都有对应的桶值，用于快速定位。每个链表结构是&lt;key,value&gt;的键值对。</p>
<p>当向HashMap集合添加元素时，首先调用键对象k的hash(k)方法，快速定位并寻址到该元素在集合中要存储的位置。在定位到存储元素键对象k的哈希值所对应桶位置后，会出现两种情况：<br>1.键对象k的hash值所在的桶位置为空，则直接向该桶插入元素对象。<br>2.键对象k的hash值所在的桶位置不为空，则继续通过键对象的equals(k)方法比较新插入的元素键对象k和已存在的元素键对象k是否相同：<br>1.如果相同，则会对原有元素的值对象v进行替换并返回原来的旧值。<br>2.如果都不相同，则在该桶的链表结构头部新增一个节点来插入新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>);  <span class="comment">//put已存在的key，会进行覆盖</span></span><br><span class="line">System.out.println(m);  <span class="comment">//打印</span></span><br><span class="line"><span class="comment">//查看键是否存在</span></span><br><span class="line">m.containsKey(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment">//获取键对应的值</span></span><br><span class="line">m.get(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment">//获取键集合、值集合</span></span><br><span class="line">m.keySet()</span><br><span class="line">m.values()</span><br><span class="line"><span class="comment">//替换指定键的值</span></span><br><span class="line">m.replace(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">删除指定键值对</span><br><span class="line">m.remove(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意，HashMap查找时，需要遍历链表，逐一通过equals方法进行比对，因此桶越多，HashMap中的链表越少，性能越好。属于空间换时间。</p>
<p>HashMap中，<strong>动态分配桶的数量</strong>：通过<code>new HashMap()</code>方法创建HashMap时，会默认集合容量capacity大小为16，加载因子loadFactor为0.75，此时集合桶的阈值为12，超过12个时，HashMap会默认增加一倍桶的数量。开发者也可以使用<code>new HashMap(int intialCapacity, float loadFactor)</code>构造方法，在创建HashMap集合时指定集合容量和加载因子。</p>
<h4 id="Map集合遍历"><a href="#Map集合遍历" class="headerlink" title="Map集合遍历"></a>Map集合遍历</h4><h5 id="Iterator迭代器遍历"><a href="#Iterator迭代器遍历" class="headerlink" title="Iterator迭代器遍历"></a>Iterator迭代器遍历</h5><p>使用Iterator迭代器遍历Map集合，需要先将Map集合转换为Iterator接口对象，然后进行遍历，有两种方法进行转换：</p>
<p>（1）keySet()方法</p>
<p>先将Map集合中所有键对象转换为Set单列集合，然后将Set集合转换为Iterator接口对象，遍历得到键，再获得值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>); </span><br><span class="line">Set keySet = map.keySet();   <span class="comment">//获取键的集合</span></span><br><span class="line">Iterator it = keySet.iterator();  <span class="comment">//迭代键的集合</span></span><br><span class="line"><span class="keyword">while</span>(it.hashNext())&#123;</span><br><span class="line">	Object k = it.next();</span><br><span class="line">	Object v = m.get(key);</span><br><span class="line">	System.out.println(k+<span class="string">&quot;:&quot;</span>+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）entrySet()方法</p>
<p>将原有Map集合中的键值对作为一个整体返回为Set集合，接着将Set转换为Iterator接口对象，然后获取键值对映射关系，取出键和值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>); </span><br><span class="line">Set entrySet = m.entrySet();</span><br><span class="line">Iterator it = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	Map.Entry en = (Map.Entry)(it.next());</span><br><span class="line">	Object k = en.getKey();</span><br><span class="line">	Object v = en.getValue();</span><br><span class="line">	System.out.println(k+<span class="string">&quot;:&quot;</span>+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map.Entry是Map接口内部类，每个Map.Entry对象代表Map中的一个键值对。getKey和getValue是映射对象的方法。</p>
<h5 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach()方法"></a>forEach()方法</h5><p>再JDK8中根据Lambda表达式特性新增了一个forEach方法来遍历Map集合，该方法需要的参数是一个函数式接口，可以用Lambda表达式书写这个函数式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>); </span><br><span class="line">m.forEach((k,v)-&gt;System.out.println(k+<span class="string">&quot;:&quot;</span>+v));</span><br></pre></td></tr></table></figure>

<p>如果只想遍历value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection v = m.values();</span><br><span class="line">v.forEach(va-&gt;System.out.println(va));</span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>HashMap无序，不保证集合元素存入和取出的顺序。</p>
<p>但是LinkedHashMap是HashMap的子类，和LinkedList一样使用双向链表来维护内部元素的关系，使得元素有序（存入和取出的顺序）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> LinkedHashMap();  <span class="comment">//创建</span></span><br></pre></td></tr></table></figure>

<h4 id="TreeMap集合"><a href="#TreeMap集合" class="headerlink" title="TreeMap集合"></a>TreeMap集合</h4><p>Map接口的另一个实现类TreeMap，同样不允许重复的键。TreeMap内部是通过二叉树的原理来保证键的唯一性，这与TreeSet集合存储的原理一样，因此，TreeMap中所有的键是按照某种顺序排列的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> TreeMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">System.out.println(m);</span><br></pre></td></tr></table></figure>

<p>上面的键是String类型，String类实现了Comparable接口，因此默认会按照自然顺序从小到大进行排列。</p>
<p>桶TreeSet一样，TreeMap可以自定义比较器Comparator的方式对所有的键进行定制排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义比较器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object obj1, Object obj2)</span></span>&#123;</span><br><span class="line">		String key1 = (String)obj1;</span><br><span class="line">		String key2 = (String)obj2;</span><br><span class="line">	    <span class="keyword">return</span> key2.compareTo(key1);  <span class="comment">//从大到小排列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Map m = <span class="keyword">new</span> TreeMap(<span class="keyword">new</span> MyComparator());</span><br></pre></td></tr></table></figure>

<h4 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h4><p>Map接口还有一个实现来Hashtable，它和HashMap十分相似，区别在于Hashtable是线程安全的，因此在使用上Hashtable的效率不及HashMap。因此通常使用HashMap。</p>
<p>但是Hashtable有一个子类Properties，主要用来存储字符串类型的键值，在实际开发中，经常用来存取应用的配置项。</p>
<p>假设有一个配置文件：test.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color = red;</span><br><span class="line">size = 10;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.通过Properties进行属性文件读取操作</span></span><br><span class="line">	Properties pps = <span class="keyword">new</span> Properties();</span><br><span class="line">	<span class="comment">//加载文件</span></span><br><span class="line">	pps.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.properties&quot;</span>));</span><br><span class="line">	<span class="comment">//遍历键值对信息</span></span><br><span class="line">	pps.forEach((k,v)-&gt;System.out.println(k+<span class="string">&quot;:&quot;</span>+v));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.通过Properties进行属性文件写入操作</span></span><br><span class="line">	<span class="comment">//指定写入操作的文件名称和位置</span></span><br><span class="line">	<span class="function">FileOutputStream out new <span class="title">FileOutputStream</span><span class="params">(<span class="string">&quot;test.properties&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">//向Properties类文件进行写入键值对信息</span></span><br><span class="line">	pps.setProperty(<span class="string">&quot;charset&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">	<span class="comment">//将此Properties集合中新增的键值对写入配置文件</span></span><br><span class="line">	pps.store(out, <span class="string">&quot;新增charset编码&quot;</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Properties的setProperty方法，用来新增一个键值对元素。store方法用来将新增信息写入到properties配置文件。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在之前创建集合，当把一个对象存入集合后，集合会忘记这个对象的类型，将该对象从集合中取出时，这个对象的编译类型就会统一变成Object类型。也就是说，存入元素啥类型都行，但是取出元素后，进行强制转换容易出错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList lis = new ArrayList();</span><br><span class="line">lis.add(&quot;aa&quot;);</span><br><span class="line">lis.add(&quot;bb&quot;);</span><br><span class="line">for(Object obj:lis)&#123;</span><br><span class="line">	String s = (String)obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为解决该问题，Java引入“参数化类型”概念，即泛型。泛型可以限定操作的数据类型，在定义集合类时，可以使用“&lt;参数化类型&gt;”的形式指定集合中存储的数据类型。</p>
<p><code>ArrayList&lt;String&gt;lis = new ArrayList&lt;String&gt;();</code></p>
<p>这样限定了集合元素的数据类型，程序编译时类型不必配的话会编译不通过，避免运行时发生错误。遍历时<code>for(String s:lis)&#123;&#125;</code></p>
<h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>Java提供的一个专门工具类用来操作集合，位于java.util包中。Collections类中提供了大量的静态方法用于对集合中的元素进行排序、查找、修改等操作。</p>
<h4 id="添加、排序"><a href="#添加、排序" class="headerlink" title="添加、排序"></a>添加、排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt;lis = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">Collections.addAll(lis,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">//集合可以直接输出，而数组不可以，数组可以用forEach的Lambda表达式？</span></span><br><span class="line">System.out.println(lis);</span><br><span class="line">Collections.sort(lis);  <span class="comment">//排序</span></span><br><span class="line">Collections.reverse(lis);  <span class="comment">//反转</span></span><br><span class="line">Collections.shuffle(lis);  <span class="comment">//随机打乱集合顺序</span></span><br><span class="line">Collections.swap(lis,<span class="number">0</span>,lis.size()-<span class="number">1</span>);  <span class="comment">//交换元素</span></span><br></pre></td></tr></table></figure>

<h4 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt;lis = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">Collections.addAll(lis,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">最大元素： Collections.max(lis);</span><br><span class="line">最小元素： Collections.min(lis);</span><br><span class="line">Collections.replace(lis,<span class="number">2</span>,<span class="number">0</span>);  <span class="comment">//将集合中的2用0替换掉</span></span><br><span class="line">Collections.sort(lis);  <span class="comment">//排序</span></span><br><span class="line"><span class="comment">//通过二分查找查找元素3所在的角标，一定要先排序</span></span><br><span class="line"><span class="keyword">int</span> index = Collections.binarySearch(lis, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h3><p>java针对数组操作提供的数据工具类Arrays，提供大量静态方法。</p>
<h4 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">不能通过System.out直接打印数组，需要<span class="keyword">for</span>循环打印</span><br><span class="line">Arrays.sort(arr);  <span class="comment">//排序</span></span><br><span class="line">Arrays.sort(arr,<span class="number">1</span>,<span class="number">4</span>);  左闭右开</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">int</span> index=Arrays.binarySearch(arr,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><p>在不破坏原数组的情况下使用数组的部分元素，将指定范围的元素拷贝到一个新的数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] cop = Arrays.copyOfRange(arr, <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">//结果cop：8，3，5，2，0，0，左闭右开共六个，没有的用默认0</span></span><br></pre></td></tr></table></figure>

<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>将数组的所有元素替换为一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.fill(arr,<span class="number">8</span>);  <span class="comment">//全换为8</span></span><br></pre></td></tr></table></figure>

<h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>Lambda表达式可以简化集合和数组的遍历、过滤和提取等操作。基于此特性，JDK8新增了聚合操作。</p>
<h4 id="Stream接口"><a href="#Stream接口" class="headerlink" title="Stream接口"></a>Stream接口</h4><p>JDK8提供，该接口将集合、数组中的元素转换为Stream流的形式，并结合Lambda表达式进一步简化集合、数组中元素的查找、过滤、转换操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt;lis <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">lis.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line"><span class="comment">//创建一个Stream流对象</span></span><br><span class="line">Stream&lt;String&gt;stream = lis.stream();</span><br><span class="line"><span class="comment">//对Stream流中的元素进行过滤、截取</span></span><br><span class="line">Stream&lt;String&gt;stream2 = stream.filter(i-&gt;i.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">Stream&lt;String&gt;stream3 = stream.filter(i-&gt;i.length()&gt;<span class="number">1</span>);</span><br><span class="line">Stream&lt;String&gt;stream4 = stream2.limit(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//对Stream流中的元素进行终结操作</span></span><br><span class="line">stream4.forEach(j-&gt;System.out.println(j));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过链式表达式的形式完成聚合操作</span></span><br><span class="line">lis.stream().filter(i-&gt;i.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">			.limit(<span class="number">1</span>)</span><br><span class="line">			.forEach(j-&gt;System.out.println(j));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问：创建list时，最先的List和ArrayList有何区别？</p>
<p>List<int>可以吗？还是说元素必须为引用类型</int></p>
</blockquote>
<p>链式表达式：调用有返回值的方法时不获取返回值而是直接再调用另一个方法，实现聚合操作，也被称为操作管道流。</p>
<p>执行某个方法返回类型仍为stream流对象的方法归为中间操作，如过滤截取排序。</p>
<p>执行方法后返回类型不再是Stream流对象的方法归为终结操作，如遍历统计收集。</p>
<h4 id="创建Stream流对象"><a href="#创建Stream流对象" class="headerlink" title="创建Stream流对象"></a>创建Stream流对象</h4><p>聚合操作针对的是可迭代数据进行操作：如集合、数组。因此创建Stream流对象是将集合、数组通过一些方法转换为Stream流对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Stream流对象的集中方法</span></span><br><span class="line">Integer[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//将数组转换为List集合</span></span><br><span class="line">List&lt;Integer&gt;lis=Arrays.asList(arr);</span><br><span class="line"><span class="comment">//1.使用集合对象的stream()静态方法创建stream流对象</span></span><br><span class="line">Stream&lt;Integer&gt;stream=lis.stream();</span><br><span class="line">stream.forEach(i-&gt;System.out.print(i+<span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用Stream接口的of()静态方法为基本类型包装类数组、引用类型数组、单个元素创建stream流对象</span></span><br><span class="line">Stream&lt;Integer&gt;stream2=Stream.of(arr);</span><br><span class="line">stream2.forEach(i-&gt;System.out.print(i+<span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用Arrays数组工具类的stream()静态方法创建stream流对象</span></span><br><span class="line">Stream&lt;Integer&gt;stream3=Arrays.stream(arr);</span><br><span class="line">stream3.forEach(i-&gt;System.out.print(i+<span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure>

<p>注意：集合对象的stream()静态方法只是针对单列集合Collection接口对象提供的，对Map集合首先通过Map集合的<code>keySet()  values()  entrySet()</code>方法转换为单列Set集合。</p>
<h4 id="map-映射"><a href="#map-映射" class="headerlink" title="map()映射"></a>map()映射</h4><p>Stream流对象的map()方法可以将流对象中的元素通过特定的规则进行修改然后映射为另一个流对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt;stream=Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">stream.map(String::toUpperCase)  <span class="comment">//流中所有元素字母转为大写</span></span><br><span class="line">	  .sorted()</span><br><span class="line">	  .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="截取limit"><a href="#截取limit" class="headerlink" title="截取limit()"></a>截取limit()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.skip(<span class="number">1</span>)   <span class="comment">//跳过流中的前一个元素</span></span><br><span class="line">      .limit(<span class="number">2</span>)   <span class="comment">//截取前2个元素</span></span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><p>forEach()操作无法将进行中间操作后的流元素作为我们熟悉的对象或是数据类型进行保存，为此JDK8为操作流对象增加了一个终结操作—-collect。</p>
<p>collect可以把Stream中的元素保存为另一种形式，如集合、字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存为List集合</span></span><br><span class="line">Stream&lt;String&gt;stre = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">List&lt;String&gt;lis = stre.filter(i-&gt;i,startWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">					  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//将流元素使用&quot;and&quot;连接，收集到一个字符串中</span></span><br><span class="line">Stream&lt;String&gt;stre = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">String st = stre.filter(i-&gt;i,startWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">					  .collect(Collectors.joining(<span class="string">&quot;and&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存为数组</span></span><br><span class="line">Stream&lt;String&gt;stre = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">String[] arr = stre.filter(i-&gt;i,startWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">					  .collect(Collectors.toArray());</span><br></pre></td></tr></table></figure>

<p>注意：一个Stream可以进行多个中间操作，但只能进行一个终结操作，一旦进行了终结操作，流对象就不复存在了。因此，只能保存一次。</p>
<h4 id="Parrel-Stream并行流"><a href="#Parrel-Stream并行流" class="headerlink" title="Parrel Stream并行流"></a>Parrel Stream并行流</h4><p>JDK8针对大批量数据提供并行流，并行流是将源数据分为多个子流对象进行多线程操作（多个管道流），然后将处理的结果再汇总为一个流对象。</p>
<p>并行流可以提高程序执行效率，但是在多线程执行时会出现线程安全问题，需要保证源数据在并行执行时不会被改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建List集合数据源</span></span><br><span class="line">List&lt;String&gt;lis = Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">//1.直接用Collection接口的parallelStream()创建并行流</span></span><br><span class="line">Stream&lt;String&gt;para = lis.parallelStream();</span><br><span class="line"><span class="comment">//判断是否为并行流</span></span><br><span class="line">System.out.println(para.isParallel());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用BaseStream接口的parallel()方法将串行流转变为并行流</span></span><br><span class="line">Stream&lt;String&gt;str = Stream.of(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>.<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">Stream&lt;String&gt;para = str.parallel();</span><br><span class="line"><span class="comment">//判断是否为并行流</span></span><br><span class="line">System.out.println(para.isParallel());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
