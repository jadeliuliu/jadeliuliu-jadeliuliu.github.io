<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jadeliu&#39;s blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Jadeliu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jade liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jadeliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jadeliu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/08/myblog/JAVA/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/08/myblog/JAVA/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B/" class="post-title-link" itemprop="url">《Java基础入门》面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-08 10:33:43" itemprop="dateCreated datePublished" datetime="2021-11-08T10:33:43+08:00">2021-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-17 14:07:08" itemprop="dateModified" datetime="2021-11-17T14:07:08+08:00">2021-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java开发入门"><a href="#Java开发入门" class="headerlink" title="Java开发入门"></a>Java开发入门</h2><p>Java是由Sun公司于1995年开发的可编写跨平台应用软件、完全面向对象的程序设计语言。2009年被Oracle公司收购。</p>
<h3 id="Java三个技术平台"><a href="#Java三个技术平台" class="headerlink" title="Java三个技术平台"></a>Java三个技术平台</h3><p>针对不同的开发市场，Sun公司将Java划分为三个技术平台。</p>
<p>（1）Java SE：（standard edition）Java平台标准版，为开发普通桌面和商务应用程序提供的解决方案，是三个平台中最核心的部分，Java EE和Java ME都是从Java SE的基础上发展而来，Java SE包括Java最核心的类库，如集合、IO、数据库连接及网络编程。</p>
<p>（2）Java EE：（enterprise edition）平台企业版，为开发企业级应用程序提供的解决方案，包括Servlet、JSP、JavaBean、EJB、Web Service等。用来做web开发的java框架。</p>
<p>（3）Java ME：（micro edition）平台微型版，为开发电子消费产品和嵌入式设备提供的解决方案，用于微型数字电子设备上软件程序的开发，例如家用电器增加智能化控制和联网功能，未手机增加游戏和通讯录管理功能。此外，还提供HTTP等协议，为移动电话提供Client/Server方式访问Internet，提供无线交流。</p>
<p>不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。</p>
<p>J2SE是标准版本，J2ME是手机方向的，J2EE是网站开发方向的。</p>
<h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><ul>
<li>简单易用：丢弃了c++中的：操作符重载、多继承、自动强制类型转换、不使用指针而是引用，提供自动分配和回收内存空间。</li>
<li>安全可靠：Java通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。</li>
<li>跨平台：通过JVM虚拟机在不同的操作系统上允许Java程序。</li>
<li>面向对象：将一切事物都看成对象，类、接口、继承。只支持类之间的单继承，支持接口之间的多继承，支持类与接口之间的实现机制（implements）。java全面支持动态绑定，c++只对虚函数使用动态绑定。</li>
<li>支持多线程：内置了多线程控制，可使用户程序并发执行。</li>
</ul>
<h3 id="JDK-gt-JRE-gt-JVM"><a href="#JDK-gt-JRE-gt-JVM" class="headerlink" title="JDK&gt;JRE&gt;JVM"></a><strong>JDK&gt;JRE&gt;JVM</strong></h3><p><strong>JVM</strong> ：（Java Virtual Machine）， Java 虚拟机。它只认识 xxx.class 类型的文件，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。jvm 是 Java 能够跨平台的核心。</p>
<p><strong>JRE</strong> ：（Java Runtime Environment），Java 运行时环境。主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。普通用户只需要JRE进行运行已经编译好的java程序，而不需要开发。</p>
<p><strong>JDK</strong> ：（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe（编译 java 源码的编译器 javac），java.exe（java运行工具），jar.exe（java打包工具），java文档生成工具 等很多 java 程序调试和分析的工具。</p>
<p>1996年推出jdk1.0，随后到1.5改变命名方式，jdk1.5=jdk5.2017年jdk9，2018年jdk10.但是并不稳定。目前最多运用jdk8.</p>
<p>安装jdk时，安装开发工具（包括javac.exe、java.exe等，以及一个专用JRE环境），源代码（Java所有核心类库的源代码），公共JRE相当于多装一个JRE在其他路径，所以不需要。</p>
<p>JDK=JRE(JVM+JAVA基本类库)+开发工具</p>
<h3 id="JDK目录"><a href="#JDK目录" class="headerlink" title="JDK目录"></a>JDK目录</h3><ul>
<li>bin目录：存放一些可执行程序，如javac.exe（java编译器）、java.exe（java运行工具）、jar.exe（打包工具）、javadoc.exe（文档生成工具）等。</li>
<li>db目录：纯java实现的支持JDBC4.0所有规范的小型数据库。</li>
<li>include目录：由于JDK是通过C和C++实现的，因此在启动时引入一些C语言的头文件，该目录就是存放这些头文件的。</li>
<li>jre目录：Java运行时环境的根目录，，包括java虚拟机、运行时的类包、java应用启动器以及一个bin目录，不包括开发环境中的开发工具。</li>
<li>lib目录：java类库或库文件，是开发工具使用的归档包文件。</li>
</ul>
<blockquote>
<p>javac.exe：编译器工具，将java文件编译成可执行的java字节码文件.class</p>
<p>java.exe：java运行工具，会启动一个java虚拟机进程，专门负责运行字节码文件</p>
</blockquote>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>目的：在任何位置都能够编译和运行java程序。</p>
<p>配置：PATH：用于告知操作系统去指定路径寻找JDK，CLASSPATH：告知JDK去指定路径查找类文件(.class文件)</p>
<p>当在命令窗口中运行一个可执行文件时，操作系统首先会在当前目录下寻找是否存在该文件，如果不存在，会在PATH环境变量中定义的路径下寻找这个文件。</p>
<h3 id="java运行机制"><a href="#java运行机制" class="headerlink" title="java运行机制"></a>java运行机制</h3><p>.java文件，</p>
<p>使用javac.exe即java编译器进行编译，</p>
<p>.class文件，</p>
<p>使用java命令开启Java虚拟机运行程序，java虚拟机首先将编译好的字节码文件加载到内存（类加载，由类加载器完成），然后虚拟机通过java解析器对加载到内存中的java类进行解释执行，</p>
<p>机器码文件，</p>
<p>计算机运行机器码文件。</p>
<blockquote>
<p>java程序是由java虚拟机负责解释执行的，而不是操作系统，因此跨平台。</p>
</blockquote>
<h3 id="类包"><a href="#类包" class="headerlink" title="类包"></a>类包</h3><p>import导包：import 包名.类名  /  import 包名.*</p>
<p>java的核心类主要放在java包及其子包下。java扩展的大部分类在javax包及其子包下。</p>
<p>java.util：java的大量工具类、集合类，如Arrays、List、Set等</p>
<p>java.net：java网络编程相关的类和接口</p>
<p>java.io：java输入输出相关类和接口</p>
<p>java.awt：构建图形界面GUI的类和接口</p>
<p>java.sql：数据库编程</p>
<h2 id="Java编程基础"><a href="#Java编程基础" class="headerlink" title="Java编程基础"></a>Java编程基础</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行//  多行/*  */</p>
<p>文档注释：对某个类或类中的方法进行系统性解释说明。开发人员可使用JDK提供的javadoc工具将文档注释提取出来生成一份API帮助文档。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  content</span><br><span class="line">*  content</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>包名：一律小写<br>类名、接口名：首字母大写<br>常量名：都大写下划线连接<br>变量名和方法名：一个单词首字母小写，后面首字母大写</p>
<h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>八种基本数据类型：<br>byte：是8位、有符号的，以二进制补码表示的整数；-128~127；<br>short：16位<br>int：32位<br>long：64位，所赋的值超过int的取值范围，则需要加L，long num=10000000L;<br>float：单精度32位，小数默认为double类型，因此定义float型需要在后面加f/F<br>double：双精度64位<br>boolean：布尔<br>char：字符，2个字节</p>
<p>引用数据类型：<br>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型。<br>所有引用类型的默认值都是null，表示没有指向任何对象。</p>
<p><code>char c=&#39;a&#39;</code> 和 <code>char c=97</code>一样。因为可以将char变量赋值为0-65535范围内的整数，计算机将整数自动转化为对应的字符。</p>
<h3 id="变量的类型转换"><a href="#变量的类型转换" class="headerlink" title="变量的类型转换"></a>变量的类型转换</h3><p>（1）自动类型转换（隐式类型转换）：将一个类型取值范围小的数值直接赋值给另一个取值范围大的数据类型变量。大壶装小壶。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte b=3;</span><br><span class="line">int x=b;</span><br><span class="line">double y=x;</span><br></pre></td></tr></table></figure>

<p>（2）强制类型转换（显式类型转换）：目标类型取值范围小于源类型。小壶装大壶。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte a;</span><br><span class="line">int b=298;</span><br><span class="line">a=(byte)b;   //结果a会变成42</span><br></pre></td></tr></table></figure>

<p>强制类型转换中可能丢失精度，例如int占用4个字节，而byte占用1个字节，298变二进制后只留下最低的八位。</p>
<p>（3）表达式类型自动提升：byte、short、char类型的变量在运算期间类型会自动提示为int类型，然后进行运算，因此在最后获得结果时需要强制类型转换。</p>
<p>（4）在使用+=、-=、*=等运算符时，强制类型转换会自动完成。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>整形常量：二进制0b/0B开头，八进制0开头，十六进制0x/0X开头。</p>
<p>null：表示对象的引用为空。</p>
<p>需要用final关键字定义常量：<br><code>final int a=0</code></p>
<p>转义符<br>\r  回车符<br>\n  换行符<br>\t  制表符<br>\b  退格符，backspace<br>\后加&#39;或&quot;或\表示本身</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选，可以不break而继续执行。</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选，最后才看</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义的三种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">剖析：<span class="keyword">int</span>[] nums;  nums变量的类型是<span class="keyword">int</span>[]。</span><br><span class="line">nums会占用一块内存单元，nums=<span class="keyword">new</span> <span class="keyword">int</span>[]; 表示创建数组，并将数组的内存地址赋值给变量nums。在程序运行期间可以用变量nums来引用数组.</span><br></pre></td></tr></table></figure>

<p>多维数组：<code>String[][] str = new String[3][4];</code></p>
<p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>对数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">Arrays.sort(arr,<span class="number">1</span>,<span class="number">4</span>);  左闭右开</span><br></pre></td></tr></table></figure>

<h2 id="面向对象（上）"><a href="#面向对象（上）" class="headerlink" title="面向对象（上）"></a>面向对象（上）</h2><p>面向对象是把构成问题的事物按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。</p>
<p>封装：将对象的属性和行为封装起来。</p>
<p>继承：描述类与类之间的关系，使得无须重新编写原有类的情况下对原有类的功能进行扩展。</p>
<p>多态：一个类中定义的属性和功能被其他类继承后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现出的多种不同行为特征。</p>
<p>类是对象的抽象，共同特征作为属性（成员变量），共同行为作为类的方法（成员方法）。对象是类的实例。</p>
<p>创建对象：<code>Person p=new Person();</code></p>
<p>第一步：<code>Person p;</code> 声明一个Person类型的变量p</p>
<p>第二步：<code>=new Person();</code>创建Person对象，并将Person对象在内存中的地址赋值给变量p，这样变量p便持有了对象的引用。</p>
<p>内存中，p变量存对象的地址，在栈内存，p是一个引用，指向真正的对象。对象创建在堆内存。</p>
<blockquote>
<p>栈内存：存放基本类型的变量和对象的引用变量。</p>
<p>堆内存：存放new创建的对象和数组。</p>
</blockquote>
<p>创建好对象后，可以通过对象的引用来访问对象的所有成员。对象引用.对象成员</p>
<p>也可以使用创建的对象本身来引用对象成员：<code>new Person().成员</code>。由于没有对象引用的存在，在完成一个对象成员的访问后，该对象变成垃圾对象。<strong>当对象没有被任何变量所引用就会变成垃圾。</strong></p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>访问控制级别由小到大：private→default→protected→public</p>
<ul>
<li>private（当前类访问级别）：该成员只能被该类的其他成员访问，其他类无法直接访问。</li>
<li>default（包访问级别）：不使用任何访问控制修饰符的话，就是default，表示这个类或者类的成员只能被本包中的其他类访问。</li>
<li>protected（子类访问级别）：成员能被同一包内的其他类访问，也能被不同包下该类的子类访问。</li>
<li>public（公共访问级别）：该类或类的成员能被所有的类访问，不管是否在同一包中。</li>
</ul>
<blockquote>
<p>如果一个java源文件中定义的所有类都没有public修饰符，那么这个源文件的文件名可以是一切合法的文件名。</p>
<p>如果java源文件中定义了一个public修饰的类，则源文件名必须与public修饰的类的类名一致。</p>
</blockquote>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类的封装，是指将对象的属性隐藏在对象内部，设为private级别，不允许外部程序直接访问对象的内部信息，而通过类内public的方法（setxxx，getxxx）实现对内部信息的操作及访问。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>在实例化对象的同时为这个对象的属性进行赋值，可以通过构造方法来实现。</p>
<p>构造方法需要满足的三个条件：方法名与类名相同、在方法名的前面没有返回值类型的声明、方法中不能使用return返回一个值但是可以单独return来结束方法。</p>
<p>构造方法的重载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line">    TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java中每个类都至少有一个构造方法，如果一个类中没有显示地定义构造方法，系统会自动为这个类创建一个无参构造方法。但是一旦自己定义了有参的构造方法，系统将不再提供无参的构造方法。</p>
<blockquote>
<p>疑问：构造方法用来在实例化对象的时候为对象的成员变量赋值，而在定义类的时候，可以声明变量（不赋值）也可以定义变量（赋值），那么定义了变量之后，实例化对象，是给对象的成员赋初值了吗？应该是吧</p>
</blockquote>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>关键字this用来指代当前对象，用来在方法中访问对象的其他成员。</p>
<ul>
<li>通过this关键字调用成员变量，解决与局部变量名称冲突的问题。</li>
<li>通过this关键字调用成员方法。</li>
<li>通过this关键字调用构造函方法，构造方法是在实例化对象时被java虚拟机自动调用的，但是可以<strong>在一个构造方法中</strong>用<code>this(参数);</code>的形式来调用其他的构造方法。注意：只能在构造方法中用，且必须是构造方法中的第一条语句，且只能出现一次，而且不能在两个构造方法中相互调用。</li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>（1）静态变量</p>
<p>类内的数据成员被一个类的所有实例对象所共享时使用，例如学校学生的学校名。不必要在每个对象占用的空间中都声明这个对象，而是在对象之外的空间中声明一个变量供所有对象来共享。</p>
<p>注意：static关键字只能用于修饰成员变量，不能用于修饰局部变量。</p>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String schoolName;</span><br><span class="line">&#125;</span><br><span class="line">main函数中：</span><br><span class="line">Student.schoolName=<span class="string">&quot;daxue&quot;</span>;</span><br><span class="line">Student stu1=<span class="keyword">new</span> Student();</span><br><span class="line">使用： stu1.schoolName</span><br></pre></td></tr></table></figure>

<p>（2）静态方法</p>
<p>希望在不创建对象的情况下就可以调用某个方法时使用。</p>
<p>访问方式：<code>类名.方法</code>    或    <code>实例对象名.方法</code></p>
<p>注意：在一个静态方法中只能访问用static修饰的成员，原因在于没有没sttaic修饰的成员需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象。</p>
<blockquote>
<p>思考：一个文件中可以有多个类，文件名叫public的类的名字，类内可以有public static main函数，有main函数的类得是public的?</p>
<p>static 的成员函数，只能访问static的成员（函数或变量），public static main函数中可以创建其他类的对象，然后访问其他非static类的成员。</p>
</blockquote>
<p>（3）静态代码块</p>
<p>static{…}  在类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块也只执行一次。通常使用静态代码块对类的成员变量进行初始化。第一次实例化对象时会加载类。</p>
<h2 id="面向对象（下）"><a href="#面向对象（下）" class="headerlink" title="面向对象（下）"></a>面向对象（下）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>is a的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类在继承父类的时候，会自动拥有父类所有公共的成员。</p>
<p>java中只支持单继承，不允许多继承，一个类只能有一个直接父类。</p>
<h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>不能使用比父类中重写的方法更严格的访问权限，如父类的访问权限是public，子类方法不能是private。</p>
<p>也可以重新定义父类的属性。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>子类重写父类方法或重新定义父类属性后，子类对象无法直接访问他们，因此，用super访问。<code>super.成员变量/成员方法</code></p>
<p>还可以用super关键字来调用父类的构造方法。<code>super([参数1,参数2]);</code>但是，只能出现在子类构造方法的第一行，且只能出现一次。</p>
<p>注意：子类的构造方法中一定会调用父类的某个构造方法，可以通过super指定。如果没有super，则会默认调用父类无参的构造方法。因此，如果父类只定义了有参的构造方法，系统不给默认无参构造方法，就会出错。因此需要在父类添加无参构造方法，或者子类指定调用父类有参构造方法。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>java中的Object类是所有类的父类，每个类都直接或间接地继承自该类，称为超类、基类、或根类。Object类中有一些自定义的方法。</p>
<p><code>对象名.toString()  </code>返回对象的字符串表示。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>不可更改，最终的意思。</p>
<p>（1）修饰类：不能被继承。</p>
<p>（2）修饰方法：不能被子类重写</p>
<p>（3）修饰变量：常量，只能被赋值一次。</p>
<p>final修饰的成员变量，必须在声明的同时进行赋值。</p>
<p>final修饰的局部变量，可以先声明，再进行一次赋值。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>例如在定义Animal类时，shout()方法无法明确表示，java提供抽象方法来使得其无需提供方法的具体实现。</p>
<p>抽象方法：<code>public abstract void shout();</code>没有大括号</p>
<p>包含抽象方法的类一定是抽象类，class前加abstract，但是抽象类中可以不包含抽象方法。</p>
<p>抽象类不能被实例化，只能创建子类，并在子类中实现抽象类中的抽象方法。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种特殊的抽象类，它不包含普通方法，内部所有方法都是抽象方法。</p>
<p>JDK8中对接口进行了重新定义，接口中除了抽象方法外，可以有default修饰的默认方法，static修饰的静态方法，这两种方法都允许有方法体。</p>
<p>用interface修饰，可以extends多个接口。接口内部可以有final常量，定义常量时必须进行初始化赋值。</p>
<p>小提示：定义常量时<code>public static final</code>可省略，定义方法时<code>public abstract</code>可省略</p>
<p>调用静态方法：<code>接口名.方法名</code></p>
<p>调用抽象方法和默认方法需要通过接口实现类的实例对象来调用。默认方法不需要子类中实现。</p>
<p><code>public interface Hockey extends Sports, Event</code>   接口的多继承</p>
<p>一个类可以在继承一个类的同时实现多个接口：<code>public class 类名 extends 类名 implements 接口1，接口2</code>  ，extend需要在前面</p>
<blockquote>
<p>注意：如果一个类通过implement实现接口，如果该类是抽象类，则可以实现接口中的部分抽象方法，如果不是抽象类，则需要实现接口中的所有抽象方法。</p>
</blockquote>
<p>总结：类继承类（只能继承一个类，但同时可以实现多个接口），接口继承接口（可一次继承多个接口），类实现接口（可一次实现多个接口）</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指一个类中定义的属性和方法被其他类继承或重写后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现的多种不同形态。</p>
<p>把子类对象直接赋值给父类引用变量时，程序只有在运行时才知道该引用变量具体代表哪个子类对象。</p>
<h3 id="对象的类型转换"><a href="#对象的类型转换" class="headerlink" title="对象的类型转换"></a>对象的类型转换</h3><p>子类对象当作父类类型使用：向上转型</p>
<p><code>Animal an1=new Cat();</code>   不需要任何显示声明，但是不能通过父类变量去调用子类特有的方法。</p>
<p>要想使用子类特有的方法，需要将本质为Cat类型的an1对象由Animal类型向下转型为Cat类型。</p>
<p><code>Cat cat=(Cat)an1;</code> 就可以用cat变量来调用子类特有方法了。</p>
<p><code>instanceof</code>关键字，用来判断一个对象是否为某个类或接口的实例或子类实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal an1=new Cat();</span><br><span class="line">if(an1 instanceof Cat)&#123;</span><br><span class="line">    Cat cat=(Cat)an1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>java中允许一个类的内部定义类，这样的类叫内部类。内部类所在类叫外部类。根据内部类的位置、修饰符、定义方式的不同分为四种。</p>
<p>（1）成员内部类</p>
<p>像成员变量、成员方法一样的存在，在成员内部类中，可以访问外部类的所有成员。在外部类中，可以访问成员内部类的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">外部类访问内部类的成员：</span><br><span class="line">Inner inner = new Inner();</span><br><span class="line">inner.成员</span><br><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer out = new Outer();  创建外部类对象</span><br><span class="line">Outer.Inner in = new Inner();   创建内部类对象</span><br></pre></td></tr></table></figure>

<p>（2）局部内部类</p>
<p>也叫方法内部类，是定义在某个方法内的，有效范围仅限于方法内部。</p>
<p>局部内部类可以访问外部类所有成员，而只有在包含局部内部类的方法中才可以访问内部类的成员。</p>
<p>（3）静态内部类</p>
<p>使用static关键字修饰的成员内部类，静态内部类只能访问外部类的静态成员.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer.Inner inner = new Outer.Inner();</span><br><span class="line">inner.成员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般在刷题时，定义Solution类，类内定义成员方法实现算法。测试时，定义另一个类，类内main函数中输入输出，然后定义对象<code>Solution s = new Solution();</code>通过对象访问算法方法。</p>
</blockquote>
<p>（4）匿名内部类</p>
<p>在java中调用某个方法时，如果该方法的参数是一个接口类型，除了可以传入一个参数接口实现类，还可以使用匿名内部类实现接口来作为该方法的参数。</p>
<p>匿名内部类就是没有名称的内部类，在调用包含有接口类型参数的方法时，通常为了简化代码，不会创建一个接口的实现类作为方法参数传入，而是直接通过匿名内部类的形式传入一个接口类型参数，在匿名内部类中直接完成方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义动物类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String name=<span class="string">&quot;maomao&quot;</span>;</span><br><span class="line">		<span class="comment">//定义匿名内部类作为参数传递给animalShout方法</span></span><br><span class="line">		animalShout(<span class="keyword">new</span> Animal()&#123;</span><br><span class="line">		    <span class="comment">//匿名内部类中实现shout方法</span></span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">		    	<span class="comment">//JDK8开始，局部内部类、匿名内部类可以访问非final的局部变量</span></span><br><span class="line">		    	System.out.println(name+“喵喵”)；</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;)；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义静态方法animalShout(),接收接口类型参数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">animalShout</span><span class="params">(Animal an)</span></span>&#123;</span><br><span class="line">		an.shout(); <span class="comment">//调用传入对象的shout()方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分两步：</p>
<p>第一步 <code>animalShout(new Animal()&#123;&#125;)</code> 参数位置创建一个实例对象，表示创建的对象为Animal的子类实例，该子类是匿名的。</p>
<p>第二步<code>&#123;&#125;</code>中编写匿名子类的实现代码。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda 表达式，也可称为<strong>闭包</strong>，它是推动 Java 8 发布的最重要新特性。它使用一个清晰简洁的表达式来表达一个接口。</p>
<p>匿名内部类存在一个问题：如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然冗余。</p>
<p>Lambda表达式针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br><span class="line">可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</span><br><span class="line">可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</span><br><span class="line">可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</span><br><span class="line">可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，return可省略</span><br></pre></td></tr></table></figure>

<p>上面的例子，用lambda表达式来做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animalShout(()-&gt;System.out.println(name+“喵喵”);)</span><br></pre></td></tr></table></figure>

<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>Lambda表达式可以实现匿名内部类的功能，但是局限在于接口中只有一个抽象方法时才能使用Lambda表达式代替匿名内部类。</p>
<p>因为Lambda表达式是基于函数式接口实现的，函数式接口就是只有一个抽象方法的接口。</p>
<p>JDK8中专门为函数式接口引入@FunctionalInterface注解，显示地标识接口是一个函数式接口，如果不是编译器就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculate</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		showSum(<span class="number">10</span>, <span class="number">20</span>, (x,y)-&gt;x+y);  <span class="comment">//实现方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建参数为接口的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Calculate cu)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;和为：&quot;</span>+cu.sum(x, y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式的引用形式"><a href="#Lambda表达式的引用形式" class="headerlink" title="Lambda表达式的引用形式"></a>Lambda表达式的引用形式</h3><p>Lambda表达式的主体只有一条语句时，程序可通过<code>：：</code>的语法格式来引用方法和构造器。本质是对Lambda表达式的主体部分已存在的方法进行直接引用。</p>
<p>相当于calc方法需要实现，而又现成的abs方法可以用。</p>
<p>（1）类名引用普通方法/静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculate</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含静态方法的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&lt;<span class="number">0</span>)  <span class="keyword">return</span> -num;</span><br><span class="line">		<span class="keyword">else</span>  <span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAbs</span><span class="params">(<span class="keyword">int</span> num, Calculate cu)</span></span>&#123;</span><br><span class="line">		System.out.println(cu.calc(num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, n-&gt;Math.abs(n));</span><br><span class="line">		<span class="comment">//使用方法引用</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, Math::abs);  类名::类静态方法/普通方法名</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）对象名引用方法</p>
<p>也可以通过实例化对象的名称来对其方法进行引用。是普通方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math ma = new Math();</span><br><span class="line">printAbs(-10, n-&gt;ma.abs(n));</span><br><span class="line">printAbs(-10,ma::abs);</span><br></pre></td></tr></table></figure>

<p>（3）构造器引用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">buildPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个Person类，并添加有参构造方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(String name, PersonBuilder bu)</span></span>&#123;</span><br><span class="line">		System.out.println(bu.buildPerson(name).getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式   ()-&gt;new 类名()</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, name-&gt;<span class="keyword">new</span> Person(name));</span><br><span class="line">		<span class="comment">//使用方法引用    类名::new</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, Person::<span class="keyword">new</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>java语言引入了异常，以异常类的形式对正常情况进行封装。</p>
<p>异常类都继承自java.lang.Throwable类。</p>
<p>Throwable有两个直接子类Error和Exception。</p>
<p>其中Error称为错误类，代表Java运行时产生的系统内部错误或资源耗尽的错误，如系统崩溃、虚拟机错误。</p>
<p>Exception类称为异常类，标识程序本身可以处理的错误，异常处理都是针对该类及其子类。RuntimeException表示运行时异常，其他表示编译时异常。</p>
<p>Throwable类中常用的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String getMessage()</span><br><span class="line">返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</span><br><span class="line">public void printStackTrace()</span><br><span class="line">打印toString()结果和栈层次到System.err，即错误输出流。</span><br><span class="line">public Throwable getCause()</span><br><span class="line">返回一个Throwable 对象代表异常原因。</span><br></pre></td></tr></table></figure>

<p>运行时异常是在程序运行时由Java虚拟机自动进行捕获处理的。例如数组越界。</p>
<h3 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在除法方法中：</span><br><span class="line">try&#123;</span><br><span class="line">   可能发生异常的语句</span><br><span class="line">&#125;catch(Exception类或其子类 e1)&#123;</span><br><span class="line">   对捕获的异常进行相应的处理</span><br><span class="line">   System.out.println(&quot;异常：&quot;+e1.getMessage());</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	无论程序是否异常都会执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try{}中的代码块发生异常，系统会将这个异常的信息封装成一个异常对象，传递给catch(){}代码块，catch代码块需要一个参数指明它所能接收的异常类型，必须是Exception类或其子类。</p>
<p>finally{}中的代码不受return语句和程序异常的影响，可以用来完成必须要做的事，例如释放系统资源、关闭线程池等。但是在try…catch…代码块中执行了<code>System.exit(0)</code>语句的话，finally不会执行，因为<code>System.exit(0)</code>表示退出当前的java虚拟机。</p>
<h3 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h3><p>用于将异常从当前方法中抛出，throws写在方法声明的后面，后跟声明方法中发生异常的类型，这种做法叫做方法申明抛出一个异常。一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int divide(int x, int y) throws Exception&#123;</span><br><span class="line">	int res=x/y;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了throws后，还需要再出现异常的代码（main中）处使用try…catch…代码块进行捕获处理。</p>
<h3 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h3><p>throw用于方法体内，并且抛出的是一个异常类对象。</p>
<p>通过throw关键字抛出异常后，还需要try…catch…或throws关键字对异常进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void deposit(double amount) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">  if(判断)&#123;</span><br><span class="line">      throw new Exception(&quot;异常&quot;); //可以用来指示异常信息</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throw抛出异常对象，然后通过throws关键字抛出异常，最后通过try…catch…语句捕获异常。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>java允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类。在构造方法中使用super()语句调用Exception的构造方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 	<span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();  <span class="comment">//调用无参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(message);  <span class="comment">//调用有参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>java提供垃圾回收机制（Java GC），虚拟机会自动回收垃圾对象所占用的内存空间。</p>
<p>当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分为三种：</p>
<p>（1）可用状态：对象被创建后，有一个以上的引用变量引用它，那么这个对象在程序中将处于可用状态，程序可以通过引用变量来调用该对象的实例变量和方法。</p>
<p>（2）可恢复状态：程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。系统准备回收，回收之前会调用可恢复状态对象的<code>finalize()</code>方法进行资源清理。如果在调用<code>finalize()</code>方法之前重新使一个引用变量引用该对象，则这个对象会再次变为可用对象。</p>
<p>（3）不可用状态：调用<code>finalize()</code>方法后，对象进入不可用状态，内存被清理。</p>
<blockquote>
<p>一个对象在失去引用成为垃圾后，会暂时保存在内存中，垃圾堆积到一定程度时，java虚拟机会启动垃圾回收器将这些垃圾对象从内存中释放，也就说回收的时机无法把握。</p>
</blockquote>
<p>强制系统进行垃圾回收的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br><span class="line">或：</span><br><span class="line">Runtime.getRuntime().gc();</span><br></pre></td></tr></table></figure>

<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>当一个对象在内存中被释放时，它的<code>finalize()</code>方法会自动调用，<code>finalize()</code>方法是定义在Object类中的实例方法，方法原型：</p>
<p><code>protected void finalize() throws Throwable&#123;&#125;</code></p>
<p>任何java类都可以重写Object类的<code>finalize()</code>方法，在该方法中清理对象占用的资源。重写实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">	public void finalize()&#123;</span><br><span class="line">		System.out.println(&quot;d&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/" class="post-title-link" itemprop="url">javaのleecode二叉树篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-07 16:56:08 / Modified: 20:17:04" itemprop="dateCreated datePublished" datetime="2021-11-07T16:56:08+08:00">2021-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二叉树的输入和遍历"><a href="#二叉树的输入和遍历" class="headerlink" title="二叉树的输入和遍历"></a>二叉树的输入和遍历</h2><p>二叉树定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序创建二叉树：输入一个节点回车一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入二叉树！&quot;</span>);</span><br><span class="line">        TreeNode root = creatTree();</span><br><span class="line">        ArrayList&lt;Integer&gt; qianxu = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        qianxu=preOrderReverse(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>+qianxu);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照前序遍历方式创建二叉树，0代表空，例如1左2右3：1200300</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">creatTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeNode root;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="comment">//回车结束输入</span></span><br><span class="line">        <span class="comment">//Scanner in=new Scanner(System.in);</span></span><br><span class="line">        <span class="comment">//num=in.nextInt();</span></span><br><span class="line">        <span class="comment">//还是回车结束</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.next();</span><br><span class="line">        num=Integer.parseInt(str);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            root=<span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root=<span class="keyword">new</span> TreeNode(num);</span><br><span class="line">            root.left=creatTree();</span><br><span class="line">            root.right=creatTree();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归法进行遍历</span></span><br><span class="line">    <span class="comment">//前序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">preOrderReverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);           <span class="comment">// 注意这一句</span></span><br><span class="line">        preOrder(root.left, result);</span><br><span class="line">        preOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序创建二叉树：输入一个节点空格一次，一行输入。</p>
<h2 id="前中后序遍历，用递归，带输入输出"><a href="#前中后序遍历，用递归，带输入输出" class="headerlink" title="前中后序遍历，用递归，带输入输出"></a>前中后序遍历，用递归，带输入输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建二叉树</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入二叉树！&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">            b[j] = Integer.parseInt(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = creatTree(b);</span><br><span class="line">        <span class="comment">//前序遍历</span></span><br><span class="line">        ArrayList&lt;Integer&gt; qianxu = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        qianxu=preOrderReverse(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>+qianxu);</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        List&lt;Integer&gt; zhongxu = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        zhongxu=inorderTraversal(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>+zhongxu);</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        List&lt;Integer&gt; houxu = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        houxu=postorderTraversal(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历：&quot;</span>+houxu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照前序遍历方式创建二叉树，0代表空，例如1左2右3：1200300</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">creatTree</span><span class="params">(<span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">        TreeNode root;</span><br><span class="line">        <span class="keyword">int</span> num=b[t++];</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root=<span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        root.left=creatTree(b);</span><br><span class="line">        root.right=creatTree(b);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归法进行遍历</span></span><br><span class="line">    <span class="comment">//前序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">preOrderReverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);           <span class="comment">// 注意这一句</span></span><br><span class="line">        preOrder(root.left, result);</span><br><span class="line">        preOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, list);</span><br><span class="line">        postorder(root.right, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前中后序遍历，用迭代"><a href="#前中后序遍历，用迭代" class="headerlink" title="前中后序遍历，用迭代"></a>前中后序遍历，用迭代</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur = stack.pop();</span><br><span class="line">               result.add(cur.val);</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//checkFun01(root,0);</span></span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS--递归方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFun01</span><span class="params">(TreeNode node, Integer deep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resList.size() &lt; deep) &#123;</span><br><span class="line">            <span class="comment">//当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS--迭代方式--借助队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFun02</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> len = que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="keyword">null</span>) que.offer(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="keyword">null</span>) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226题-翻转二叉树"><a href="#226题-翻转二叉树" class="headerlink" title="226题.翻转二叉树"></a>226题.翻转二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前后序遍历都可以</span></span><br><span class="line"><span class="comment">     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        swapChildren(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapChildren</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = deque.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = deque.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;deque.offer(node.left);&#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;deque.offer(node.right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101题-对称二叉树"><a href="#101题-对称二叉树" class="headerlink" title="101题.对称二叉树"></a>101题.对称二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较外侧</span></span><br><span class="line">        <span class="keyword">boolean</span> compareOutside = compare(left.left, right.right);</span><br><span class="line">        <span class="comment">// 比较内侧</span></span><br><span class="line">        <span class="keyword">boolean</span> compareInside = compare(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> compareOutside &amp;&amp; compareInside;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用双端队列，相当于两个栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.offerFirst(root.left);</span><br><span class="line">        deque.offerLast(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            TreeNode leftNode = deque.pollFirst();</span><br><span class="line">            TreeNode rightNode = deque.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> &amp;&amp; rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> || rightNode == <span class="keyword">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerFirst(leftNode.left);</span><br><span class="line">            deque.offerFirst(leftNode.right);</span><br><span class="line">            deque.offerLast(rightNode.right);</span><br><span class="line">            deque.offerLast(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用普通队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric3</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.offer(root.left);</span><br><span class="line">        deque.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            TreeNode leftNode = deque.poll();</span><br><span class="line">            TreeNode rightNode = deque.poll();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> &amp;&amp; rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> || rightNode == <span class="keyword">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里顺序与使用Deque不同</span></span><br><span class="line">            deque.offer(leftNode.left);</span><br><span class="line">            deque.offer(rightNode.right);</span><br><span class="line">            deque.offer(leftNode.right);</span><br><span class="line">            deque.offer(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="257题-二叉树的所有路径"><a href="#257题-二叉树的所有路径" class="headerlink" title="257题.二叉树的所有路径"></a>257题.二叉树的所有路径</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; paths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        traversal(root, paths, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        paths.add(root.val);</span><br><span class="line">        <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                sb.append(paths.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(paths.get(paths.size() - <span class="number">1</span>));</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traversal(root.left, paths, res);</span><br><span class="line">            paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traversal(root.right, paths, res);</span><br><span class="line">            paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="39题-组合总和"><a href="#39题-组合总和" class="headerlink" title="39题.组合总和"></a>39题.组合总和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br><span class="line">说明：</span><br><span class="line">所有数字（包括 target）都是正整数。</span><br><span class="line">解集不能包含重复的组合。</span><br><span class="line">示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剪枝优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates); <span class="comment">// 先进行排序</span></span><br><span class="line">        backtracking(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到了数字和为 target 的组合</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(res, path, candidates, target, sum + candidates[i], i);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯，移除路径 path 最后一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/" class="post-title-link" itemprop="url">javaのleecode字符串篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-07 13:42:43 / Modified: 15:04:08" itemprop="dateCreated datePublished" datetime="2021-11-07T13:42:43+08:00">2021-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>char ch : s.<strong>toCharArray()</strong>  遍历字符串中的字符。c++中的 ch：s 不可用。</p>
<p>字符串中，获得第几个字符，不能用s[i]，而是：s.<strong>charAt(i)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.setCharAt(<span class="number">0</span>,<span class="string">&#x27;v&#x27;</span>);  <span class="comment">//替换某位置的字符</span></span><br></pre></td></tr></table></figure>

<h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Runoob&quot;;</span><br><span class="line">String str2=new String(&quot;Runoob&quot;);</span><br><span class="line">String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</span><br><span class="line">char[] helloArray = &#123; &#x27;r&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;b&#x27;&#125;;</span><br><span class="line">String helloString = new String(helloArray);  </span><br></pre></td></tr></table></figure>

<p>**注意:**String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。</p>
<p>如果需要对字符串做很多修改，那么应该选择使用 [StringBuffer &amp; StringBuilder 类]。</p>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String site = &quot;www.runoob.com&quot;;</span><br><span class="line">int len = site.length();   (结果为14)</span><br></pre></td></tr></table></figure>

<h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;我的名字是 &quot;.concat(&quot;Runoob&quot;);</span><br><span class="line">String string1 = &quot;菜鸟教程网址：&quot;;     </span><br><span class="line">System.out.println(&quot;1、&quot; + string1 + &quot;www.runoob.com&quot;);  </span><br></pre></td></tr></table></figure>

<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(字符串变量的值为%s&quot;, stringVar);</span><br><span class="line">String fs;</span><br><span class="line">fs = String.format(&quot; 字符串变量的值为 %s&quot;, stringVar);</span><br></pre></td></tr></table></figure>

<h3 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h3><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p>
<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，<strong>所以如果需要对字符串进行修改推荐使用 StringBuffer。</strong></p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，<strong>所以多数情况下建议使用 StringBuilder 类。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder(10);  //定大小</span><br><span class="line">sb.append(&quot;Runoob..&quot;);    //在容量内加</span><br><span class="line">sb.insert(8, &quot;Java&quot;);    //在容量外加</span><br><span class="line">System.out.println(sb); </span><br><span class="line">sb.delete(5,8);    //删除</span><br><span class="line">变成string字符串：  res.toString();</span><br></pre></td></tr></table></figure>

<p><strong>在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类</strong>。</p>
<h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Str.substring(4)   从4开始，包括4</span><br><span class="line">Str.substring(4, 10)   左闭右开，包括4不包括10</span><br></pre></td></tr></table></figure>

<h3 id="字符串转换为int"><a href="#字符串转换为int" class="headerlink" title="字符串转换为int"></a>字符串转换为int</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.valueOf(&quot;444&quot;,16)  //16进制</span><br><span class="line">Integer.parseInt(arr[j]);</span><br></pre></td></tr></table></figure>

<h3 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb=new StringBuilder(s);</span><br><span class="line">return sb.reverse().toString();</span><br></pre></td></tr></table></figure>

<h2 id="344题-反转字符串"><a href="#344题-反转字符串" class="headerlink" title="344题.反转字符串"></a>344题.反转字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</span><br><span class="line">不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</span><br><span class="line">示例 1：</span><br><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p>思路：一头一尾双指针，交换即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            s[l] ^= s[r]; </span><br><span class="line">            s[r] ^= s[l];  </span><br><span class="line">            s[l] ^= s[r];  </span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="541题-反转字符串Ⅱ"><a href="#541题-反转字符串Ⅱ" class="headerlink" title="541题.反转字符串Ⅱ"></a>541题.反转字符串Ⅱ</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</span><br><span class="line">如果剩余字符少于 k 个，则将剩余字符全部反转。</span><br><span class="line">如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</span><br><span class="line">示例:</span><br><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;bacdfeg&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解法一：用StringBuffer类，对字符串进行改变。用到append（）方法、substring方法（）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; length) &#123;</span><br><span class="line">            <span class="comment">// 找到k处和2k处</span></span><br><span class="line">            StringBuffer temp = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="comment">// 与length进行判断，如果大于length了，那就将其置为length</span></span><br><span class="line">            <span class="keyword">int</span> firstK = (start + k &gt; length) ? length : start + k;</span><br><span class="line">            <span class="keyword">int</span> secondK = (start + (<span class="number">2</span> * k) &gt; length) ? length : start + (<span class="number">2</span> * k);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//无论start所处位置，至少会反转一次</span></span><br><span class="line">            temp.append(s.substring(start, firstK));</span><br><span class="line">            res.append(temp.reverse());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果firstK到secondK之间有元素，这些元素直接放入res里即可。</span></span><br><span class="line">            <span class="keyword">if</span> (firstK &lt; secondK) &#123; <span class="comment">//此时剩余长度一定大于k。</span></span><br><span class="line">                res.append(s.substring(firstK, secondK));</span><br><span class="line">            &#125;</span><br><span class="line">            start += (<span class="number">2</span> * k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：用char型数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="comment">//这里是判断尾数够不够k个来取决end指针的位置</span></span><br><span class="line">            <span class="keyword">int</span> end = Math.min(ch.length - <span class="number">1</span>, start + k - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//用异或运算反转 </span></span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                ch[end] ^= ch[start];</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);   <span class="comment">//char型数组变string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指offer05-替换空格"><a href="#剑指offer05-替换空格" class="headerlink" title="剑指offer05.替换空格"></a>剑指offer05.替换空格</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br><span class="line">示例 1： 输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<p>思路：直接用一个stringbuilder来新建字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//选用 StringBuilder 单线程使用，比较快</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//碰到空格则替换，否则直接复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">		<span class="comment">//str.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot; &quot;</span>.equals(String.valueOf(s.charAt(i))))&#123;</span><br><span class="line">        <span class="comment">//.valueOf类型转换，类似parseInt也可以string转int</span></span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，逐个翻转字符串中的每个单词。</span><br><span class="line">示例 1：</span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<p>思路：首先将整个字符串反转过来，然后将字符串中的单词反转一下，即可。</p>
<ul>
<li>移除多余空格 : “the sky is blue”</li>
<li>字符串反转：”eulb si yks eht”</li>
<li>单词反转：”blue is sky the”</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.reverseWords2() called with: s = [&quot; + s + &quot;]&quot;);</span></span><br><span class="line">        <span class="comment">// 1.去除首尾以及中间多余空格</span></span><br><span class="line">        StringBuilder sb = removeSpace(s);</span><br><span class="line">        <span class="comment">// 2.反转整个字符串</span></span><br><span class="line">        reverseString(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.反转各个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">removeSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(start) == <span class="string">&#x27; &#x27;</span>) start++;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseEachWord</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = sb.length();</span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseString(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer58-II-左旋转字符串"><a href="#剑指Offer58-II-左旋转字符串" class="headerlink" title="剑指Offer58-II.左旋转字符串"></a>剑指Offer58-II.左旋转字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<p>思路：如果要求不申请额外空间</p>
<ol>
<li>反转区间为前n的子串</li>
<li>反转区间为n到末尾的子串</li>
<li>反转整个字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        reverseString(sb,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        reverseString(sb,n,len-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//翻转函数</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="459题-重复的子字符串"><a href="#459题-重复的子字符串" class="headerlink" title="459题.重复的子字符串"></a>459题.重复的子字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</span><br><span class="line">输入: &quot;abab&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure>

<p>思路：KMP算法，KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>
<p>KMP的精髓所在就是前缀表，前缀表：起始位置到下表i之前（包括i）的子串中，有多大长度的相同前缀后缀。</p>
<p>前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。</p>
<p>后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了</span></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 构造 next 数组过程，j从0开始(空格)，i从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 匹配不成功，j回到前一位置 next 数组所对应的值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">// 匹配成功，j往后移</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">// 更新 next 数组的值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值</span></span><br><span class="line">        <span class="keyword">if</span> (next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">javaのleecode栈与队列篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-07 13:42:43 / Modified: 15:03:52" itemprop="dateCreated datePublished" datetime="2021-11-07T13:42:43+08:00">2021-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Character&gt; st = new Stack&lt;Character&gt;();</span><br><span class="line">或</span><br><span class="line">Deque&lt;Character&gt; st = new LinkedList&lt;Character&gt;();</span><br><span class="line">st.isEmpty()</span><br><span class="line">st.peek()</span><br><span class="line">st.pop();</span><br><span class="line">st.push(ch);</span><br></pre></td></tr></table></figure>

<h2 id="20题-有效的括号"><a href="#20题-有效的括号" class="headerlink" title="20题.有效的括号"></a>20题.有效的括号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串，判断字符串是否有效。</span><br><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        if (n % 2 == 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = new HashMap&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">            put(&#x27;)&#x27;, &#x27;(&#x27;);</span><br><span class="line">            put(&#x27;]&#x27;, &#x27;[&#x27;);</span><br><span class="line">            put(&#x27;&#125;&#x27;, &#x27;&#123;&#x27;);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        //Deque&lt;Character&gt; stack = new LinkedList&lt;Character&gt;();</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            char ch = s.charAt(i);</span><br><span class="line">            if (pairs.containsKey(ch)) &#123;</span><br><span class="line">                if (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue1= new LinkedList&lt;&gt;();</span><br><span class="line">queue1.isEmpty()</span><br><span class="line">queue2.offer(x);   //添加一个元素并返回true   如果队列已满，则返回false</span><br><span class="line">queue1.poll()   //移除并返问队列头部的元素  如果队列为空，则返回null</span><br><span class="line">queue1.peek()  //返回队列头部的元素   如果队列为空，则返回null</span><br><span class="line">remove   移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常</span><br><span class="line">element  返回队列头部的元素  如果队列为空，则抛出一个NoSuchElementException异常</span><br><span class="line">add       增加一个元索   如果队列已满，则抛出一个IIIegaISlabEepeplian异常</span><br><span class="line">put       添加一个元素  如果队列满，则阻塞</span><br><span class="line">take      移除并返回队列头部的元素    如果队列为空，则阻塞</span><br><span class="line"></span><br><span class="line">1、add()和offer()区别:</span><br><span class="line">add()和offer()都是向队列中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。因此就可以在程序中进行有效的判断！</span><br><span class="line"></span><br><span class="line"> 2、poll()和remove()区别：</span><br><span class="line">remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。</span><br><span class="line"></span><br><span class="line">3、element() 和 peek() 区别：</span><br><span class="line">element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。</span><br></pre></td></tr></table></figure>

<h2 id="deque与queue"><a href="#deque与queue" class="headerlink" title="deque与queue"></a>deque与queue</h2><p><strong>Queue</strong>是简单的FIFO队列，<strong>Deque</strong>继承<strong>Queue</strong>实现双端队列。</p>
<p>队列(queue)是一种常用的<strong>数据结构</strong>，可以将队列看做是一种特殊的线性表，该结构遵循的先进先出原则。Java中，<strong>LinkedList实现了Queue接口</strong>,因为LinkedList进行插入、删除操作效率较高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      抛出异常	返回特殊值</span><br><span class="line">插入	add(e)	offer(e)</span><br><span class="line">移除	remove()	poll()</span><br><span class="line">检查	element()	peek()</span><br><span class="line"></span><br><span class="line">boolean add(E e);将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。</span><br><span class="line">boolean offer(E e);将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。</span><br><span class="line">E remove();获取并移除此队列的头。</span><br><span class="line">E poll();获取并移除此队列的头，如果此队列为空，则返回 null。</span><br><span class="line">E element();获取，但是不移除此队列的头。</span><br><span class="line">E peek();获取但不移除此队列的头；如果此队列为空，则返回 null。</span><br></pre></td></tr></table></figure>

<p>双向队列<strong>Deque</strong>继承了<strong>Queue</strong>，此队列两端都能进行出列和入列操作。除了继承了<strong>Queue</strong>的接口，又对每种方法额外添加了<code>first</code>与<code>last</code>方法用以实现操作双端队列。</p>
<h3 id="队列queue的使用："><a href="#队列queue的使用：" class="headerlink" title="队列queue的使用："></a>队列queue的使用：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Queue&lt;String&gt;que = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        que.offer(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        que.offer(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        que.offer(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的队列：&quot;</span>+que);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str=que.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的队列：&quot;</span>+que);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向队列deque的使用："><a href="#双向队列deque的使用：" class="headerlink" title="双向队列deque的使用："></a>双向队列deque的使用：</h3><p>第一种用法：同queue一样，作为单向队列使用，此时使用offer入列，poll出列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDeque1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Deque&lt;String&gt; deq = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        deq.offer(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        deq.offer(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        deq.offer(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的队列：&quot;</span>+deq);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(deq.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str=deq.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的队列：&quot;</span>+deq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种用法：作为双向队列使用，此时使用offerFirst、pollFirst，offerLast、pollFirst，则可以实现队首队尾入列或者出列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDeque2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Deque&lt;String&gt; deq2 = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        deq2.offerLast(<span class="string">&quot;aa&quot;</span>);  <span class="comment">//从后面进入</span></span><br><span class="line">        deq2.offerLast(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        deq2.offerLast(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的队列：&quot;</span>+deq2);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(deq2.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str= deq2.pollFirst();  <span class="comment">//从前面输出</span></span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的队列：&quot;</span>+deq2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种用法：作为栈来使用，遵循先入后出的原则，使用push和pop进行入栈和出栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDeque3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Deque&lt;String&gt; st = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        st.push(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        st.push(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        st.push(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的栈：&quot;</span>+st);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(st.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str= st.pop(); </span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的栈：&quot;</span>+st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>queue是单向队列，遵循先入先出的原则，而deque是queue的子接口，不仅可以作为单向队列使用，同时可以作为双向队列使用，根据入列出列在队尾或者队首决定输出元素顺序，在使用push和poll方法时，deque被称为栈，实现先入后出的原则。</p>
<h2 id="239题-滑动窗口最大值"><a href="#239题-滑动窗口最大值" class="headerlink" title="239题.滑动窗口最大值"></a>239题.滑动窗口最大值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span><br><span class="line">返回滑动窗口中的最大值。</span><br><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br></pre></td></tr></table></figure>

<p>思路：单调队列，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。</p>
<p>每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回我们要的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用双端队列手动实现单调队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span></span><br><span class="line">            <span class="comment">// 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="number">1</span>)&#123;</span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            deque.offer(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">                res[idx++] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="347题-前K个高频元素（优先级队列）"><a href="#347题-前K个高频元素（优先级队列）" class="headerlink" title="347题.前K个高频元素（优先级队列）"></a>347题.前K个高频元素（优先级队列）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</span><br><span class="line">示例 1:</span><br><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<p>思路：统计元素出现的频率，对频率进行排序，找出前k个高频元素。首先统计元素出现的频率，这一类的问题可以使用map来进行统计。然后是对频率进行排序，这里我们可以使用一种 容器适配器就是<strong>优先级队列</strong>。</p>
<p>优先级队列：其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p>
<p>而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？</p>
<p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。</p>
<p><strong>堆是一颗完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p>
<p>大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p>
<p>本题<strong>要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="comment">// 根据map的value值正序排，相当于一个小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123;</span><br><span class="line">            queue.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; k) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = queue.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/03/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/03/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/" class="post-title-link" itemprop="url">javaのleecode哈希表篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-03 21:33:12" itemprop="dateCreated datePublished" datetime="2021-11-03T21:33:12+08:00">2021-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 17:03:30" itemprop="dateModified" datetime="2021-11-07T17:03:30+08:00">2021-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
<p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p>
<p>哈希函数、哈希碰撞：拉链法。线性探测法（要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了）</p>
<p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<h3 id="Java中Map与HashMap-Hashtable-HashSet的区别"><a href="#Java中Map与HashMap-Hashtable-HashSet的区别" class="headerlink" title="Java中Map与HashMap,Hashtable,HashSet的区别"></a>Java中Map与HashMap,Hashtable,HashSet的区别</h3><p>HashMap和Hashtable两个类都实现了Map接口，二者保存K-V对（key-value对）；HashSet则实现了Set接口，性质类似于集合。</p>
<p>HashTable和HashMap区别：</p>
<p>一、继承的父类不同<br>Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。<br>二、线程安全性不同<br>Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理。<br>三、是否提供contains方法<br>HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。<br>Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。<br>四、key和value是否允许null值<br>其中key和value都是对象，并且不能包含重复key，但可以包含重复的value。<br>Hashtable中，key和value都不允许出现null值。<br>HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。<br>五、两个遍历方式的内部实现上不同<br>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。<br>六、hash值不同<br>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。<br>七、内部实现使用的数组初始化和扩容方式不同<br>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。<br>HashMap中hash数组的默认大小是16，而且一定是2的指数。</p>
<h2 id="242题-有效的字母异位词"><a href="#242题-有效的字母异位词" class="headerlink" title="242题.有效的字母异位词"></a>242题.有效的字母异位词</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</span><br><span class="line">示例 1: 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true</span><br><span class="line">示例 2: 输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false</span><br></pre></td></tr></table></figure>

<p>思路：用map，先遍历一个往里加，再遍历另一个减，如果没有或者value是0，则false。看到只有小写字母，所以长度为26的数组来充当map也可以。</p>
<p>知识：char ch : s.<strong>toCharArray()</strong>  遍历字符串中的字符。c++中的 ch：s 不可用。</p>
<p>字符串中，获得第几个字符，不能用s[i]，而是：s.<strong>charAt(i)</strong></p>
<p>判断map中是否有某key：if(!m.containsKey(ch))</p>
<p>获得key对应的value：m.get(key)</p>
<p>改变某key的value，直接覆盖？不能：m[i]++;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt;m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())&#123;</span><br><span class="line">        <span class="comment">//数组的长度length不加括号，字符串的长度要加括号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m.containsKey(ch))&#123;</span><br><span class="line">                m.put(ch,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m.put(ch, m.get(ch)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:t.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m.containsKey(ch) || m.get(ch)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//a==0 和 a.equals(0) 一样</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m.put(ch, m.get(ch)-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方法：单纯的字符串排序比较</p>
<p>首先将字符串变成字符数组，然后进行排序，然后进行比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="349题-两个数组的交集"><a href="#349题-两个数组的交集" class="headerlink" title="349题.两个数组的交集"></a>349题.两个数组的交集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定两个数组，编写一个函数来计算它们的交集。</span><br><span class="line">说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</span><br></pre></td></tr></table></figure>

<p>思路：哈希set即可。一个遍历得到数字，一个存储结果。</p>
<p>int[] 是固定长数组，没法像vector一样push_back</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组2的过程中判断哈希表中是否存在该元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">                resSet.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] resArr = <span class="keyword">new</span> <span class="keyword">int</span>[resSet.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将结果几何转为数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : resSet) &#123;  <span class="comment">//数组、set可以这样做，string不行</span></span><br><span class="line">            resArr[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="202题-快乐数"><a href="#202题-快乐数" class="headerlink" title="202题.快乐数"></a>202题.快乐数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</span><br></pre></td></tr></table></figure>

<p>思路：使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p>
<p>知识：set判断某数是否存在：s.contains(i);</p>
<p>set添加一个数：s.add(i);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; record = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !record.contains(n)) &#123;</span><br><span class="line">            record.add(n);</span><br><span class="line">            n = getsum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得n各位平方后的和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n % <span class="number">10</span>;</span><br><span class="line">            res += temp * temp;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="454题-四数相加"><a href="#454题-四数相加" class="headerlink" title="454题.四数相加"></a>454题.四数相加</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</span><br><span class="line"></span><br><span class="line">为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</span><br></pre></td></tr></table></figure>

<p>思路：用一个map代表双层循环，另外再来个双层循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span>[] nums3, <span class="keyword">int</span>[] nums4)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计两个数组中的元素之和，同时统计出现的次数，放入map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : nums2) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line">                    map.put(temp, map.get(temp) + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(temp, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : nums4) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15题-三数之和"><a href="#15题-三数之和" class="headerlink" title="15题.三数之和"></a>15题.三数之和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</span><br><span class="line">注意： 答案中不可以包含重复的三元组。</span><br><span class="line">示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</span><br></pre></td></tr></table></figure>

<p>思路：难点在于去重</p>
<p>方法一：两层循环，第二层加一个set。注意去重。</p>
<p>方法二：双指针法，其实是三指针，i指针后，left和right。三数之和如果大了，右指针左移，小了，左指针右移。</p>
<p>知识：动态数组ArrayList。添加数：result.add(Arrays.asList(nums[i], nums[left], nums[right])); （）asList是降int[]变成list的意思。</p>
<p>数组int[] 排序：Arrays.sort(nums);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    right--; </span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18题-四数之和"><a href="#18题-四数之和" class="headerlink" title="18题.四数之和"></a>18题.四数之和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span><br><span class="line">注意：答案中不可以包含重复的四元组。</span><br><span class="line">示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</span><br></pre></td></tr></table></figure>

<p>四数之和，和15.三数之和是一个思路，都是使用双指针法, 基本解法就是在15.三数之和的基础上再套一层for循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); </span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/02/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/%E9%93%BE%E8%A1%A8%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/02/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/%E9%93%BE%E8%A1%A8%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" class="post-title-link" itemprop="url">javaのleecode刷题链表篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-02 14:47:32" itemprop="dateCreated datePublished" datetime="2021-11-02T14:47:32+08:00">2021-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-03 21:33:34" itemprop="dateModified" datetime="2021-11-03T21:33:34+08:00">2021-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链表的定义输入输出"><a href="#链表的定义输入输出" class="headerlink" title="链表的定义输入输出"></a>链表的定义输入输出</h2><p>首先使用结构体定义，与c++不同，java中没有指针，隐藏指针，让指向某对象的指针看起来更像那个对象本身。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">为什么java中的main函数不能是非static？</span><br><span class="line"></span><br><span class="line">不能在main方法中打印this关键字的信息，因为不能在静态方法中调用this。理由很简单，this表示“这个对象”，也就是声明一个类的对象，然而静态方法是不属于某一个特定对象而是属于这个类的。那么问题来了，为什么main函数必须设置成静态的呢？</span><br><span class="line"></span><br><span class="line">首先，main函数作为java程序的入口，也可以理解为一个接口，这个接口不是提供给程序员使用的，这时提供给用户等使用的，用户等不需要知道程序内部的实现，只需要知道接口就可以了，如果是非静态的，那么当用户开始使用时，就必须先去创建对象，那么创建对象的代码又写在哪里呢？呵呵，所以这个很难讲清。</span><br><span class="line"></span><br><span class="line">Main方法是我们学习Java编程语言时知道的第一个方法，你是否曾经想过为什么main方法是public、static、void的。当然，很多人首先学的是C和C++，但是在Java中main方法与前者有些细微的不同，它不会返回任何值，为什么main方式是public、static、void，这篇文章尝试去找到一些答案。</span><br><span class="line"></span><br><span class="line">Main方法是Java程序的入口，记住，我们这里不会讨论Servlet、MIDlet和其他任何容器管理的java程序，在java核心编程中，JVM会查找类中的public static void main(String[] args)，如果找不到该方法就抛出错误NoSuchMethodError:main 程序终止。</span><br><span class="line">Main方法必须严格遵循它的语法规则，方法签名必须是public static void，参数是字符串数组类型，如果是Java1.5及以后的版本还可以使用可变参数：</span><br><span class="line">public  static void main(String... args)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为什么main方法是静态的（static）</span><br><span class="line"></span><br><span class="line">正因为main方法是静态的，JVM调用这个方法就不需要创建任何包含这个main方法的实例。</span><br><span class="line">因为C和C++同样有类似的main方法作为程序执行的入口。</span><br><span class="line">如果main方法不声明为静态的，JVM就必须创建main类的实例，因为构造器可以被重载，JVM就没法确定调用哪个main方法。</span><br><span class="line">静态方法和静态数据加载到内存就可以直接调用而不需要像实例方法一样创建实例后才能调用，如果main方法是静态的，那么它就会被加载到JVM上下文中成为可执行的方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么main方法是公有的（public）</span><br><span class="line">Java指定了一些可访问的修饰符如：private、protected、public，任何方法或变量都可以声明为public，Java可以从该类之外的地方访问。因为main方法是公共的，JVM就可以轻松的访问执行它。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么main方法没有返回值（Void） </span><br><span class="line"></span><br><span class="line">因为main返回任何值对程序都没任何意义，所以设计成void，意味着main不会有任何值返回</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">总结</span><br><span class="line"></span><br><span class="line">main方法必须声明为public、static、void，否则JVM没法运行程序</span><br><span class="line">如果JVM找不到main方法就抛出NoSuchMethodError:main异常，例如：如果你运行命令：java HelloWrold，JVM就会在HelloWorld.class文件中搜索public static void main (String[] args) 放法</span><br><span class="line">main方式是程序的入口，程序执行的开始处。</span><br><span class="line">main方法被一个特定的线程”main”运行，程序会一直运行直到main线程结束或者non-daemon线程终止。</span><br><span class="line">当你看到“Exception in Thread main”如：Excpetion in Thread main:Java.lang.NullPointedException ,意味着异常来自于main线程</span><br><span class="line">你可以声明main方法使用java1.5的可变参数的方式如：</span><br><span class="line">public  static void main(String... args)</span><br><span class="line">除了static、void、和public，你可以使用final，synchronized、和strictfp修饰符在main方法的签名中，如：</span><br><span class="line">public  strictfp final  synchronized static  void main(String[] args)</span><br><span class="line">main方法在Java可以像其他方法一样被重载，但是JVM只会调用上面这种签名规范的main方法。</span><br><span class="line">你可以使用throws子句在方法签名中，可以抛出任何checked和unchecked异常</span><br><span class="line">静态初始化块在JVM调用main方法前被执行，它们在类被JVM加载到内存的时候就被执行了。</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/peikunye/article/details/100513579">https://blog.csdn.net/peikunye/article/details/100513579</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxiao1204/article/details/75142811?yyue=a21bo.50862.201879">https://blog.csdn.net/maxiao1204/article/details/75142811?yyue=a21bo.50862.201879</a></p>
<p>对于java的构造函数有点懵逼，有参构造和无参构造可以同时存在吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">链表节点定义：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;  <span class="comment">//必须要加public吗？</span></span><br><span class="line">    <span class="keyword">public</span> ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">反转链表：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseListNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输入输出+测试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输入不定长的数组</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入链表：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        ListNode head = <span class="keyword">null</span>; <span class="comment">//代表是个空节点</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>; <span class="comment">//pre在这里定义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">            b[j] = Integer.parseInt(arr[j]);</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(b[j]); <span class="comment">//真正的构造节点</span></span><br><span class="line">            <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;  <span class="comment">//首先判断是不是头节点</span></span><br><span class="line">                head = node;</span><br><span class="line">                pre = head; <span class="comment">//pre在这里等于head，不能在上面等于</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next=node;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        printList(head);</span><br><span class="line">        ListNode res = reversal(head);</span><br><span class="line">        printList(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reversal</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode front = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = front;</span><br><span class="line">            front = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="203题-移除链表元素"><a href="#203题-移除链表元素" class="headerlink" title="203题.移除链表元素"></a>203题.移除链表元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">题意：删除链表中等于给定值 val 的所有节点。</span><br><span class="line">示例 1：</span><br><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p>思路：有可能头节点是要删除的，所以用prehead节点。c/c++需要清理节点内存。java/python则不需要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">链表节点定义：</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode() &#123;&#125;</span><br><span class="line">     ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">     ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        prehead.next = head;</span><br><span class="line">        <span class="comment">//ListNode prehead = new ListNode(-1, head);</span></span><br><span class="line">        ListNode pre = prehead;</span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//括号内不可以只是pre.next</span></span><br><span class="line">            <span class="keyword">if</span>(pre.next.val == val)&#123;</span><br><span class="line">                pre.next=pre.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24题-两两交换链表中得节点"><a href="#24题-两两交换链表中得节点" class="headerlink" title="24题.两两交换链表中得节点"></a>24题.两两交换链表中得节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span><br><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>

<p>思路：相当于是swap节点，不能只改变值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        prehead.next = head;</span><br><span class="line">        ListNode pre = prehead;</span><br><span class="line">        <span class="keyword">while</span>(pre.next!=<span class="keyword">null</span> &amp;&amp; pre.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode node1 = pre.next;</span><br><span class="line">            pre.next = node1.next;</span><br><span class="line">            ListNode node2 = pre.next.next;</span><br><span class="line">            pre.next.next = node1;</span><br><span class="line">            node1.next = node2;</span><br><span class="line">            pre = pre.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19题-删除链表的倒数第N个节点"><a href="#19题-删除链表的倒数第N个节点" class="headerlink" title="19题.删除链表的倒数第N个节点"></a>19题.删除链表的倒数第N个节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span><br><span class="line">输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] </span><br></pre></td></tr></table></figure>

<p>思路：明显的双指针法，为了降低时间复杂度，尽可能扫描一次链表来解决。一个指针先走n步，再一起走，当前面的走到头，那就是要删除的倒数第n个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        prehead.next=head;</span><br><span class="line">        ListNode left = prehead;</span><br><span class="line">        ListNode right = prehead;</span><br><span class="line">        <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            left=left.next;</span><br><span class="line">            right=right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next=left.next.next;</span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题02-07-链表相交"><a href="#面试题02-07-链表相交" class="headerlink" title="面试题02.07.链表相交"></a>面试题02.07.链表相交</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</span><br></pre></td></tr></table></figure>

<p>思路：一眼双指针，阿里二面题目，这道题里链表相交的话后面是重叠了，合并，而不是只交一个点，交一个点的话只能双层for循环了。两个指针走完了都走另一个，会同时到达合并的第一个节点。如果没有合并，同时遍历到空节点返回空节点。如果两个合并的长度一样，则走到第一个点就会返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode a = headA;</span><br><span class="line">        ListNode b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="keyword">null</span>)  a=headB;</span><br><span class="line">            <span class="keyword">else</span> a=a.next;</span><br><span class="line">            <span class="keyword">if</span>(b==<span class="keyword">null</span>)  b=headA;</span><br><span class="line">            <span class="keyword">else</span> b=b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142题-环形链表Ⅱ"><a href="#142题-环形链表Ⅱ" class="headerlink" title="142题.环形链表Ⅱ"></a>142题.环形链表Ⅱ</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><br><span class="line">为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</span><br><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p>思路：经典的快慢指针。一个一次走一格，一个一次走两格。不需要虚拟头节点。这是判断链表是否有环的方法，如果有环，两个指针都会一直走，两个指针一定会相遇。但是相遇的点不一定是环的入口。</p>
<p>这个环肯定是后面一个环就不再出来了。</p>
<p>而要找到环的入口，画个图，最后得出来：x = (n - 1) (y + z) + z。再跑一遍就可以得到环的入口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)&#123;  <span class="comment">//有环了，下面再找入口</span></span><br><span class="line">                <span class="keyword">while</span>(head!=slow)&#123;</span><br><span class="line">                    head=head.next;</span><br><span class="line">                    slow=slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>链表的种类主要为：单链表，双链表，循环链表</li>
<li>链表的存储方式：链表的节点在内存中是分散存储的，通过指针连在一起。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/31/myblog/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/31/myblog/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">秋招面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-31 16:24:02" itemprop="dateCreated datePublished" datetime="2021-10-31T16:24:02+08:00">2021-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-25 18:27:58" itemprop="dateModified" datetime="2021-12-25T18:27:58+08:00">2021-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">笔经面经</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="虾皮-后端-一面-2021-7-18"><a href="#虾皮-后端-一面-2021-7-18" class="headerlink" title="虾皮-后端-一面-2021.7.18"></a>虾皮-后端-一面-2021.7.18</h3><p>1.redis数据类型的底层结构 set<br>2.hashmap底层结构<br>3.c++禁止拷贝构造<br>4.tcp三次握手四次挥手<br>5.四次挥手time_wait机制<br>6.http、ip、dns属于什么层<br>7.cpu调度算法<br>8.linux命令，看文件后几行，日志关键词查询<br>9.进程间通信 信号量<br>10.逻辑地址与物理地址映射<br>11.编程：翻转句子但不翻转单词</p>
<h3 id="字节-商业化后端-一面-2021-7-18"><a href="#字节-商业化后端-一面-2021-7-18" class="headerlink" title="字节-商业化后端-一面-2021.7.18"></a>字节-商业化后端-一面-2021.7.18</h3><p>1.redis分布式锁机制<br>2.redis数据类型使用场景<br>3.hashmap用红黑树优点是什么，map底层数据结构<br>4.vector和list底层实现原理<br>5.互斥锁底层原理，如何实现原子性<br>6.智力题：圆上取三点，构成锐角、直角、钝角三角形的概率？<br>7.编程：合并区间<br>8.编程：最长回文子串</p>
<h3 id="字节-商业化后端-二面-2021-7-18"><a href="#字节-商业化后端-二面-2021-7-18" class="headerlink" title="字节-商业化后端-二面-2021.7.18"></a>字节-商业化后端-二面-2021.7.18</h3><p>1.编程：给定一个多任务场景， 不同任务执行过程中是有相互依赖关系的；<br>输入： n 代表n个任务<br>输出： k代表k个依赖关系<br>输出： n个任务能够完成一次调度执行；<br>提示：用节点的入度，入度为0可以删掉。<br>2.redis如何保证原子性<br>3.redis事务<br>4.mysql避免死锁底层如何实现<br>5.tcp是保序的吗？seq、syn<br>6.五层模型都是干嘛的</p>
<h3 id="商汤scg-三面-2021-7-19"><a href="#商汤scg-三面-2021-7-19" class="headerlink" title="商汤scg-三面-2021.7.19"></a>商汤scg-三面-2021.7.19</h3><p>1.乐观锁的版本号机制如何实现<br>2.redis集群主从同步失败怎么办<br>3.网站打不开的原因，发散<br>4.聚簇索引和非聚簇索引，增量索引？<br>5.编程：岛屿数量<br>6.go结构体嵌套，new操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">type a struct &#123;</span><br><span class="line">    add string</span><br><span class="line">&#125;</span><br><span class="line">type b struct &#123;</span><br><span class="line">    *a</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    b := new(b)</span><br><span class="line">    b.add = &quot;add&quot;</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节-商业化后端-三面-2021-7-20"><a href="#字节-商业化后端-三面-2021-7-20" class="headerlink" title="字节-商业化后端-三面-2021.7.20"></a>字节-商业化后端-三面-2021.7.20</h3><p>1.编程：二叉树转化为双向链表<br>2.智力：老虎吃羊问题<br>3.redis索引原理<br>4.线程池实现考虑什么，伪代码<br>5.c++的锁<br>6.c++管理内存泄漏的方法<br>7.说说智能指针，几种的区别<br>8.单继承和多继承的虚函数表的区别<br>9.多态如何实现<br>10.IO多路复用<br>11.redis持久化</p>
<h3 id="字节-数据中台后端-一面-2021-7-29"><a href="#字节-数据中台后端-一面-2021-7-29" class="headerlink" title="字节-数据中台后端-一面-2021.7.29"></a>字节-数据中台后端-一面-2021.7.29</h3><p>1.redis持久化写硬盘，对内存操作有没有影响？<br>2.写硬盘的方法，怎么最快<br>3.mysql索引底层<br>4.数据库锁<br>5.select * from table where a between 10 and 20 for update；之后再插入一条20-20之间的数据，发生什么？<br>可重复读：不能插，解决了幻读。读未提交，能插入？<br>6.实现strncpy函数<br>7.二分查找<br>8.截断数组的查找</p>
<h3 id="字节-数据中台后端-二面-2021-8-2"><a href="#字节-数据中台后端-二面-2021-8-2" class="headerlink" title="字节-数据中台后端-二面-2021.8.2"></a>字节-数据中台后端-二面-2021.8.2</h3><p>1.redis单线程如何实现的<br>2.http输入url过程<br>3.http和https<br>4.评论系统数据库表设计<br>5.写代码，求一条评论的所有子评论个数<br>6.网络攻击手段，sql注入，怎么防止，把自己套圈子里了</p>
<h3 id="虾皮-后端-二面-2021-8-3"><a href="#虾皮-后端-二面-2021-8-3" class="headerlink" title="虾皮-后端-二面-2021.8.3"></a>虾皮-后端-二面-2021.8.3</h3><p>1.hashtable怎么实现的<br>2.c++ stl用过什么，数组与链表<br>3.二叉树路径-回溯算法<br>4.针对订单的安全id怎么生成</p>
<h3 id="阿里云-后端-二面-2021-8-3"><a href="#阿里云-后端-二面-2021-8-3" class="headerlink" title="阿里云-后端-二面-2021.8.3"></a>阿里云-后端-二面-2021.8.3</h3><p>1.个人云和企业云的区别的看法，toB和toC<br>2.发号器不需要做切流，下线吗？<br>    系统自保、准入条件、云计算：资源的池化、分割售卖、安全隔离、资源隔离、超卖、服务契约<br>3.哈希打散的id怎么生成？<br>4.雪花算法，时间回滚，机器不知道，不能识别，怎么办？<br>5.code：求相对路径</p>
<h3 id="商汤-hr面-2021-8-5"><a href="#商汤-hr面-2021-8-5" class="headerlink" title="商汤-hr面-2021.8.5"></a>商汤-hr面-2021.8.5</h3><p>1.性格缺点<br>2.选择公司最看重什么<br>3.对智慧交通看法</p>
<h3 id="360-后端一面-2021-8-6"><a href="#360-后端一面-2021-8-6" class="headerlink" title="360-后端一面-2021.8.6"></a>360-后端一面-2021.8.6</h3><p>1.平衡二叉树和红黑树，为什么用红黑树<br>2.服务器实例无法访问数据库怎么办，db不能平衡扩展<br>3.编程：扑克牌判断是不是顺子<br>4.udp怎么可靠</p>
<h3 id="虾皮-后端-hr面-2021-8-10"><a href="#虾皮-后端-hr面-2021-8-10" class="headerlink" title="虾皮-后端-hr面-2021.8.10"></a>虾皮-后端-hr面-2021.8.10</h3><p>1.如何看待加班<br>2.评价一下自己，他人眼中的你什么样的<br>3.有什么其他offer或者流程中<br>4.想要什么公司氛围<br>5.想去什么业务<br>6.为啥选后端</p>
<h3 id="腾讯-交通平台产品部-一面-2021-8-10"><a href="#腾讯-交通平台产品部-一面-2021-8-10" class="headerlink" title="腾讯-交通平台产品部-一面-2021.8.10"></a>腾讯-交通平台产品部-一面-2021.8.10</h3><p>1.有啥爱好？？？？？<br>2.推荐悬疑书？？？<br>3.手撕：一个字符串切片成字典里的字符串，回溯<br>4.unordered_set和set区别，实现方面<br>5.c++和go<br>6.set什么语法实现降序</p>
<h3 id="阿里-三面-凉经"><a href="#阿里-三面-凉经" class="headerlink" title="阿里-三面-凉经"></a>阿里-三面-凉经</h3><p>1.做过网络编程没有<br>2.一个程序运行，资源空间如何变化<br>3.拷问项目<br>4.为什么对边缘计算感兴趣<br>5.怎么看边缘计算<br>6.大致觉得没有网络相关的项目，没有可问的，问我自己认为有什么优点<br>7.大佬就是大佬，秒凉</p>
<h3 id="阿里-高德-后端-一面"><a href="#阿里-高德-后端-一面" class="headerlink" title="阿里-高德-后端-一面"></a>阿里-高德-后端-一面</h3><p>1.用过除redis、mysql之外的中间件吗<br>2.mysql innodb为什么用B+树<br>3.redis数据结构底层实现<br>4.redis集群怎么部署<br>5.设计模式了解哪些，平常用的<br>6.zookeeper优缺点<br>7.聚集索引和非聚集索引</p>
<h3 id="网易-AI-c-算法落地-一面"><a href="#网易-AI-c-算法落地-一面" class="headerlink" title="网易-AI-c++算法落地-一面"></a>网易-AI-c++算法落地-一面</h3><p>1.深挖项目<br>2.为什么不用高频？？高频-&gt;波长短-&gt;按说传输距离高，因为频率高衰减大<br>  说成了多普勒，开始深挖多普勒<br>3.手撕：1.最少跳跃次数 （用广度优先，没写过）换：2.最小编辑距离（ac）        </p>
<h3 id="渤海银行-提前批-软开-2021-8-29-笔试准备"><a href="#渤海银行-提前批-软开-2021-8-29-笔试准备" class="headerlink" title="渤海银行-提前批-软开-2021.8.29-笔试准备"></a>渤海银行-提前批-软开-2021.8.29-笔试准备</h3><p>渤海银行成立时间：</p>
<p>渤海企业文化：诚信、远见、开放、创新、关爱</p>
<p>品牌主张：一旦选择,终身相伴</p>
<h3 id="阿里高德-一面-笔试面"><a href="#阿里高德-一面-笔试面" class="headerlink" title="阿里高德-一面-笔试面"></a>阿里高德-一面-笔试面</h3><p>笔试构造什么数据结构，父子结构的，<br>分布式事务<br>CAP原则<br>一致性哈希<br>消息队列<br>限流算法</p>
<h3 id="网易有道AI-c-算法开发工程师-二面"><a href="#网易有道AI-c-算法开发工程师-二面" class="headerlink" title="网易有道AI-c++算法开发工程师-二面"></a>网易有道AI-c++算法开发工程师-二面</h3><p>深挖项目<br>手撕：给一个数组变成偶数位上都是偶数或是奇数位上都是奇数<br>手撕：二叉树回溯，求路径和</p>
<h3 id="阿里-高德-二面-凉经"><a href="#阿里-高德-二面-凉经" class="headerlink" title="阿里-高德-二面-凉经"></a>阿里-高德-二面-凉经</h3><p>上来自己的IDE共享屏幕手撕：多线程输出<br>手撕：最长无重复子串的长度<br>思考：相交链表找相交节点<br>数据库隔离级别如何实现<br>手里的offer，规划之类</p>
<h3 id="阿里-高德-三面"><a href="#阿里-高德-三面" class="headerlink" title="阿里-高德-三面"></a>阿里-高德-三面</h3><p>面试官还不错，上来问我以后用啥语言，跟我讲阿里的java生态<br>思考题：城市有公交站和地铁站，每个站有辐射面积，算城市交通的覆盖率。<br>聊聊面向对象三个特征<br>自己的优缺点<br>平常怎么提高效率的<br>有了解什么新技术吗？面试官讲了一通中国软件界的兼容问题<br>反问：学习java意见<br>1、学语言思想，《深入浅出java虚拟机》《java编程思想》学习语法<br>2、应用，java web spring mvc boot<br>数据库MYbrits，关系型数据库，分布式数据库H-base，分库分表，catch<br>RPC框架，分布式高并发高响应。</p>
<h3 id="渤海-一面"><a href="#渤海-一面" class="headerlink" title="渤海-一面"></a>渤海-一面</h3><p>java垃圾回收，sb了应该说一些的<br>hashmap负载因子<br>hashmap和hashtable<br>数据库存储引擎<br>写代码多少年了<br>redis持久化<br>重载和重写<br>异常处理，catch和finish，蒙了一些</p>
<h3 id="农行-测试-2021-9-13"><a href="#农行-测试-2021-9-13" class="headerlink" title="农行-测试-2021.9.13"></a>农行-测试-2021.9.13</h3><p>三道题，a了一点多道</p>
<h3 id="华为-通信算法-一面-2021-9-13"><a href="#华为-通信算法-一面-2021-9-13" class="headerlink" title="华为-通信算法-一面-2021.9.13"></a>华为-通信算法-一面-2021.9.13</h3><p>全程问项目论文，对于细节问的蛮多<br>本来2点开始，结果2.20才叫面试<br>三点10分还没结束，无奈最后的写一个框图的题写得草率。</p>
<h3 id="华为-通信算法-二面"><a href="#华为-通信算法-二面" class="headerlink" title="华为-通信算法-二面"></a>华为-通信算法-二面</h3><p>论文+项目<br>做一道题，关于似然等概率知识的，都忘光了</p>
<h3 id="华为-通信算法-主管面"><a href="#华为-通信算法-主管面" class="headerlink" title="华为-通信算法-主管面"></a>华为-通信算法-主管面</h3><p>论文，还可以</p>
<h3 id="农行-2021-9-14-凉经"><a href="#农行-2021-9-14-凉经" class="headerlink" title="农行-2021.9.14-凉经"></a>农行-2021.9.14-凉经</h3><p>c++连接数据库的方式<br>c++不能重载的运算符<br>c++创建进程的方式<br>创建线程的类<br>创建线程池的方式</p>
<h3 id="网易-总监面-2021-9-14"><a href="#网易-总监面-2021-9-14" class="headerlink" title="网易-总监面-2021.9.14"></a>网易-总监面-2021.9.14</h3><p>手撕求平方，精确到小数点后10位<br>手撕两个四边形面积的重叠面积/总面积<br>看我的论文？？？</p>
<h3 id="网易-hr面"><a href="#网易-hr面" class="headerlink" title="网易-hr面"></a>网易-hr面</h3><h3 id="阿里-hr面"><a href="#阿里-hr面" class="headerlink" title="阿里-hr面"></a>阿里-hr面</h3><p>介绍个项目，遇到的难点，如何解决<br>遇到过什么困难，如何化解</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/31/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E6%95%B0%E7%BB%84%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/31/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E6%95%B0%E7%BB%84%E7%AF%87/" class="post-title-link" itemprop="url">javaのleecode刷题数组篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-31 16:16:09" itemprop="dateCreated datePublished" datetime="2021-10-31T16:16:09+08:00">2021-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 17:12:12" itemprop="dateModified" datetime="2021-11-07T17:12:12+08:00">2021-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="27题の移除元素"><a href="#27题の移除元素" class="headerlink" title="27题の移除元素"></a>27题の移除元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p>思路：暴力解法：两个for循环，每找到一个，都将它后面的元素一个个往前移。时间复杂度是O(n^2)。</p>
<p>简单解法：快慢指针法，对哪个指针进行判断是关键，如果对慢指针进行判断，则有一个就会后面一直相邻交换。应该对快指针进行判断，快指针判断到不是目标值，将该值赋给慢指针所在位置，慢指针移动1，如果是目标值，直接跳过，慢指针不移动。因此一层循环可以解决，<strong>循环内是快指针</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fast=<span class="number">0</span>; fast&lt;nums.length; fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=val)&#123;</span><br><span class="line">                nums[slow]=nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="977题の有序数组的平方"><a href="#977题の有序数组的平方" class="headerlink" title="977题の有序数组的平方"></a>977题の有序数组的平方</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</span><br><span class="line"></span><br><span class="line">示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</span><br><span class="line"></span><br><span class="line">示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>

<p>思路：双指针，因为原始数组是有序的，但是左边可能是负数，所以，数组的左右各一个指针，都往中间移动，判断两头的大小，挨个按照逆序塞到结果数组中。</p>
<p>知识：创建数组 int[] nums=new int[size];<br>Math.pow(n,m)幂次运算结果为double类型<br>强制类型转换(int)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];  <span class="comment">//创建数组</span></span><br><span class="line">        <span class="keyword">int</span> index=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.pow(nums[left],<span class="number">2</span>)&gt;=Math.pow(nums[right],<span class="number">2</span>))&#123;</span><br><span class="line">                res[index--]=(<span class="keyword">int</span>)Math.pow(nums[left],<span class="number">2</span>);</span><br><span class="line">                <span class="comment">//pow幂次运算结果是double类型，(int)来强制类型转换</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[index--]=(<span class="keyword">int</span>)Math.pow(nums[right],<span class="number">2</span>);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="209题の长度最小的子数组"><a href="#209题の长度最小的子数组" class="headerlink" title="209题の长度最小的子数组"></a>209题の长度最小的子数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<p>思路：滑动窗口，想象一下：右边加一个数，左边可以少几个数<br>窗口：连续的数组<br>起始位置：终止位置移动后，根据窗口内的和来判断是否移动起始指针<br>终止位置：<strong>循环内</strong>一个一个移动</p>
<p>知识：int的最大值：Integer.MAX_VALUE<br>最小运算：Math.min(a,b)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=<span class="number">0</span>; right&lt;nums.length; right++)&#123;</span><br><span class="line">            sum+=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">                <span class="comment">//这里得是&gt;=，并且min运算得在前面，因为开始窗口移动后可能不足target</span></span><br><span class="line">                res=Math.min(right-left+<span class="number">1</span>, res); <span class="comment">//注意判断的位置，一定得是while里</span></span><br><span class="line">                sum-=nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==Integer.MAX_VALUE? <span class="number">0</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59题の螺旋矩阵Ⅱ"><a href="#59题の螺旋矩阵Ⅱ" class="headerlink" title="59题の螺旋矩阵Ⅱ"></a>59题の螺旋矩阵Ⅱ</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</span><br><span class="line">示例:</span><br><span class="line">输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</span><br></pre></td></tr></table></figure>

<p>思路：判断是否进入四个角，需要拐弯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n*n; k++)&#123;</span><br><span class="line">            res[i][j]=k;</span><br><span class="line">            <span class="keyword">if</span>((i==<span class="number">0</span>||res[i-<span class="number">1</span>][j]!=<span class="number">0</span>)&amp;&amp;j&lt;n-<span class="number">1</span>&amp;&amp;res[i][j+<span class="number">1</span>]==<span class="number">0</span>)  j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((j==n-<span class="number">1</span>||res[i][j+<span class="number">1</span>]!=<span class="number">0</span>)&amp;&amp;i&lt;n-<span class="number">1</span>&amp;&amp;res[i+<span class="number">1</span>][j]==<span class="number">0</span>) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((i==n-<span class="number">1</span>||res[i+<span class="number">1</span>][j]!=<span class="number">0</span>)&amp;&amp;j&gt;=<span class="number">1</span>&amp;&amp;res[i][j-<span class="number">1</span>]==<span class="number">0</span>) j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((j==<span class="number">0</span>||res[i][j-<span class="number">1</span>]!=<span class="number">0</span>)&amp;&amp;i&gt;=<span class="number">1</span>&amp;&amp;res[i-<span class="number">1</span>][j]==<span class="number">0</span>) i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于数组，思考一些双指针法、快慢指针法、滑动窗口法。</p>
<h2 id="动态数组ArrayList"><a href="#动态数组ArrayList" class="headerlink" title="动态数组ArrayList"></a>动态数组ArrayList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 ArrayList 类</span></span><br><span class="line">ArrayList&lt;E&gt; objectName =<span class="keyword">new</span> ArrayList&lt;&gt;();　 <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">访问 ArrayList 中的元素可以使用 get() 方法：</span><br><span class="line">System.out.println(sites.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">如果要修改 ArrayList 中的元素可以使用 set() 方法：</span><br><span class="line">sites.set(<span class="number">2</span>, <span class="string">&quot;Wiki&quot;</span>); <span class="comment">// 第一个参数为索引位置，第二个为要修改的值</span></span><br><span class="line"></span><br><span class="line">如果要删除 ArrayList 中的元素可以使用 remove() 方法：</span><br><span class="line">sites.remove(<span class="number">3</span>); <span class="comment">// 删除第四个元素</span></span><br><span class="line"></span><br><span class="line">如果要计算 ArrayList 中的元素数量可以使用 size() 方法：</span><br><span class="line">System.out.println(sites.size());</span><br><span class="line"></span><br><span class="line">Collections.sort(sites);  <span class="comment">// 字母排序</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/13/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/1.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/13/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/1.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">java二分查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-10-13 19:21:50 / Modified: 20:27:40" itemprop="dateCreated datePublished" datetime="2021-10-13T19:21:50+08:00">2021-10-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有序的序列，每次都是以序列的中间位置的数来与待查找的关键字进行比较，每次缩小一半的查找范围，直到匹配成功。</p>
<p>一个情景：将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">twosplit</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类内二分查找函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">commonBinarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = <span class="number">0</span>;            <span class="comment">//定义middle</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; arr[low] || key &gt; arr[high]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            middle = low + (high - low) / <span class="number">2</span>;  <span class="comment">//防止溢出</span></span><br><span class="line">            <span class="comment">//如果 left 和 right 足够大，mid = (left + right)/2，可能会由于 left+right 导致 int 数据类型越界。</span></span><br><span class="line">            <span class="keyword">if</span> (arr[middle] &gt; key) &#123;</span><br><span class="line">                high = middle - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[middle] &lt; key) &#123;</span><br><span class="line">                low = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;        <span class="comment">//最后仍然没有找到，则返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入输出+测试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入有序数组：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            nums[j] = Integer.parseInt(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入目标值：&quot;</span>);</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> target = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=commonBinarySearch(nums, target);</span><br><span class="line">        System.out.printf(<span class="string">&quot;结果：%d&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/13/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/0.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/13/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/0.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" class="post-title-link" itemprop="url">java数和数组输入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-13 16:02:14" itemprop="dateCreated datePublished" datetime="2021-10-13T16:02:14+08:00">2021-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 18:53:59" itemprop="dateModified" datetime="2021-11-07T18:53:59+08:00">2021-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>java的输入需要依赖Scanner类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br></pre></td></tr></table></figure>

<p>如果需要输入，则先声明一个Scanner对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = new Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>Scanner附属于输入流System.in，声明Scanner对象之后，在输入的时候需要使用<strong>next()方法</strong>系列指定输入的类型，如输入整数、输入字符串等。遇到回车结束。</p>
<p>常用的next()方法系列：nextInt():输入整数  nextLine():输入字符串   nextDouble():输入双精度数   next():输入字符串（以空格作为分隔符）。</p>
<p>next()方法读取到空白符就结束l；<br>nextLine()读取到回车结束也就是“\r”；</p>
<p>!!!意思是next(),空格结束是键盘输入，回车之后，拿取空格之前的，还是需要回车的。</p>
<p>就不能空格结束算作输入一个吗？？？貌似不能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入数字</span></span><br><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> x;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        x=in.nextFloat();</span><br><span class="line">        System.out.println(x);   <span class="comment">//换行输出，输出之后自动换行</span></span><br><span class="line">        System.out.print(x);    <span class="comment">//不换行打印</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;输出是：%f&quot;</span>, x);   <span class="comment">//按格式输出</span></span><br><span class="line"></span><br><span class="line">        String s1;</span><br><span class="line">        Scanner sin=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        s1=sin.next();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        String s2;</span><br><span class="line">        Scanner sin2=<span class="keyword">new</span> Scanner(System.in);  <span class="comment">//每次输入之前，都需要重新来？？？</span></span><br><span class="line">        s2=sin2.nextLine();</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入数组</span></span><br><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">nums</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输入不定长的数组</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">            b[j] = Integer.parseInt(arr[j]);</span><br><span class="line">            System.out.print(b[j] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输入定长数组</span></span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入三个数：&quot;</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span>[] c=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c.length; i++)&#123;</span><br><span class="line">            c[i]=in.nextInt();</span><br><span class="line">            System.out.print(c[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jade liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jade liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
