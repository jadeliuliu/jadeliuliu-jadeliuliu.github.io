<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jadeliu&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Jadeliu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jade liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jadeliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jadeliu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/22/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/leeco%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/leeco%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">javaのleecode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-22 09:27:14" itemprop="dateCreated datePublished" datetime="2022-10-22T09:27:14+08:00">2022-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-30 11:45:22" itemprop="dateModified" datetime="2022-10-30T11:45:22+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>题目：给个数组和目标值，给出数组中两个数之和等于目标值的数的索引。<br>思想：哈希映射，利用map的快速查找key特性（<code>map.containsKey(key)</code>）来实现遍历一次就够了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 两数之和</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-20 23:39</span><br><span class="line"> **/</span><br><span class="line">public class TwoNumSum &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = new int[]&#123;2,7,11,15&#125;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        int[] res = solution.twoSum(nums, 9);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">            HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">                if (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                    return new int[]&#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new IllegalArgumentException(&quot;no result&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="两链表表示的数相加"><a href="#两链表表示的数相加" class="headerlink" title="两链表表示的数相加"></a>两链表表示的数相加</h2><p>题目：两个链表表示的数，1-&gt;2-&gt;3 表示 123，相加得到和的链表。<br>思想：相加遍历进位即可，carry表示进位，要在while循环外定义，要先算和再算进位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计算两个琏表表示的数的和</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-22 10:18</span><br><span class="line"> **/</span><br><span class="line">public class TwoLinkNumSum &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 构造链表</span><br><span class="line">        ListNode listNode1 = ListNode.inputList(1, 2, 3);</span><br><span class="line">        ListNode.printList(listNode1);</span><br><span class="line">        ListNode.printList(ListNode.reverseList(listNode1));</span><br><span class="line">        ListNode l1 = ListNode.inputList(2, 4, 3);</span><br><span class="line">        ListNode l2 = ListNode.inputList(5, 6, 4);</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        ListNode sum = s.addTwoNumbers(l1, l2);</span><br><span class="line">        ListNode.printList(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">            // 定义pre节点，保证头节点也参与循环</span><br><span class="line">            ListNode pre = new ListNode(0);</span><br><span class="line">            ListNode cur = pre;</span><br><span class="line">            int carry = 0;</span><br><span class="line">            while (l1 != null || l2 != null) &#123;</span><br><span class="line">                int x = l1 == null ? 0 : l1.val;</span><br><span class="line">                int y = l2 == null ? 0 : l2.val;</span><br><span class="line">                int sum = (x + y + carry) % 10;</span><br><span class="line">                carry = (x + y + carry) / 10;</span><br><span class="line">                cur.next = new ListNode(sum);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                if (l1 != null) &#123;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if (l2 != null) &#123;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (carry != 0) &#123;</span><br><span class="line">                cur.next = new ListNode(carry);</span><br><span class="line">            &#125;</span><br><span class="line">            return pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ListNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;;</span><br><span class="line">        ListNode(int val) &#123;this.val = val;&#125;</span><br><span class="line">        ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"></span><br><span class="line">        /** 向队尾添加节点 */</span><br><span class="line">        private void addNode(ListNode newNode) &#123;</span><br><span class="line">            if (this.next == null) &#123;</span><br><span class="line">                this.next = newNode;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.next.addNode(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /** 使用方法可变参数把一串数字变成链表 */</span><br><span class="line">        public static ListNode inputList(int ...data) &#123;</span><br><span class="line">            ListNode listHead = null;</span><br><span class="line">            for (int temp : data) &#123;</span><br><span class="line">                ListNode newNode = new ListNode(temp);</span><br><span class="line">                if (listHead == null) &#123;</span><br><span class="line">                    listHead = newNode;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    listHead.addNode(newNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return listHead;</span><br><span class="line">        &#125;</span><br><span class="line">        /** 打印链表 */</span><br><span class="line">        public static void printList(ListNode head) &#123;</span><br><span class="line">            while (head != null) &#123;</span><br><span class="line">                System.out.print(head.val + &quot;-&gt;&quot;);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        /** 翻转链表 */</span><br><span class="line">        public static ListNode reverseList(ListNode head) &#123;</span><br><span class="line">            ListNode pre = null;</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            while (cur != null) &#123;</span><br><span class="line">                ListNode next = cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            return pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串的最长无重复字符子串"><a href="#字符串的最长无重复字符子串" class="headerlink" title="字符串的最长无重复字符子串"></a>字符串的最长无重复字符子串</h2><p>题目：一个字符串，给出字符串的连续子串中其中无重复字符的子串的最大长度。<br>思想：滑动窗口，或者叫做双指针，两个指针的差+1表示窗口的长度，用一个map记录某字符最晚出现的位置的下一个位置。如果在start指针后面出现过就需要移动start到map该字符的value的位置了。如果要子串本身，还得记录开始位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 无重复字符的最长子串</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-22 12:29</span><br><span class="line"> **/</span><br><span class="line">public class MaxNoRepeatString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;abcabc&quot;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        System.out.println(solution.lengthOfLongestSubstring(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">            // 用map表示字符对应的下一个位置</span><br><span class="line">            Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            int res = 0;</span><br><span class="line">            String sub = null;</span><br><span class="line">            for (int start = 0, end = 0; end &lt; s.length(); end ++) &#123;</span><br><span class="line">                char c = s.charAt(end);</span><br><span class="line">                if (map.containsKey(c)) &#123;</span><br><span class="line">                    start = Math.max(start, map.get(c));</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果存在key，会更新</span><br><span class="line">                map.put(c, end + 1);</span><br><span class="line">                //res = Math.max(res, end - start + 1);</span><br><span class="line">                if (end - start + 1 &gt; res) &#123;</span><br><span class="line">                    res = end - start + 1;</span><br><span class="line">                    sub = s.substring(start, end + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;sub字符串：&quot; + sub);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><p>题目：给两个正序排列的数组，返回这两个数组合起来的数组的中位数。<br>思路1：遍历，在两个数组间横跳，遍历(m+n)/2+1次就好了。时间复杂度是O(m+n)<br>思路2：遍历是挨个排除不可能的值，那么如果用二分法就可以一半一半地排除不可能的值。其实是找第K小的数，要比两个数组的K/2位置的数，小的那个数组K/2及前面的数就可以排除掉，这样递归查找。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 寻找两个正序数组的中位数</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-23 10:10</span><br><span class="line"> **/</span><br><span class="line">public class MedianOfTwoArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array1 = new int[]&#123;1, 2&#125;;</span><br><span class="line">        int[] array2 = new int[]&#123;3, 4&#125;;</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        System.out.println(s.findMedianSortedArrays(array1, array2));</span><br><span class="line">        System.out.println(s.findMedianSortedArrays2(array1, array2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        // 方法一：在两个数组间遍历，移动(m+n)/2+1步</span><br><span class="line">        public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">            int index1 = 0, index2 = 0, left = 0, right = 0;</span><br><span class="line">            int size = nums1.length + nums2.length;</span><br><span class="line">            for (int i = 0; i &lt;= size / 2; i++) &#123;</span><br><span class="line">                // left慢一步</span><br><span class="line">                left = right;</span><br><span class="line">                if (index1 &lt; nums1.length &amp;&amp; (index2 == nums2.length || nums1[index1] &lt;= nums2[index2])) &#123;</span><br><span class="line">                    right = nums1[index1++];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right = nums2[index2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (size % 2 == 0) &#123;</span><br><span class="line">                return (left + right) / 2.0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 方法二：二分法</span><br><span class="line">        public double findMedianSortedArrays2(int[] nums1, int[] nums2) &#123;</span><br><span class="line">            int n = nums1.length;</span><br><span class="line">            int m = nums2.length;</span><br><span class="line">            int left = (n + m + 1) / 2;</span><br><span class="line">            int right = (n + m + 2) / 2;</span><br><span class="line">            return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取两正序数组的第k大的值</span><br><span class="line">        private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) &#123;</span><br><span class="line">            // 要进行比较的数组的长度</span><br><span class="line">            int len1 = end1 - start1 + 1;</span><br><span class="line">            int len2 = end2 - start2 + 1;</span><br><span class="line">            if (len1 + len2 &lt; k) &#123;throw new IllegalArgumentException(&quot;no result&quot;);&#125;</span><br><span class="line">            // 出递归条件</span><br><span class="line">            if (len1 == 0) return nums2[start2 + k - 1];</span><br><span class="line">            if (len2 == 0) return nums1[start1 + k - 1];</span><br><span class="line">            if (k == 1) return Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">            // 要比较的两个数组的索引</span><br><span class="line">            int i = start1 + Math.min(len1, k / 2) - 1;</span><br><span class="line">            int j = start2 + Math.min(len2, k / 2) - 1;</span><br><span class="line">            if (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>题目：给一个字符串，返回该字符串的最长回文子串，例如：aba，abba。<br>思想1：可以挨个遍历每个字符，从字符开始向左右散发，如果不相等了就停止，并且分两种散发：一个中心字符，两个一样的作为中心字符。记录开始位置和结束位置。<br>思想2：回文子串也是该字符串与它倒过来的字符串的最长公共子串，可以用动态规划维护一个二维数组来做。动态规划就是为了减少重复计算的问题。动态规划听起来很高大上。其实说白了就是空间换时间，将计算结果暂存起来，避免重复计算。作用和工程中用 redis 做缓存有异曲同工之妙。<br>求出最长公共子串后，并不一定是回文串，我们还需要判断该字符串倒置前的下标和当前的字符串下标是不是匹配</p>
<blockquote>
<p>整体思想就是，申请一个二维的数组初始化为 0，然后判断对应的字符是否相等，相等的话<br>arr [ i ][ j ] = arr [ i - 1 ][ j - 1] + 1 。<br>当 i = 0 或者 j = 0 的时候单独分析，字符相等的话 arr [ i ][ j ] 就赋为 1 。<br>arr [ i ][ j ] 保存的就是公共子串的长度，表示以i为结尾和以j为结尾的前arr[i][j]个字符是公共子串。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最长回文子串</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-29 20:43</span><br><span class="line"> **/</span><br><span class="line">public class HuiWenString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;aacabdkacaa&quot;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        System.out.println(solution.longestPalindrome(s));</span><br><span class="line">        System.out.println(solution.longestPalindrome1(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public String longestPalindrome(String s) &#123;</span><br><span class="line">            if (null == s || s.length() &lt; 2) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">            int max = 0;</span><br><span class="line">            String res = null;</span><br><span class="line">            for (int i = 0; i &lt; s.length() - 1; i ++) &#123;</span><br><span class="line">                int l = i, r = i;</span><br><span class="line">                while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                    l --;</span><br><span class="line">                    r ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (r - l + 1 &gt; max) &#123;</span><br><span class="line">                    max = r - l + 1;</span><br><span class="line">                    res = s.substring(l + 1, r);</span><br><span class="line">                &#125;</span><br><span class="line">                l = i;</span><br><span class="line">                r = i + 1;</span><br><span class="line">                while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                    l --;</span><br><span class="line">                    r ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (r - l + 1 &gt; max) &#123;</span><br><span class="line">                    max = r - l + 1;</span><br><span class="line">                    res = s.substring(l + 1, r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String longestPalindrome1(String s) &#123;</span><br><span class="line">            if (null == s || s.length() &lt; 2) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">            String res = null;</span><br><span class="line">            int max = 0;</span><br><span class="line">            int length = s.length();</span><br><span class="line">            int[][] arr = new int[length][length];</span><br><span class="line">            String rev = new StringBuffer(s).reverse().toString(); //字符串翻转</span><br><span class="line">            for (int i = 0; i &lt; length; i ++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; length; j ++) &#123;</span><br><span class="line">                    //如果不想等可以不赋值为0，表示以这个字符为公共最后字符没有公共字符，动态规划也用不上</span><br><span class="line">                    if (s.charAt(i) == rev.charAt(j)) &#123;</span><br><span class="line">                        //为0的边界</span><br><span class="line">                        if (i == 0 || j == 0) &#123;</span><br><span class="line">                            arr[i][j] = 1;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            arr[i][j] = arr[i - 1][j - 1] + 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (arr[i][j] &gt; max) &#123;</span><br><span class="line">                        int beforeRev = length - 1 - j; //倒置前的坐标</span><br><span class="line">                        if (beforeRev + arr[i][j] - 1 == i) &#123; //判断下标是否对应</span><br><span class="line">                            max = arr[i][j];</span><br><span class="line">                            res = s.substring(i - arr[i][j] + 1, i + 1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/mysql%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/mysql%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Mysql技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-25 16:25:11" itemprop="dateCreated datePublished" datetime="2022-09-25T16:25:11+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-04 21:52:07" itemprop="dateModified" datetime="2022-11-04T21:52:07+08:00">2022-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="sql实用函数"><a href="#sql实用函数" class="headerlink" title="sql实用函数"></a>sql实用函数</h2><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>1、datepart()</p>
<p>获取日期中的年月日<br>datepart(‘2022-11-11 12:12:12’, ‘yyyy’)<br>得到：2022，也可以是mm、dd</p>
<p>2、datetrunc()</p>
<p>获取日期的指定起始日期，比如一天的开始<br>datetrunc(‘2022-11-11 12:12:12’, ‘yyyy‘)<br>得到：2022-01-01 00:00:00</p>
<p>3、quarter()</p>
<p>获取日期的季度<br>quarter(‘2022-11-11 00:00:00’)<br>得到：4</p>
<h2 id="mySQL-with-as用法"><a href="#mySQL-with-as用法" class="headerlink" title="mySQL - with as用法"></a>mySQL - with as用法</h2><p>如果一整句查询中多个子查询都需要使用同一个子查询的结果，那么就可以用with as，将共用的子查询提取出来，加个别名。后面查询语句可以直接用，对于大量复杂的SQL语句起到了很好的优化作用。</p>
<p>构造数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 分类表</span><br><span class="line">CREATE TABLE category ( cid VARCHAR ( 32 ) PRIMARY KEY, cname VARCHAR ( 50 ) );</span><br><span class="line"></span><br><span class="line">-- 商品表</span><br><span class="line">CREATE TABLE products (</span><br><span class="line">	pid VARCHAR ( 32 ) PRIMARY KEY,</span><br><span class="line">	pname VARCHAR ( 50 ),</span><br><span class="line">	price INT,</span><br><span class="line">	flag VARCHAR ( 2 ),-- 是否上架标记为：1表示上架、0表示下架</span><br><span class="line">	category_id VARCHAR ( 32 ),</span><br><span class="line">	FOREIGN KEY ( category_id ) REFERENCES category ( cid ) </span><br><span class="line">);</span><br><span class="line">-- 分类数据</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c001&#x27;,&#x27;家电&#x27;);</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c002&#x27;,&#x27;鞋服&#x27;);</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c003&#x27;,&#x27;化妆品&#x27;);</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c004&#x27;,&#x27;汽车&#x27;);</span><br><span class="line"></span><br><span class="line">-- 商品数据</span><br><span class="line">INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#x27;p001&#x27;,&#x27;小米电视机&#x27;,5000,&#x27;1&#x27;,&#x27;c001&#x27;);</span><br><span class="line">INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#x27;p002&#x27;,&#x27;格力空调&#x27;,3000,&#x27;1&#x27;,&#x27;c001&#x27;);</span><br><span class="line">INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#x27;p003&#x27;,&#x27;美的冰箱&#x27;,4500,&#x27;1&#x27;,&#x27;c001&#x27;);</span><br></pre></td></tr></table></figure>

<p>查询两个商品的平均价格：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WITH xm_gl AS ( SELECT * FROM products WHERE pname IN ( &#x27;小米电视机&#x27;, &#x27;格力空调&#x27; ) ) </span><br><span class="line">SELECT avg( price ) FROM xm_gl;</span><br></pre></td></tr></table></figure>

<p>使用with as还可以创建多个临时表，但是要注意同一个查询语句前写一个with就够了，另外子查询需要逗号隔开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WITH a AS ( SELECT * FROM category WHERE cname = &#x27;家电&#x27; ),</span><br><span class="line">b AS ( SELECT * FROM products WHERE pname IN ( &#x27;小米电视机&#x27;, &#x27;格力空调&#x27; ) ) </span><br><span class="line">SELECT * FROM	a	LEFT JOIN b ON a.cid = b.category_id;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、with as 相当于一个临时表，但是不同于视图（create table as），不会存储起来，要与select配合使用。<br>2、同一个select前可以有多个临时表，写一个with就可以，用逗号隔开，最后一个with语句不要用逗号。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/397195826">https://zhuanlan.zhihu.com/p/397195826</a></p>
<p>实战总结：<br><code>with as</code>不能单独加<code>;</code>一句单独使用，需要后面跟select一起使用。第一个<code>with as</code>得到的临时表可以在第二个临时表里用。好处是可以分步骤生成表，不用嵌套很多层。</p>
<p>如果<code>create table as</code> ，是要加在<code>with as</code>之前的。</p>
<h2 id="mysql-case-when-用法"><a href="#mysql-case-when-用法" class="headerlink" title="mysql case when 用法"></a>mysql case when 用法</h2><p>MySQL 的 case when 的语法有两种：</p>
<p>简单函数<br><code>CASE [col_name] WHEN [value1] THEN [result1]…ELSE [default] END</code></p>
<p>搜索函数<br><code>CASE WHEN [expr] THEN [result1]…ELSE [default] END</code></p>
<p>简单函数用法：根据case字段when已知可能值，then列出已知装备（也可以是表的某个字段）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    NAME &#x27;英雄&#x27;,</span><br><span class="line">    CASE NAME</span><br><span class="line">        WHEN &#x27;德莱文&#x27; THEN</span><br><span class="line">            &#x27;斧子&#x27;</span><br><span class="line">        WHEN &#x27;德玛西亚-盖伦&#x27; THEN</span><br><span class="line">            &#x27;大宝剑&#x27;</span><br><span class="line">        WHEN &#x27;暗夜猎手-VN&#x27; THEN</span><br><span class="line">            &#x27;弩&#x27;</span><br><span class="line">        ELSE</span><br><span class="line">            &#x27;无&#x27;</span><br><span class="line">    END &#x27;装备&#x27;</span><br><span class="line">FROM</span><br><span class="line">    user_info;</span><br></pre></td></tr></table></figure>

<p>搜索函数用法：case when 某个字段的函数 then某值（也可以是表的字段）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># when 表达式中可以使用 and 连接条件</span><br><span class="line">SELECT</span><br><span class="line">    NAME &#x27;英雄&#x27;,</span><br><span class="line">    age &#x27;年龄&#x27;,</span><br><span class="line">    CASE</span><br><span class="line">        WHEN age &lt; 18 THEN</span><br><span class="line">            &#x27;少年&#x27;</span><br><span class="line">        WHEN age &lt; 30 THEN</span><br><span class="line">            &#x27;青年&#x27;</span><br><span class="line">        WHEN age &gt;= 30</span><br><span class="line">        AND age &lt; 50 THEN</span><br><span class="line">            &#x27;中年&#x27;</span><br><span class="line">        ELSE</span><br><span class="line">            &#x27;老年&#x27;</span><br><span class="line">    END &#x27;状态&#x27;</span><br><span class="line">FROM</span><br><span class="line">    user_info;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenduzizhong/p/9590741.html">https://www.cnblogs.com/chenduzizhong/p/9590741.html</a></p>
<h2 id="mysql批量删除大量数据"><a href="#mysql批量删除大量数据" class="headerlink" title="mysql批量删除大量数据"></a>mysql批量删除大量数据</h2><p>假设有一个表(syslogs)有1000万条记录，需要在业务不停止的情况下删除其中statusid=1的所有记录，差不多有600万条， 直接执行 DELETE FROM syslogs WHERE statusid=1 会发现删除失败，因为lock wait timeout exceed的错误。</p>
<p>因为这条语句所涉及的记录数太多，因此我们通过LIMIT参数分批删除，比如每10000条进行一次删除，那么我们可以利用 MySQL这样的语句来完成:<br><code>DELETE FROM syslogs WHERE status=1 ORDER BY statusid LIMIT 10000;</code></p>
<p>如果要用order by 必须要和 limit 联用，否则被优化掉。然后分多次执行就可以把这些记录成功删除。</p>
<p>注意：<br>执行大批量删除的时候注意要使用上limit。因为如果不用limit，删除大量数据很有可能造成死锁。<br><strong>如果delete的where语句不在索引上，可以先找主键，然后根据主键删除数据库。</strong><br>平时update和delete的时候最好也加上limit 1 来防止误操作。</p>
<p>mybatis中的delete语句可以有返回，返回结果int是删除的条数，如果没删除，返回0.</p>
<h2 id="delete和truncate，drop的区别"><a href="#delete和truncate，drop的区别" class="headerlink" title="delete和truncate，drop的区别"></a>delete和truncate，drop的区别</h2><p>1、delete删除数据的原理:(delete属于DML语句)</p>
<p>表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放。<br>这种删除表的优点是：支持回滚，后悔了可以恢复数据，可以带where条件删除部分数据，灵活性强。<br>缺点：删除效率比较低</p>
<p><code>delete from user;  //删除user表中的数据，但是这种删除数据的方式有点慢。</code></p>
<p>2、truncate删除数据的原理:(DDL)</p>
<p>可以理解为，drop table然后再create table。<br>效率比较高，表被一次截断，物理删除<br>优点：快速，不走事务，不会锁表，也不会产生大量日志写入日志文件<br>缺点：不支持回滚，只能删除表中所有数据，不能删单条数据<br>如果说公司项目里面有一张大表，数据非常多，几亿条记录：<br>删除的时候，使用delete，也许执行一个小时才能删除完，效率极其低；<br>可以选择使用truncate删除表中的数据。只需要不到1s的时间就能删除结束，效率较高。<br>但是使用truncate之前，必须仔细询问客户是否真的需要删除，并警告删除之后不可恢复。</p>
<p><code>truncate table user; //删除user表中的数据，快速。</code></p>
<p><strong>truncate和delete的差异</strong></p>
<blockquote>
<p>1、truncate是DDL语句，它不存在所谓的“事务回滚”；<br>delete是DML语句，它执行完是可以rollback的。<br>2、truncate table返回值是0；<br>delete from table返回值是被删除的行数。<br>3、InnoDB支持一个表一个文件时：<br>truncate会一次性把表干掉，且不会激活触发器，速度非常快；<br>delete from table则会一行一行删除，会激活触发器，速度比较慢。<br>delete数据，是要记录日志的，truncate表不需要记录日志。<br>4、当表中有列被其它表作为外键(foreign key)时：<br>truncate会是失败； delete则会成功。<br>5、当表中有自增列时：<br>truncate会使得自增列计数复原；<br>delete所有数据后，自增列计数并不会复原，而是保持原来的顺序自增。</p>
</blockquote>
<p>3、drop删除表操作</p>
<p>truncate和delete是删除表中的数据，表还在。</p>
<p><code>drop table 表名；// 删除表，不是删除表中的数据</code></p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jike11231/article/details/126551510">https://blog.csdn.net/jike11231/article/details/126551510</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jkzyx123/article/details/127223589">https://blog.csdn.net/jkzyx123/article/details/127223589</a></p>
<h2 id="mysql的subdate函数"><a href="#mysql的subdate函数" class="headerlink" title="mysql的subdate函数"></a>mysql的subdate函数</h2><p>MySQL中的SUBDATE()函数用于从给定日期减去某间隔时间。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SUBDATE(date, INTERVAL expr, unit)</span><br><span class="line"></span><br><span class="line">此函数接受以下三个参数：</span><br><span class="line">日期：第一个指定的日期。</span><br><span class="line">expr：要减去的时间/日期间隔的值。负的表示该时间之后</span><br><span class="line">单位：间隔的类型。MICROSECOND\SECOND\MINUTE\HOUR\DAY\WEEK\MONTH\QUARTER\YEAR</span><br></pre></td></tr></table></figure>

<p>例子：<br><code>select subdate(&quot;2020-11-25&quot;, INTERVAL 30 DAY)</code></p>
<p>今天的日期：<br><code>select curdate();  2022-10-30</code><br>现在的时间：<br><code>select curtime();   13:13:54</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/11/myblog/JAVA/java%20web/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/11/myblog/JAVA/java%20web/" class="post-title-link" itemprop="url">java web相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-11 14:46:24 / Modified: 15:03:17" itemprop="dateCreated datePublished" datetime="2022-09-11T14:46:24+08:00">2022-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网页502"><a href="#网页502" class="headerlink" title="网页502"></a>网页502</h2><p>502 Bad Gateway是指错误网关，无效网关；在互联网中表示一种网络错误。表现在WEB浏览器中给出的页面反馈。</p>
<p>服务端代码下掉，重新部署的间隙，访问接口会502.</p>
<h2 id="504错误"><a href="#504错误" class="headerlink" title="504错误"></a>504错误</h2><p>504错误代表网关超时 （Gateway timeout），是指服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p>
<p>接口504超时，是服务端这边超时断开请求了，需要看一下nginx配置。如果是tomcat，看一下conf中配置的请求超时时间。</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="✅nginx是什么？"><a href="#✅nginx是什么？" class="headerlink" title="✅nginx是什么？"></a>✅nginx是什么？</h3><blockquote>
<p>Nginx是十分轻量级的HTTP服务器。Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器。</p>
<p>Ngnix 是互联网企业使用最为广泛的代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。</p>
<p>Nginx是lgor Sysoev为俄罗斯访问量第二的rambler.ru站点设计开发的。从2004年发布至今，凭借开源的力量，已经接近成熟与完善。<br>Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。<br>Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p>
</blockquote>
<p>nginx是服务器，代理服务器，负载均衡，反向代理，服务器架构。</p>
<p>Nginx凭借其稳定性、低资源消耗、简单配置和丰富的功能，从十多年前名不见经传的Web服务器软件，发展到如今能够跟Apache匹敌的地位。</p>
<p>1、作为Web服务器，Nginx处理静态文件、索引文件，自动索引的效率非常高</p>
<p>2、作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度</p>
<p>3、作为负载均衡服务器，Nginx既可以在内部直接支持Rails和PHP，也可以支持HTTP代理服务器对外进行服务，同时还支持简单的容错和利用算法进行负载均衡</p>
<p>4、在性能方面，Nginx是专门为性能优化而开发的，实现上非常注重效率。它采用内核Poll模型，可以支持更多的并发连接，最大可以支持对5万个并发连接数的响应，而且只占用很低的内存资源</p>
<p>5、在稳定性方面，Nginx采取了分阶段资源分配技术，使得CPU与内存的占用率非常低。Nginx官方表示，Nginx保持1万个没有活动的连接，而这些连接只占用2.5MB内存，因此，类似DOS这样的攻击对Nginx来说基本上是没有任何作用的</p>
<p>6、在高可用性方面，Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到7x24小时不间断地运行<br>————————————————<br>解读nginx：<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_60274825/article/details/122101640">https://blog.csdn.net/weixin_60274825/article/details/122101640</a></p>
<h3 id="✅什么是代理服务器？"><a href="#✅什么是代理服务器？" class="headerlink" title="✅什么是代理服务器？"></a>✅什么是代理服务器？</h3><p>代理服务器是介于客户端和Web服务器之间的另一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页，而是通过向代理服务器发送请求，信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p>
<p><img src="https://img-blog.csdnimg.cn/865dde1f883d4cd6a0ec00a61bc960c9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5bCx5Z2Q6L-Z55yL55yL,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>代理位于Web客户端和Web服务器之间，扮演“中间人”的角色。<br>HTTP的代理服务器既是Web服务器又是Web客户端。</p>
<h3 id="✅什么是正反向代理"><a href="#✅什么是正反向代理" class="headerlink" title="✅什么是正反向代理"></a>✅什么是正反向代理</h3><p>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取的内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端，客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p>正向代理代理的对象是客户端，正向代理中，proxy和client同属一个LAN，对server透明 （客户端服务端多对一？）</p>
<p>反向代理服务器：在服务器端接收客户端的请求，然后把请求分发给具体的服务器进行处理，然后再将服务器的响应结果反馈给客户端。Nginx就是其中的一种反向代理服务器软件。</p>
<p>反向代理代理的对象是服务端，反向代理中，proxy和server同属一个LAN，对client透明  （客户端服务端多对多）</p>
<p>正向代理客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。<br>反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间中的内容发送普通请求，接着反向代理将判断向哪个原始服务器转交请求，并将获得的内容返回给客户端。<br>————————————————<br>解读nginx：<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_60274825/article/details/122101640">https://blog.csdn.net/weixin_60274825/article/details/122101640</a></p>
<h3 id="✅nginx与tomcat什么关系"><a href="#✅nginx与tomcat什么关系" class="headerlink" title="✅nginx与tomcat什么关系"></a>✅nginx与tomcat什么关系</h3><p>nginx是上面做web代理服务器的，而tomcat是上面做真正web服务器的。</p>
<p>nginx常用做静态内容服务和代理服务器，直面外来请求转发给后面的应用服务（tomcat，django什么的），tomcat更多用来做做一个应用容器，让java web app跑在里面的东西，对应同级别的有jboss,jetty等东西。</p>
<p>但是事无绝对，nginx也可以通过模块开发来提供应用功能，tomcat也可以直接提供http服务，通常用在内网和不需要流控等小型服务的场景。</p>
<p>严格的来说，Apache/Nginx 应该叫做「HTTP Server」；而 Tomcat 则是一个「Application Server」，或者更准确的来说，是一个「Servlet/JSP」应用的容器（Ruby/Python 等其他语言开发的应用也无法直接运行在 Tomcat 上）。</p>
<p>一个 HTTP Server 关心的是 HTTP 协议层面的传输和访问控制，所以在 Apache/Nginx 上你可以看到代理、负载均衡等功能。客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。通过 CGI 技术，也可以将处理过的内容通过 HTTP Server 分发，但是一个 HTTP Server 始终只是把服务器上的文件如实的通过 HTTP 协议传输给客户端。</p>
<p>而应用服务器，则是一个应用执行的容器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。对于 Tomcat 来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44517990/article/details/100712182">https://blog.csdn.net/weixin_44517990/article/details/100712182</a></p>
<h3 id="✅-springboot内置tomcat-和-tomcat"><a href="#✅-springboot内置tomcat-和-tomcat" class="headerlink" title="✅ springboot内置tomcat 和 tomcat"></a>✅ springboot内置tomcat 和 tomcat</h3><p>1.内置的tomcat没有tomcat的主页页面<a target="_blank" rel="noopener" href="http://localhost:9999/%EF%BC%8C%E8%80%8C%E6%88%91%E4%BB%AC%E5%B9%B3%E6%97%B6%E7%94%A8%E7%9A%84%E5%A4%96%E7%BD%AE%E7%9A%84tomcat%E6%98%AF%E6%9C%89%E7%9A%84">http://localhost:9999/，而我们平时用的外置的tomcat是有的</a></p>
<p>2.内置的tomcat可以用main跑项目，而如果要用外置的tomcat就需要把项目打成war包，然后拷贝到webapp下进行运行</p>
<p>Tomcat：<br>Tomcat是一个Web应用服务器，也是Servlet容器。它的作用是，解析客户端client发起的request，并组装出HttpRequest、创建HttpResponse，将二者交于内部的HttpServlet处理和填充</p>
<p>Tomcat映射处理请求的Servlet是通过web.xml做的。</p>
<p>SpringMVC使用一个DispatcherServlet来接收所有的请求，并把它们分发到不同的controller中来做进一步处理。</p>
<p>SpringMVC = Spring + Web框架，Spring这部分主要是AOP/IOC容器。</p>
<p>SpringBoot是Spring的扩展，简化了Spring的配置，通过starter的方式简化了常用组件依赖的引入，使其更加易用。</p>
<p>SpringBoot内置了tomcat。</p>
<h3 id="✅tomcat和spring-mvc"><a href="#✅tomcat和spring-mvc" class="headerlink" title="✅tomcat和spring mvc"></a>✅tomcat和spring mvc</h3><p>tomcat既是Http服务器（不用代理的话，其实是应用服务器），Http服务器与Servlet容器的功能界限是：可以把HTTP服务器想象成前台的接待，负责网络通信和解析请求，Servlet容器是业务部门，负责处理业务请求。</p>
<p>Tomcat和Servlet作为Web服务器和Servlet容器的结合，可以接受网络http请求解析为Servlet规范的请求对象和响应对象。比如，HttpServletRequest对象是Tomcat提供的，Servlet是规范，Tomcat是实现规范的Servlet容器。tomcat监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理;然后调用那个servlet的service方法，service方法返回一个response对象;<br>tomcat再把这个response返回给客户端。</p>
<p>SpringMVC是处理Servlet请求的应用，其中DispatcherServlet实现了Servlet接口，Tomcat负责加载和调用DispatcherServlet。同时，DispatcherServlet有自己的容器（SpringMVC）容器，这个容器负责管理SpringMVC相关的bean，比如Controler和ViewResolver等。同时，Spring中还有其他的Bean比如Service和DAO等，这些由全局的Spring IOC容器管理，因此，Spring有两个IOC容器。</p>
<p>如果只是使用spring(不包含springmvc)，那么是tomcat容器解析xml文件，通过反射实例化对应的类，根据这些servlet规范实现类，触发对应的代码处理逻辑，这个时候tomcat负责http报文的解析和servlet调度的工作。</p>
<p>如果使用spring mvc，那么tomcat只是解析http报文，然后将其转发给dispatchsetvlet，然后由springmvc根据其配置，实例对应的类，执行对应的逻辑，然后返回结果给dispatchservlet，最后由它转发给tomcat,由tomcat负责构建http报文数据。</p>
<p>DispatcherServlet：是Spring MVC中的一个类，实现了Servlet接口。所以部署在Tomcat中的Spring项目，对Tomcat来说，都是一个servlet。</p>
<p>————————————————<br>spring mvc还需要tomcat吗？<br>版权声明：本文为CSDN博主「黄泥川水猴子」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40277163/article/details/124730530">https://blog.csdn.net/qq_40277163/article/details/124730530</a></p>
<h3 id="✅nginx与域名解析DNS什么关系"><a href="#✅nginx与域名解析DNS什么关系" class="headerlink" title="✅nginx与域名解析DNS什么关系"></a>✅nginx与域名解析DNS什么关系</h3><p>首先，nginx是web服务器和反向代理服务器。 dns是域名解析服务器。nginx不带dns。</p>
<p>作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。访问域名，dns帮忙解析到ip，然后访问这个地址的资源呈现给你。hosts和nginx在后面用到。</p>
<p>hosts文件：<br>hosts文件是个本地域名解析文件，不管你是windwos还是linux，那都是有的，他里面的有效内容，就是一个个的ip和域名映射关系。<br>windows一般在：C:/Windows/System32/drivers/etc/hosts<br>Linux的hosts文件路径一般：/etc/hosts<br>比如：127.0.0.1 localhost<br>这个文件其实也是配置了ip和域名之间的映射关系的数据库，本地要是有这个文件，就优先用这个文件中的配置去解析，如果没有，那就通过dns解析。<br>注意：hosts文件只能配置ip和域名的映射关系，但是不能配置端口号，默认访问80端口</p>
<p>因为要解决端口问题，这里就得使用反向代理软件nginx，nginx中的每个server就是一个反向代理配置，可以有多个server。</p>
<p>理解：<em><strong>客户端请求 - dns解析域名 - 解析到nginx服务器的ip - nginx代理到tomcat服务器+端口 - tomcat将请求给servlet - servlet的service处理请求。</strong></em></p>
<h3 id="✅nginx与CDN内容分发网络什么关系"><a href="#✅nginx与CDN内容分发网络什么关系" class="headerlink" title="✅nginx与CDN内容分发网络什么关系"></a>✅nginx与CDN内容分发网络什么关系</h3><p>cdn是网络，nginx是服务器也是负载均衡。</p>
<p>cdn：<br>1、CDN的全称是Content Delivery Network，即内容分发网络。<br>2、其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。<br>3、通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。<br>4、其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度**。<br>5、内容分发网络是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。</p>
<p>cdn的工作原理：<br>CDN这个技术其实说起来并不复杂，最初的核心理念，就是将内容缓存在终端用户附近。</p>
<p>内容源不是远么？那么，我们就在靠近用户的地方，建一个缓存服务器，把远端的内容，复制一份，放在这里，不就OK了？</p>
<p>具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓吧？）</p>
<p>大家可能觉得，这个不就是“镜像服务器”嘛？其实不一样。镜像服务器是源内容服务器的完整复制。而CDN，是部分内容的缓存，智能程度更高。</p>
<p><img src="https://img-blog.csdnimg.cn/20210629132506469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDA5MTQz,size_16,color_FFFFFF,t_70"></p>
<p>借用阿里云官网的例子，来简单介绍CDN的工作原理。</p>
<p>假设通过CDN加速的域名为 <a href="http://www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：">www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：</a></p>
<p>1、当终端用户（北京）向<a target="_blank" rel="noopener" href="http://www.a.com下的指定资源发起请求时,首先向ldns(本地dns)发起域名解析请求./">www.a.com下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。</a></p>
<p>2、LDNS检查缓存中是否有<a target="_blank" rel="noopener" href="http://www.a.com的ip地址记录.如果有,则直接返回给终端用户;如果没有,则向授权dns查询./">www.a.com的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。</a></p>
<p>3、当授权DNS解析<a target="_blank" rel="noopener" href="http://www.a.com时,返回域名cname/">www.a.com时，返回域名CNAME</a> <a target="_blank" rel="noopener" href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></p>
<p>4、域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</p>
<p>5、LDNS获取DNS返回的解析IP地址。</p>
<p>6、用户获取解析IP地址。</p>
<p>7、用户向获取的IP地址发起对该资源的访问请求。</p>
<p>8、如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</p>
<p>9、如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。</p>
<p>所以：<br>（1）CDN的加速资源是跟域名绑定的。<br>（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP<br>（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。</p>
<hr>
<p>nginx负载均衡：负载均衡实际上就是将大量请求进行分布式处理的策略</p>
<p>Nginx 作为一个基于 C 实现的高性能 Web 服务器，可以通过系列算法解决上述的负载均衡问题。并且由于它具有高并发、高可靠性、高扩展性、开源等特点，成为开发人员常用的反向代理工具</p>
<p>1、正向代理</p>
<p>正向代理（Forward Proxy）最大的特点是，客户端非常明确要访问的服务器地址，它代理客户端，替客户端发出请求。比如：科学上网。</p>
<p>假设客户端想要访问 Google，它明确知道待访问的服务器地址是 <a target="_blank" rel="noopener" href="https://www.google.com/%EF%BC%8C%E4%BD%86%E7%94%B1%E4%BA%8E%E6%9D%A1%E4%BB%B6%E9%99%90%E5%88%B6%EF%BC%8C%E5%AE%83%E6%89%BE%E6%9D%A5%E4%BA%86%E4%B8%80%E4%B8%AA%E8%83%BD%E5%A4%9F%E8%AE%BF%E9%97%AE%E5%88%B0">https://www.google.com/，但由于条件限制，它找来了一个能够访问到</a> Google 的”朋友”：代理服务器。客户端把请求发给代理服务器，由代理服务器代替它请求 Google，最终再将响应返回给客户端。这便是一次正向代理的过程，该过程中服务器并不知道真正发出请求的是谁。<br>（客户端 - 正向代理 - 服务器）</p>
<p>2、反向代理</p>
<p>随着请求量的爆发式增长，服务器觉得自己一个人始终是应付不过来，需要兄弟服务器们帮忙，于是它喊来了自己的兄弟以及代理服务器朋友。此时，来自不同客户端的所有请求实际上都发到了代理服务器处，再由代理服务器按照一定的规则将请求分发给各个服务器。这就是反向代理（Reverse Proxy），反向代理隐藏了服务器的信息，它代理的是服务器端，代其接收请求。换句话说，反向代理的过程中，客户端并不知道具体是哪台服务器处理了自己的请求。如此一来，既提高了访问速度，又为安全性提供了保证<br>（一堆客户端 - 反向代理 - 一堆服务器）</p>
<p>在这之中，反向代理需要考虑的问题是，如何进行均衡分工，控制流量，避免出现局部节点负载过大的问题。通俗的讲，就是如何为每台服务器合理的分配请求，使其整体具有更高的工作效率和资源利用率。</p>
<p>3、负载均衡常用算法</p>
<p>轮询 （round-robin）<br>轮询为负载均衡中较为基础也较为简单的算法，它不需要配置额外参数。假设配置文件中共有 台服务器，该算法遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。特点：由于该算法中每个请求按时间顺序逐一分配到不同的服务器处理，因此适用于服务器性能相近的集群情况，其中每个服务器承载相同的负载。但对于服务器性能不同的集群而言，该算法容易引发资源分配不合理等问题。</p>
<p>加权轮询<br>为了避免普通轮询带来的弊端，加权轮询应运而生。在加权轮询中，每个服务器会有各自的 weight。一般情况下，weight 的值越大意味着该服务器的性能越好，可以承载更多的请求。该算法中，客户端的请求按权值比例分配，当一个请求到达时，优先为其分配权值最大的服务器。特点：加权轮询可以应用于服务器性能不等的集群中，使资源分配更加合理化。</p>
<p>IP 哈希（IP hash）<br>ip_hash 依据发出请求的客户端 IP 的 hash 值来分配服务器，该算法可以保证同 IP 发出的请求映射到同一服务器，或者具有相同 hash 值的不同 IP 映射到同一服务器。特点：该算法在一定程度上解决了集群部署环境下 Session 不共享的问题。</p>
<p>所以：<br>Nginx 作为一款优秀的反向代理服务器，可以通过不同的负载均衡算法来解决请求量过大情况下的服务器资源分配问题。较为常见的负载均衡算法有轮询、加权轮询、IP 哈希等等，可分别应对不同的请求场景。</p>
<p>————————————————<br>好文章：从对CDN的理解到Nginx负载均衡<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40409143/article/details/118330238">https://blog.csdn.net/qq_40409143/article/details/118330238</a></p>
<h3 id="✅nginx与RPC远程过程调用什么关系？"><a href="#✅nginx与RPC远程过程调用什么关系？" class="headerlink" title="✅nginx与RPC远程过程调用什么关系？"></a>✅nginx与RPC远程过程调用什么关系？</h3><p>RPC是远程过程调用，是一种计算机通信协议。<br>nginx是代理服务器。<br>Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互。也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。</p>
<p>讲RPC、RPC与nginx、RPC与HTTP间的关系的好文章：<br><a target="_blank" rel="noopener" href="https://www.kancloud.cn/machh03/server/2096716">https://www.kancloud.cn/machh03/server/2096716</a></p>
<h3 id="✅与gateway有什么关系？"><a href="#✅与gateway有什么关系？" class="headerlink" title="✅与gateway有什么关系？"></a>✅与gateway有什么关系？</h3><p>网关(Gateway)就是一个网络连接到另一个网络的“关口”。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy53YW5kb3VpcC5jb20vY3Jhd2xlci9hcnRpY2xlLzIwMTk4MS9hYTVmNTVkNjVkMTUxYjUxYzJiOGRhZTAyNTNmN2NmMQ?x-oss-process=image/format,png"></p>
<p>1、nginx也可以做网关，是用户访问的总入口，也就是前端页面的容器，流量网关。</p>
<p>流量网关是定义全局性的、跟具体的后端业务应用和服务完全无关的策略网关。<br>流量网关通常只专注于全局的Api管理策略，比如全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等，有点类似防火墙。</p>
<p>2、gateway的定义是针对每一个业务微服务来得，属于业务网关。是介于nignx以及业务应用之间的中间层，主要负责将请求路由到不同的微服务中以及对请求的合法性进行校验。</p>
<p>业务网关针对具体的业务需要提供特定的流控策略、缓存策略、鉴权认证策略等等。<br>业务网关一般部署在流量网关之后、业务系统之前，比流量网关更靠近业务系统。通常API网指的是业务网关。 有时候我们也会模糊流量网关和业务网关，让一个网关承担所有的工作,所以这两者之间并没有严格的界线。</p>
<hr>
<p>网关可以看做系统与外界联通的入口，我们可以在网关进行处理一些非业务逻辑的逻辑，比如权限验证，监控，缓存，请求路由等等。</p>
<p>1、nginx是用户到 前端工程 的网关，对外网关<br>nginx是用C语言写的<br>nginx做网关，更多的是做总流量入口，反向代理，负载均衡等，还可以用来做web服务器。<br>Nginx在其中扮演的角色是什么？<br>反向代理<br>负载均衡</p>
<p>2、gateway 是前端工程 到 后台服务器之间的一个 对内网关<br>gateway是java语言的一个框架，可以在框架上进行代码的扩展与控制，例如：安全控制，统一异常处理，XXS,SQL注入等；权限控制，黑白名单，性能监控，日志打印等<br>gateway的主要功能有，路由，断言，过滤器，利用它的这些特性，可以做流控。<br>SpringGateway在其中扮演的角色是什么？<br>统一鉴权</p>
<p>nginx与gateway：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yangbindxj/article/details/125040773">https://blog.csdn.net/yangbindxj/article/details/125040773</a></p>
<hr>
<p>网关服务的端口号默认是80或者443.<br>相同点：都是可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等，可以实现和网关一样的效果。<br>Nginx实现负载均衡的原理属于服务器端负载均衡器。<br>Gateway实现负载均衡原理采用本地负载均衡器的形式。</p>
<h3 id="✅nginx与统一接入有什么关系？"><a href="#✅nginx与统一接入有什么关系？" class="headerlink" title="✅nginx与统一接入有什么关系？"></a>✅nginx与统一接入有什么关系？</h3><p>统一接入层是：指的是设置专属一层，统一接入所有流量，包括 PC 流量、无线流量、IoT 流量。在应用层之上的一层。</p>
<p>如果没有统一接入层，之前的业务方，例如购物车、商品等都要自己维护一个网关，这就涉及到维护成本和机器成本。例如卸载 HTTPS，如果所有业务方都要申请证书，那造成的应用成本是非常高的。可如果将所有功能全放在这一层进行，好处非常明显：一方面是机器集中管理节省成本；另外一方面，如果遇到新的瓶颈可以在统一接入层集中优化，如请求响应 Body 统一在这一层进行压缩减少带宽消耗，压缩会消耗 CPU，可以在这一层通过硬件加速的方式集中优化等。</p>
<p>阿里统一接入层：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96510277?hmsr=toutiao.io">https://zhuanlan.zhihu.com/p/96510277?hmsr=toutiao.io</a></p>
<p>统一接入层方案：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Leo_wl/archive/2012/10/17/2728541.html">https://www.cnblogs.com/Leo_wl/archive/2012/10/17/2728541.html</a></p>
<p>统一接入层是网关中最前端的服务，统一接入到集群中。<br>所以，统一接入层应该是在web代理服务器nginx前的。</p>
<h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><h3 id="nginx配置文件结构"><a href="#nginx配置文件结构" class="headerlink" title="nginx配置文件结构"></a>nginx配置文件结构</h3><p>Main 位于 nginx.conf 配置文件的最高层；<br>Main 层下可以有 Event、HTTP 层；<br>Http 层下面允许有多个 Server 层，用于对不同的网站做不同的配置；<br>Server 层下面允许有多个 Location，用于对不同的路径进行不同模块的配置。</p>
<p>1、main（最上面）<br>全局配置部分用来配置对整个 server 都有效的参数。主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等<br>全局Main配置<br>user nginx;<br>worker_processes 1; #设置值和CPU核心数一致</p>
<p>error_log /var/log/nginx/error.log warn; #日志位置和日志级别<br>pid       /var/run/nginx.pid;</p>
<p>2.event<br>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 worker process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 worker process 可以同时支持的最大连接数等。<br>Event配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、http<br>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。<br>http配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  include       /etc/nginx/mime.types;</span><br><span class="line">  default_type application/octet-stream;</span><br><span class="line">  log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                    &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                    &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">  access_log /var/log/nginx/access.log main;</span><br><span class="line">  sendfile       on;</span><br><span class="line">  #tcp_nopush     on;</span><br><span class="line">  keepalive_timeout 65;</span><br><span class="line">  #gzip on;</span><br><span class="line">  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、server<br>Server 块也被叫做“虚拟主机”部分，它描述的是一组根据不同 server_name 指令逻辑分割的资源，这些虚拟服务器响应 HTTP 请求，因此都包含在 http 部分。最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。一个 server 块可以配置多个 location 块。<br>server配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  location / &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">      index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">  error_page   500 502 503 504 /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nginx配置结构：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1729793004418584302&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1729793004418584302&amp;wfr=spider&amp;for=pc</a></p>
<p>菜鸟nginx配置：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">https://www.runoob.com/w3cnote/nginx-setup-intro.html</a></p>
<p>nginx配置详细介绍：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_12218973/2457715">https://blog.51cto.com/u_12218973/2457715</a></p>
<h3 id="nginx超时配置"><a href="#nginx超时配置" class="headerlink" title="nginx超时配置"></a>nginx超时配置</h3><p>Nginx主要有四类超时设置：客户端超时设置、DNS解析超时设置、代理超时设置，如果使用ngx_lua，则还有lua相关的超时设置。</p>
<p>1、客户端超时</p>
<p>客户端超时主要设置有读取请求头超时时间、读取请求体超时时间、发送响应超时时间、长连接超时时间。通过客户端超时设置避免客户端恶意或者网络状况不佳造成连接长期占用，影响服务端的可处理的能力。</p>
<p><strong>client_header_timeout time</strong>：设置读取客户端请求头超时时间，默认为60s，如果在此超时时间内客户端没有发送完请求头，则响应408（RequestTime-out）状态码给客户端。</p>
<p><strong>client_body_timeout time</strong>：设置读取客户端内容体超时时间，默认为60s，此超时时间指的是两次成功读操作间隔时间，而不是发送整个请求体的超时时间，如果在此超时时间内客户端没有发送任何请求体，则响应408（RequestTime-out）状态码给客户端。</p>
<p><strong>send_timeout time</strong>：设置发送响应到客户端的超时时间，默认为60s，此超时时间指的也是两次成功写操作间隔时间，而不是发送整个响应的超时时间。如果在此超时时间内客户端没有接收任何响应，则Nginx关闭此连接。</p>
<p>**keepalive_timeout timeout [header_timeout]**：设置HTTP长连接超时时间，其中，第一个参数timeout是告诉Nginx长连接超时时间是多少，默认为75s。第二个参数header_timeout是用于设置响应头“Keep-Alive: timeout=time”，即告知客户端长连接超时时间。如果timeout设置为0，则表示禁用长连接。</p>
<p>2、DNS解析超时</p>
<p><strong>resolver_timeout 30s</strong>：设置DNS解析超时时间，默认为30s</p>
<p>3、代理超时</p>
<p>主要有三组配置：网络连接/读/写超时设置、失败重试机制设置、upstream存活超时设置</p>
<p><strong>proxy_connect_timeout time</strong>：与后端/上游服务器建立连接的超时时间，默认为60s，此时间不超过75s。</p>
<p><strong>proxy_read_timeout time</strong>：设置从后端/上游服务器读取响应的超时时间，默认为60s，此超时时间指的是两次成功读操作间隔时间，而不是读取整个响应体的超时时间，如果在此超时时间内上游服务器没有发送任何响应，则Nginx关闭此连接。</p>
<p><strong>proxy_send_timeout time</strong>：设置往后端/上游服务器发送请求的超时时间，默认为60s，此超时时间指的是两次成功写操作间隔时间，而不是发送整个请求的超时时间，如果在此超时时间内上游服务器没有接收任何响应，则Nginx关闭此连接。</p>
<p><strong>proxy_next_upstream_tries number</strong>：设置重试次数，默认0表示不限制，注意此重试次数指的是所有请求次数（包括第一次和之后的重试次数之和）。</p>
<p><strong>proxy_next_upstream_timeout time</strong>：设置重试最大超时时间，默认0表示不限制。</p>
<p>Nginx超时配置：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiao__jia__jia/article/details/124075274">https://blog.csdn.net/xiao__jia__jia/article/details/124075274</a></p>
<h2 id="PoolingHttpClientConnectionManager"><a href="#PoolingHttpClientConnectionManager" class="headerlink" title="PoolingHttpClientConnectionManager"></a>PoolingHttpClientConnectionManager</h2><p>HttpClien高并发请求连接池 - PoolingHttpClientConnectionManager</p>
<p>连接池：<br>连接池技术作为创建和管理连接的缓冲池技术，目前已广泛用于诸如数据库连接等长连接的维护和管理中，能够有效减少系统的响应时间，节省服务器资源开销。其优势主要有两个：其一是减少创建连接的资源开销，其二是资源的访问控制。连接池管理的对象是长连接。</p>
<p>PoolingHttpClientConnectionManager是通过租用连接和收回链接的方式来实现的。解决了http请求的多线程问题。</p>
<p>依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>实现http连接池：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34484062/article/details/109470135">https://blog.csdn.net/qq_34484062/article/details/109470135</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/10/myblog/JAVA/java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/10/myblog/JAVA/java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">java诊断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-10 23:39:58" itemprop="dateCreated datePublished" datetime="2022-09-10T23:39:58+08:00">2022-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-17 12:16:32" itemprop="dateModified" datetime="2022-09-17T12:16:32+08:00">2022-09-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="java诊断工具arthas"><a href="#java诊断工具arthas" class="headerlink" title="java诊断工具arthas"></a>java诊断工具arthas</h2><h3 id="✅简介"><a href="#✅简介" class="headerlink" title="✅简介"></a>✅简介</h3><p>Arthas 是Alibaba开源的Java诊断工具。安装在系统所在服务器。可以帮助开发人员或者运维人员查找问题，分析性能，bug追踪。</p>
<p>解决问题：<br>1、以全局视角来查看系统的运行状况、健康状况。<br>2、反编译源码，查看jvm加载的是否为预期的文件内容。<br>3、查看某个方法的返回值，参数等等。<br>4、方法内调用路径及各方法调用耗时。<br>5、查看jvm运行状况。<br>6、外部.class文件重新加载到jvm里。<br>等等…..</p>
<p>场景：<br>1）调用接口时，接口返回异常信息，如果该异常信息没有清晰的定位到代码，那么我们通常只能依靠大脑回忆代码，来估计错误发生地了，如果无法估计，一般情况下就会进入测试环境，模拟复现，如果无法复现。<br>2）这个查询，耗时20s，我们想要分析一下到底是哪些代码导致的。但是该方法内部又穿插调用了其它业务功能方法，难道手写System.currentTimeMillis()自己做减运算，还是guava的StopWatch亦或是commons的StopWatch？这几种方式需要我们手动嵌入代码，容易遗漏、费力还费时。<br>等等<br>arthas可以为我们解决上述问题，帮助程序员尽早下班，尽早交代。</p>
<h3 id="✅安装启动"><a href="#✅安装启动" class="headerlink" title="✅安装启动"></a>✅安装启动</h3><p>下载: wget <a target="_blank" rel="noopener" href="https://alibaba.github.io/arthas/arthas-boot.jar">https://alibaba.github.io/arthas/arthas-boot.jar</a><br>启动: java -jar arthas-boot.jar</p>
<p>退出arthas<br>quit —— 退出当前 Arthas 客户端，其他 Arthas 客户端不受影响<br>shutdown —— 关闭 Arthas 服务端，所有 Arthas 客户端全部退出 &amp; 重置所有增强过的类，就不用单独调用reset</p>
<h3 id="✅应用"><a href="#✅应用" class="headerlink" title="✅应用"></a>✅应用</h3><p>1、查看某方法耗时</p>
<p><code>trace cn.asae.e.contract.web.ContractController getContract</code></p>
<p>2、显示进程相关信息，仪表盘</p>
<p><code>dashboard</code></p>
<p>3、查看类里某个方法的返回值和入参</p>
<p>命令+类完全限定名+监测方法+表达式<br><code>watch cn.asae.e.contract.web.ContractSubjectController getContractSubjectLogs &quot;&#123;params,returnObj&#125;&quot;</code></p>
<p>4、时空隧道</p>
<p>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</p>
<p><code>tt -t cn.asae.e.contract.web.ContractSubjectController getContractSubjectLogs</code><br>-t 代表记录下每次方法执行情况</p>
<p>5、查看JVM已加载的类信息</p>
<p><code>sc -d cn.asae.e.contract.web.ContractSubjectController</code></p>
<p>-d 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。<br>如果一个类被多个ClassLoader所加载，则会出现多次</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiawen010/p/15513454.html">https://www.cnblogs.com/jiawen010/p/15513454.html</a></p>
<p>其他：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37650458/article/details/123561000">https://blog.csdn.net/weixin_37650458/article/details/123561000</a></p>
<h2 id="fullGC"><a href="#fullGC" class="headerlink" title="fullGC"></a>fullGC</h2><h3 id="✅什么是GC-amp-heap分区"><a href="#✅什么是GC-amp-heap分区" class="headerlink" title="✅什么是GC &amp; heap分区"></a>✅什么是GC &amp; heap分区</h3><p>Java垃圾回收机制，Java通过可达性分析一个对象的引用是否存在，当不存在的时候，将回收堆中的对象。回收无用内存空间</p>
<p>一般而言，GC主要是针对运行的数据区的。作为程序员要关注的区域主要有5块，分别是方法区(Method Area)，Java栈(Java stack)，本地方法栈(Native Method Stack)，堆(Heap)，程序计数器(Program Counter Register)。实际jvm在管理内存的时候，比这个分的更细致，只不过做应用程序开发，我们只需要关注这5块就可以了。</p>
<p>“堆”，也就是Heap了，它是Jvm管理的内存中最大的一块。程序的主要数据也都是存放在堆内存中的，也就是说程序所创建的对象基本上都在该区域进行内存分配，这一块区域被所有的线程所共享，通常出现线程安全问题的一般都是这个区域的数据出现的问题。通常我们所说的gc主要是针对java heap这块区域的。</p>
<p>Heap区在设计上是分代设计的，其划分为了Eden、Survivor 和 Tenured/Old ，其中Eden区、Survivor(存活)属于年轻代，Tenured/Old区属于老年代或者持久代。</p>
<p>一般我们将年轻代发生的GC称为Minor GC，对老年代进行GC称为Major GC。</p>
<p>而FullGC是对整个堆来说的，在最近几个版本的JDK里默认包括了对永生带即方法区的回收(JDK8中无永生带了)，出现Full GC的时候经常伴随至少一次的Minor GC,但非绝对的。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<hr>
<p>JVM的堆区对象分配的一般规则：</p>
<ol>
<li><p>对象优先在Eden区分配</p>
</li>
<li><p>大对象直接进入老年代(-XX:PretenureSizeThreshold=3145728 这个参数来定义多大的对象直接进入老年代)</p>
</li>
<li><p>长期存活的对象将进入老年代(在JDK8中测试，-XX:MaxTenuringThreshold=1的阀值设定根本没用)</p>
</li>
<li><p>动态对象年龄判定(虚拟机并不会永远地要求对象的年龄都必须达到MaxTenuringThreshold才能晋升老年代，如果Survivor空间中相同年龄的所有对象的大小总和大于Survivor的一半，年龄大于或等于该年龄的对象就可以直接进入老年代)</p>
</li>
<li><p>空间分配担保</p>
</li>
<li><p>只要老年代的连续空间大于(新生代所有对象的总大小或者历次晋升的平均大小)就会进行minor GC，否则会进行full GC。</p>
</li>
</ol>
<h3 id="✅FullGC的触发条件"><a href="#✅FullGC的触发条件" class="headerlink" title="✅FullGC的触发条件"></a>✅FullGC的触发条件</h3><p>FullGC是针对整个Heap区而言的，它将在以下几种情况被触发：</p>
<p>1、在程序中调用了System.gc()方法。此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过<code>-XX:+ DisableExplicitGC</code>来禁止RMI(Java远程方法调用)调用System.gc。</p>
<p>2、老年代空间不足。老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误【java.lang.OutOfMemoryError: Java heap space】，而为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<p>3、Permanet Generation空间满了。也就是以前所说的方法区，Permanet Generation中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出错误信息：java.lang.OutOfMemoryError: PermGen space 。为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
<p>4、通过Minor GC后进入老年代的平均大小大于老年代的可用内存。如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。分配很大的对象。所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但停顿时间不得不变长了，JVM设计者们还提供了另外一个参数 <code>-XX:CMSFullGCsBeforeCompaction</code>，这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。</p>
<h3 id="✅分代收集算法"><a href="#✅分代收集算法" class="headerlink" title="✅分代收集算法"></a>✅分代收集算法</h3><p>针对年轻代和老年代，JVM将使用不同的垃圾收集算法进行收集，达到高效的垃圾回收。</p>
<p>1、年轻代采用的是标记-复制算法，将需要回收的对象标记，将不需要的对象移动到Survivor空间，然后将标记对象回收，该算法可以实现对大多数会失效的对象进行回收，对少部分不需要回收的对象进行转移，保证eden区拥有连续的内存空间，而且复制的效率高。</p>
<p>因为在年轻代不需要回收的对象一般是很少的，每次垃圾收集时都有大批对象死去，只有少量存活，选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>2、老年代采用的是标记-整理算法，将需要回收的对象标记，将不需要的对象进行移动整理，使不需要回收的对象占用连续的内存空间，再清除回收对象，保证老年代拥有连续的内存空间，而且整理效率高。</p>
<p>因为在老年代需要回收的对象一般是很少的，其存活率较高、没有额外空间对它进行分配担保。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_35291771/article/details/114075710">https://blog.csdn.net/weixin_35291771/article/details/114075710</a></p>
<h3 id="✅什么是fullgc"><a href="#✅什么是fullgc" class="headerlink" title="✅什么是fullgc"></a>✅什么是fullgc</h3><p>一些概念：</p>
<p>GC<br>GC 全称为garbage collection,中文含义为垃圾回收，在jvm中的含义为回收无用内存空间</p>
<p>Young space<br>中文名为年轻代或者新生代，为JVM 堆的一部分，由分代GC概念划分而来，保存生命周期较短的对象</p>
<p>Tenured space<br>中文名为老年代或年老代，为JVM 堆的一部分，由分代GC概念划分而来，保存生命周期较长的对象</p>
<p>Minor GC<br>minor gc指的是发生在年轻代或者说新生代（Young space）中的gc，也有人称其为young gc或者ygc,在下文中我们统一使用minor gc表示</p>
<p>Major GC<br>major gc指的是发生在老年代（Tenured space）中的gc，也有人称为old gc,o gc,cms gc等，在下文我们统一使用major gc表示</p>
<p>stop the world<br>指的是用户线程在运行至安全点（safe point）或安全区域（safe region）之后，就自行挂起，进入暂停状态，对外的表现看起来就像是全世界都停止运转了一样,而不论何种gc算法，不论是minor gc还是major gc都会stop the world，区别只在于stop the world的时间长短。</p>
<p><strong>什么是Full GC</strong></p>
<p>先说一下结论，Full GC这个概念是没有官方定义的，而且含义还特别混乱，在不同地方表达的含义是不同的，需要就不同的场景分别进行讨论。</p>
<p>大众认知上：<br>在通常意义上人们口中说的Full GC为一次特殊GC行为的描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace等，这个是最常见的一种认知，很多人也就了解到这个程度，因此在遇到一些特殊场景的时候就会发现实际情况和自己的认知会发生冲突</p>
<p>从GC日志上：<br>在gc.log中会发现在部分gc日志头中也有Full GC这样的字眼，这里表示的含义是在这次GC的全过程中，都是Stop The world的状态，也就是说在这次GC的全过程中所有用户线程都是处于暂停的状态</p>
<p>阿里老哥总结的：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kep159/article/details/103088438">https://blog.csdn.net/kep159/article/details/103088438</a></p>
<h3 id="✅jstat查看GC"><a href="#✅jstat查看GC" class="headerlink" title="✅jstat查看GC"></a>✅jstat查看GC</h3><p><strong>使用jstat 查出来的FGC 次数和时间，实际上指的是老年代的收集器发生Stop the world 的次数和持续时间</strong></p>
<p>1、查询GC使用情况：<br><code>jstat -gcutil 23484 1000 5</code></p>
<p>1000是间隔时间，5是总共打印5次，可缺省。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">68.75   0.00  62.73   0.17  96.39  90.54      2    0.010     0    0.000    0.010</span><br><span class="line"></span><br><span class="line">S0: 新生代中Survivor space 0区已使用空间的百分比</span><br><span class="line">S1: 新生代中Survivor space 1区已使用空间的百分比</span><br><span class="line">E: 新生代已使用空间的百分比</span><br><span class="line">O: 老年代已使用空间的百分比</span><br><span class="line">M：元数据区使用比例</span><br><span class="line">CCS：压缩使用比例</span><br><span class="line">YGC: 从应用程序启动到当前，发生Yang GC 的次数</span><br><span class="line">YGCT: 从应用程序启动到当前，Yang GC所用的时间【单位秒】</span><br><span class="line">FGC: 从应用程序启动到当前，发生Full GC的次数</span><br><span class="line">FGCT: 从应用程序启动到当前，Full GC所用的时间</span><br><span class="line">GCT: 从应用程序启动到当前，用于垃圾回收的总时间【单位秒】</span><br></pre></td></tr></table></figure>

<p>2、垃圾总体回收统计<br><code>jstat -gc 91185 1000 5</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 68.75   0.00  62.73   0.17  96.39  90.54      2    0.010     0    0.000    0.010</span><br><span class="line"></span><br><span class="line">S0C：第一个幸存区的大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">S0U：第一个幸存区的使用大小</span><br><span class="line">S1U：第二个幸存区的使用大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">EU：伊甸园区的使用大小</span><br><span class="line">OC：老年代大小</span><br><span class="line">OU：老年代使用大小</span><br><span class="line">MC：方法区大小</span><br><span class="line">MU：方法区使用大小</span><br><span class="line">CCSC:压缩类空间大小</span><br><span class="line">CCSU:压缩类空间使用大小</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">YGCT：年轻代垃圾回收消耗时间</span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure>

<p>3、新生代垃圾回收统计<br><code>jstat -gcnew 91185 1000 5</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line">5120.0 5120.0 3520.2    0.0  7  15 5120.0  33280.0  20877.8      2    0.010</span><br><span class="line"></span><br><span class="line">S0C：第一个幸存区大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">S0U：第一个幸存区的使用大小</span><br><span class="line">S1U：第二个幸存区的使用大小</span><br><span class="line">TT:对象在新生代存活的次数</span><br><span class="line">MTT:对象在新生代存活的最大次数</span><br><span class="line">DSS:期望的幸存区大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">EU：伊甸园区的使用大小</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">YGCT：年轻代垃圾回收消耗时间</span><br></pre></td></tr></table></figure>

<p>4、堆内存统计<br><code>jstat -gccapacity 18528 1000 5 //整体统计</code><br><code>jstat -gcnewcapacity 18528 1000 5 //新生代统计</code><br><code>jstat -gcoldcapacity 18528 1000 5 //老年代统计</code></p>
<h2 id="java堆栈"><a href="#java堆栈" class="headerlink" title="java堆栈"></a>java堆栈</h2><h3 id="✅java内存空间"><a href="#✅java内存空间" class="headerlink" title="✅java内存空间"></a>✅java内存空间</h3><p>JAVA在程序运行时，在内存中划分5片空间进行数据的存储。分别是：1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。<br>堆和栈都是Java用来在RAM中存放数据的地方</p>
<p>1、堆</p>
<p>可以把堆理解为一家餐厅，里面有200张桌子，也就是最多能同时容纳200桌客人就餐，来一批客人就为他们安排一些桌子，如果某天来的客人特别多，超过200桌了，那就不能再接待超出的客人了。</p>
<p>当然，进来吃饭的客人不可能是同时的，有的早，有的晚，先吃好的客人，老板会安排给他们结账走人，然后空出来的桌子又能接待新的客人。</p>
<p>这里，堆就是餐厅，最大容量200桌就是堆内存的大小，老板就相当于GC(垃圾回收)，给客人安排桌子就相当于java创建对象的时候分配堆内存，结账就相当于GC回收对象占用的空间。</p>
<p>2、栈</p>
<p>接着把栈比作一口废井，这口井多年不用已经没水了，主人现在把它作为贮存自酿酒的地方，存酒的时候就用绳子勾着酒坛子慢慢放下去，后面再存就一坛一坛堆着放上去，取酒的时候就先取最上面的坛子。</p>
<h3 id="✅什么时候存到堆Heap里"><a href="#✅什么时候存到堆Heap里" class="headerlink" title="✅什么时候存到堆Heap里"></a>✅什么时候存到堆Heap里</h3><p>存放：存放由new创建的对象和数组。</p>
<p>在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，会在栈中定义一个引用变量，这个变量的取值等于数组或者对象在堆内存中的首地址，引用变量相当于为数组或者对象起的一个别名，或者代号。</p>
<p>数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!</p>
<p>堆内存的特点是什么？<br>第一点：堆其实可以类似的看做是管道，或者说是平时去排队买票的情况差不多，所以堆内存的特点就是：先进先出，后进后出，也就是你先排队好，你先买票。<br>第二点：堆可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，但缺点是，由于要在运行时动态分配内存，存取速度较慢。<br>new对象在堆中如何分配？<br>由Java虚拟机的自动垃圾回收器来管理。</p>
<h3 id="✅什么时候存到栈Stack里"><a href="#✅什么时候存到栈Stack里" class="headerlink" title="✅什么时候存到栈Stack里"></a>✅什么时候存到栈Stack里</h3><p>存放：在函数中定义的一些基本类型的变量(8种，int, short, long, byte, float, double, boolean, char，不包含String)和对象的引用变量、main方法、方法函数</p>
<p>当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。</p>
<p>栈内存的特点<br>第一点：栈内存就好像一个矿泉水瓶，往里面放入东西，那么先放入的沉入底部，所以它的特点是：先进后出，后进先出<br>第二点：存取速度比堆要快，仅次于寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p>
<p>栈中主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和对象句柄。<br>栈有一个很重要的特殊性，就是存在栈中的数据可以共享。<br>栈内存分配机制<br>栈内存可以称为一级缓存，由垃圾回收器自动回收<br>例子：<br>int a = 3;<br>int b = 3;</p>
<h3 id="✅堆栈的区别"><a href="#✅堆栈的区别" class="headerlink" title="✅堆栈的区别"></a>✅堆栈的区别</h3><p>JVM是基于堆栈的虚拟机，JVM为新创建的线程都分配一个堆栈，也就是说，对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作：以帧为单位的压栈和出栈操作。</p>
<p>差异：<br>1). 堆内存用来存放由new创建的对象和数组<br>2). 栈内存用来存放方法或者局部变量等<br>3). 堆是先进先出，后进后出<br>4). 栈是先进后出，后进先出<br>5). 共享性的不同：栈内存是线程私有的，<strong>堆内存是所有线程共有的</strong><br>6). 生存空间不同：栈中数据的生存空间一般在当前scopes内(就是由{…}括起来的区域).</p>
<p>栈：</p>
<p>函数中定义的基本类型变量，对象的引用变量都在函数的栈内存中分配。<br>栈内存特点，数数据一执行完毕，变量会立即释放，节约内存空间。<br>栈内存中的数据，没有默认初始化值，需要手动设置。</p>
<p>堆：</p>
<p>堆内存用来存放new创建的对象和数组。<br>堆内存中所有的实体都有内存地址值。<br>堆内存中的实体是用来封装数据的，这些数据都有默认初始化值。<br>堆内存中的实体不再被指向时，JVM启动垃圾回收机制，自动清除，这也是JAVA优于C++的表现之一（C++中需要程序员手动清除）</p>
<h3 id="✅String-str-“abc”的内部工作"><a href="#✅String-str-“abc”的内部工作" class="headerlink" title="✅String str = “abc”的内部工作"></a>✅String str = “abc”的内部工作</h3><p>(1)先定义一个名为str的对String类的对象引用变量：String str；</p>
<p>(2)在栈中查找有没有存放值为”abc”的地址，如果没有，则开辟一个存放字面值为”abc”的地址，接着在堆中创建一个新的String类的对象o，并将o的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为”abc”的地址，则查找对象o，并返回o的地址。</p>
<p>(3)将str指向对象o的地址。</p>
<p>值得注意的是，一般String类中字符串值都是直接存值的。但像String str = “abc”；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = “abc”;  </span><br><span class="line">String str2 = “abc”;  </span><br><span class="line">System.out.println(str1==str2); //true</span><br></pre></td></tr></table></figure>

<p>str1.equals(str2)；的方式是将比较两个字符串的值是否相等。==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。<br>结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。实现堆中数据的共享。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = “abc”;  </span><br><span class="line">String str2 = “abc”;  //没创建新对象，创建了一个新引用变量</span><br><span class="line">str1 = “bcd”;   //改变值，只能创建一个新对象，引用变量指向新的对象</span><br><span class="line">System.out.println(str1 + “,” + str2); //bcd, abc  </span><br><span class="line">System.out.println(str1==str2); //false</span><br></pre></td></tr></table></figure>

<p>赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为”bcd”时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。</p>
<p>💡原因：事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = new String(“abc”);</span><br><span class="line">String str2 = “abc”;</span><br><span class="line">System.out.println(str1==str2); //false</span><br></pre></td></tr></table></figure>

<p>💡原因：只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。</p>
<p><strong>意思是：String str = “abc” 的创建对象方式，会在栈中保存“abc”。如果多次这样创建一个值的String对象，会先去栈里看有没有，如果有，堆里就不新建对象了，栈里新建一个引用变量指向那个对象，如果没有就新建，但是new方式不会看，都是新建。</strong></p>
<p>结论：</p>
<p>(1)我们在使用诸如String str = “abc”; 的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为”abc”的String对象。</p>
<p>(2)使用String str = “abc”; 的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(“abc”); 的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。</p>
<p>(3)当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==。</p>
<p>(4)由于String类的不可改变immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。</p>
<p>参考：<br>程序中堆栈空间加载过程：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/229958.htm">https://www.jb51.net/article/229958.htm</a><br>堆栈区别、String创建过程：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/529280783">https://zhuanlan.zhihu.com/p/529280783</a></p>
<h3 id="✅堆内存共享性问题"><a href="#✅堆内存共享性问题" class="headerlink" title="✅堆内存共享性问题"></a>✅堆内存共享性问题</h3><p>问题来源：既然各个java进程共享堆内存，那么看fullgc的情况跟哪个进程线程有什么关系呢？</p>
<p>没错，堆是全局共享的，但是会存在一些问题</p>
<p>就是多个线程在堆上同时申请空间，如果在并发的场景中，两个线程先后把对象引用指向了同一个堆的内存区域，那可能就会出现问题；为了解决这个问题呢，就得进行同步控制，说到同步控制，就会影响到效率。</p>
<p>为了解决这个并发问题，对象的内存分配过程就必须进行同步控制。<br>HotSpot虚拟机（HotSpot虚拟机是目前最流行的虚拟机）的方案：<br>每个线程在Java堆中预先分配一小块内存，然后在给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。<br>这种方案被称之为TLAB分配，即Thread Local Allocation Buffer。这部分Buffer是从堆中划分出来的，但是是本地线程独享的。</p>
<p><strong>TLAB</strong></p>
<p>TLAB是虚拟机在堆内存的eden划分出来的一块专用空间，是<strong>线程专属</strong>的。在虚拟机的TLAB功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，<strong>只给当前线程使用</strong>，这样<strong>每个线程都单独拥有一个空间</strong>，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。</p>
<p><strong>所以说，因为有了TLAB技术，堆内存并不是完完全全的线程共享，其eden区域中还是有一部分空间是分配给线程独享的。</strong></p>
<p>⚠️TLAB是线程独享的，但是只是在“分配”这个动作上是线程独享的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。也就是说，虽然每个线程在初始化时都会去堆内存中申请一块TLAB，并不是说这个TLAB区域的内存其他线程就完全无法访问了，其他线程的读取还是可以的，只不过无法在这个区域中分配内存而已。并且，在TLAB分配之后，并不影响对象的移动和回收，也就是说，虽然对象刚开始可能通过TLAB分配内存，存放在Eden区，但是还是会被垃圾回收或者被移到Survivor Space、Old Gen等。</p>
<p>⚠️TLAB带来的问题：<br>TLAB是在eden区分配的，因为eden区域本身就不太大，而且TLAB空间的内存也非常小，默认情况下仅占有整个Eden空间的1%。所以，必然存在一些大对象是无法在TLAB直接分配。<br>遇到TLAB中无法分配的大对象，对象还是可能在eden区或者老年代等进行分配的，但是这种分配就需要进行同步控制，这也是为什么我们经常说：小的对象比大的对象分配起来更加高效。<br>————————————————<br>为了解决这两个方案存在的问题，虚拟机定义了一个refill_waste的值，这个值可以翻译为“最大浪费空间”。</p>
<p>当请求分配的内存大于refill_waste的时候，会选择在堆内存中分配。若小于refill_waste值，则会废弃当前TLAB，重新创建TLAB进行对象内存分配。</p>
<p>总结：<br>为了保证对象的内存分配过程中的线程安全性，HotSpot虚拟机提供了一种叫做TLAB(Thread Local Allocation Buffer)的技术。</p>
<p>在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，当需要分配内存时，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。</p>
<p>所以，“堆是线程共享的内存区域”这句话并不完全正确，因为TLAB是堆内存的一部分，他在读取上确实是线程共享的，但是在内存分配上，是线程独享的。</p>
<p>TLAB的空间其实并不大，所以大对象还是可能需要在堆内存中直接分配。那么，对象的内存分配步骤就是先尝试TLAB分配，空间不足之后，再判断是否应该直接进入老年代，然后再确定是再eden分配还是在老年代分配。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jiey0407/article/details/125190629">https://blog.csdn.net/jiey0407/article/details/125190629</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/25/myblog/%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/25/myblog/%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/" class="post-title-link" itemprop="url">《java并发编程的艺术》笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-25 23:05:34" itemprop="dateCreated datePublished" datetime="2022-08-25T23:05:34+08:00">2022-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-01 09:18:50" itemprop="dateModified" datetime="2022-11-01T09:18:50+08:00">2022-11-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一章-并发编程的挑战"><a href="#第一章-并发编程的挑战" class="headerlink" title="第一章 并发编程的挑战"></a>第一章 并发编程的挑战</h2><h3 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1.上下文切换"></a>1.上下文切换</h3><p>CPU通过给每个线程分配CPU时间片来实现多线程，时间片一般几十毫秒。</p>
<p>上下文切换是指切换前需要保存上一个任务的状态。</p>
<p>由于线程有创建和上下文切换的开销，并发执行的速度不一定比串行快。</p>
<p>上下文每1s切换1000多次。</p>
<p>如何减少上下文切换？<br>1、无锁并发编程，多线程竞争锁时会引起上下文切换，可以将数据id根据hash算法取模分段，不同线程处理不同段的数据。<br>2、CAS算法，Atomic包下，不需要加锁。<br>3、避免创建不需要的线程。每次从waiting到runnable都需要进行一次上下文切换。<br>4、协程：在单线程中实现多任务调度，维持多个任务间的切换。</p>
<h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2.死锁"></a>2.死锁</h3><p>线程a和线程b互相等待对方释放锁。</p>
<p>一旦出现死锁，业务可感知，使用jstack命令dump线程。</p>
<p>避免死锁的几个方法：<br>1、避免一个线程同时获取多个锁。<br>2、避免一个线程在锁内同时占用多个资源。<br>3、尝试使用定时锁，使用lock.tryLock(timeout)来替代内部锁机制<br>4、对于数据库锁，加锁和解锁必须在一个数据库连接中，否则会出现解锁失败。</p>
<h3 id="3-资源限制"><a href="#3-资源限制" class="headerlink" title="3.资源限制"></a>3.资源限制</h3><p>并发编程时的资源限制：<br>硬件限制：带宽的上传/下载速度（2Mb/s）、硬盘读写速度、CPU处理速度<br>软件限制：数据库连接数、socket连接数<br>例如：线程数比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。</p>
<p>使用等待超时模式模拟数据库连接池：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52043808/article/details/125759727">https://blog.csdn.net/m0_52043808/article/details/125759727</a></p>
<p>受到资源限制时，并发执行可能会编程串行执行，但是增加了上下文切换和资源调度的时间，比串行还慢。</p>
<p>如何解决？<br>1、对于硬件约束，考虑使用集群并行执行程序，不同机器处理不同数据。<br>2、对于软件限制，考虑使用资源池将资源复用。</p>
<h3 id="4-jstack命令dump线程"><a href="#4-jstack命令dump线程" class="headerlink" title="4.jstack命令dump线程"></a>4.jstack命令dump线程</h3><h4 id="✅什么是jstack？"><a href="#✅什么是jstack？" class="headerlink" title="✅什么是jstack？"></a>✅什么是jstack？</h4><p>如果有一天，你的Java程序长时间停顿，也许是它病了，需要用jstack拍个片子分析分析，才能诊断具体什么病症，是死锁综合征，还是死循环等其他病症。</p>
<p>jstack是JVM自带的Java堆栈跟踪工具，它用于打印出给定的java进程ID、core file、远程调试服务的Java堆栈信息.</p>
<pre><code>1、jstack命令用于生成虚拟机当前时刻的线程快照。
2、线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因， 如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。
3、线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。
4、如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。
5、另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。
</code></pre>
<h4 id="✅怎么用："><a href="#✅怎么用：" class="headerlink" title="✅怎么用："></a>✅怎么用：</h4><p>首先使用 jps命令查看需要打印线程栈的java进程号pid。<br>然后 jstack pid。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-F	当正常输出的请求不被响应时，强制输出线程堆栈</span><br><span class="line">-m	如果调用到本地方法的话，可以显示C/C++的堆栈</span><br><span class="line">-l	除堆栈外，显示关于锁的附加信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</span><br></pre></td></tr></table></figure>

<p>输出解读：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;jstack 9348</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.281-b09 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x0000018da5881000 nid=0x34c8 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">[通过 jstack查看线程栈信息时通常看到的最多的是RUNNABLE,BLOCKED,WAITING和TIMED_WAITING这几种状态，</span><br><span class="line">我们一般看不到线程的NEW和TERMINATED状态，是因为在代码的运行过程中这两种状态只占很小一部分，</span><br><span class="line">我们捕捉到这两种状态前这两种状态已经一闪而过了。</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x0000000002e7e800 nid=0x2a1c in Object.wait() [0x0000000002f7f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line"></span><br><span class="line">其中开头是线程名称，后面的为线程信息：</span><br><span class="line"> #1 表示当前线程ID，从 main线程开始，JVM 根据线程创建的顺序为线程编号.</span><br><span class="line">prio 是priority优先级的缩写，表名了当前线程的优先级，取值范围为[1-10]，默认为 5。在虚拟机进行线程调度的时候会参考该优先级为线程分配计算资源，这个数值越低越有优先获取到计算资源，一般不设置直接使用默认的优先级。</span><br><span class="line">os_prio为线程对应系统的优先级。</span><br><span class="line">nid 本地线程编号NativeID的缩写,对应JVM 虚拟机中线程映射在操作系统中的线程编号。我们可以使用 top 查看进程对应的线程情况进行相关映射。</span><br></pre></td></tr></table></figure>

<p>nid表示的是线程对应的系统本地的线程编号.</p>
<h4 id="✅案例：jstack-分析死锁问题"><a href="#✅案例：jstack-分析死锁问题" class="headerlink" title="✅案例：jstack 分析死锁问题"></a>✅案例：jstack 分析死锁问题</h4><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法进行下去</p>
<p>死锁demo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Java 死锁demo</span><br><span class="line"> */</span><br><span class="line">public class DeathLockTest &#123;</span><br><span class="line">    private static Lock lock1 = new ReentrantLock();</span><br><span class="line">    private static Lock lock2 = new ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    public static void deathLock() &#123;</span><br><span class="line">        Thread t1 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock1.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock1&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    lock2.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock2&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock2.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock2&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    lock1.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock1&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //设置线程名字，方便分析堆栈信息</span><br><span class="line">        t1.setName(&quot;mythread-jay&quot;);</span><br><span class="line">        t2.setName(&quot;mythread-tianluo&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        deathLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排查步骤：<br>1、在终端中输入jsp查看当前运行的java程序<br>2、使用 jstack -l pid 查看线程堆栈信息<br>3、分析堆栈信息</p>
<p>会出现：Found one Java-level deadlock: 信息。</p>
<p>当一个线程占有一个锁的时候，线程堆栈会打印一个－locked&lt;0x22bffb60&gt;<br>当一个线程正在等在其他线程释放该锁，线程堆栈会打印一个－waiting to lock&lt;0x22bffb60&gt;<br>当一个线程占有一个锁，但又执行在该锁的wait上，线程堆栈中首先打印blocked,然后打印－waiting on &lt;0x22c03c60&gt;</p>
<h4 id="✅案例：分析CPU过高"><a href="#✅案例：分析CPU过高" class="headerlink" title="✅案例：分析CPU过高"></a>✅案例：分析CPU过高</h4><p>导致CPU过高的demo程序，一个死循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 有个导致CPU过高程序的demo，死循环</span><br><span class="line"> */</span><br><span class="line">public class JstackCase &#123;</span><br><span class="line"> </span><br><span class="line">     private static ExecutorService executorService = Executors.newFixedThreadPool(5);</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        Task task1 = new Task();</span><br><span class="line">        Task task2 = new Task();</span><br><span class="line">        executorService.execute(task1);</span><br><span class="line">        executorService.execute(task2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Object lock = new Object();</span><br><span class="line"> </span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line"> </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                long sum = 0L;</span><br><span class="line">                while (true)&#123;</span><br><span class="line">                    sum += 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排查步骤：<br>1、jps 命令获取目标 java 进程号<br>2、在服务器上，我们可以通过top命令查看各个进程的cpu使用情况，它默认是按cpu使用率由高到低排序的，拿到pid<br>top -Hp pid 【奇怪，不能用，只能top -p pid】<br>通过top -Hp pid可以查看该进程下，各个线程的cpu使用情况<br>3、把线程pid换成nid<br>将该线程好打印成 16进制的<br><code>printf &quot;%x\n&quot; 19343</code><br>4、jstack -l [PID] &gt;/tmp/log.txt<br>一般在生成环境，我们可以把这些堆栈信息打到一个文件里，再回头仔细分析<br>jstack 进程pid | grep -10 线程<br>nid<br>可以看到目标线程的线程堆栈信息了</p>
<p>转自：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44588186/article/details/124680586">https://blog.csdn.net/weixin_44588186/article/details/124680586</a><br>【jstack案例】<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19922839/article/details/115379649">https://blog.csdn.net/qq_19922839/article/details/115379649</a><br>【里面还有pstree 查看进程树，jvm 监控工具Liberica Mission Control】</p>
<h4 id="✅dump线程"><a href="#✅dump线程" class="headerlink" title="✅dump线程"></a>✅dump线程</h4><p>线程dump的目的是转存线程快照。快照中是当前JVM所有线程正在执行方法的堆栈信息。</p>
<p>通过线程dump来分析定位线程出现长时间停顿的原因，如线程死锁、线程死循环、线程请求外部资源长时间等待等。</p>
<p>可以用arthas获取dump文件，dump文件很大，几个G，可以用IDEA打开，或者用其他分析工具。arthas也可以输出所有线程。</p>
<p>线程dump：<a target="_blank" rel="noopener" href="https://blog.csdn.net/HaierFiller/article/details/117367228">https://blog.csdn.net/HaierFiller/article/details/117367228</a></p>
<h2 id="第二章-java并发机制的底层实现原理"><a href="#第二章-java并发机制的底层实现原理" class="headerlink" title="第二章 java并发机制的底层实现原理"></a>第二章 java并发机制的底层实现原理</h2><p>.java代码 -编译为- .class字节码文件 -加载到- jvm -执行字节码- 转化为汇编语言在cpu执行。</p>
<p>java的并发机制依赖于jvm的实现和cpu的执行。</p>
<h3 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1.volatile"></a>1.volatile</h3><h4 id="✅volatile底层"><a href="#✅volatile底层" class="headerlink" title="✅volatile底层"></a>✅volatile底层</h4><p>volatile是轻量级的synchronized，在多处理器开发中保证了共享变量的可见性（所有线程看到的这个变量的值是一致的）。比synchronized执行成本低，不会引起线程上下文的切换和调度。</p>
<p>首先，了解一下cpu处理逻辑：<br>为了提高处理速度，cpu不直接与内存进行通信，而是先将内存的数据读到自己的内存缓存（以缓存行为单位）中。</p>
<p>处理器 - 高速缓存 - 缓存   \<br>处理器 - 高速缓存 - 一致性  - 总线 - 主内存<br>处理器 - 高速缓存 - 协议   /</p>
<p>存储大体上分两种, 主存是堆内存, 工作内存是栈内存, 属于线程私有。<br>对字段操作都需要先从主存读取数据加载进工作内存, 工作内存对这个副本数据进行操作<br>volatile修饰的变量, 等于在堆中这个变量的内存区域上打了个标, 所有操作都必须从主存中读取, 由MESI&lt;缓存一致性协议&gt;实现</p>
<p>对volatile声明的变量进行写操作会发生什么：<br>1、jvm向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回系统内存。lock指令执行期间会锁住总线/缓存，保证不会同时多个cpu修改共享变量。<br>2、多处理下，实现缓存一致性协议，每个处理器使用嗅探技术，保证它的内部缓存和系统内存的数据在总线上保持一致（发现自己缓存行对应的内存地址被修改，首先将缓存行置为无效，重新从系统内存中将数据读到缓存）。</p>
<p>volitale的使用优化：<br>jdk7中的LinkedTransferQueue，使用volitale时，采用追加字节的方式优化出队入队效率。</p>
<p>为什么？<br>因为处理器的高速缓存行是64个字节宽，不支持部分填充缓存行。这样头节点和尾节点在一个高速缓存行中，多处理器下，一个处理器修改头节点，会将整个缓存行锁定，在缓存一致性的作用下，导致其他处理器不能访问自己高速缓存行中的尾节点。<br>节点追加到64字节，可以避免头尾节点加载到同一个缓存行中，修改时不会相互锁定。</p>
<p>注意：缓存行非64字节的别这么做，共享变量不会被频繁写的话别这么做。</p>
<h4 id="✅volatile使用"><a href="#✅volatile使用" class="headerlink" title="✅volatile使用"></a>✅volatile使用</h4><p>⚠️注意：volatile能保证可见性，但不能保证原子性。<br>在 volatile 字段上进行了非原子类操作，会idea提示：<code>Non-atomic operations on volatile fields</code><br>比如：count++ 就是非原子操作，分三步：<br>1、从主存读取 i<br>2、在寄存器中进行加一运算, 自增操作, 此时已经修改工作内存中的值<br>3、将计算后的值赋给 i, 也就是刷回主存</p>
<p><strong>可见性</strong></p>
<p>volatile和static的可见性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//private boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">//private static boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">private volatile  boolean tag = false; //会运行tag is true,exit</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void visibleTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //当tag标志变为true时结束循环并打印退出信息</span><br><span class="line">            while(!tag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;tag is true,exit......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            tag = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>volatile的可见性：是多个线程间的共享变量，当一个线程修改时，其他的线程能够知道这个修改。<br>static不能知道变化，它的可见性：可访问。</p>
<p>volatile修饰的共享变量对其他线程具有可见性，可以保证线程安全。<br>static修饰的变量为全局变量, 对所有线程可访问, 可用于线程间的通信，但是不能保证线程安全。</p>
<p>static线程安全测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int count = 0;</span><br><span class="line"></span><br><span class="line">    private static void count() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            es.execute(VolatileDemo::count);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (es.isTerminated()) &#123;</span><br><span class="line">                System.out.println(&quot;end...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long end = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;count:&quot; + count);</span><br><span class="line">        System.out.println(&quot;cost:&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动一个缓存线程池进行对static字段进行自增，结果不是100.<br>t1线程与 t2线程读取 count 值, 然后同步修改为 1, 再写回内存, 写了两遍 1。</p>
<p>因此，static修饰的变量确实可以在线程间通信, 对各个线程都是可见的。但是不能保证线程安全。</p>
<p>那么用volatile，相当于每次修改volatile变量都需要重新读取数据。<br>但是结果依然不是100.</p>
<p>volatile的可见性测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//private boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">//private static boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">private volatile  boolean tag = false; //会运行tag is true,exit</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void visibleTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //当tag标志变为true时结束循环并打印退出信息</span><br><span class="line">            while(!tag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;tag is true,exit......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            tag = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非原子性</strong></p>
<p>t1线程与t2线程同时从主存中读取了count = 1,自增, 这时候两个线程的寄存器中存的计算后的值都是 2, 然后要写回count的主存, 假设这时 t1成功了, 那么主存中的count就是2, 然后根据MESI协议, t2需要重新从主存读取count值, 得到的是2, 再将寄存器中的计算结果2 赋值给count, 刷回主存, 此时主存中的count值还是2, 而不是期望中的3。</p>
<p>怎么解决？<br>synchronized关键字，或者 atomic原子类 + volatile</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private volatile static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">private static void count() &#123;</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-12 20:14</span><br><span class="line"> **/</span><br><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    private volatile AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testVolatile() throws InterruptedException &#123;</span><br><span class="line">        Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                    System.out.println(Thread.currentThread() + &quot; count:&quot; + count);</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                    System.out.println(Thread.currentThread() + &quot; count:&quot; + count);</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(&quot;count:&quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、static修饰的变量是静态变量, 表示不管对象有多少实例, 只有这一个变量, 强调变量的唯一性<br>2、volatile是基于JMM与MESI提出的一种内存一致性解决方案, 强调的是对共享变量的修改是可见的, 变量值是唯一的<br>3、volatile 可以保证对其所修饰的共享变量的原子性操作是线程安全的</p>
<p>转自：<br>volatile的可见性和非原子性：<a target="_blank" rel="noopener" href="https://www.codenong.com/js5a773b9fb9cb/">https://www.codenong.com/js5a773b9fb9cb/</a></p>
<h3 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2.synchronized"></a>2.synchronized</h3><p>synchronized之前被称为重量级锁，但是java se 1.6 对synchronized进行优化：减少获取锁和释放锁带来的性能消耗而引入偏向锁、轻量级锁。</p>
<h4 id="✅synchronized锁三种形式"><a href="#✅synchronized锁三种形式" class="headerlink" title="✅synchronized锁三种形式"></a>✅synchronized锁三种形式</h4><p>1.对于普通同步⽅法：锁的是当前实例对象，通常指this，所有的普通同步⽅法⽤的都是同⼀把锁，即实例对象本身。</p>
<p>2.对于静态同步⽅法：锁的是当前类的Class对象。</p>
<p>3.对于同步⽅法块：锁的是synchronized 括号内的对象。</p>
<p>⚠️几个锁的区别：<br>1.静态方法同步和静态代码块同步：所有的静态同步⽅法⽤的也是同⼀把锁——类对象本身，⼀旦⼀个静态同步⽅法获取锁后，其他的静态同步⽅法都必须等待该⽅法释放锁后才能获取锁。（和实例没关系）</p>
<p>2.静态同步和普通同步：具体实例对象this和唯⼀模板Class，这两把锁是两个不同的对象，所以静态同步⽅法与普通同步⽅法之间是不会有竞态条件的</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-17 14:11</span><br><span class="line"> **/</span><br><span class="line">//资源类</span><br><span class="line">class Phone&#123;</span><br><span class="line">    //1.静态方法（加锁）</span><br><span class="line">    public static synchronized void sendEmail() &#123;</span><br><span class="line">        //暂停几秒钟线程</span><br><span class="line">        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------sendEmail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //2.普通方法（加锁）</span><br><span class="line">    public synchronized void sendSMS() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------sendSMS&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 普通方法不加锁</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主方法</span><br><span class="line">public class SynchronizedDemo&#123;</span><br><span class="line">    //一切程序的入口，主线程</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Phone phone = new Phone();//资源类1</span><br><span class="line">        Phone phone2 = new Phone();//资源类2</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //phone.sendSMS(); //1、2</span><br><span class="line">                //phone.hello();</span><br><span class="line">                phone.sendEmail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //phone.sendSMS(); //1、2</span><br><span class="line">                //phone.hello();</span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">        try &#123; TimeUnit.MILLISECONDS.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅synchronized锁的实现原理"><a href="#✅synchronized锁的实现原理" class="headerlink" title="✅synchronized锁的实现原理"></a>✅synchronized锁的实现原理</h4><p>反编译命令：<code>javap -v -p *.class &gt; 类.txt </code>（将进⾏输出到txt中）</p>
<p>synchronized在jvm中的实现原理：jvm基于进入和退出Monitor对象来实现方法同步和代码块同步，monitor是一个对象的监视器。</p>
<p><strong>同步代码块：</strong></p>
<p>同步代码块是通过monitorenter和monitorexit指令实现的。</p>
<p>monitorenter：在编译后插入到同步代码块的开始位置，会尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁。</p>
<p>monitorexit：代表执行完synchronized代码块之后，要从对象监视器中退出，也就是释放锁。</p>
<p><strong>同步普通⽅法：</strong></p>
<p>1.同步普通⽅法反编译后的结构：可以看到在synchronized修饰实例方法中，不会再有monitorenter和monitorexit指令，而是在这个方法上多了一个ACC_SYNCHRONIZED的flag。</p>
<p>2.调用普通方法的流程：当程序在运行时，调用method()方法时，会检查该方法是否有ACC_SYNCHRONIZED访问标识，如果有，则表明该方法是同步方法，这时候该线程会先尝试去获取该方法对应的监视器（monitor）对象，如果获取成功，则继续执行该method()方法。</p>
<p>3.在执行期间，任何其他线程都不能再获取该方法监视器的使用权，直到该方法正常退出或者抛出异常，才会释放，其他线程可以重新获得该监视器。</p>
<p><strong>同步静态方法：</strong></p>
<p>synchronized修饰静态方法和实例方法没有区别，都是增加一个ACC_SYNCHRONIZED的flag，静态方法只是比实例方法多一个ACC_STATIC标识代表这个方法是静态的。</p>
<p><strong>阿里开发手册说明：</strong></p>
<p>⾼并发时，同步调⽤应该去考量锁的性能损耗。<br>1.能⽤⽆锁数据结构，就不要⽤有锁；<br>2.能锁区块，就不要锁整个⽅法体；<br>3.能⽤对象锁，就不要⽤类锁；</p>
<p>参考：<br>synchronized三种加锁方式：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38963649/article/details/126139304">https://blog.csdn.net/weixin_38963649/article/details/126139304</a></p>
<h4 id="✅java对象头"><a href="#✅java对象头" class="headerlink" title="✅java对象头"></a>✅java对象头</h4><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>HotSpot虚拟机的对象头包括三部分信息：<br>1、mark word 2、元类指针 3、数组长度<br>普通对象头有两个区域（1，2）、数组对象头有三个区域（1,2,3）</p>
<p><strong>Mark Word</strong></p>
<p>这部分主要存储对象自身的运行数据，如Hashcode、gc分代年龄、对象锁，锁状态标志，偏向锁（线程）ID，偏向时间等等。mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位。</p>
<p>Java对象头一般占有2个机器码（64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</p>
<p><strong>指向类的指针</strong></p>
<p>该指针在32位JVM的长度是32Bit，64是64bit<br>它主要指向类的数据，也就是指向方法区中的位置。</p>
<p><strong>数组长度</strong></p>
<p>只有数组对象保存了这部分数据<br>该数据在32位和64位JVM都是32bit</p>
<p>参考：<br>java对象头以及打印对象头：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sumengnan/article/details/125035218">https://blog.csdn.net/sumengnan/article/details/125035218</a><br>java对象头以及锁升级过程：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Alei777/p/16308553.html">https://www.cnblogs.com/Alei777/p/16308553.html</a></p>
<h4 id="✅锁的升级与对比"><a href="#✅锁的升级与对比" class="headerlink" title="✅锁的升级与对比"></a>✅锁的升级与对比</h4><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。<br>在 Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状 态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。<br>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<p><strong>偏向锁</strong></p>
<p>背景：<br>大多数情况下，锁不仅不存在多线程竞争，而且总是由同 一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p>偏向锁原理：<br>当一个线程访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧</strong>中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p>偏向锁释放和升级：<br>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正 在执行的字节码）。<br>1、首先暂停拥有偏向锁的线程<br>2、然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；<br>3、如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁（升级为轻量级锁），最后唤醒暂停的线程。</p>
<p>关闭偏向锁<br>偏向锁在Java 6和Java 7里是默认启用，如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：<br><code>-XX:-UseBiasedLocking=false</code></p>
<p><strong>轻量级锁</strong></p>
<p>升级为轻量级锁后，线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>来获取锁。自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁。</p>
<p><strong>重量级锁</strong></p>
<p>轻量级锁 -&gt; 重量级锁 的方式有两种：</p>
<p>1 若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。</p>
<p>2 另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。</p>
<p>自旋会消耗CPU，一旦重量级锁，就不会恢复为轻量级锁。当锁处于这个状态下，其他线程试图获取锁时， 都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<p><strong>几种锁的对比</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">锁	优点	缺点	使用场景</span><br><span class="line">偏向锁	加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳秒级的差距	如果线程间存在锁竞争，会带来额外的撤销消耗	适用于只有一个线程访问同步块场景</span><br><span class="line">轻量级锁	竞争的线程不会阻塞，提高了程序的响应速度	如果始终得不到锁竞争的线程，会自旋消耗CPU	追求响应时间、同步块执行非常快</span><br><span class="line">重量级锁	线程不使用自旋，不会消耗CPU	线程阻塞，响应时间缓慢	追求吞吐量、同步块执行速度较快</span><br></pre></td></tr></table></figure>

<p>参考：<br>《书中内容》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Hello_mengkebao/article/details/119874999">https://blog.csdn.net/Hello_mengkebao/article/details/119874999</a></p>
<p><strong>总结：锁的升级过程</strong></p>
<p>JVM一般是这样使用锁和Mark Word的：</p>
<p>1，当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。</p>
<p>2，当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。</p>
<p>3，当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。</p>
<p>4，当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。</p>
<p>5，偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。</p>
<p>6，轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。</p>
<p>7，自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</p>
<h3 id="3-Atomic原子操作"><a href="#3-Atomic原子操作" class="headerlink" title="3.Atomic原子操作"></a>3.Atomic原子操作</h3><p>原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。</p>
<h4 id="✅处理器如何实现原子操作"><a href="#✅处理器如何实现原子操作" class="headerlink" title="✅处理器如何实现原子操作"></a>✅处理器如何实现原子操作</h4><p>首先处理器会自动保证<strong>基本的内存操作的原子性</strong>。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的。</p>
<p>但是<strong>复杂的内存操作处理器是不能自动保证其原子性的</strong>，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂内存操作的原子性。</p>
<p>首先我们要明确一点：a++是三步操作（取数，加一，赋值），而计算机和Java都只保证一步操作的原子性，多步操作是不保证原子性的。所以a++不是原子性的。想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p>
<p>⚠️volitale保证可见性为什么不能实现i++的线程安全？</p>
<blockquote>
<p>可见性是指瞬时可见性，是指那一时刻的可见性。放在这个例子里，就是指当线程1把（a=0，a++）的结果a=1刷回到主存中时，所有目前有a这个变量的缓存此时都应该变为a=1，而不是使用原来的值。所以，线程2也执行加一后，还没有写回到缓存中，保存在寄存器中，线程2缓存里面的a=0被置为无效，所以线程2又从主存中取得a=1替换掉了自己缓存中的a=0，然后线程2将a=1写入自己的缓存中，随后a=1又一次被立刻刷回到主存中。最后主存中的值还是a=1。</p>
</blockquote>
<p><strong>总线锁</strong></p>
<p>总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p>
<p><strong>缓存锁</strong></p>
<p>总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大。</p>
<p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。</p>
<p>“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong>，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
<p>不能使用缓存锁的情况：<br>1、第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行。<br>2、有些处理器不支持缓存锁定</p>
<h4 id="✅java如何实现原子操作"><a href="#✅java如何实现原子操作" class="headerlink" title="✅java如何实现原子操作"></a>✅java如何实现原子操作</h4><p><strong>循环CAS</strong></p>
<p>CAS 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制。CAS 操作包含三个操作数 – 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值相比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。（像改密码需要先验证旧密码一样）</p>
<p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</p>
<p>从Java 1.5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值）。这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p>
<p>CAS仍然存在<strong>三大问题</strong>。ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。</p>
<p>1、ABA问题<br>CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p>
<p>从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>2、循环时间长开销大<br>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<p>3、只能保证一个共享变量的原子操作<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证<strong>引用对象之间的原子性</strong>，就可以把多个变量放在一个对象里来进行CAS操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">count.incrementAndGet(); //原子自增</span><br><span class="line">int i = count.get();</span><br><span class="line">boolean suc = count.compareAndSet(i, ++i); //cas</span><br></pre></td></tr></table></figure>

<p><strong>使用锁实现原子操作</strong></p>
<p>使用锁机制实现原子操作锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p>
<p>参考：<br>书的笔记：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/412363896">https://zhuanlan.zhihu.com/p/412363896</a><br>jdk中的原子操作类：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a47285790467">https://www.jianshu.com/p/a47285790467</a><br>cas原理、synchronized悲观锁和cas乐观锁：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/huansky/p/15746624.html">https://www.cnblogs.com/huansky/p/15746624.html</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>几个java实现多线程安全的操作：<br>1、synchronized加锁<br>2、Volatile关键字<br>3、CAS</p>
<h2 id="第三章-Java内存模型"><a href="#第三章-Java内存模型" class="headerlink" title="第三章 Java内存模型"></a>第三章 Java内存模型</h2><h3 id="1-java内存模型的基础"><a href="#1-java内存模型的基础" class="headerlink" title="1.java内存模型的基础"></a>1.java内存模型的基础</h3><h4 id="✅并发编程的两个关键问题"><a href="#✅并发编程的两个关键问题" class="headerlink" title="✅并发编程的两个关键问题"></a>✅并发编程的两个关键问题</h4><p>1、线程之间如何通信：<br>通信是指线程之间以何种机制来交换信息<br>通信机制有两种：共享内存和消息传递</p>
<p>2、线程之间如何同步：<br>同步：指程序中用于控制不同线程间操作发生相对顺序的机制</p>
<p>java的并发采用的是共享内存模型，java线程之间的通信总是隐式进行，整个过程对程序员完全透明。</p>
<h4 id="✅java内存模型"><a href="#✅java内存模型" class="headerlink" title="✅java内存模型"></a>✅java内存模型</h4><p>堆内存：实例域、静态域、数组元素；在线程之间共享。<br>栈内存：局部变量、方法定义参数、异常处理器参数；不在线程之间共享，没有内存可见性问题。</p>
<p>Java线程之间的通信由Java内存模型(JMM)控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见</p>
<p>线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存(抽象概念)，本地内存中存储了该线程以读/写共享变量的副本。</p>
<p>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证<br>两个线程要通信，要经历下面2个步骤：<br>线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br>线程B到主内存中去读取线程A之前已更新过的共享变量</p>
<h4 id="✅从源代码到指令序列的重排序"><a href="#✅从源代码到指令序列的重排序" class="headerlink" title="✅从源代码到指令序列的重排序"></a>✅从源代码到指令序列的重排序</h4><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序</p>
<p>重排序分3种类型，第一种属于编译器重排，后两种属于处理器重排：<br>编译器优化的重排序<br>指令级并行的重排序<br>内存系统的重排序</p>
<p>JMM通过禁止特定类型的编译器重排序和处理器重排序（插入特定类型的内存屏障），提供内存可见性保证。</p>
<p>处理器利用写缓冲区来临时保存向内存写入的数据。但是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。例如a=1，先写在缓冲区，然后下一个语句用了a，然后缓冲区才将a=1写入主内存。这就算重排序了。</p>
<h4 id="✅happens-before"><a href="#✅happens-before" class="headerlink" title="✅happens-before"></a>✅happens-before</h4><p>JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系（一种阐述内存可见性的概念）。就是要求前一个操作的执行结果对后一个操作可见。并不意味着操作A就一定在操作B之前执行。</p>
<p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读</p>
<h3 id="2-重排序"><a href="#2-重排序" class="headerlink" title="2.重排序"></a>2.重排序</h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p>
<h4 id="✅数据依赖性"><a href="#✅数据依赖性" class="headerlink" title="✅数据依赖性"></a>✅数据依赖性</h4><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。<br>数据依赖可分为：读后写、写后读、写后写。</p>
<p>编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</p>
<h4 id="✅as-if-serial语义"><a href="#✅as-if-serial语义" class="headerlink" title="✅as-if-serial语义"></a>✅as-if-serial语义</h4><p>一个概念，意思是：不管怎么重排序，单线程的程序的执行结果不能被改变</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。</p>
<p>意思就是，编译器和处理器为了提高单线程的并行度，会对没有依赖关系的操作重排序，但是不影响结果和可见性。</p>
<h4 id="✅重排序对多线程的影响"><a href="#✅重排序对多线程的影响" class="headerlink" title="✅重排序对多线程的影响"></a>✅重排序对多线程的影响</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ReorderExample &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        a = 1; // 1</span><br><span class="line">        flag = true; // 2</span><br><span class="line">    &#125;</span><br><span class="line">    Public void reader() &#123;</span><br><span class="line">        if (flag) &#123; // 3</span><br><span class="line">        int i = a * a; // 4</span><br><span class="line">    ……</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法.</p>
<p>操作1和操作2没有数据依赖关系，且操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两对操作重排序.</p>
<p>对线程A的两个操作进行重排序：<br>1、线程A首先写标记变量flag<br>2、随后线程B读这个变量。由于条件判断为真，线程B将读取变量a<br>3、此时，变量a还没有被线程A写入，多线程程序的语义被重排序破坏</p>
<p>对线程B的两个操作进行重排序：<br>1、由于操作3和操作4存在控制依赖关系，执行线程B的处理器可提前读取并计算a*a<br>2、然后把计算结果临时保存到一个名为重排序缓冲(Reorder Buffer，ROB)的硬件缓存中<br>3、当操作3的条件判断为真时，就把该计算结果写入变量i中，多线程程序的语义被重排序破坏</p>
<h3 id="3-顺序一致性"><a href="#3-顺序一致性" class="headerlink" title="3.顺序一致性"></a>3.顺序一致性</h3><p>数据竞争的定义：在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读没有通过同步来排序</p>
<p>顺序一致性：如果程序是正确同步的，程序的执行将具有顺序一致性(即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同)【是一个理想化的概念】</p>
<h4 id="✅顺序一致性模型"><a href="#✅顺序一致性模型" class="headerlink" title="✅顺序一致性模型"></a>✅顺序一致性模型</h4><p>在顺序一致性模型（理论参考模型）中（不管有没有同步）：<br>任意时刻最多只有一个线程可以连接到内存。<br>一个线程的所有操作按程序的顺序串行执行。<br>每个操作必须立即对任意线程可见。<br>所有线程都只能看到一个一致的整体执行顺序。</p>
<blockquote>
<p>JMM中没有上述保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致</p>
</blockquote>
<h4 id="✅同步程序的执行效果"><a href="#✅同步程序的执行效果" class="headerlink" title="✅同步程序的执行效果"></a>✅同步程序的执行效果</h4><p>在JMM中，临界区（一个同步块儿）内的代码可以重排序(因为JMM目的是在不改变程序执行结果的前提下，尽可能优化编译器和处理器)。</p>
<p>结果是：重排序提高了执行效率，而且没有改变程序的执行结果。</p>
<h4 id="✅未同步程序的执行效果"><a href="#✅未同步程序的执行效果" class="headerlink" title="✅未同步程序的执行效果"></a>✅未同步程序的执行效果</h4><p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致（一致也没意义）。因为如果想要保证执行结果一致，JMM需要禁止大量的处理器和编译器的优化，这对程序的执行性能会产生很大的影响。</p>
<p>JMM不保证单线程内的操作会按程序顺序执行。所有线程看到的操作顺序可能不一致。执行顺序可能是：2-3-4-1，语义被破坏。可能是4的右边-1-2-3-4的左边，语义被破坏。</p>
<h4 id="✅处理器总线事务"><a href="#✅处理器总线事务" class="headerlink" title="✅处理器总线事务"></a>✅处理器总线事务</h4><p>总线事务包括读事务（内存-处理器）和写事务（处理器-内存），中间都要通过总线，总线会同步试图并发使用总线的事务，一次只有一个事务可以操作总线访问内存。</p>
<p>所以，一次最多只有一个处理器可以访问内存，这保证了单个总线事务之中的内存读写（读跟写，不是i++）具有原子性。</p>
<p>但是：32位的处理器上，对long型和double型这俩64位的数据的写操作拆分成了两个写事务，会分配在不同的总线事务中执行。所以不具有原子性。</p>
<h3 id="4-volatile的内存语义"><a href="#4-volatile的内存语义" class="headerlink" title="4.volatile的内存语义"></a>4.volatile的内存语义</h3><h4 id="✅volatile的特性："><a href="#✅volatile的特性：" class="headerlink" title="✅volatile的特性："></a>✅volatile的特性：</h4><p>1、可见性：对volatile变量的单个读写，相当于是用同一个锁对单个读写方法做了同步。对volatile变量的读，总能看到最后的写入。被volatile修饰的变量对所有线程总是立即可见的，对volatile变量的所有写操作总是能立刻反应到其他线程中。</p>
<p>2、原子性：对单个volatile变量的读写（64位的long和double类型也是）具有原子性，volatile++的复合操作不具有原子性。</p>
<h4 id="✅volatile变量读写实现线程之间通信"><a href="#✅volatile变量读写实现线程之间通信" class="headerlink" title="✅volatile变量读写实现线程之间通信"></a>✅volatile变量读写实现线程之间通信</h4><p>volatile变量的写、读，与锁的释放、获取有相同的内存效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">volatile boolean flag = false;</span><br><span class="line"></span><br><span class="line">public void writer() &#123;</span><br><span class="line">    a = 1;//1</span><br><span class="line">    flag = true;//2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void reader() &#123;</span><br><span class="line">    if (flag) &#123;  //3</span><br><span class="line">        int i = a; //4</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1 happens-before 2  (执行顺序可能在一个临界区内重排序)<br>3 happens-before 4<br>2 happens-before 3 （volatile带来的）<br>so: 1 happens-before 4</p>
<p>疑问：1.2没有数据依赖，可能被重排序。<br>指令重排使得执行顺序不会变成：2-3-4-1 吗？ 下面给答案。</p>
<h4 id="✅volatile写读的内存语义"><a href="#✅volatile写读的内存语义" class="headerlink" title="✅volatile写读的内存语义"></a>✅volatile写读的内存语义</h4><p>线程 - 本地内存 - 主内存</p>
<p>1、当写一个volatile变量时，JMM会把线程对应的本地内存中的共享变量（那个a）值刷新到主内存。（实质就是A向接下来要读这个volatile变量的某个线程发出了消息（我对共享变量做出的修改））</p>
<p>2、当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。（实质就是接受了之前某个线程发出的消息）</p>
<p>3、A写，B读，实质就是A通过主内存向B发送消息，实现线程之间通信</p>
<h4 id="✅volatile内存语义的实现-禁止指令重排。"><a href="#✅volatile内存语义的实现-禁止指令重排。" class="headerlink" title="✅volatile内存语义的实现-禁止指令重排。"></a>✅volatile内存语义的实现-禁止指令重排。</h4><p>背景：上面实现线程间通信那一小节，疑惑的是1.2是不是能重排序，3.4是不是能重排序。在这里给出答案，</p>
<p>为了实现volatile的内存语义，JMM会限制重排序类型。</p>
<p>1、当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到写之后。</p>
<p>2、当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到读之前。</p>
<p>3、当第一个操作是volatile写时，第二个操作是volatile读时，不能重排序。</p>
<p>那么，如何实现限制指令重排？<br>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>尽管内存屏障会降低效率，但是JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<h4 id="✅JSR-133增强volatile的内存语义"><a href="#✅JSR-133增强volatile的内存语义" class="headerlink" title="✅JSR-133增强volatile的内存语义"></a>✅JSR-133增强volatile的内存语义</h4><p>Java内存模型是一个雄心勃勃的计划，它是编程语言规范第一次尝试合并一个能够在各种处理器架构中为并发提供一致语义的内存模型。不过，定义一个既一致又直观的内存模型远比想象要更难。JSR133为Java语言定义了一个新的内存模型，它修复了早期内存模型中的缺陷。为了实现JSR133，final和volatile的语义需要重新定义。</p>
<p>旧的内存模型中，volatile的写读没有锁的释放和获取的内存语义，也就是实现线程之间通信那一小节里，会指令重排。</p>
<p>JSR-133，严格限制编译器和处理器对volatile变量与普通变量的重排序，确保了volatile的写读有锁的释放和获取的内存语义。</p>
<p>volatile与锁对比：<br>锁在功能上比volatile更强大，可以确保整个临界区代码具有原子性。volatile只能对单个volatile变量读写具有原子性。（所以不能单纯用volatile实现计数器）<br>在可伸缩性和执行性能上，volatile更具有优势。</p>
<h3 id="5-锁的内存语义"><a href="#5-锁的内存语义" class="headerlink" title="5.锁的内存语义"></a>5.锁的内存语义</h3><p>达到效果：线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立即变得对B线程可见。</p>
<h4 id="✅锁释放和获取的内存语义"><a href="#✅锁释放和获取的内存语义" class="headerlink" title="✅锁释放和获取的内存语义"></a>✅锁释放和获取的内存语义</h4><p>1、当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。（实质上是线程A向接下来要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。）</p>
<p>2、当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器锁保护的临界区代码必须从主内存中读取共享变量。（实质上是线程B接受了之前某个线程发出的（在释放这个锁对共享变量锁做的修改的）消息。）</p>
<p>3、线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</p>
<h4 id="✅锁内存语义的实现"><a href="#✅锁内存语义的实现" class="headerlink" title="✅锁内存语义的实现"></a>✅锁内存语义的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock();                 // 获取锁</span><br><span class="line">try &#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();          // 释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronized(AQS) 。AQS使用一个整型的volatile变量（state）来维护同步状态，这个volatile变量是ReentrantLock内存语义实现的关键。</p>
<p><strong>公平锁：</strong></p>
<p>加锁方法首先读取volatile变量state。<br>释放锁的最后写volatile变量state。</p>
<p>效果：释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取到同一个volatile变量后将立即变得对获取锁的线程可见。</p>
<p><strong>非公平锁：</strong></p>
<p>非公平锁的释放和公平锁的释放完全一致。</p>
<p>加锁：用了：<code>unsafe.compareAndSwapInt(this, stateOffset, expect, update);</code></p>
<p>该方法以原子操作的方式更新state变量，也就是compareAndSet() (CAS)操作。JDK文档对该方法说明如下：如果当前状态值等于预期值，则以原子方式同步状态设置为给定更新的值。此操作具有volatile读和写的内存语义。<br>（编译器不能对CAS与CAS前面和后面任意内存操作重排序。）</p>
<p>CAS具有volatile读写内存语义的实现方式：lock前缀<br>intel手册对lock前缀的说明：<br>对内存的读-改-写操作原子执行。（总线锁定/缓存锁定）<br>禁止该指令，与之前的读和写指令重排序<br>把写缓冲区的所有数据刷新到内存中<br>上面的2、3两点所具有的内存屏障的效果，足以同时实现volatile读和volatile写的内存语义。所以JDK文档说CAS 具有volatile读和volatile写的内存语义对于处理器也是符合的。</p>
<p><strong>总结：</strong><br>释放锁-获取锁的内存语义的实现方式总结 ：<br>利用volatile变量的写-读所具有的内存语义<br>利用CAS所附带的volatile读和volatile写的内存语义</p>
<h4 id="✅concurrent包的实现"><a href="#✅concurrent包的实现" class="headerlink" title="✅concurrent包的实现"></a>✅concurrent包的实现</h4><p>Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器实现同步的关键。同时volatile变量的读/写和CAS可以实现线程之间的通信。这些特性就是Java整个concurrent包的基石。</p>
<p>concurrent包的通用化实现模式：<br>1、声明共享变量volatile<br>2、使用CAS的原子条件更新来实现线程之间的同步<br>3、配合volatile的读/写和CAS具有的volatile读和写的内存语义来实现线程之间的通信。</p>
<p>AQS（java.util.concurrent.locks.AbstractQueuedSynchronizer）、非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中基础类都是使用这个模式来实现的，而concurrent包中的高层类又是依赖于这些基础类。</p>
<p>图示concurrent包的实现示意图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/332bc0544764bd13d7ddb4ac4e73871f.png"></p>
<h3 id="6-final域的内存语义"><a href="#6-final域的内存语义" class="headerlink" title="6.final域的内存语义"></a>6.final域的内存语义</h3><p>文中探讨的变量对线程可见，是保证线程安全的方式，如果不可见，那就要同步加锁，反言之，加锁也是为了变量对线程可见。</p>
<h4 id="✅final域的重排序规则"><a href="#✅final域的重排序规则" class="headerlink" title="✅final域的重排序规则"></a>✅final域的重排序规则</h4><p>对于final域，编译器和处理器要遵守两个重排序规则。</p>
<p>1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
<blockquote>
<p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。</p>
<p>写普通域的操作可能被编译器重排序到了构造函数之外，读线程B错误地读取了普通变量i初始化之前的值，很可能obj对象还没有构造完成，初始值1还没有写入普通域i。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确地读取了final变量初始化之后的值。</p>
</blockquote>
<blockquote>
<p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p>
</blockquote>
<p>2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p>
<blockquote>
<p>编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器的。</p>
</blockquote>
<blockquote>
<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class FinalExample &#123;</span><br><span class="line">    int i;  //普通变量</span><br><span class="line">    final int j;  //final变量</span><br><span class="line">    static FinalExample obj;</span><br><span class="line">    public FinalExample() &#123; //构造函数</span><br><span class="line">        i = 1; //写普通域</span><br><span class="line">        j = 2; //写final域</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123; //写线程A执行</span><br><span class="line">        obj = new FinalExample();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123; //读线程B执行</span><br><span class="line">        FinalExample object = obj; //读对象引用</span><br><span class="line">        int a = object.i; //读普通域</span><br><span class="line">        int b = object.j; //读final域</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅final域为引用类型"><a href="#✅final域为引用类型" class="headerlink" title="✅final域为引用类型"></a>✅final域为引用类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceExample &#123;</span><br><span class="line">    final int[] intArray; //final是引用类型</span><br><span class="line">    static FinalReferenceExample obj;</span><br><span class="line">    public FinalReferenceExample() &#123; //构造函数</span><br><span class="line">        intArray = new int[1]; //1</span><br><span class="line">        intArray[0] = 1; //2</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writerOne() &#123; //写线程A执行</span><br><span class="line">        obj = new FinalReferenceExample(); //3</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writerTwo() &#123; //写线程B执行</span><br><span class="line">        obj.intArray[0] = 2; //4</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123; //读线程C执行</span><br><span class="line">        if (obj != null) &#123; //5</span><br><span class="line">            int temp1 = obj.intArray[0]; //6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在<strong>构造函数内</strong>对一个final引用的对象的成员域的写入(2)，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量(3)，这两个操作之间不能重排序。</p>
<p>1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p>
<p>写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。</p>
<h4 id="✅为什么含final的对象引用不能从构造函数内“溢出”"><a href="#✅为什么含final的对象引用不能从构造函数内“溢出”" class="headerlink" title="✅为什么含final的对象引用不能从构造函数内“溢出”"></a>✅为什么含final的对象引用不能从构造函数内“溢出”</h4><p>写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实，要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceEscapeExample &#123;</span><br><span class="line">    final int                          i;</span><br><span class="line">    static FinalReferenceEscapeExample obj;</span><br><span class="line">    public FinalReferenceEscapeExample() &#123;</span><br><span class="line">        i = 1; //1写final域</span><br><span class="line">        obj = this; //2 this引用在此“逸出”</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123;</span><br><span class="line">        new FinalReferenceEscapeExample();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123;  //线程B</span><br><span class="line">        if (obj != null) &#123; //3</span><br><span class="line">            int temp = obj.i; //4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作2使得对象还未完成构造前就为线程B可见。这里的操作1和操作2之间可能被重排序。线程B看到了此时的final域可能还没有被初始化。</p>
<p>final不同于普通变量达到的效果是：在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p>
<h4 id="✅处理器中如何实现final语义"><a href="#✅处理器中如何实现final语义" class="headerlink" title="✅处理器中如何实现final语义"></a>✅处理器中如何实现final语义</h4><p>本来应该要插入内存屏障的。<br>X86处理器不会对写-写操作做重排序，X86处理器不会对存在间接依赖关系的操作做重排序，也就是说，在X86处理器中，final域的读/写不会插入任何内存屏障！（普通变量也有依赖关系吧，也有final语义？）</p>
<h4 id="✅JSR-133为什么要增强final的语义"><a href="#✅JSR-133为什么要增强final的语义" class="headerlink" title="✅JSR-133为什么要增强final的语义"></a>✅JSR-133为什么要增强final的语义</h4><p>在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为1（被某个线程初始化之后的值）。</p>
<p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p>
<h3 id="7-happens-before"><a href="#7-happens-before" class="headerlink" title="7.happens-before"></a>7.happens-before</h3><h4 id="✅设计初衷"><a href="#✅设计初衷" class="headerlink" title="✅设计初衷"></a>✅设计初衷</h4><p>设计内存模型JMM的初衷：让程序员易于理解，易于编程，提供内存可见性保证。对编译器和处理器的束缚越少越好，方便它们优化来提高性能。</p>
<p>JMM 对于这两种类型的重排序做了不同的处理：<br>对于有数据依赖的重排序，JMM 要求编译器和处理器禁止这种重排序<br>对于没有数据依赖的重排序，JMM 要求编译器和处理器不做处理</p>
<p>JMM 的 happens - before 向程序员提供了足够强的内存可见性保证，但是其中有些内存可见性保证其实不一定存在，【比如 int a=1; int b=2; 这个就只是可见，不保证执行顺序，但也是happens-before】。</p>
<p>JMM 对于编译器和处理器的优化已经尽可能少了。JMM 其实在遵循一个规则：单线程下或者已经同步的多线程下（synchronized，volatile等），只要不改变程序的执行结果，编译器和处理器想要怎么优化都可以。【比如 对于volatile 变量，如果编译器分析后认定这个变量只会被单线程访问，不存在多线程的可见性问题，那么编译器就会把 volatile 变量当作普通变量进行处理】。</p>
<h4 id="✅happens-before的定义"><a href="#✅happens-before的定义" class="headerlink" title="✅happens-before的定义"></a>✅happens-before的定义</h4><p>JSR - 133中提出，JSR - 133 使用 happens - before 关系来向程序员提供跨线程的内存可见性保证。</p>
<p>1、如果一个操作 happens - before 另一个操作，那么另一个操作的执行结果将对第二个操作可见。</p>
<p>2、两个操作之间存在 happens - before 关系，并不意味这 Java 平台必须要按照 happens - before 规定的顺序来执行。只要重排序之后的结果是不改变的，那么 JMM 是默认不对这种重排序处理的</p>
<p>核心原则是：只要不改变程序的执行结果（<strong>单线程和正确同步的多线程</strong>），编译器和处理器怎么优化都行。程序员对于这两个操作是否真的被重排序并不关心，程序员只需要关系的是程序执行时的语义不能被改变（就是执行结果不能被改变）。</p>
<p>happens - before 给编写正确同步的多线程程序的程序员一个幻觉：正确同步的多线程程序是按照 happens - before 指定的顺序来执行的。实际上不是，但是语义和按顺序执行是一样的。<br>（实际上是可见性，但也是一种假的顺序）</p>
<h4 id="✅happens-before规则"><a href="#✅happens-before规则" class="headerlink" title="✅happens-before规则"></a>✅happens-before规则</h4><p>1、程序顺序规则：一个线程中的每个操作，happens - before 于该程序的任意后续操作。</p>
<p>2、监视器规则：对一个锁的解锁，happens - before 于随后对这个锁的加锁。</p>
<p>3、volatile 变量规则：对一个 volatile 域的写，happens - before 于任意后续对这个 volatile 域的读。</p>
<p>4、传递性，如果 A happens - before B， B happens - before C，那么 A happens - before C</p>
<p>5、start() 规则：如果线程 A 执行操作 ThreadB.start()（启动线程B），那么线程 A 的 ThreadB.start() 操作 happens - before 线程 B 中的任意操作。</p>
<p>6、join() 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens- before 于线程 A 从 Thread.join() 操作成功返回。</p>
<p>⚠️像volitale变量一样，线程a写volatile变量前还写一个共享变量，线程b读那个volatile变量后还读那个共享变量，如何保证共享变量的安全性，因为线程a里的操作可能重排序，是由volitile的内存屏障插入策略和volatile的禁止编译器重排序规则来保证的，其他start方法和join方法也一样。因为重排序了的话，执行结果会不一样。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/laohuangaa/article/details/122773633">https://blog.csdn.net/laohuangaa/article/details/122773633</a></p>
<h3 id="8-双重检查锁定与延迟初始化"><a href="#8-双重检查锁定与延迟初始化" class="headerlink" title="8.双重检查锁定与延迟初始化"></a>8.双重检查锁定与延迟初始化</h3><p>在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。双重检查锁定是常见的延迟初始化技术，但它是一个错误的用法。</p>
<p>下面会讲述双重检查锁定为什么错误，以及两种线程安全的延迟初始化方案。</p>
<h4 id="✅双重检查锁定的由来"><a href="#✅双重检查锁定的由来" class="headerlink" title="✅双重检查锁定的由来"></a>✅双重检查锁定的由来</h4><p>在Java程序中，有时候可能需要推迟一些高开销的对象初始化操作，并且只有在使用这些对象时才进行初始化。此时，程序员可能会采用延迟初始化。</p>
<p>因为初始化可能在多线程环境下，它们共用一个对象，是需要一个线程创建就好了。非线程安全的延迟初始化对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class UnsafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null) //1：A线程执行</span><br><span class="line">            instance = new Instance(); //2：B线程执行</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A线程执行代码1的同时，B线程执行代码2。此时，线程A可能会看到instance引用的对象还没有完成初始化. 导致AB线程都初始化对象。</p>
<p>同步处理来实现线程安全的延迟初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line">    public synchronized static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">            instance = new Instance();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：synchronized将导致性能开销。如果getInstance()方法被多个线程频繁的调用，将会导致程序执行性能的下降。</p>
<p>因此，双重检查锁定来实现延迟初始化诞生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleCheckedLocking &#123; //1</span><br><span class="line">    private static Instance instance; //2</span><br><span class="line">    public static Instance getInstance() &#123; //3</span><br><span class="line">        if (instance == null) &#123; //4:第一次检查</span><br><span class="line">            synchronized (DoubleCheckedLocking.class) &#123; //5:加锁</span><br><span class="line">                if (instance == null) //6:第二次检查</span><br><span class="line">                    instance = new Instance(); //7:问题的根源出在这里</span><br><span class="line">            &#125; //8</span><br><span class="line">        &#125; //9</span><br><span class="line">        return instance; //10</span><br><span class="line">    &#125; //11</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心思想：不会每个线程都加锁，检查instance不为null，那么就不需要执行下面的加锁和初始化操作。获取锁之后，再检查一次是不是为null，因为在第一次判断是否为null时，可能另一个线程正在初始化。<br>（获取锁之前检查一次，获取锁之后检查一次）</p>
<p>但是是错误的：在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
<h4 id="✅双重检查锁定的问题"><a href="#✅双重检查锁定的问题" class="headerlink" title="✅双重检查锁定的问题"></a>✅双重检查锁定的问题</h4><p>第7行（instance=new Singleton();）创建了一个对象。这一行代码可以分解为如下的3行伪代码。</p>
<p>memory = allocate();　　// 1<strong>：分配对象的内存空间（引用变量）<br>ctorInstance(memory);　 // 2</strong>：初始化对象<br>instance = memory;　　 // 3**：设置instance指向刚分配的内存地址（赋值引用变量）（这个时候就不为null了）</p>
<p>上面3行伪代码中的2和3之间，可能会被重排序，因为这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。</p>
<p>如果发生重排序，另一个并发执行的线程B就有可能在第4行判断instance不为null。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化。<strong>线程B将会访问到一个还未初始化的对象</strong>。</p>
<p>如何解决，来实现线程安全的延迟初始化：<br>1） 不允许2和3重排序。<br>2）允许2和3重排序，但不允许其他线程“看到”这个重排序。</p>
<h4 id="✅基于volatile的解决方案"><a href="#✅基于volatile的解决方案" class="headerlink" title="✅基于volatile的解决方案"></a>✅基于volatile的解决方案</h4><p>把instance声明为volatile型，就可以实现线程安全的延迟初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SafeDoubleCheckedLocking &#123;</span><br><span class="line">    private volatile static Instance instance;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (SafeDoubleCheckedLocking.class) &#123;</span><br><span class="line">                if (instance == null)</span><br><span class="line">                    instance = new Instance();//instance为volatile，现在没问题了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要JDK 5或更高版本（因为从JDK 5开始使用新的JSR-133内存模型规范).</p>
<p>原理：使用了volatile修饰后，2、3将不会重排序。</p>
<h4 id="✅基于类初始化的解决方案"><a href="#✅基于类初始化的解决方案" class="headerlink" title="✅基于类初始化的解决方案"></a>✅基于类初始化的解决方案</h4><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceFactory &#123;</span><br><span class="line">    private static class InstanceHolder &#123;</span><br><span class="line">        public static Instance instance = new Instance();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        return InstanceHolder.instance; //这里将导致InstanceHolder类被初始化</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设两个线程并发执行getInstance()方法，但是只有一个线程能获取class对象的初始化锁，然后执行对象初始化。</p>
<p>💡初始化类的时机和原理：</p>
<p>初始化一个类，包括<strong>执行这个类的静态初始化和初始化在这个类中声明的静态字段</strong>。根据Java语言规范，在首次发生下列任意一种情况时，一个类或接口类型T将被立即初始化：<br>1）T是一个类，而且一个T类型的实例被创建。<br>2）T是一个类，且T中声明的一个静态方法被调用。<br>3）T中声明的一个静态字段被赋值。<br>4）T中声明的一个静态字段被使用，而且这个字段不是一个常量字段。<br>5）T是一个顶级类（Top Level Class），而且一个断言语句嵌套在T内部被执行。</p>
<p>在InstanceFactory示例代码中，首次执行getInstance()方法的线程将导致InstanceHolder类被初始化，是情况4.<br>（相当于是用一个工厂类来初始化另一个类？）</p>
<p>Java语言是多线程的，多个线程可能在同一时间尝试去初始化同一个类或接口（比如这里多个线程可能在同一时刻调用getInstance()方法来初始化InstanceHolder类）。因此，在Java中初始化一个类或者接口时，需要做细致的同步处理。</p>
<p>Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了。</p>
<p>（<strong>多个线程初始化类不是创建不同的对象吗？难道初始化类和创建对象不一样？</strong> 是的，先初始化类再创建对象）</p>
<p>对于类或接口的初始化，Java语言规范制定了精巧而复杂的类初始化处理过程。Java初始化一个类或接口的处理过程如下：</p>
<p>第1阶段：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化，获取锁之后，初始化维护一个状态，设置state=initialing，然后释放锁。获取不到的话，这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。</p>
<p>第2阶段：线程A执行类的初始化（上面的三步），同时线程B获取到初始化锁，发现状态是initialing，然后释放锁。后在初始化锁对应的condition上等待。</p>
<p>第3阶段：线程A获取初始化锁，设置state=initialized后，唤醒在condition中等待的所有线程，释放锁。</p>
<p>第4阶段：线程B获取锁，发现状态是initialed，释放锁，结束类的初始化处理。</p>
<p>所以，线程A执行类的初始化时的写入操作（执行类的静态初始化和初始化类中声明的静态字段），线程B一定能看到。</p>
<p>注意：这里的condition和state标记是本文虚构出来的。</p>
<p><strong>总结：</strong></p>
<p>基于类初始化的方案的实现代码更简洁，但只能对静态字段使用。但基于volatile的双重检查锁定的方案有一个额外的优势：除了可以对静态字段实现延迟初始化外，还可以对实例字段实现延迟初始化。</p>
<p>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://dandelioncloud.cn/article/details/1462953051467345921/">https://dandelioncloud.cn/article/details/1462953051467345921/</a></p>
<h3 id="9-java内存模型综述"><a href="#9-java内存模型综述" class="headerlink" title="9.java内存模型综述"></a>9.java内存模型综述</h3><h4 id="✅处理器的内存模型"><a href="#✅处理器的内存模型" class="headerlink" title="✅处理器的内存模型"></a>✅处理器的内存模型</h4><p>JMM：相当于是java编译器的内存模型</p>
<p>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为参照。在设计时，JMM和处理器内存模型会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。内存模型的束缚越少，处理器性能越好。</p>
<p>根据对不同类型的读/写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为如下几种类型：<br>1、放松程序中写-读操作的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）<br>2、在上面的基础上，继续放松程序中写-写操作的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。<br>3、在前面两条的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了Relaxed Memory Order内存模型（简称为RMO）和PowerPC内存模型。</p>
<p>这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，<strong>处理器不会对存在数据依赖性的两个内存操作做重排序</strong>）。</p>
<p>所有处理器内存模型都允许写-读重排序，原因是：使用了写缓存区。写缓存区可能导致写-读操作重排序。都允许更早读到当前处理器的写，原因同样是因为写缓存区。由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己写缓存区中的写。</p>
<p><strong>虚拟机对不同操作系统反映的一致性：</strong></p>
<p>由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。</p>
<h4 id="✅各种内存模型之间的关系"><a href="#✅各种内存模型之间的关系" class="headerlink" title="✅各种内存模型之间的关系"></a>✅各种内存模型之间的关系</h4><p>JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。</p>
<p>处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计得会越弱。</p>
<p>执行性能越好，易编程性越差。</p>
<h4 id="✅JMM的内存可见性保证"><a href="#✅JMM的内存可见性保证" class="headerlink" title="✅JMM的内存可见性保证"></a>✅JMM的内存可见性保证</h4><p>1、单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</p>
<p>2、正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p>
<p>3、未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。</p>
<p>最小安全性“发生”在对象被任意线程使用之前。64位数据的非原子性写“发生”在对象被多个线程使用的过程中（写共享变量）。如果是写了一半的，那就是线程B写了一半的，并不是null。<br>最小安全性保证线程读取到的值不会无中生有的冒出来，但并不保证线程读取到的值一定是正确的。</p>
<p>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h4 id="✅JSR-133对旧内存模型的修补"><a href="#✅JSR-133对旧内存模型的修补" class="headerlink" title="✅JSR-133对旧内存模型的修补"></a>✅JSR-133对旧内存模型的修补</h4><p>JSR-133对JDK 5之前的旧内存模型的修补主要有两个。</p>
<p>· 增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</p>
<p>· 增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，JSR-133为final增加了两个重排序规则。在保证final引用不会从构造函数内逸出的情况下，final具有了初始化安全性。</p>
<h2 id="第四章-java并发编程"><a href="#第四章-java并发编程" class="headerlink" title="第四章 java并发编程"></a>第四章 java并发编程</h2><p>Java从诞生开始就明智地选择了内置对多线程的支持，这使得Java语言相比同一时期的其他语言具有明显的优势。</p>
<p>线程作为操作系统调度的最小单元，多个线程能够同时执行（多核同时，单核并发），这将显著提升程序性能，在多核环境中表现得更加明显。但是，过多地创建线程和对线程的不当管理也容易造成问题。</p>
<h3 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1.线程简介"></a>1.线程简介</h3><h4 id="✅什么是线程"><a href="#✅什么是线程" class="headerlink" title="✅什么是线程"></a>✅什么是线程</h4><p>现代操作系统在运行一个程序时，会为其创建一个进程。操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<p>处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</p>
<p>Java程序天生就是多线程程序，使用JMX来查看一个普通的Java程序包含哪些线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MultiThread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 获取Java线程管理 MXBean</span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        // 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);</span><br><span class="line">        // 遍历线程信息，仅打印线程 ID 和 线程名称信息</span><br><span class="line">        for (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.println(&quot;[&quot; + threadInfo.getThreadId() + &quot;] &quot; + threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅为什么使用多线程"><a href="#✅为什么使用多线程" class="headerlink" title="✅为什么使用多线程"></a>✅为什么使用多线程</h4><p>1、更多的处理器核心<br>如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</p>
<p>2、更快的响应时间<br>使用多线程技术，将数据一致性不强的操作派发给不同线程处理（消息队列也可以做到），响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。</p>
<p>3、更好的编程模式<br>Java为多线程编程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决</p>
<h4 id="✅线程优先级"><a href="#✅线程优先级" class="headerlink" title="✅线程优先级"></a>✅线程优先级</h4><p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。</p>
<p>时间片就是分配给线程的处理器资源，在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。</p>
<p>设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。</p>
<p>一个计数线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static class Job implements Runnable &#123;</span><br><span class="line">            private int priority;</span><br><span class="line">            private long jobCount;</span><br><span class="line">            public Job(int priority) &#123;</span><br><span class="line">                    this.priority = priority;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (notStart) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">                while (notEnd) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                    jobCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看10s多个不同优先级的计数，操作系统可能会忽略对线程优先级的设定。</p>
<h4 id="✅线程的状态"><a href="#✅线程的状态" class="headerlink" title="✅线程的状态"></a>✅线程的状态</h4><p>线程创建之后，调用start()方法开始运行。当线程执行wait()方法之后，线程进入等待状态（释放锁）。</p>
<p>进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。</p>
<p>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。</p>
<p>等待和超时等待的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//该线程在waiting.class实例上等待</span><br><span class="line">static class Waiting implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (Waiting.class) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Waiting.class.wait();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该线程不断进行睡眠，超时等待</span><br><span class="line">static class TimeWaiting implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            SleepUtils.second(100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java将操作系统中的运行和就绪两个状态合并称为运行状态。<br>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</p>
</blockquote>
<h4 id="✅Daemon线程"><a href="#✅Daemon线程" class="headerlink" title="✅Daemon线程"></a>✅Daemon线程</h4><p>守护线程。</p>
<p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出，所有Daemon线程都需要立即终止。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。</p>
<p>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。因此，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p>
<h3 id="2-启动和终止线程"><a href="#2-启动和终止线程" class="headerlink" title="2.启动和终止线程"></a>2.启动和终止线程</h3><p>调用start方法进行启动线程，随着run方法的执行完毕，线程随之终止。</p>
<h4 id="✅构造线程"><a href="#✅构造线程" class="headerlink" title="✅构造线程"></a>✅构造线程</h4><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。</p>
<p>个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。</p>
<p>一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</p>
<h4 id="✅启动线程"><a href="#✅启动线程" class="headerlink" title="✅启动线程"></a>✅启动线程</h4><p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。</p>
<p>线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</p>
<h4 id="✅中断线程"><a href="#✅中断线程" class="headerlink" title="✅中断线程"></a>✅中断线程</h4><p>中断，效果是终止一个线程，可以理解为线程的一个标识位属性 （并不能直接终止一个线程），它表示一个运行中的线程是否被其他线程进行了中断操作。</p>
<p>中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的 interrupt() 方法对其进行中断操作。线程通过检查自身是否被中断来进行响应，线程通过方法 isInterrupted() 来进行判断是否被中断。</p>
<p>从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep （long millis）方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。</p>
<p>如下所示的例子中，首先创建了两个线程，SleepThread和BusyThread，前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Interrupted &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // sleepThread不停的尝试睡眠</span><br><span class="line">        Thread sleepThread = new Thread(new SleepRunner(), &quot;SleepThread&quot;);</span><br><span class="line">        sleepThread.setDaemon(true);</span><br><span class="line">        // busyThread不停的运行</span><br><span class="line">        Thread busyThread = new Thread(new BusyRunner(), &quot;BusyThread&quot;);</span><br><span class="line">        busyThread.setDaemon(true);</span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line">        // 休眠5秒，让sleepThread和busyThread充分运行</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line">        System.out.println(&quot;SleepThread interrupted is &quot; + sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(&quot;BusyThread interrupted is &quot; + busyThread.isInterrupted());</span><br><span class="line">        // 防止sleepThread和busyThread立刻退出</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125;</span><br><span class="line">    static class SleepRunner implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(10000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 对于Sleep，如果发生了中断，就会抛出中断异常。抛出后，interrupt的表示位会被重置。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class BusyRunner implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，抛出InterruptedException的线程SleepThread，其中断标识位被清除了，返回false。而一直忙碌运作的线程BusyThread，中断标识位没有被清除，返回true。</p>
<h4 id="✅过期的suspend-、resume-和stop"><a href="#✅过期的suspend-、resume-和stop" class="headerlink" title="✅过期的suspend()、resume()和stop()"></a>✅过期的suspend()、resume()和stop()</h4><p>suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。</p>
<p>不建议使用的原因主要是：</p>
<p>以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。<br>同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
<p>暂停和恢复操作可以用后面提到的等待/通知机制来替代。</p>
<h4 id="✅安全地终止线程"><a href="#✅安全地终止线程" class="headerlink" title="✅安全地终止线程"></a>✅安全地终止线程</h4><p>中断状态是线程的一个标识位，而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。</p>
<p>除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。</p>
<p>方法1：使用中断interrupt方法进行中断。按说是直接中断线程了，没加代码中的判断也应该中断的。❓<br>方法2：使用一个volatile的boolean类型变量来控制，实际上是中断while方法，然后执行完run方法，终止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Shutdown &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Runner one = new Runner();</span><br><span class="line">        Thread countThread = new Thread(one, &quot;CountThread&quot;);</span><br><span class="line">        countThread.start();</span><br><span class="line">        // 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line">        Runner two = new Runner();</span><br><span class="line">        countThread = new Thread(two, &quot;CountThread&quot;);</span><br><span class="line">        countThread.start();</span><br><span class="line">        // 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Runner implements Runnable &#123;</span><br><span class="line">        private long i;</span><br><span class="line">            private volatile boolean on = true;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            while (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;Count i = &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        public void cancel() &#123;</span><br><span class="line">            on = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例在执行过程中，main线程通过中断操作和cancel()方法均可使CountThread得以终止。</p>
<p>这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。</p>
<h3 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3.线程间通信"></a>3.线程间通信</h3><p>线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。多个线程配合工作，才更有价值。</p>
<h4 id="✅volatile和synchronized关键字"><a href="#✅volatile和synchronized关键字" class="headerlink" title="✅volatile和synchronized关键字"></a>✅volatile和synchronized关键字</h4><p>背景：<br>Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还可以拥有一份拷贝，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性）（就是线程的本地内存），所以程序在执行过程中，一个线程看到的变量并不一定是最新的。</p>
<p>volatile怎么解决：<br>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p>
<p>sychronized怎么解决：<br>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
<p>一点sychronized的实现原理：</p>
<p>看字节码文件，monitorenter和monitorexit指令，是对一个对象的监视器的获取，这个获取过程是排他的，一个时刻只有一个线程能够获取到由sychronized保护的对象的监视器。</p>
<p>任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处（进入同步队列），进入BLOCKED状态。当获锁线程释放了锁，该释放操作唤醒阻塞在同步队列中的线程，重新尝试对监视器的获取。</p>
<h4 id="✅等待-通知机制"><a href="#✅等待-通知机制" class="headerlink" title="✅等待/通知机制"></a>✅等待/通知机制</h4><p>背景：生产者线程修改某个变量的值，消费者线程能够感知到。简单的办法是让消费者线程不断地循环检查变量是否符合预期。但是开销大。</p>
<p>Java通过内置的等待/通知机制能够很好地解决这个矛盾并实现所需的功能。<br>等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类java.lang.Object上。（监视器方法）</p>
<p>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。<br>上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。（两个notify都是通知等待队列里的，不是阻塞状态的同步队列，notify通知一个，notifyAll通知所有）。</p>
<p>例子：创建了两个线程——WaitThread和NotifyThread，前者检查flag值是否为false，如果符合要求，进行后续操作，否则在lock上等待，后者在睡眠了一段时间后对lock进行通知。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotify &#123;</span><br><span class="line">    static boolean flag = true;</span><br><span class="line">    static Object lock = new Object();</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Thread waitThread = new Thread(new Wait(), &quot;WaitThread&quot;);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        Thread notifyThread = new Thread(new Notify(), &quot;NotifyThread&quot;);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    static class Wait implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 加锁，拥有lock的Monitor</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                // 当条件不满足时，继续wait，同时释放了lock的锁</span><br><span class="line">                while (flag) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + &quot; flag is true. wait@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 条件满足时，完成工作</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; flag is false. running@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Notify implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 加锁，拥有lock的Monitor</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                // 获取lock的锁，然后进行通知，通知时不会释放lock的锁，</span><br><span class="line">                // 直到当前线程释放了lock后，WaitThread才能从wait方法中返回</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; hold lock. notify @ &quot; +</span><br><span class="line">                        new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 再次加锁</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; hold lock again. sleep@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用wait()、notify()以及notifyAll()时需要注意的细节:</p>
<p>1、使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</p>
<p>2、调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列，并释放锁。</p>
<p>3、notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。</p>
<p>4、notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。</p>
<p>5、从wait()方法返回的前提是获得了调用对象的锁。<strong>等待/通知机制依托于同步机制</strong>，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改（也就是flag变量）。</p>
<p>梳理一下等待线程的状态变化：<br>1、wait线程首先获取锁，调用lock的wait方法，放弃了锁，进入等待队列，等待状态。（可以有很多个wait线程）<br>2、notify线程获取了锁，调用lock的notify方法，将wait线程从等待队列移动到了同步队列，是阻塞状态。（notify只能唤醒一个）<br>3、notify线程运行完了，释放锁，wait线程获取到锁，从wait方法返回并继续执行。</p>
<p>sleep不会释放锁<br>wait会释放锁</p>
<h4 id="✅等待-通知的经典范式"><a href="#✅等待-通知的经典范式" class="headerlink" title="✅等待/通知的经典范式"></a>✅等待/通知的经典范式</h4><p>范式分为两部分，分别针对等待方（消费者）和通知方（生产者）</p>
<p>等待方遵循如下原则：<br>1、获取对象的锁。<br>2、如果条件不满足（flag变量），那么调用对象的wait()方法，被通知后仍要检查条件。<br>3、条件满足则执行对应的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">	while(条件不满足) &#123;</span><br><span class="line">		对象.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知方遵循如下原则：<br>1、获得对象的锁。<br>2、改变条件。<br>3、通知所有等待在对象上的线程。（先改变条件还是先通知都行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">	改变条件(flag)</span><br><span class="line">	对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、flag的目的：相当于是一个线程修改了某个值，另一个线程能感知到，起到一个多线程通信达到什么条件做什么事的效果。<br>2、同步的目的：获取了锁才能wait和notify，同步的目的是把修改变量和notify包在一起，让wait出来的时候能感知到变量的变化。<br>3、其实这个模式已经是偏底层了。<br>4、flag和lock可以用一个，直接用flag来当锁（就像后面的手写线程池）</p>
<h4 id="✅管道输入-输出流"><a href="#✅管道输入-输出流" class="headerlink" title="✅管道输入/输出流"></a>✅管道输入/输出流</h4><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p>
<p>管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</p>
<p>例子：printThread线程接受main线程的输入，任何main线程的输入均通过PipedWriter写入，而printThread在另一端通过PipedReader将内容读出并打印。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Piped &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        PipedWriter out = new PipedWriter();</span><br><span class="line">        PipedReader in = new PipedReader();</span><br><span class="line">        // 将输出流和输入流进行连接，否则在使用时会抛出IOException</span><br><span class="line">        out.connect(in);</span><br><span class="line">        Thread printThread = new Thread(new Print(in), &quot;PrintThread&quot;);</span><br><span class="line">        printThread.start();</span><br><span class="line">        int receive = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while ((receive = System.in.read()) != -1) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Print implements Runnable &#123;</span><br><span class="line">        private PipedReader in;</span><br><span class="line"></span><br><span class="line">        public Print(PipedReader in) &#123;</span><br><span class="line">            this.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int receive = 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                while ((receive = in.read()) != -1) &#123;</span><br><span class="line">                    System.out.print((char) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️对于Piped类型的流，必须先要进行绑定，也就是调用connect()方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。</p>
<h4 id="✅Thread-join-的使用"><a href="#✅Thread-join-的使用" class="headerlink" title="✅Thread.join()的使用"></a>✅Thread.join()的使用</h4><p>如果一个线程A执行了thread.join()语句，其含义是：<br>当前线程A等待thread线程终止之后才从thread.join()返回，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。</p>
<p>例子：创建了10个线程，编号0~9，每个线程调用前一个线程的join()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Join &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Thread previous = Thread.currentThread();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span><br><span class="line">            Thread thread = new Thread(new Domino(previous), String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">            previous = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Domino implements Runnable &#123;</span><br><span class="line">        private Thread thread;</span><br><span class="line"></span><br><span class="line">        public Domino(Thread thread) &#123;</span><br><span class="line">            this.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）。加锁、循环和处理逻辑3个步骤。</p>
<p>1、线程a执行线程b的join方法，相当于用线程b对象做同步，内部本线程wait进入等待，并用一个变量flag进行条件判断。<br>2、线程b终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。</p>
<h4 id="✅ThreadLocal的使用"><a href="#✅ThreadLocal的使用" class="headerlink" title="✅ThreadLocal的使用"></a>✅ThreadLocal的使用</h4><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。它不是线程共有的，而是私有的。即修改不会影响其他线程。每一个线程都维护一个私有的ThreadLocalMap。（❓map是每个线程私有还是每个键值对是线程私有）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line">取出后，(T)value强转即可</span><br></pre></td></tr></table></figure>

<p>例子：一个Profile类，具有begin()和end()两个方法，而end()方法返回从begin()方法调用开始到end()方法被调用时的时间差，单位是毫秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Profiler &#123;</span><br><span class="line">    // 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次</span><br><span class="line">    private static final ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = new ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">        protected Long initialValue() &#123;</span><br><span class="line">            return System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static final void begin() &#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final long end() &#123;</span><br><span class="line">        return System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        System.out.println(&quot;Cost: &quot; + Profiler.end() + &quot; mills&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用途：Profiler可以被复用在方法调用耗时统计的功能上，在方法的入口前执行begin()方法，在方法调用后执行end()方法。好处是两个方法的调用不用在一个方法或者类中。</p>
<h3 id="4-线程应用案例"><a href="#4-线程应用案例" class="headerlink" title="4.线程应用案例"></a>4.线程应用案例</h3><h4 id="✅等待超时模式"><a href="#✅等待超时模式" class="headerlink" title="✅等待超时模式"></a>✅等待超时模式</h4><p>在前面等待/通知模式的基础上，如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。</p>
<p>范式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 对当前对象加锁</span><br><span class="line">public synchronized Object get(long mills) throws InterruptedException &#123;</span><br><span class="line">	long future = System.currentTimeMillis() + mills;</span><br><span class="line">	long remaining = mills;</span><br><span class="line">	// 当超时大于0并且result返回值不满足要求</span><br><span class="line">	while ((result == null) &amp;&amp; remaining &gt; 0) &#123;</span><br><span class="line">		wait(remaining);</span><br><span class="line">		remaining = future - System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等待超时模式就是在等待/通知范式基础上增加了超时控制，这使得该模式相比原有范式更具有灵活性，因为即使方法执行时间过长，也不会“永久”阻塞调用者，而是会按照调用者的要求“按时”返回。</p>
<p>并且，不是只wait固定的时间就完事，而是循环检查是不是wait够了，够了就直接返回不wait了。</p>
<h4 id="✅一个简单的数据库连接池示例"><a href="#✅一个简单的数据库连接池示例" class="headerlink" title="✅一个简单的数据库连接池示例"></a>✅一个简单的数据库连接池示例</h4><p>使用等待超时模式来构造一个简单的数据库连接池，在示例中模拟从连接池中获取、使用和释放连接的过程，而客户端获取连接的过程被设定为等待超时的模式，也就是在1000毫秒内如果无法获取到可用连接，将会返回给客户端一个null。</p>
<p>设定连接池的大小为10个，然后通过调节客户端的线程数来模拟无法获取连接的场景。</p>
<p>首先看一下连接池的定义。它通过构造函数初始化连接的最大上限，通过一个双向队列来维护连接，调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连接，当连接使用完成后，需要调用releaseConnection(Connection)方法将连接放回线程池，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionPool &#123;</span><br><span class="line">	//连接池</span><br><span class="line">    private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    //构造</span><br><span class="line">    public ConnectionPool(int initialSize) &#123;</span><br><span class="line">        if (initialSize &gt; 0) &#123;</span><br><span class="line">        	//创建数据库连接</span><br><span class="line">            for (int i = 0; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());//该类在后面实现，用于初始化线程池</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void releaseConnection(Connection connection) &#123;</span><br><span class="line">        if (connection != null) &#123;</span><br><span class="line">            synchronized (pool) &#123;</span><br><span class="line">                // 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                // 唤醒所有等待，让他们去竞争锁</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在mills内无法获取到连接，将会返回null</span><br><span class="line">    //获取连接</span><br><span class="line">    public Connection fetchConnection(long mills) throws InterruptedException &#123;</span><br><span class="line">        synchronized (pool) &#123;</span><br><span class="line">        	// 该部分代码逻辑为</span><br><span class="line">        	// 当完全超时时，必然会获得一个连接池对象,也即是无线等待时间。当传入mills &gt; 0时，不会走入该分支。因为else分支会处理其中超时情况</span><br><span class="line">        	// 非完全超时时，获得就返回一个连接池对象，不然就返回空</span><br><span class="line">        	</span><br><span class="line">            // 完全超时</span><br><span class="line">            if (mills &lt;= 0) &#123;</span><br><span class="line">            	// 连接池为空</span><br><span class="line">                while (pool.isEmpty()) &#123;</span><br><span class="line">                    //以连接池为通知对象，等待直到被唤醒，不在主动醒来</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                // 拿出连接池中第一个连接，并返回给当前请求者</span><br><span class="line">                return pool.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            //未超时 </span><br><span class="line">            else &#123;</span><br><span class="line">                long future = System.currentTimeMillis() + mills;</span><br><span class="line">                long remaining = mills;</span><br><span class="line">                //连接池为空且未超时</span><br><span class="line">                while (pool.isEmpty() &amp;&amp; remaining &gt; 0) &#123;</span><br><span class="line">                	//以连接池为通知对象，等待remaining毫秒,或者被唤醒</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    // 获取剩余时间，通过它来判断是主动醒来（超时），还是被动唤醒（notify）</span><br><span class="line">                    // 无论是被动还是主动醒来，都尝试获取连接池这个对象锁</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                    // 获得锁以后判断连接池是不是空的，空的的话再判断是否超时，超时就离开循环</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Connection result = null;</span><br><span class="line">                //抢到连接池这个对象锁后，若此时连接池不为空</span><br><span class="line">                if (!pool.isEmpty()) &#123;</span><br><span class="line">                	// 拿出连接池中第一个连接，并返回给当前请求者</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                // 否则此时为空</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于java.sql.Connection是一个接口，最终的实现是由数据库驱动提供方来实现的，考虑到只是个示例，我们通过<strong>动态代理</strong>构造了一个Connection，该Connection的代理实现仅仅是在commit()方法（提交sql）调用时休眠100毫秒，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionDriver &#123;</span><br><span class="line"></span><br><span class="line">    static class ConnectionHandler implements InvocationHandler &#123;</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123;</span><br><span class="line">         // 在方法执行之前</span><br><span class="line">        // 当方法是提交时，我们睡眠100毫秒</span><br><span class="line">        if (method.getName().equals(&quot;commit&quot;))&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 执行原本方法，此处就不执行了</span><br><span class="line">       	// Object invoke = method.invoke(vehical, args);</span><br><span class="line">       	</span><br><span class="line">		// 执行方法之后，此处也不处理，直接放回null</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个Connection的代理，在commit时休眠100毫秒</span><br><span class="line">    public static final Connection createConnection() &#123;</span><br><span class="line">    	// 创建一个代理实例</span><br><span class="line">    	// 类加载器(用哪个类加载器去加载代理对象) + 代理的类(接口，切入点) + 代理方法</span><br><span class="line">    	// 可以理解我们为Connection的&quot;commit&quot;方法，通过JDK的方式代理了一层(AOP)</span><br><span class="line">    	// 返回的就是我们Spring中学习的 代理额外增加的层 + 原本的类对象</span><br><span class="line">        return (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(),new Class &lt;?&gt;[]&#123;</span><br><span class="line">            Connection.class</span><br><span class="line">        &#125;,new ConnectionHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面通过一个示例来测试简易数据库连接池的工作情况，模拟客户端ConnectionRunner获取、使用、最后释放连接的过程，当它使用时连接将会增加获取到连接的数量，反之，将会增加未获取到连接的数量，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionPoolTest &#123;</span><br><span class="line">    static ConnectionPool pool = new ConnectionPool(10);</span><br><span class="line">    // 保证所有ConnectionRunner能够同时开始</span><br><span class="line">    static CountDownLatch start = new CountDownLatch(1);</span><br><span class="line">    // main线程将会等待所有ConnectionRunner结束后才能继续执行</span><br><span class="line">    static CountDownLatch end;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 线程数量，可以修改线程数量进行观察</span><br><span class="line">        int threadCount = 10;</span><br><span class="line">        end = new CountDownLatch(threadCount);</span><br><span class="line">        int count = 20;</span><br><span class="line">        // 用原子记录 获取到的与没有获取到的</span><br><span class="line">        AtomicInteger got = new AtomicInteger();</span><br><span class="line">        AtomicInteger notGot = new AtomicInteger();</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">        	// 运行线程</span><br><span class="line">            Thread thread = new Thread(new ConnetionRunner(count, got, notGot),</span><br><span class="line">                    &quot;ConnectionRunnerThread&quot;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        //运行到这里start值-1，此时为0，因此所有线程不再会被阻塞，开始执行</span><br><span class="line">        start.countDown();</span><br><span class="line">        //主线程阻塞在这里，等待end为0，即等待所有线程结束</span><br><span class="line">        end.await();   //等10个线程都执行完</span><br><span class="line">        System.out.println(&quot;total invoke: &quot; + (threadCount * count));</span><br><span class="line">        System.out.println(&quot;got connection: &quot; + got);</span><br><span class="line">        System.out.println(&quot;not got connection &quot; + notGot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ConnetionRunner implements Runnable &#123;</span><br><span class="line">        int count;</span><br><span class="line">        AtomicInteger got;</span><br><span class="line">        AtomicInteger notGot;</span><br><span class="line"></span><br><span class="line">		// got、noteGot因为是引用，所以本质还是原来的那个</span><br><span class="line">        public ConnetionRunner(int count, AtomicInteger got, AtomicInteger notGot) &#123;</span><br><span class="line">            this.count = count;</span><br><span class="line">            this.got = got;</span><br><span class="line">            this.notGot = notGot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            	// 阻塞在这里，等待start为0</span><br><span class="line">                start.await();  //等10个线程都创建好后一起执行</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当count &gt; 0 时，再次执行</span><br><span class="line">            while (count &gt; 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 从线程池中获取连接，如果1000ms内无法获取到，将会返回null</span><br><span class="line">                    // 分别统计连接获取的数量got和未获取到的数量notGot</span><br><span class="line">                    Connection connection = pool.fetchConnection(1000);</span><br><span class="line">                    // 如果获取到了</span><br><span class="line">                    if (connection != null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                        	// 创建SQL语句</span><br><span class="line">                            connection.createStatement();</span><br><span class="line">                            // 执行提交</span><br><span class="line">                            connection.commit();</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                        	// 释放</span><br><span class="line">                            pool.releaseConnection(connection);</span><br><span class="line">                            // 获取到got + 1</span><br><span class="line">                            got.incrementAndGet();</span><br><span class="line">                        &#125;</span><br><span class="line">                     // 没有获取到</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                    	// 没有获取到notGot + 1</span><br><span class="line">                        notGot.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                </span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 线程结束 end - 1</span><br><span class="line">            end.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中使用了CountDownLatch来确保ConnectionRunnerThread能够同时开始执行，并且在全部结束之后，才使main线程从等待状态中返回。</p>
<p>在资源一定的情况下（连接池中的10个连接），随着客户端线程的逐步增加，客户端出现超时无法获取连接的比率不断升高。</p>
<h4 id="✅线程池技术及其示例"><a href="#✅线程池技术及其示例" class="headerlink" title="✅线程池技术及其示例"></a>✅线程池技术及其示例</h4><p>如果服务端每次接受到一个任务，创建一个线程，然后进行执行，这会使操作系统频繁的进行线程上下文切换，无故增加系统的负载，而线程的创建和消亡都是需要耗费系统资源的，也无疑浪费了系统资源。</p>
<p>线程池技术能够很好地解决这个问题，它预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。</p>
<p>线程池的好处：<br>1、消除了频繁创建和消亡线程的系统资源开销<br>2、面对过量任务的提交能够平缓的劣化。</p>
<p>线程池接口定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface ThreadPool&lt;Job extends Runnable&gt; &#123;</span><br><span class="line">    // 执行一个Job，这个Job需要实现Runnable</span><br><span class="line">    void execute(Job job);</span><br><span class="line"></span><br><span class="line">    // 关闭线程池</span><br><span class="line">    void shutdown();</span><br><span class="line"></span><br><span class="line">    // 增加工作者线程</span><br><span class="line">    void addWorkers(int num);</span><br><span class="line"></span><br><span class="line">    // 减少工作者线程</span><br><span class="line">    void removeWorker(int num);</span><br><span class="line"></span><br><span class="line">    // 得到正在等待执行的任务数量</span><br><span class="line">    int getJobSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端可以通过execute(Job)方法将Job提交入线程池执行，而客户端自身不用等待Job的执行完成。<br>除了execute(Job)方法以外，线程池接口提供了增大/减少工作者线程以及关闭线程池的方法。<br>这里工作者线程代表着一个重复执行Job的线程，而每个由客户端提交的Job都将进入到一个工作队列中等待工作者线程的处理。</p>
<p>手写一个线程池，不用Executor创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123;</span><br><span class="line">    // 线程池最大限制数</span><br><span class="line">    private static final int MAX_WORKER_NUMBERS = 10;</span><br><span class="line">    // 线程池默认的数量</span><br><span class="line">    private static final int DEFAULT_WORKER_NUMBERS = 5;</span><br><span class="line">    // 线程池最小的数量</span><br><span class="line">    private static final int MIN_WORKER_NUMBERS = 1;</span><br><span class="line">    // 这是一个工作列表，将会向里面插入工作</span><br><span class="line">    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();</span><br><span class="line">    // 工作者列表</span><br><span class="line">    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;());</span><br><span class="line">    // 工作者线程的数量</span><br><span class="line">    private int workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    // 线程编号生成</span><br><span class="line">    private AtomicLong threadNum = new AtomicLong();</span><br><span class="line">	</span><br><span class="line">    //构造函数</span><br><span class="line">    public DefaultThreadPool() &#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DefaultThreadPool(int num) &#123;</span><br><span class="line">    	// num &gt; max ， 取 max，num &lt; min 取 min。其他取 num</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS:(num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num);</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute(Job job) &#123;</span><br><span class="line">        if (job != null) &#123;</span><br><span class="line">            // 添加一个工作，然后进行通知</span><br><span class="line">            synchronized (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();   //通知（这里jobs既是flag又是lock）</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        for (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addWorkers(int num) &#123;</span><br><span class="line">        synchronized (jobs) &#123;</span><br><span class="line">            // 限制新增的Worker数量不能超过最大值</span><br><span class="line">            if (num + this.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - this.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            this.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeWorker(int num) &#123;</span><br><span class="line">        synchronized (jobs) &#123;</span><br><span class="line">            if (num &gt;= this.workerNum) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;beyond workNum&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 按照给定的数量停止Worker</span><br><span class="line">            int count = 0;</span><br><span class="line">            while (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                if (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getJobSize() &#123;</span><br><span class="line">        return jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化线程工作者</span><br><span class="line">    private void initializeWokers(int num) &#123;</span><br><span class="line">        for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = new Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.inrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 工作者，负责消费任务</span><br><span class="line">    class Worker implements Runnable &#123;</span><br><span class="line">        // 是否工作</span><br><span class="line">        private volatile boolean running = true;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (running) &#123;</span><br><span class="line">                Job job = null;</span><br><span class="line">                synchronized (jobs) &#123;</span><br><span class="line">                    // 如果工作者列表是空的，那么就wait</span><br><span class="line">                    while (jobs.isEmpty()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            jobs.wait();  //等待</span><br><span class="line">                        &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                            // 感知到外部对WorkerThread的中断操作，返回</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 取出一个Job</span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                if (job != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; catch (Exception ex) &#123;</span><br><span class="line">                        // 忽略Job执行中的Exception</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void shutdown() &#123;</span><br><span class="line">            running = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Job是要放入线程池的线程，Worker是线程池内执行Job线程的工作线程。里面用了等待通知模式，放入一个job会通知一下，jobs为空了就会等待。</p>
<p>当客户端调用execute(Job)方法时，会不断地向任务列表jobs中添加Job，而每个工作者线程会不断地从jobs上取出一个Job进行执行，当jobs为空时，工作者线程进入等待状态。</p>
<p>添加一个Job后，对工作队列jobs调用了其notify()方法，而不是notifyAll()方法，因为能够确定有工作者线程被唤醒，这时使用notify()方法将会比notifyAll()方法获得更小的开销（避免将等待队列中的线程全部移动到阻塞队列中）。</p>
<p>可以看到，线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作队列上取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者线程，随着大量的任务被提交，更多的工作者线程会被唤醒。</p>
<h4 id="✅一个基于线程池技术的简单Web服务器"><a href="#✅一个基于线程池技术的简单Web服务器" class="headerlink" title="✅一个基于线程池技术的简单Web服务器"></a>✅一个基于线程池技术的简单Web服务器</h4><p>目前的浏览器都支持多线程访问，比如说在请求一个HTML页面的时候，页面中包含的图片资源、样式资源会被浏览器发起并发的获取。</p>
<p>大部分Web服务器也都是支持并发访问的。常用的Java Web服务器，如Tomcat、Jetty，在其处理请求的过程中都使用到了线程池技术。</p>
<p>使用前一节中的线程池来构造一个简单的Web服务器，这个Web服务器用来处理HTTP请求，目前只能处理简单的文本和JPG图片内容。这个Web服务器使用main线程不断地接受客户端Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleHttpServer &#123;</span><br><span class="line">    // 处理HttpRequest的线程池</span><br><span class="line">    static ThreadPool&lt;HttpRequestHandler&gt; threadPool = new DefaultThreadPool&lt;HttpRequestHandler&gt;(1);</span><br><span class="line">    // SimpleHttpServer的根路径</span><br><span class="line">    static String basePath;</span><br><span class="line">    static ServerSocket serverSocket;</span><br><span class="line">    // 服务监听端口</span><br><span class="line">    static int port = 8080;</span><br><span class="line"></span><br><span class="line">    public static void setPort(int port) &#123;</span><br><span class="line">        if (port &gt; 0) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setBasePath(String basePath) &#123;</span><br><span class="line">         if (basePath != null &amp;&amp; new File(basePath).exists() &amp;&amp; new File(basePath).isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启动SimpleHttpServer，一个客户端请求</span><br><span class="line">    public static void start() throws Exception &#123;</span><br><span class="line">        serverSocket = new ServerSocket(port);</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        //accept():3次握手结束，接受连接</span><br><span class="line">        while ((socket = serverSocket.accept()) != null) &#123;</span><br><span class="line">            // 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span><br><span class="line">            threadPool.execute(new HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class HttpRequestHandler implements Runnable &#123;</span><br><span class="line">        private Socket socket;</span><br><span class="line"></span><br><span class="line">        public HttpRequestHandler(Socket socket) &#123;</span><br><span class="line">            this.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            String line = null;</span><br><span class="line">            BufferedReader br = null;</span><br><span class="line">            BufferedReader reader = null;</span><br><span class="line">            PrintWriter out = null;</span><br><span class="line">            InputStream in = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">                // 由相对路径计算出绝对路径</span><br><span class="line">                String filePath = basePath + header.split(&quot; &quot;)[1];</span><br><span class="line">                out = new PrintWriter(socket.getOutputStream());</span><br><span class="line">                 // 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span><br><span class="line">                if (filePath.endsWith(&quot;jpg&quot;) || filePath.endsWith(&quot;ico&quot;)) &#123;</span><br><span class="line">                    in = new FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">                    int i = 0;</span><br><span class="line">                    while ((i = in.read()) != -1) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    byte[] array = baos.toByteArray();</span><br><span class="line">                    out.println(&quot;HTTP/1.1 200 OK&quot;);</span><br><span class="line">                    out.println(&quot;Server: yjx23332&quot;);</span><br><span class="line">                    out.println(&quot;Content-Type: image/jpeg&quot;);</span><br><span class="line">                    out.println(&quot;Content-Length: &quot; + array.length);</span><br><span class="line">                    out.println(&quot;&quot;);</span><br><span class="line">                    System.out.println(&quot;传回！&quot;);</span><br><span class="line">                    socket.getOutputStream().write(array, 0, array.length);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    br = new BufferedReader(new InputStreamReader(new</span><br><span class="line">                            FileInputStream(filePath)));</span><br><span class="line">                    out = new PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(&quot;HTTP/1.1 200 OK&quot;);</span><br><span class="line">                    out.println(&quot;Server: yjx23332&quot;);</span><br><span class="line">                    out.println(&quot;Content-Type: text/html; charset=UTF-8&quot;);</span><br><span class="line">                    out.println(&quot;&quot;);</span><br><span class="line">                    while ((line = br.readLine()) != null) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                out.println(&quot;HTTP/1.1 500&quot;);</span><br><span class="line">                out.println(&quot;&quot;);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 关闭流或者Socket</span><br><span class="line">    private static void close(Closeable... closeables) &#123;</span><br><span class="line">        if (closeables != null) &#123;</span><br><span class="line">            for (Closeable closeable : closeables) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleHttpServer提供设置端口和跟路径的方法，SimpleHttpServer在建立了与客户端的连接之后，并不会处理客户端的请求，而是将其包装成HttpRequestHandler并交由线程池处理。</p>
<p>在线程池中的Worker处理客户端请求的同时，SimpleHttpServer能够继续完成后续客户端连接的建立，不会阻塞后续客户端的请求。Worker处理请求资源生成响应内容后，异步输出内容到客户端。</p>
<p>html页面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;测试页面&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">&lt;body &gt;</span><br><span class="line">	&lt;h1&gt;第一张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;1.jpg&quot; /&gt;</span><br><span class="line">	&lt;h1&gt;第二张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;2.jpg&quot; /&gt;</span><br><span class="line">	&lt;h1&gt;第三张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;3.jpg&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>将SimpleHttpServer的根目录设定到该HTML页面所在目录，并启动SimpleHttpServer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    SimpleHttpServer.setBasePath(&quot;C:\Users\Administrator\Desktop\server&quot;);</span><br><span class="line">    SimpleHttpServer.setPort(8080);</span><br><span class="line">    SimpleHttpServer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️线程池中的线程不是越多越好：<br>线程池中线程数量并不是越多越好，具体的数量需要评估每个任务的处理时间，以及当前计算机的处理器能力和数量。使用的线程过少，无法发挥处理器的性能；使用的线程过多，将会增加系统的无故开销，起到相反的作用。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46949627/article/details/127009251">https://blog.csdn.net/weixin_46949627/article/details/127009251</a></p>
<h2 id="第五章-java中的锁"><a href="#第五章-java中的锁" class="headerlink" title="第五章 java中的锁"></a>第五章 java中的锁</h2><p>介绍java并发包中与锁相关的API和组件，以及这些API和组件的使用方式和实现细节。</p>
<h3 id="1-Lock接口"><a href="#1-Lock接口" class="headerlink" title="1.Lock接口"></a>1.Lock接口</h3><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。</p>
<h4 id="✅Lock接口和synchronized关键字的对比"><a href="#✅Lock接口和synchronized关键字的对比" class="headerlink" title="✅Lock接口和synchronized关键字的对比"></a>✅Lock接口和synchronized关键字的对比</h4><p>在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。</p>
<p>虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<p>使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。当然，这种方式简化了同步的管理，可是扩展性没有显示的锁获取和释放来的好。例如：先获得锁A，然后再获取锁B。</p>
<p>Lock的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。</p>
<p>Lock具备的sychronized关键字不具备的特点：<br>1、非阻塞地获取锁<br>2、能被中断地获取锁（获取到锁的线程能响应中断，中断异常被抛出，同时锁释放）<br>3、超时获取锁（截止时间无法获取锁，则返回）</p>
<h4 id="✅Lock接口中的API"><a href="#✅Lock接口中的API" class="headerlink" title="✅Lock接口中的API"></a>✅Lock接口中的API</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void lock()</span><br><span class="line">获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回</span><br><span class="line"></span><br><span class="line">void lockInterruptibly() throws InterruptedException	</span><br><span class="line">可中断地获取锁，和 lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程</span><br><span class="line"></span><br><span class="line">boolean tryLock()	</span><br><span class="line">尝试非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回true，否则返回false</span><br><span class="line"></span><br><span class="line">boolean tryLock(1ong time,TimeUnit unit) throws InterruptedException	</span><br><span class="line">超时的获取锁，当前线程在以下3种情况下会返回：①当前线程在超时时间内获得了锁 ②当前线程在超时时间内被中断 ③超时时间结束，返回false</span><br><span class="line"></span><br><span class="line">void unlock() </span><br><span class="line">释放锁</span><br><span class="line"></span><br><span class="line">Condition newCondition()	</span><br><span class="line">获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的 wait()方法，而调用后，当前线程将释放锁</span><br></pre></td></tr></table></figure>

<p>随后会详细介绍同步器AbstractQueuedSynchronizer以及常用Lock接口的实现ReentrantLock。Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。</p>
<h3 id="2-队列同步器"><a href="#2-队列同步器" class="headerlink" title="2.队列同步器"></a>2.队列同步器</h3><p>队列同步器 AbstractQueuedSynchronizer（AQS，以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<p>同步器提供的3个方法来对同步状态进行更改，它们能够保证状态的改变是安全的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getState()  获取当前同步状态。</span><br><span class="line">setState(int newState)  设置当前同步状态。</span><br><span class="line">compareAndSetState(int expect,int update)） 使用CAS设置当前状态，该方法能够保证状态</span><br></pre></td></tr></table></figure>

<p>子类通过继承同步器并实现它的抽象方法来管理同步状态，子类推荐被定义为自定义同步组件的静态内部类。同步器自身没有实现任何同步接口，它仅仅是定义了上面同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件：<br>ReentrantLock<br>ReentrantReadWriteLock<br>CountDownLatch</p>
<p>队列同步器与锁的关系：</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</p>
<p>1、锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节<br>2、同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<h4 id="✅队列同步器的接口与示例"><a href="#✅队列同步器的接口与示例" class="headerlink" title="✅队列同步器的接口与示例"></a>✅队列同步器的接口与示例</h4><p>同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器作为静态内部类组合在自定义同步组件的实现中，并调用同步器提供的模板方法。</p>
<p><strong>同步器可重写的方法</strong>，包含两种，一种是获取独占锁，一种是获取共享锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态，实现该方法需要查询当前状态，并判断同步状态是否符合预期，然后通过CAS设置同步状态（非阻塞的？）</span><br><span class="line"> */</span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式释放同步状态，此时等待获取同步状态的线程将有机会获取同步状态</span><br><span class="line"> */</span><br><span class="line">protected boolean tryRelease(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态，返回结果大于等于0，表示获取成功，否则获取失败</span><br><span class="line"> */</span><br><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式释放同步状态</span><br><span class="line"> */</span><br><span class="line">protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否被当前线程所独占</span><br><span class="line"> */</span><br><span class="line">protected boolean isHeldExclusively() &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自定义的同步器组件时，将会调用<strong>同步器提供的模板方法</strong>，同步器提供的模板方法分为三类：一是独占式获取与释放同步状态、二是共享式获取与释放同步状态、三是查询同步队列中等待线程的情况。自定义的同步器将使用这些提供的模板方法来实现自己的同步语义。同步器提供的模板方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 如果当前线程获取同步状态成功，则该方法执行完毕，否则，当前线程将会进入</span><br><span class="line"> * 同步队列等待，该方法将会调用重写的tryAcquire方法（区别：一个有返回，一个没有，输入没什么用？）</span><br><span class="line"> */</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 与acquire 相同，但是该方法响应中断，当前线程未获取到同步状态则进入同步队列；如果当前线程被中断，则该方法会抛出异常并返回</span><br><span class="line"> */</span><br><span class="line">public final void acquireInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 该方法在 acquireInterruptibly(int arg) 基础上增加了超时限制，如果当前线程在超时时间内没有获取同步状态，那么将返回false，否则返回true</span><br><span class="line"> */</span><br><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式释放同步状态</span><br><span class="line"> * 该方法会在释放同步状态后，将同步队列中第一个节点中的线程唤醒</span><br><span class="line"> */</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 与独占式的区别在于，同一时刻可以有多个线程获得同步状态</span><br><span class="line"> */</span><br><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 与方法acquireShared(int arg) 一样，只是该方法响应中断</span><br><span class="line"> */</span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 在方法 acquireSharedInterruptibly(int arg) 基础上，增加了超时限制</span><br><span class="line"> */</span><br><span class="line">public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquireShared(arg) &gt;= 0 ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式释放同步状态</span><br><span class="line"> */</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取在同步队列上等待的线程的集合</span><br><span class="line"> */</span><br><span class="line">public final Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">    ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();</span><br><span class="line">    for (Node p = tail; p != null; p = p.prev) &#123;</span><br><span class="line">        Thread t = p.thread;</span><br><span class="line">        if (t != null)</span><br><span class="line">            list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，独占锁是在同一时刻只能有一个线程获得锁，而其他获取锁的线程只能在同步队列中等待，只有持有锁的线程释放了，其他线程才能获得锁。<strong>独占锁的示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class Mutex implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态内部类自定义同步器</span><br><span class="line">     */</span><br><span class="line">    private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 是否处于独占状态</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean isHeldExclusively() &#123;</span><br><span class="line">            return getState() == 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 独占式获取锁，状态为0时获取锁</span><br><span class="line">         * 如果经过CAS设置成功（同步状态设置为1）</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            if (compareAndSetState(0, 1)) &#123;  //0是期望，1是更新</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 独占式释放锁，只是将状态置为0</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryRelease(int releases) &#123;</span><br><span class="line">            if (getState() == 0) &#123;</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 实例化一个 Condition，每个 Condition 都包含一个队列</span><br><span class="line">         */</span><br><span class="line">        Condition newCondition() &#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Sync sync = new Sync();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isLocked() &#123;</span><br><span class="line">        return sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasQueuedThreads() &#123;</span><br><span class="line">        return sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：<br>1、自定义定义独占锁实现Lock，所以需要实现Lock接口中的API<br>2、自定义同步器作为静态内部类继承自同步器，重写同步器方法，实现独占式获取和释放同步状态<br>3、Lock的API中使用同步器的重写方法/模版方法</p>
<p>在使用自定义同步器Mutex 时，不会直接与内部同步器交互，而是通过Mutex 提供的方法。</p>
<p>lock和tryLock的区别：<br>lock是非阻塞的，会一直尝试或锁，用acquire方法（内部用tryAcquire方法）线程调用该方法获取同步状态失败后会被加入到同步队列中等待；tryLock是阻塞的，获取一次，所以直接用tryAcquire方法。</p>
<p>Condition是什么？<br>ConditionObject 是AQS的内部类，用来维护等待队列<br>AQS内部实际上有两个队列<br>同步队列：公平/非公平，共享/非共享<br>等待队列：条件等待队列，也就是Condition<br>等待队列中就是用await方法时任务进入的队列（类似之前使用的wait，该队列中的任务只有唤醒才会尝试获取锁，以此减少CPU频繁的获取锁），通过signal唤醒。</p>
<h4 id="✅队列同步器的实现分析"><a href="#✅队列同步器的实现分析" class="headerlink" title="✅队列同步器的实现分析"></a>✅队列同步器的实现分析</h4><p>接下来将从实现角度分析同步器是如何完成线程同步的。<br>主要包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模板方法。</p>
<h5 id="一、同步队列"><a href="#一、同步队列" class="headerlink" title="一、同步队列"></a>一、同步队列</h5><p>同步器依赖内部的同步队列（一个FIFO双向队列,FIFO先进先出）来完成同步状态的管理。</p>
<p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node，它也是AQS的内部类）并将其加入同步队列的尾部，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</p>
<p>当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：<code>compareAndSetTail(Node expect,Node update)</code>，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p>
<p>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。（只有一个线程获取到同步状态，所以设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。）</p>
<h5 id="二、独占式同步状态获取和释放"><a href="#二、独占式同步状态获取和释放" class="headerlink" title="二、独占式同步状态获取和释放"></a>二、独占式同步状态获取和释放</h5><p>同步器的 <code>acquire(int arg)</code> 方法可以获取同步状态（阻塞型的，相当于是获锁），该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，<strong>线程不会从同步队列中移出</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">	if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作。首先tryAcquire非阻塞型地获取，如果获取到直接返回了，获取不到，就构造节点加入同步队列，在同步队列中会一直自旋尝试获取同步状态。</p>
<p>步骤：<br>1、调用自定义同步器实现的 tryAcquire(int arg) 方法，该方法保证线程安全的获取同步状态</p>
<p>2、如果同步状态获取失败，则构造同步节点（独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过 addWaiter(Node node) 方法将该节点加入到同步队列的尾部。</p>
<blockquote>
<p>enq(final Node node) 方法中，同步器通过 “死循环” 来保证节点的正确添加，在 “死循环” 中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线程不断地尝试设置。<br>可以看出，enq(final Node node) 方法将并发添加节点的请求通过CAS变得 “串行化” 了。</p>
</blockquote>
<p>3、节点进入同步队列之后，就进入了一个自旋的过程（acquireQueued(Node node,int arg) 方法），每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，代表获取了锁，否则依旧留在这个自旋过程中（并会阻塞节点的线程，阻塞线程也就是进入等待，自旋不停？）</p>
<blockquote>
<p>虽然同步队列中每个线程都会自旋，但是只有前驱节点是头节点才能够尝试获取同步状态：<br>头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。<br>维护同步队列的FIFO原则。</p>
</blockquote>
<p>4、如果获取不到则阻塞节点中的线程，而<strong>被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现</strong>。</p>
<blockquote>
<p>节点自旋，发现前驱不是头节点，就进入等待状态，只有线程被中断或前驱节点被释放才会再判断是不是前驱是头节点。前驱是头节点后，获取同步状态，如果获取失败，则进入等待状态。（几个等待状态应该不一样？）</p>
</blockquote>
<p>独占式同步状态获取流程，见P128</p>
<p>5、线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。调用同步器的 release(int arg) 模版方法（内部用tryRelease重写方法）可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // 尝试释放锁</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        //头节点不为空或者状态不是0</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            // 唤醒后继节点</span><br><span class="line">            unparkSuccessor(h);  //用来唤醒处于等待状态的线程</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>独占式同步状态获取和释放过程总结：<br>1、在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被自旋地加入到队列中并在队列中进行自旋<br>2、移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。<br>3、如果线程被中断，只是会唤醒被阻塞线程，是不会立刻被移出队列的，而是FIFO到该节点才移出。<br>4、不管是获取还是释放，都是模版方法里调用了重写的try方法。acquire是阻塞的，tryAcquire是非阻塞的，试一次，会返回是否成功。</p>
<p>疑问❓：<br>同步队列中节点的自旋和线程被阻塞的关系是什么？自旋发现前驱节点不是头节点或者获取不到同步状态的话，会阻塞线程，阻塞后是依靠前驱节点释放同步状态后唤醒或是中断唤醒还是一直自旋？</p>
<h5 id="三、共享式同步状态获取与释放"><a href="#三、共享式同步状态获取与释放" class="headerlink" title="三、共享式同步状态获取与释放"></a>三、共享式同步状态获取与释放</h5><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，读可以是共享锁，可以同时读，写是独占锁，一个在写，其他既不能读也不能写。</p>
<p>在 acquireShared(int arg) 方法中，同步器调用 tryAcquireShared(int arg) 方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    // 小于零获取锁失败</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    // 共享模式加入同步队列</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 如果前一个线程为头结点</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                // 尝试获取锁</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                // 成功</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    // 将自己设置为头节点同时，传播状态，r就是之前返回的值</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null;</span><br><span class="line">                    // 如果过被当前线程状态为true，就设置当前线程的中断状态</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 逻辑同前</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 逻辑同前</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用releaseShared(int arg)方法可以释放同步状态:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 尝试释放锁</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 成功就修改自己节点状态</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。因为可能多个线程获取锁，所以，它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p>
<h5 id="四、独占式超时获取同步状态"><a href="#四、独占式超时获取同步状态" class="headerlink" title="四、独占式超时获取同步状态"></a>四、独占式超时获取同步状态</h5><p>通过调用同步器的 doAcquireNanos(int arg,long nanosTimeout) 【模版方法】方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。</p>
<p>在Java 5之前，当一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧会阻塞在synchronized上，等待着获取锁。</p>
<p>在Java 5中，同步器提供了acquireInterruptibly(int arg)方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出InterruptedException。</p>
<p>超时获取同步状态过程可以被视作响应中断获取同步状态过程的“增强版”，doAcquireNanos(int arg,long nanosTimeout)方法在支持响应中断的基础上，增加了超时获取的特性。</p>
<p>该方法在自旋过程中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。</p>
<p>如果当前线程获取同步状态失败，则判断是否超时（nanosTimeout小于等于0表示已经超时），如果没有超时，重新计算超时间隔nanosTimeout，然后使当前线程等待 nanosTimeout 纳秒（当已到设置的超时时间，该线程会从LockSupport.parkNanos(Object<br>blocker,long nanos)方法返回）。</p>
<p><strong>总结：</strong><br>独占式超时获取同步状态doAcquireNanos(int arg,long nanosTimeout)和独占式获取同步状态acquire(int args)在流程上非常相似，其主要区别在于未获取到同步状态时的处理逻辑：<br>1、acquire(int args)在未获取到同步状态时，将会使当前线程一直处于等待状态<br>2、doAcquireNanos(int arg,long nanosTimeout)会使当前线程等待nanosTimeout纳秒，如果当前线程在nanosTimeout纳秒内没有获取到同步状态，将会从等待逻辑中自动返回。</p>
<h5 id="五、自定义同步组件——TwinsLock"><a href="#五、自定义同步组件——TwinsLock" class="headerlink" title="五、自定义同步组件——TwinsLock"></a>五、自定义同步组件——TwinsLock</h5><p>设计一个同步工具：该工具在同一时刻，只允许至多两个线程同时访问，超过两个线程的访问将被阻塞。</p>
<p>TwinsLock在同一时刻允许至多两个线程的同时访问，表明同步资源数为2，这样可以设置初始状态status为2，当一个线程进行获取，status减1，该线程释放，则status加1，状态的合法范围为0、1和2，其中0表示当前已经有两个线程获取了同步资源，此时再有其他线程对同步状态进行获取，该线程只能被阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class TwinsLock implements Lock &#123;</span><br><span class="line">    private final Sync sync = new Sync(2);</span><br><span class="line"></span><br><span class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            if (count &lt;= 0) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;count must large than zero.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 在本方法中，用状态去代指资源数目</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int tryAcquireShared(int reduceCount) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                int newCount = current - reduceCount;</span><br><span class="line">                if (newCount &lt; 0 || compareAndSetState(current,newCount)) &#123;</span><br><span class="line">                	// 返回当前剩余资源</span><br><span class="line">                    return newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean tryReleaseShared(int returnCount) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                // 当前数目 + 释放数目</span><br><span class="line">                int newCount = current + returnCount;</span><br><span class="line">                if (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">    	// 获取共享锁，state + 1</span><br><span class="line">    	// 使用的是node节点的方法</span><br><span class="line">        sync.acquireShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 释放共享锁 -1</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 其他接口方法略</span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, @NotNull TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    @NotNull</span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：<br>1、TwinsLock实现Lock接口，提供面向使用者的接口，使用者调用lock()<br>方法获取锁，随后调用unlock()方法释放锁，而同一时刻只能有两个线程同时获取到锁。<br>2、自定义同步器Sync作为静态内部类，该同步器面向线程访问和同步状态控制。共享式获取同步状态。<br>3、重写tryAcquireShared(int reduceCount)等方法，内部用过CAS确保状态的正确设置。acquireShared方法里是判断tryAcquireShared方法返回值大于等于0时，当前线程才获取同步状态。</p>
<p>总结：<br>1、acquireShared方法里输入的int，都是1呢。啥意思？<br>2、同步器作为一个桥梁，连接线程访问以及同步状态控制等底层技术与不同并发组件（比如Lock、CountDownLatch等）的接口语义。</p>
<p>测试类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line">public class TwinsLockTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        final Lock lock = new TwinsLock();</span><br><span class="line">        class Worker extends Thread &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName());</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        throw new RuntimeException(e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 启动10个线程</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Worker w = new Worker();</span><br><span class="line">            w.setDaemon(true);</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">        // 每隔1秒换行</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程名称成对输出，在同一时刻只有两个线程能够获取到锁。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46949627/article/details/127078972">https://blog.csdn.net/weixin_46949627/article/details/127078972</a><br><a target="_blank" rel="noopener" href="http://t.zoukankan.com/liukaifeng-p-10052596.html">http://t.zoukankan.com/liukaifeng-p-10052596.html</a><br>Lock和sychronized区别：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41010294/article/details/123528508">https://blog.csdn.net/weixin_41010294/article/details/123528508</a></p>
<h3 id="3-重入锁"><a href="#3-重入锁" class="headerlink" title="3.重入锁"></a>3.重入锁</h3><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</p>
<p>上一节的独占锁示例中，调用Mutex的lock()方法获取锁之后，如果再次调用lock()方法，则该线程将会被自己所阻塞，原因是Mutex在实现tryAcquire(int acquires)方法时没有考虑占有锁的线程再次获取锁的场景，而在调用tryAcquire(int acquires)方法时返回了false，导致该线程被阻塞。</p>
<p>所以说，Mutex是一个不支持重进入的锁。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，而不像Mutex由于获取了锁，而在下一次获取锁时出现阻塞自己的情况。</p>
<p>重入锁：在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p>
<p>公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。</p>
<h4 id="✅实现重进入"><a href="#✅实现重进入" class="headerlink" title="✅实现重进入"></a>✅实现重进入</h4><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。</p>
<p>1、线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</p>
<p>2、锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</p>
<p>非公平锁获取的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 非公平锁获取</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    // 当前线程</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    // 获取锁状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 0 代表无锁</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        // 设置状态</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            // 设置独享锁的拥有者</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    // 如果当前线程是独有线程的线程ID</span><br><span class="line">    &#125; else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        // 是则增加次数</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        //设置</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。成功获取锁的线程再次获取锁，只是增加了同步状态值.</p>
<p>非公平锁释放的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    // 减去释放的值</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    // 如果当前线程不是拥有者</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 是否完全释放</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 如果是 0 则完全释放</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        // 抹去拥有者</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p>
<h4 id="✅公平与非公平获取锁的区别"><a href="#✅公平与非公平获取锁的区别" class="headerlink" title="✅公平与非公平获取锁的区别"></a>✅公平与非公平获取锁的区别</h4><p>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。</p>
<p>对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同。判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。<br>【因此，上面的独占锁和共享锁也都是公平的】</p>
<p>测试公平和非公平锁在获取锁时的区别，五个线程循环获取锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class FairAndUnfairTest &#123;</span><br><span class="line">    private static Lock fairLock = new ReentrantLock2(true);</span><br><span class="line">    private static Lock unfairLock = new ReentrantLock2(false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void fair() &#123;</span><br><span class="line">        testLock(fairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void unfair() &#123;</span><br><span class="line">        testLock(unfairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void testLock(Lock lock)&#123;</span><br><span class="line">        // 启动5个Job</span><br><span class="line">        for(int i = 0; i &lt; 5;i++)&#123;</span><br><span class="line">            new Job(lock).start();</span><br><span class="line">        &#125;</span><br><span class="line">        while (true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Job extends Thread &#123;</span><br><span class="line">        private Lock lock;</span><br><span class="line"></span><br><span class="line">        public Job(Lock lock) &#123;</span><br><span class="line">            this.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 连续2次打印当前的Thread和等待队列中的Thread</span><br><span class="line">                lock.lock();</span><br><span class="line">                ReentrantLock2 reentrantLock2 = (ReentrantLock2) lock;</span><br><span class="line">                System.out.println(&quot;Fair:&quot; + reentrantLock2.isFair() + &quot;,Lock By 【&quot; + Thread.currentThread().getName() + &quot;】，waitting by  &quot; + reentrantLock2.getQueuedThreads().toString());</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ReentrantLock2 extends ReentrantLock &#123;</span><br><span class="line">        public ReentrantLock2(boolean fair) &#123;</span><br><span class="line">            super(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">            List&lt;Thread&gt; arrayList = new ArrayList&lt;Thread&gt;(super.getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);</span><br><span class="line">            return arrayList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、公平性锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁出现了一个线程连续获取锁的情况。（刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待。）</p>
<p>2、公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平锁虽然可能造成线程饥饿，但是极少的线程切换，保证了其更大的吞吐量。</p>
<h3 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4.读写锁"></a>4.读写锁</h3><p>之前提到锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升，提供写操作对读操作的可见性以及并发性的提升。</p>
<p>适用场景：在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。</p>
<p>在没有读写锁支持的（Java 5之前）时候，如果需要完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。</p>
<h4 id="✅读写锁的接口和示例"><a href="#✅读写锁的接口和示例" class="headerlink" title="✅读写锁的接口和示例"></a>✅读写锁的接口和示例</h4><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方法，而其实现——ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Cache &#123;</span><br><span class="line">    static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    static Lock r = rwl.readLock();</span><br><span class="line">    static Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    // 获取一个key对应的value</span><br><span class="line">    public static final Object get(String key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置key对应的value，并返回旧的value</span><br><span class="line">    public static final Object put(String key, Object value) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清空所有的内容</span><br><span class="line">    public static final void clear() &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个非线程安全的HashMap作为缓存,使用读写锁的读锁和写锁来保证Cache是线程安全的.Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性，同时简化了编程方式。</p>
<h4 id="✅读写锁的实现分析"><a href="#✅读写锁的实现分析" class="headerlink" title="✅读写锁的实现分析"></a>✅读写锁的实现分析</h4><h5 id="一、读写状态的设计"><a href="#一、读写状态的设计" class="headerlink" title="一、读写状态的设计"></a>一、读写状态的设计</h5><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。</p>
<p>回想ReentrantLock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，如果在一个整型变量上维护多种状态，就一定需要 “按位切割使用” 这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。</p>
<p>通过位运算可以迅速确定读和写各自的状态，假设当前同步状态值为 S ，写状态等于 S&amp;0x0000FFFF （将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。</p>
<h5 id="二、写锁的获取与释放"><a href="#二、写锁的获取与释放" class="headerlink" title="二、写锁的获取与释放"></a>二、写锁的获取与释放</h5><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    // 锁状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 通过状态计算写锁数量</span><br><span class="line">    int w = exclusiveCount(c);</span><br><span class="line">    // 锁不为0，说明有读或者写</span><br><span class="line">    if (c != 0) &#123;</span><br><span class="line">        // 写锁不存在（说明现在是读锁）或者当前获取线程不是已经获取写锁的线程</span><br><span class="line">        if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">            return false;</span><br><span class="line">        // 如果重入次数大于最大冲入数目</span><br><span class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 尝试获取写锁</span><br><span class="line">    // writerShouldBlock：公平锁会调用 hasQueuedPredecessors判断轮得到自己吗，非公平直接返回false去竞争锁</span><br><span class="line">    //  compareAndSetState 失败就会返回false</span><br><span class="line">    if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置当前线程拥有锁</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。</p>
<p>如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>
<p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p>
<h5 id="三、读锁的获取与释放"><a href="#三、读锁的获取与释放" class="headerlink" title="三、读锁的获取与释放"></a>三、读锁的获取与释放</h5><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在 没有其他写线程访问（或者写状态为0） 时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。</p>
<p>获取读锁的实现从Java 5到Java 6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount() 方法，作用是返回当前线程获取读锁的次数。由于读状态是 所有线程获取读锁次数的总和 ，所以每个线程 各自获取读锁的次数只能选择保存在ThreadLocal中 ，由线程自身维护，于是使获取读锁的实现变得复杂。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        // 获取锁状态</span><br><span class="line">        int c = getState();</span><br><span class="line">        // 读数目+1</span><br><span class="line">        int nextc = c + (1 &lt;&lt; 16);</span><br><span class="line">        // 溢出</span><br><span class="line">        if (nextc &lt; c)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        // 现在是写状态 且 拥有者不是自己</span><br><span class="line">        if (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">            return -1;</span><br><span class="line">        // 修改状态</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</p>
<p>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1&lt;&lt;16）。</p>
<h5 id="四、锁降级"><a href="#四、锁降级" class="headerlink" title="四、锁降级"></a>四、锁降级</h5><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void processData() &#123;</span><br><span class="line">		//锁住读锁</span><br><span class="line">        readLock.lock();</span><br><span class="line">        // 数据在更新吗</span><br><span class="line">        if (!update) &#123;</span><br><span class="line">			// 必须先释放读锁</span><br><span class="line">            readLock.unlock();</span><br><span class="line">			// 锁降级从写锁获取到开始</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!update) &#123;</span><br><span class="line">					// 准备数据的流程（略）</span><br><span class="line">                    update = true;</span><br><span class="line">                &#125;</span><br><span class="line">                //开始降级</span><br><span class="line">                readLock.lock();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">            	// 锁降级完成，写锁降级为读锁</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">			// 使用数据的流程（略）</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>锁降级：先获取写锁，变更数据，再获取读锁，再释放写锁。此时还有读锁，还可以读数据，其他线程也可以获取读锁读数据。<br>这样变更完数据之后，可以多个读线程一起读取数据。</p>
<p>不支持锁升级：有线程获取读锁的时候，不能获取写锁，数据更新对其他线程的可见性。</p>
<h3 id="5-LockSupport工具"><a href="#5-LockSupport工具" class="headerlink" title="5.LockSupport工具"></a>5.LockSupport工具</h3><p>队列同步器中，当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作。LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。</p>
<p>在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。</p>
<p>比如说，线程dump结果结果中，有阻塞对象的parkNanos方法能够传递给开发人员阻塞对象的信息。</p>
<p>为什么要加阻塞对象信息？<br>由于在Java 5之前，当线程阻塞（使用synchronized关键字）在一个对象上时，通过线程dump能够查看到该线程的阻塞对象，方便问题定位，而Java 5推出的Lock等并发工具时却遗漏了这一点，致使在线程dump时无法提供阻塞对象的信息。因此，在Java 6中，LockSupport新增了上述3个含有阻塞对象的park方法，用以替代原有的park方法。</p>
<h3 id="6-Condition接口"><a href="#6-Condition接口" class="headerlink" title="6.Condition接口"></a>6.Condition接口</h3><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。</p>
<p>Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的：<br>1、前置条件不但要获取锁，还要调用<code>Lock.newCondition()</code>获取Condition对象<br>2、等待队列支持多个<br>3、支持超时等待状态<br>4、支持在等待状态中不响应中断（可以对中断不敏感）</p>
<p>总结一下：<br>synchronized + Object监视器方法 - 实现等待通知 - 案例线程池<br>Lock(队列同步器) + Condition接口 - 实现等待通知 - 案例有界队列<br>可以直接使用synchronized实现同步<br>可以直接使用Lock实现锁，只不过只有同步队列，里面线程是阻塞状态，没有等待队列</p>
<h4 id="✅Condition接口与示例"><a href="#✅Condition接口与示例" class="headerlink" title="✅Condition接口与示例"></a>✅Condition接口与示例</h4><p>Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。</p>
<p>Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。</p>
<p>等待通知模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">public void conditionWait() throws InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void conditionSignal() throws InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Condition对象作为成员变量。通过Lock的newCondition()方法</p>
<p>当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
<p>Condition接口方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">await() ：造成当前线程在接到信号或被中断之前一直处于等待状态，对中断敏感。</span><br><span class="line">await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span><br><span class="line">awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。</span><br><span class="line">awaitUninterruptibly() ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。</span><br><span class="line">awaitUntil(Date deadline) ：造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返回false。</span><br><span class="line">signal() ：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。</span><br><span class="line">signalAll() ：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。</span><br></pre></td></tr></table></figure>

<p>有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程（进入等待队列），直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”。有点像线程池。</p>
<p>线程池：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class BoundedQueue&lt;T&gt; &#123;</span><br><span class="line">    private Object[] items;</span><br><span class="line">    // 添加的下标，删除的下标和数组当前数量</span><br><span class="line">    private int addIndex, removeIndex, count;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    private Condition notEmpty = lock.newCondition();</span><br><span class="line">    private Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public BoundedQueue(int size) &#123;</span><br><span class="line">        items = new Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加一个元素，如果数组满，则添加线程进入等待状态，直到有&quot;空位&quot;</span><br><span class="line">    public void add(T t) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[addIndex] = t;</span><br><span class="line">            if (++addIndex == items.length)</span><br><span class="line">                addIndex = 0;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public T remove() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[removeIndex];</span><br><span class="line">            if (++removeIndex == items.length)</span><br><span class="line">                removeIndex = 0;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return (T) x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以添加方法为例：首先需要获得锁，目的是确保数组修改的可见性和排他性。当数组数量等于数组长度时，表示数组已满，则调用notFull.await()，当前线程随之释放锁并进入等待状态。如果数组数量不等于数组长度，表示数组未满，则添加元素到数组中，同时通知等待在notEmpty上的线程，数组中已经有新元素可以获取。</p>
<p>在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。回想之前提到的等待/通知的经典范式，二者是非常类似的。</p>
<p>⚠️线程的阻塞、等待的区别：<br>在java中，线程阻塞状态是线程本身不可计划的，而线程等待状态是线程本身计划之内的。<br>相同点：<br>（1）都会暂停线程的执行。<br>区别点：<br>（1）线程进入阻塞状态是被动的, 而线程进入等待状态是主动的。<br>阻塞状态的被动：线程在同步代码外，获取对象锁失败时，线程进入阻塞状态；何时获取对象锁失败不可知，即线程阻塞状态是线程本身不可计划的。<br>等待状态的主动：线程在同步代码内await，等待其他线程唤醒时，线程接入等待状态；何时等待其他线程操作可知，即线程等待状态是线程本身计划之内的。</p>
<h4 id="✅Condition的实现分析"><a href="#✅Condition的实现分析" class="headerlink" title="✅Condition的实现分析"></a>✅Condition的实现分析</h4><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。</p>
<p>每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。</p>
<h5 id="一、等待队列"><a href="#一、等待队列" class="headerlink" title="一、等待队列"></a>一、等待队列</h5><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</p>
<p>等待队列：当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p>
<p>在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列（每个Condition对象一个）。</p>
<h5 id="二、等待"><a href="#二、等待" class="headerlink" title="二、等待"></a>二、等待</h5><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p>
<p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</p>
<p>ConditionObject的await方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 当前线程加入等待队列</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    // 释放同步状态，也就是释放锁</span><br><span class="line">    int savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    // 节点是否在同步队列中</span><br><span class="line">    // Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.</span><br><span class="line">    // 如果节点在同步队列中，现在等待重新去获取锁，返回true</span><br><span class="line">    // 一般总是在条件队列</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        // 暂停自己，等待被唤醒或者被中断</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        // 是否被中断了</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取锁成功且异常模式不为THROW_IE，就修改interruptMode</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    // 该方法是内部类Condition中的，设置下一个在首位的等待者</span><br><span class="line">    if (node.nextWaiter != null)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    // 如果interruptMode 不是0，唤醒后报告中断</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。（同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。）</p>
<p>（2）当等待队列中的节点被唤醒，则唤醒节点的线程进入同步队列，开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p>
<h5 id="三、通知"><a href="#三、通知" class="headerlink" title="三、通知"></a>三、通知</h5><p>调用Condition的signal()方法的前置条件是当前线程必须获取了锁，将在等待队列中等待时间最长的节点（首节点），线程安全地移动到同步队列，并使用LockSupport唤醒节点中的线程，然后就竞争锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    // 锁是否处于占用状态</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 获取第一个线程</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        // 唤醒</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。</p>
<p>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。如果未获取到锁，将在同步队列中阻塞。</p>
<p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>
<h2 id="第六章-java并发容器和框架"><a href="#第六章-java并发容器和框架" class="headerlink" title="第六章 java并发容器和框架"></a>第六章 java并发容器和框架</h2><h3 id="1-ConcurrentHashMap的实现原理与使用"><a href="#1-ConcurrentHashMap的实现原理与使用" class="headerlink" title="1.ConcurrentHashMap的实现原理与使用"></a>1.ConcurrentHashMap的实现原理与使用</h3><p>ConcurrentHashMap是线程安全且高效的HashMap。</p>
<h4 id="✅为什么使用ConcurrentHashMap"><a href="#✅为什么使用ConcurrentHashMap" class="headerlink" title="✅为什么使用ConcurrentHashMap"></a>✅为什么使用ConcurrentHashMap</h4><p>（1）<strong>HashMap线程不安全会死循环</strong></p>
<p>HashMap 在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(2); // 容量为2的Map</span><br><span class="line">Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i=0;i&lt;10000;i++)&#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    map.put(UUID.randomUUID().toString(),&quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;ftf&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&quot;ftf&quot;);</span><br><span class="line">thread.start();</span><br><span class="line">thread.join();</span><br></pre></td></tr></table></figure>

<p>HashMap的实现原理：<br>HashMap的主干是一个Entry数组（Entry是以链表的形式存储的）。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。(其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合)。</p>
<p>Entry结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next; // 存储指向下一个Entry的引用，单链表结构。</span><br><span class="line"> </span><br><span class="line">    int hash;	   // 对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以：HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p>HashMap在put的时候，插入的元素超过了容量(由负载因子决定)的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在其他的元素也在put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</p>
<p>HashMap的线程不安全主要体现在会造成死循环，数据丢失，数据覆盖这些问题。其中死循环和数据丢失是在JDK1.7中出现的问题，在Jdk1.8中已经得到解决，然而JDK1.8仍会有数据覆盖这样的问题。</p>
<p>（2）<strong>效率低下的HashTable</strong></p>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其它线程也访问HashTable的同步方法时，会进入阻塞或轮询状态，所以竞争越激烈效率越低。</p>
<p>（3）ConcurrentHashMap的锁分段技术可有效提升并发访问率。</p>
<p>HashTable的线程都必须竞争同一把锁，假如容器里有多把锁每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其它段的数据也能被其他线程访问。</p>
<h4 id="✅ConcurrentHashMap的结构"><a href="#✅ConcurrentHashMap的结构" class="headerlink" title="✅ConcurrentHashMap的结构"></a>✅ConcurrentHashMap的结构</h4><p>类图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁(ReentrantLock),在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。<strong>一个Segment里包含一个HashEntry数组</strong>，<strong>每个HashEntry是一个链表结构的元素（一个包含数据的链表）</strong>，每个Segment里守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p>
<h4 id="✅ConcurrentHashMap的初始化与定位"><a href="#✅ConcurrentHashMap的初始化与定位" class="headerlink" title="✅ConcurrentHashMap的初始化与定位"></a>✅ConcurrentHashMap的初始化与定位</h4><p>ConcurrentHashMap初始化方法是通过initialCapacity, loadFactor和concurrencyLevel等几个参数来初始化segment数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组来实现。</p>
<p>ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到Segment。而且，会使用再散裂算法对元素的hashCode进行一次再散列。</p>
<p>再散列的目的：减少散列冲突，使元素均匀地分布在不同的segmrnt上，提高容器的存取效率。</p>
<h4 id="✅ConcurrentHashMap的操作"><a href="#✅ConcurrentHashMap的操作" class="headerlink" title="✅ConcurrentHashMap的操作"></a>✅ConcurrentHashMap的操作</h4><p>（1）get(key)</p>
<p>经过一次再散列，先定位到segment，然后再通过散列运算定位到元素。<br>不需要加锁，除非读到的值是空的才会加锁重读。原因是：将共享变量（segment大小、HashEntry里的value）定义为volatile。利用volatile在多线程中的可见性，可以被多线程读，保证不会读到过期的值。</p>
<p>（2）put(key, value)</p>
<p>先定位到segment，然后在segment里进行插入操作。分两步：<br>1.是否需要扩容？<br>先判断HashEntry数组是否超过阈值，如果超过了就扩容，扩容之后再插入数据。而HashMap是先插入再扩容，这样不好，因为下次可能就没有数据进来了，那就白扩容了。<br>2.如何扩容？<br>先创建一个容量是原来2倍的数组，然后通过对原数组元素进行再散列后插入到新数组。扩容只会对某个segment进行。</p>
<p>（3）size()</p>
<p>Segment中有一个全局变量count是一个volatile变量，可以累加各个segment的count来计算大小。但是可能累加前count发生了变化，统计结果不准。但是锁住所有的segment再计算也不合适。</p>
<p>在每个segment中有一个volatile修饰的count属性，表示这个segment中的元素个数，先通过2次不加锁的方法统计所有count的总和，如果两次结果不相等，或者容器被修改过了，就将Segment加锁，再进行第三次统计。</p>
<p>ConcurrentHashMap中有一个modCount变量，每次put\remove\clean操作，都会对这个值加一，通过比较这个值，就知道是否容器是否被修改了。</p>
<h3 id="2-ConcurrentLinkedQueue"><a href="#2-ConcurrentLinkedQueue" class="headerlink" title="2.ConcurrentLinkedQueue"></a>2.ConcurrentLinkedQueue</h3><p>无界线程安全队列。</p>
<p>在并发编程中，有时候需要使用线程安全的对列。如果要实现一个线程安全的对列有2种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的对列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。【锁也是基于CAS和volatile来实现的吧】</p>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全对列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到对列的尾部；当我们获取一个元素时，它会返回对列头部的元素。它采用了”wait-free”算法(即CAS算法)来实现。</p>
<h4 id="✅ConcurrentLinkedQueue的结构"><a href="#✅ConcurrentLinkedQueue的结构" class="headerlink" title="✅ConcurrentLinkedQueue的结构"></a>✅ConcurrentLinkedQueue的结构</h4><p>ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素(item)和指向下一个节点(next)的引用组成，节点和节点之间就是通过这个next关联起来，从而组成一张链表结构的对列。默认情况下head节点存储的元素为空，tail节点等于head节点。</p>
<p>继承了AbstractQueue，不是阻塞队列。</p>
<p>ConcurrentLinkedQueue由head节点和tail节点组成。head、tail、next、item均使用volatile修饰，保证其内存可见性。</p>
<h4 id="✅入队列-offer-E-e"><a href="#✅入队列-offer-E-e" class="headerlink" title="✅入队列:offer(E e)"></a>✅入队列:offer(E e)</h4><p>入队列就是将入队节点添加到对列的尾部。入队主要做两件事情：<br>第一：是将入队节点设置成当前队列尾节点的下一个节点；<br>第二：是更新tail节点，如果tail节点的next不为空，则将入队节点设置为tial节点，成为队尾节点的next节点，如果tail节点的next为空，则将入队节点的设置为tail的next节点。所以tail节点不总是尾节点。【效果是两格两格得跳】</p>
<p>1.定位尾节点<br>tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能是tail节点，也可能是tail节点的next节点。</p>
<p>2.设置入队节点为尾节点<br>p.casNext(null,n)方法用于将入队节点设置为当前对尾节点的next节点，如果p是null，表示p是当前节点的尾节点，如果不为null，表示有其它线程更新了尾节点，则需要重新获取当前对列的尾节点。</p>
<p>⚠️不是每次入队都更新tail节点：<br>如果将tail节点永远作为尾节点，这样每次都需要循环CAS更新tail节点，而设置一个到尾节点的距离，当tail到尾节点的距离大于某个值（通常为1）的时候再更新tail，这样可以减少更新的次数，提高入队的效率。定位尾节点时就需要增加对volatile变量读操作，但是对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p>
<p><strong>入队方法永远返回true，所以不要通过返回值判断入队是否成功。</strong></p>
<h4 id="✅出队列：poll"><a href="#✅出队列：poll" class="headerlink" title="✅出队列：poll()"></a>✅出队列：poll()</h4><p>不是每次出队都更新head节点，当head中有元素，就直接弹出head的元素，如果没有元素，就弹出head的next，然后更新head节点，head节点变为弹出节点的next节点。【一次走两格】<br>也是通过控制距离的方式，减少CAS更新节点的消耗。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/22/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/idea%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/22/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/idea%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Idea日常使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-22 21:43:06" itemprop="dateCreated datePublished" datetime="2022-07-22T21:43:06+08:00">2022-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-25 22:12:50" itemprop="dateModified" datetime="2022-08-25T22:12:50+08:00">2022-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="替换文字"><a href="#替换文字" class="headerlink" title="替换文字"></a>替换文字</h2><p>command + R ：当前文件替换<br>command + shift + R ：全局文件替换</p>
<h2 id="字符编码问题"><a href="#字符编码问题" class="headerlink" title="字符编码问题"></a>字符编码问题</h2><p>换行符：LF<br>编码：UTF-8<br>提交代码之后中文乱码：设置里 File Encodings 里的都选UTF-8，Transparent native-to-ascii conversion（透明转换为ascii）不勾选。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/03/myblog/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/03/myblog/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/python/" class="post-title-link" itemprop="url">python语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-07-03 16:22:40 / Modified: 23:07:55" itemprop="dateCreated datePublished" datetime="2022-07-03T16:22:40+08:00">2022-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>✅计算机组成：<br>硬件：中央处理器CPU（处理指令、运算数据的）、存储器（内存（存临时数据读写速度快）、外存（硬盘、U盘））、输入设备、输出设备<br>软件：应用软件、系统软件（操作系统）</p>
<p>✅编译型语言和解释型语言：</p>
<ul>
<li><p>编译型语言：在执行之前要先经过编译过程，编译成为一个可执行的机器语言的文件，比如exe。因为翻译只做一遍，以后都不需要翻译，所以执行效率高。<br>  代表：C、C++<br>  优缺点：执行速度快、跨平台差（操作一步，与操作系统联系紧密）、不便调试。</p>
</li>
<li><p>解释型语言：解释性语言编写的程序不进行预先编译，以文本方式存储程序代码。执行时才翻译执行。程序每执行一次就要翻译一遍。解释一句，执行一句，直至结束。<br>  代表：Java、C#、Python、JavaScript<br>  优缺点：速度较慢、跨平台好（操作两步，跨平台有优势，可在windows上运行，也可在linux上运行）、易于调试</p>
</li>
</ul>
<p>怎么选：<br>编译型语言由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object Pascal（Delphi）等都是编译语言。</p>
<p>而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如Java、JavaScript、VBScript、Perl、Python、Ruby、MATLAB等等。</p>
<p>一个比较好的例子：编译型语言就像炒菜吃饭，只有将全部的菜炒好了才能吃饭，解释型语言就像吃火锅，边放菜边吃，不需要将菜全部放在火锅里面。</p>
<p>✅java是解释型语言，javac编译成.class字节码文件是？<br>java的编译器（javac.exe）先将java文件编译为class文件，也就是字节码；然后将字节码交由jvm(java虚拟机)解释执行；<br>所以很多地方都说“java是一种半编译、半解释执行”的语言；</p>
<p>java是解释型的语言，因为虽然java也需要编译，编译成.class文件，<br>但是并不是机器可以识别的语言，而是字节码，最终还是需要 jvm的解释（逐行解释为特定平台机器码），才能在各个平台执行，这同时也是java跨平台的原因。<br>所以可以说java即是编译型的，也是解释型，但是假如非要归类的话，从概念上的定义，恐怕java应该归到解释型的语言中。</p>
<p>✅编译器和解释器之间的主要区别<br>1、编译器将一个程序作为一个整体进行翻译，而解释器则一条一条地翻译一个程序<br>2、在编译器的情况下生成中间代码或目标代码。而解释器不创建中间代码<br>3、编译器比解释器要快得多，因为编译器一次完成整个程序，而解释器则是依次编译每一行代码<br>4、由于要生成目标代码，编译器比解释器需要更多的内存<br>5、编译器同时显示所有错误，很难检测错误，而解释器则逐个显示每条语句的错误，更容易检测错误<br>6、在编译器中，当程序中出现错误时，它会停止翻译，并在删除错误后重新翻译整个程序。相反，当解释器中发生错误时，它会阻止其翻译，在删除错误后，翻译将继续<br>7、在编译器中，这个过程需要两个步骤，首先将源代码翻译成目标程序，然后执行。而在解释器中，这是一个一次性的过程，源代码在编译的同时执行<br>8、编译器用于编程语言，如C、c++、c#、Scala等。解释器用于PHP、Ruby、Python等语言。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CodeHouse/article/details/121846119">https://blog.csdn.net/CodeHouse/article/details/121846119</a></p>
<p>✅脚本语言（动态语言）和静态语言</p>
<p>脚本语言:又被称为扩建的语言，或者动态语言，用来控制软件应用程序，脚本通常以文本保存，只 在被调用时进行解释或编译。脚本语言有:PHP、Python、JavaScript、Lua、Scala、VBScript， ActionScript，MAXScript，ASP，JSP，SQL，Perl，Shell，Ruby，JavaFX，AutoIt等 脚本语言是一种解释性的语言，它不象c/c++等可以编译成二进制代码，以可执行文件的形式存在，脚本 语言不需要编译，可以直接用，由解释器来负责解释。在运行时才确定数据类型的语言。</p>
<p>静态语言:要求在使用变量之前必须声明数据类型。 例如:C、C++、Golang、Java、C#等。 </p>
<p>so：脚本语言一定是解释型语言，解释型语言不一定是脚本语言。</p>
<p>✅Python解释器：<br>CPU不能直接处理 Python 语言，只能直接处理机器指令语言，那是一种由0和1数字组成的语言。.py结尾的文件需要解释器去运行执行。解释器就是能够执行用其他计算机语言编写的程序的系统软件，它是一种翻译程序。它的执行方式是一边翻译一边执行，因此其执行效率一般偏低，但是解释器的实现较为简单，而且编写源程序的高级语言可以使用更加灵活和富于表现力的语法。</p>
<p>常见的Python解释器：</p>
<p>　　1、CPython：这个解释器是用C语言开发的，所以叫CPython。在命令行下运行Python就是启动CPython解释器。CPython是使用最广的Python解释器。</p>
<p>2、IPython：IPython是基于CPython之上的一个交互解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。</p>
<p>　　3、PyPy：PyPy是另一个解释器，它的目标是执行速度。采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。</p>
<p>　　4.Jython：Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p>
<h3 id="mac安装python环境"><a href="#mac安装python环境" class="headerlink" title="mac安装python环境"></a>mac安装python环境</h3><p>终端输入python，跳出的是2.7版本<br>终端输入python3，跳出的是3.9版本<br>就没安装了，要找解析器去官网下载安装</p>
<p>终端执行.py文件：<br>1、写文件，前面要加个注释<br><code>#!/usr/bin/env python3</code><br><code>print(&quot;hello!&quot;)</code><br>2、给文件以执行权限<br><code>chmod a+x hi.py</code><br>3、运行文件<br><code>./hi.py</code></p>
<p>✅安装pycharm<br>官网下载：<a target="_blank" rel="noopener" href="https://www.jetbrains.com.cn/en-us/pycharm/download">https://www.jetbrains.com.cn/en-us/pycharm/download</a><br>下载的社区版本。破解太费劲。<br>新建工程，选择解析器，不选虚拟的那个，选previously configured nterpret.<br>警告：PEP 8: W292 no newline at end of file，因为没有换行，换个行就好了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/25/myblog/JAVA/ssm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/myblog/JAVA/ssm/" class="post-title-link" itemprop="url">ssm是什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-25 16:32:52 / Modified: 17:38:44" itemprop="dateCreated datePublished" datetime="2022-06-25T16:32:52+08:00">2022-06-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SSM框架：Spring + SpringMVC + MyBatis</p>
<p>Spring和SpringMVC是当前企业开发必用框架之一，MyBatis则是与数据库交互的持久层框架之一，由于易用性和轻便性，则被大多互联网公司所选用。SSM基础框架的掌握是当前企业开发最基本的要求，也是其他技术学习和进阶的必要基础。</p>
<p>b站视频地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1WZ4y1P7Bp?p=42">https://www.bilibili.com/video/BV1WZ4y1P7Bp?p=42</a></p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h3><p>MVC模式是什么？</p>
<p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li>
<li><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</li>
<li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li>
</ul>
<p>SpringMVC概述？</p>
<p>SpringMVC是一种基于Java实现的MVC设计模型的请求驱动类型的轻量级Web框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow中。</p>
<p>SpringMVC已经成为目前最主流的MVC框架之一，并且随着Spring3.0的发布，全面超越Structs2，成为最优秀的MVC框架。它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。web文件夹内servelet？</p>
<h3 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h3><p>持久层框架，方便数据库操作的。</p>
<p>原始比较繁琐的jdbc操作：注册驱动–获得连接–获得statement–执行查询–遍历结果集（封装实体，传递）–释放资源。</p>
<p>缺点：代码重复（比如获得连接资源），资源频繁连接关闭，消耗资源，sql语句比较死，得解耦合，用配置文件。</p>
<p>jdbc缺点：（1）数据库创建、释放资源造成系统资源浪费从而影响系统性能。（2）sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码，耦合性高。（3）查询操作时，需要手动将结果集中的数据手动封装到实体中，插入操作时，需要手动将实体的数据设置到sql语句的占位符位置。</p>
<p>应对上述问题给出的解决方案：（1）使用数据库连接池初始化连接资源。（2）将sql语句抽到xml配置文件中。（3）使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射。</p>
<p>MyBatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程，</p>
<p>MyBatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中的sql的动态参数进行映射生成最终执行的sql语句。</p>
<p>MyBatis框架执行sql并将结果集映射为java对象并返回，采用ORM（对象关系映射）思想解决了实体和数据库映射的问题，对jdbc进行封装，屏蔽jdbc api底层访问细节，不与jdbc打交道就可以完成对数据库的持久化操作。</p>
<h3 id="mvc和servlet的关系"><a href="#mvc和servlet的关系" class="headerlink" title="mvc和servlet的关系"></a>mvc和servlet的关系</h3><p>1、Servlet与JSP一起为Web应用开发带来了巨大的贡献，后来出现的众多Java Web应用开发框架都是基于这两种技术的，更确切的说，都是基于Servlet技术的。</p>
<p>2、Springmvc的核心是一个DispatcherServlet，并且DispatcherServlet继承自 FrameworkServlet继承自HttpServletBean 继承自HttpServlet（也就是你说的servelt） 本质上是一样的东西。其实就是基于tomcat等这些web容器对我们的CS请求能做更多的事情，如校验，拦截（AOP思想），后期渲染等等，好让我们专注于业务的开发。</p>
<p>总结</p>
<p>1、servlet就是一个Java接口，是JavaEE规范的一种<br>2、Servlet容器也叫做Servlet引擎：全称server applet，意为服务程序。主要作用是给上级容器(Tomcat)提供doGet()和doPost()等方法。其生命周期实例化、初始化、调用、销毁受控于 Tomcat容器。<br>3、而Tcomcat、webLogic等web容器包含servlet容器。<br>4、Tomcat容器属于web容器的一种，web容器还包括weblogic容器、JBoss容器等。<br>5、web容器：可以部署多个WEB应用程序的环境。<br>6、Spring MVC （SpringBoot）其实就是基于tomcat等这些web容器对我们的CS请求能做更多的事情</p>
<p>转自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/295173834">https://zhuanlan.zhihu.com/p/295173834</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/04/myblog/JAVA/war%E5%8C%85jar%E5%8C%85%E6%89%93%E5%8C%85tomcat%E9%83%A8%E7%BD%B2servlet%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/04/myblog/JAVA/war%E5%8C%85jar%E5%8C%85%E6%89%93%E5%8C%85tomcat%E9%83%A8%E7%BD%B2servlet%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">jar、war、tomcat、servlet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-04 14:47:55" itemprop="dateCreated datePublished" datetime="2022-06-04T14:47:55+08:00">2022-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-05 23:59:59" itemprop="dateModified" datetime="2022-06-05T23:59:59+08:00">2022-06-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="tomcat与servlet"><a href="#tomcat与servlet" class="headerlink" title="tomcat与servlet"></a>tomcat与servlet</h3><p>1.tomcat就是一个web应用服务器，相当于市存放java程序的容器。以便服务被访问。<br>2.servlet实际上是java类，java语言编写的服务器端程序，它用来处理http协议相关的所有内容，没有main方法，需要在servlet容器中进行管理，可以是tomact。如何使用：继承HttpServlet（tomcat里的jar包支持），它帮助我们完成通信的规则。<br>3.tomcat与servlet关系：tomcat是servlet/jsp容器，servlet时web应用开发的组件，tomcat负责处理客户请求，把请求传送给servlet，再将servlet的响应传送回给客户。<br>4.新建web工程时，如果不用maven，java enterprise - web application，再引入jdk、tomcat（tomcat的lib下有servlet包）。如果用maven，就选archetype-webapp。</p>
<h3 id="war包与jar包"><a href="#war包与jar包" class="headerlink" title="war包与jar包"></a>war包与jar包</h3><p>1.Jar文件（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等。<br>2.jar包是java打的包，一般只是包括一些编译后class文件和一些部署文件，在声明了Main_class之后是可以用java命令运行的。<br>3.jar包通常是开发时要引用通用类，打成包便于存放管理。<br>————————————————<br>1.War文件（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对war文件进行封装，并把它作为小型服务程序（servlet）来访问。<br>2.war包可以理解为javaweb打的包，是一个web模块，包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。<br>3.war包需要发布到一个容器里面，拿Tomcat来说,将war文件包放置它的\webapps\目录下，启动Tomcat,这个包可以自动进行解压，也就是你的web目录，相当于发布了。<br>4.WAR是Sun提出的一种Web应用程序格式，与JAR类似，也是许多文件的一个压缩包。这个包中的文件按一定目录结构来组织：通常其根目录下包含有Html和Jsp文件或者包含这两种文件的目录，另外还会有一个WEB-INF目录，这个目录很重要。通常在WEB-INF目录下有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的Servlet类和Jsp或Servlet所依赖的其它类（JavaBean）。另外还有META-INF目录，里面有MANIFEST.MF文件。存储了项目的元信息。其中文件manifest.mf仅此一份，描述了程序的基本信息、Main-Class的入口、jar依赖路径Class-Path。<br>————————————————</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Sunny5319/article/details/90933532">https://blog.csdn.net/Sunny5319/article/details/90933532</a></p>
<p>jar包和war包都是为了项目的部署和发布，通常在打包部署的时候，会在里面加上部署的相关信息。这个打包实际上就是把代码和依赖的东西压缩在一起，变成后缀名为.jar和.war的文件</p>
<hr>
<p>什么时候用jar、war?<br>当你的项目在没有完全完成的时候，不适合使用war文件，因为你的类会由于调试之类的经常改，这样来回删除、创建war文件很不方便，来回修改，来回打包，最好是你的项目已经完成了，不做修改的时候，那就打个war包，这个时候一个war文件就相当于一个web应用程序；而jar文件就是把类和一些相关的资源封装到一个包中，便于程序中引用。</p>
<h3 id="jar包打包"><a href="#jar包打包" class="headerlink" title="jar包打包"></a>jar包打包</h3><p>安装好JDK之后,jar.exe就已经安装好了。在命令行中键入jar命令之后，会有详细的用法介绍。</p>
<h4 id="✅单个文件打包"><a href="#✅单个文件打包" class="headerlink" title="✅单个文件打包"></a>✅单个文件打包</h4><p>将一个单独的java文件打包：<br><code>jar cvf /Users/liuxuan/MyProject/java/test.jar /Users/liuxuan/MyProject/java/jartest/hello.java</code><br>使用<code>java -jar test.jar</code> 提示没有主清单属性。</p>
<p>所以增加清单配置文件：MANIFEST.MF</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: hello</span><br><span class="line"></span><br><span class="line">//注意：1. 冒号后面加一个空格，2. 最后必须回车到新的空行</span><br></pre></td></tr></table></figure>
<p>再打包：<code>jar cvfm test.jar ./*</code><br>java -jar运行，找不到或无法加载主类 hello。</p>
<p>所以在打包前先编译：<code>javac hello.java</code>，生成class文件，然后再打包，运行，可以执行。</p>
<blockquote>
<p>META-INF文件夹相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务。这个文件夹和其中的 MANIFEST.MF文件，在用jar打包时自动生成。<br>执行jar文件的时候，这个jar里是需要具备 META-INF/MANIFEST.MF的，否则java -jar就找不到main class。</p>
</blockquote>
<p>多个文件也可以如此打包，首先应该javac编译，然后增加主清单配置文件，其中可以指示默认入口函数（其中有main方法）。如果打的包中有其他类，java -jar jar包 是运行默认类，运行其他类方法：<code>java -cp test.jar com.test.sum 3 9</code>。<br>main函数可以有输入参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">public class sum&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        if(args.length &lt; 2)&#123;</span><br><span class="line">            System.out.println(&quot;Paras: num1 num2&quot;);</span><br><span class="line">            System.exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        final int num1 = Integer.valueOf(args[0]);</span><br><span class="line">        System.out.println(&quot;Num1: &quot; + num1);</span><br><span class="line">        final int num2 = Integer.valueOf(args[1]);</span><br><span class="line">        System.out.println(&quot;Num2: &quot; + num2);</span><br><span class="line"></span><br><span class="line">        final int sum = num1 + num2;</span><br><span class="line">        System.out.println(num1 + &quot; + &quot; + num2 + &quot; = &quot; + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Xminyang/article/details/108059776">https://blog.csdn.net/Xminyang/article/details/108059776</a></p>
<h4 id="✅使用idea打包"><a href="#✅使用idea打包" class="headerlink" title="✅使用idea打包"></a>✅使用idea打包</h4><p>🤔不可以java -jar的打包：<br>1.点击intellij idea左上角的“File”菜单 -&gt; Project Structure<br>2.点击”Artifacts” -&gt; 绿色的”+” -&gt; “JAR” -&gt; Empty<br>3. Name栏填入自定义的名字，Output ditectory选择jar包目标目录，Available Elements里双击需要添加到jar包的文件（添加java工程编译文件）<br>4. OK之后，点击菜单中“Build” -&gt; “Build Artifacts”<br>5. 点击弹出框中待生成jar包下面的build即可</p>
<p>生成了jar包，直接java -jar执行，报<code>Error: Invalid or corrupt jarfile testjar.jar</code>.<br>需要用 -cp 指定类来执行，例如：<code>java -cp testjar.jar leecode.JianPanHang500</code></p>
<p>🤔可以直接java -jar的打包：<br>如果需要直接java -jar 执行的jar包：<br>1.点击”Artifacts” -&gt; 绿色的”+” -&gt; “JAR” -&gt; from modules…<br>2.选择主类，选择META-INF位置<br>3.OK之后，点击菜单中“Build” -&gt; “Build Artifacts”<br>4.点击弹出框中待生成jar包下面的build即可</p>
<p>注意：在选择主类时需要全路径，rebuild之后可以重新编译，<code>java -jar lee.jar</code>直接运行主类。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42239765/article/details/123236019">https://blog.csdn.net/qq_42239765/article/details/123236019</a></p>
<h4 id="✅使用maven打包"><a href="#✅使用maven打包" class="headerlink" title="✅使用maven打包"></a>✅使用maven打包</h4><p>🤔不包含依赖包，也不指定入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;!-- 项目最终打包成的名字 --&gt;</span><br><span class="line">    &lt;finalName&gt;mylogmavenpackage&lt;/finalName&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>🤔指定入口，将依赖的jar包输出到指定目录<br>指定了入口类，可以直接使用java -jar project.jar执行，但是第三方依赖存在一个指定的外部目录下，迁移时需将jar和依赖目录一起迁移。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">          &lt;manifest&gt;</span><br><span class="line">            &lt;mainClass&gt;com.netty.client.SignalClient&lt;/mainClass&gt; &lt;!-- 指定入口类 --&gt;</span><br><span class="line">            &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;!-- 在jar的MF文件中生成classpath属性 --&gt;</span><br><span class="line">            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;!-- classpath前缀,即依赖jar包的路径 --&gt;</span><br><span class="line">          &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.1&lt;/version&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;copy&lt;/id&gt;</span><br><span class="line">          &lt;phase&gt;install&lt;/phase&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">          &lt;configuration&gt;</span><br><span class="line">            &lt;!-- 指定依赖包的输出路径，需与上方的classpathPrefix保持一致 --&gt;</span><br><span class="line">            &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt;</span><br><span class="line">          &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>🤔将项目依赖和项目打成一个jar包（胖包）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">          &lt;manifest&gt;</span><br><span class="line">            &lt;mainClass&gt;com.netty.client.SignalClient&lt;/mainClass&gt; &lt;!-- 指定入口类路径 --&gt;</span><br><span class="line">          &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">        &lt;descriptorRefs&gt;</span><br><span class="line">          &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;!-- jar包后缀，生成的jar包形式为：project-1.0-SNAPSHOT-jar-with-dependencies.jar --&gt;</span><br><span class="line">        &lt;/descriptorRefs&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">      &lt;!-- 添加此项后，可直接使用mvn package | mvn install --&gt;</span><br><span class="line">      &lt;!-- 不添加此项，需直接使用mvn package assembly:single --&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">          &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="打war包"><a href="#打war包" class="headerlink" title="打war包"></a>打war包</h3><p>上面打jar包，其实都有对应的打war包的方法：</p>
<p>✅手动打war包<br><code>jar cvf test.war ./*</code></p>
<p>✅idea打war包<br>artifact中选择web application，explode对于war explode，archive对应war。</p>
<p>✅maven打war包<br>pom.xml中指示<br><code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>maven有多种打包方式。</p>
<h3 id="war包和war-explode包"><a href="#war包和war-explode包" class="headerlink" title="war包和war explode包"></a>war包和war explode包</h3><p>1.war模式<br>这种可以称之为是发布模式，就是先将WEB工程打成war包，然后再将其上传到服务器进行发布 。</p>
<p>2.war exploded模式<br>是将WEB工程以当前文件夹的位置关系上传到服务器，即直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。<br>在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来。<br>（热部署，对于Java应用程序来说，热部署就是在运行时更新Java类文件。）</p>
<p>问题：<br>idea进行部署，会将war包移到tomcat webapp文件夹下吗？</p>
<h3 id="java-web工程目录结构"><a href="#java-web工程目录结构" class="headerlink" title="java web工程目录结构"></a>java web工程目录结构</h3><p>1.src文件夹：这是用来存放Java源文件。下面有main文件夹和test文件夹。<br>1.1.src/main/java：存放相应的Java代码，并根据对应的Java项目继续分层<br>1.2.src/main/resource：存放一些配置文件，例如application.properties、logback.xml<br>1.3.src/main/webapp：Web应用的网页，用来放静态资源比如HTML、CSS、图片等文件。WEB-INF目录所在。WEB-INF中存放网站配置文件目录，web.xml等配置信息。</p>
<p>2..idea文件夹：是存储IntelliJ IDEA项目的配置信息，主要内容有IntelliJ IDEA项目本身的一些编译配置、文件编码信息、jar包的数据源和相关的插件配置信息。一般用git做版本控制的时候会把.idea文件夹排除，因为这个文件下保存的都是个人本地Idea编译器的配置。</p>
<p>3.target文件夹：是用来存放项目构建后的文件和目录、jar包、war包、编译的class文件，都是maven构建时生成的。存放的是单个module的编译结果。</p>
<p>4.out文件夹：存放该项目下所有module的编译结果。</p>
<p>5.pom.xml：项目对象模型</p>
<h3 id="新建个web工程并部署"><a href="#新建个web工程并部署" class="headerlink" title="新建个web工程并部署"></a>新建个web工程并部署</h3><p>1.new project，选maven，选archetype maven<br>2.选择maven setting，新建工程<br>3.简单写个index.jsp，在webapp目录下（主页）<br>4.通过idea部署，生成war_explode包，热部署<br>5.lsof -i:8080 查看端口占用<br>6.target文件夹下有war包了，但是在tomcat-webapp文件夹下并没有该项目。<br>7.关闭idea，web也无法访问了，所以要想一直运行，得打jar包放在webapp目录下？<br>8.并且发现，没用servlet，不用导入servlet包。</p>
<h3 id="pom-xml结构"><a href="#pom-xml结构" class="headerlink" title="pom.xml结构"></a>pom.xml结构</h3><p>pom.xml 就是 maven 的配置文件，用以描述项目的各种信息。</p>
<p><code>&lt;project </code>  是 pom.xml 中描述符的根。</p>
<p><code>&lt;modelVersion&gt;</code> 指定 pom.xml 符合哪个版本的描述符。maven 2 和 3 只能为 4.0.0。</p>
<p>在 maven 中，根据 groupId、artifactId、version 组合来唯一识别一个 jar 包。<br><code>&lt;groupId&gt;</code> - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 java 的包结构。<br><code>&lt;artifactId&gt;</code> - 单独项目的唯一标识符。例如junit。不要在 artifactId 中包含点号(.)。<br><code>&lt;version&gt;</code> - 一个项目的特定版本。</p>
<blockquote>
<p>maven 在版本管理时候可以使用几个特殊的字符串 SNAPSHOT、LATEST、RELEASE。比如 1.0-SNAPSHOT。各个部分的含义和处理逻辑如下说明：<br>SNAPSHOT - 这个版本一般用于开发过程中，表示不稳定的版本。<br>LATEST - 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。<br>RELEASE ：指最后一个发布版。</p>
</blockquote>
<p><code>&lt;packaging&gt;</code> - 项目的类型，描述了项目打包后的输出，默认是 jar。常见的输出类型为：pom, jar, maven-plugin, ejb, war, ear, rar, par。</p>
<p><code>&lt;name&gt;</code> - 项目名字</p>
<p><code>&lt;url&gt;</code> - 项目网站</p>
<p><code>&lt;description&gt;</code> - 项目描述</p>
<p><code>&lt;parent&gt;</code> - maven 支持继承功能。子 POM 可以使用 parent 指定父 POM ，然后继承其配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;my-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0&lt;/version&gt;</span><br><span class="line">    &lt;relativePath&gt;../my-parent&lt;/relativePath&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">relativePath ： 在搜索本地和远程存储库之前，它不是必需的，但可以用作 maven 的指示符，以首先搜索给定该项目父级的路径。</span><br></pre></td></tr></table></figure>

<p><code>&lt;modules&gt;</code> - 子模块列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;my-project-api&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;my-project-repository&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;properties&gt;</code> - 属性列表。定义的属性可以在 pom.xml 文件中任意处使用。使用方式为 ${propertie} 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;!-- Test --&gt;</span><br><span class="line">		&lt;junit.version&gt;1.16.1&lt;/junit.version&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;dependencies&gt;</code> - 依赖配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">groupId, artifactId, version - 和基本配置中的 groupId、artifactId、version 意义相同。</span><br><span class="line"></span><br><span class="line">type - 对应 packaging 的类型，如果不使用 type 标签，maven 默认为 jar。</span><br><span class="line"></span><br><span class="line">scope - 此元素指的是任务的类路径（编译和运行时，测试等）以及如何限制依赖关系的传递性。有 5 种可用的限定范围：</span><br><span class="line">compile : 如果没有指定 scope 标签，maven 默认为这个范围。编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目。</span><br><span class="line">provided : 与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它。它只适用于编译和测试 classpath，不可传递。</span><br><span class="line">runtime : 此范围表示编译不需要依赖关系，而是用于执行。它是在运行时和测试 classpath，但不是编译 classpath。</span><br><span class="line">test : 此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。它不是传递的。</span><br><span class="line">system : 此范围与 provided 类似，除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。</span><br><span class="line"></span><br><span class="line">systemPath - 仅当依赖范围是系统时才使用。否则，如果设置此元素，构建将失败。该路径必须是绝对路径，因此建议使用 propertie 来指定特定的路径，如\$ &#123;java.home&#125; / lib。由于假定先前安装了系统范围依赖关系，maven 将不会检查项目的仓库，而是检查库文件是否存在。如果没有，maven 将会失败，并建议您手动下载安装。</span><br><span class="line"></span><br><span class="line">optional - optional 让其他项目知道，当您使用此项目时，您不需要这种依赖性才能正常工作。</span><br><span class="line"></span><br><span class="line">exclusions - 包含一个或多个排除元素，每个排除元素都包含一个表示要排除的依赖关系的 groupId 和 artifactId。与可选项不同，可能或可能不会安装和使用，排除主动从依赖关系树中删除自己。</span><br></pre></td></tr></table></figure>

<p><code>&lt;dependencyManagement&gt;</code> - 是在<code>&lt;dependencies&gt;</code>外用的。表示依赖 jar 包的声明。即你在项目中的 dependencyManagement 下声明了依赖，maven 不会加载该依赖，dependencyManagement 声明可以被子 POM 继承。<br>它的一个使用案例是当有父子项目的时候，父项目中可以利用 <code>&lt;dependencyManagement&gt;</code> 声明子项目中需要用到的依赖 jar 包，之后，当某个或者某几个子项目需要加载该依赖的时候，就可以在子项目中 dependencies 节点只配置 groupId 和 artifactId 就可以完成依赖的引用。<br><code>&lt;dependencyManagement&gt;</code> 主要是为了统一管理依赖包的版本，确保所有子项目使用的版本一致，类似的还有plugins和pluginManagement。</p>
<p><code>&lt;build&gt;</code> - 构建配置。<br><code>&lt;plugins&gt;</code> - 配置插件，在<code>&lt;build&gt;</code>下。<br><code>pluginManagement</code> - 与 dependencyManagement 很相似，在当前 POM 中仅声明插件，而不是实际引入插件。子 POM 中只配置 groupId 和 artifactId 就可以完成插件的引用，且子 POM 有权重写 pluginManagement 定义。<br>它的目的在于统一所有子 POM 的插件版本。<br><code>&lt;extensions&gt;</code> - 扩展配置，扩展是在构建期间激活的 artifacts。扩展不需要实际执行任何操作，也不包含 Mojo。因此，扩展对于指定普通插件接口的多个实现中的一个是非常好的。</p>
<p>pom.xml解析：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/76874769">https://zhuanlan.zhihu.com/p/76874769</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/02/myblog/JAVA/mybatis%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/02/myblog/JAVA/mybatis%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">mybatis实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-02 21:45:44" itemprop="dateCreated datePublished" datetime="2022-06-02T21:45:44+08:00">2022-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-23 23:17:25" itemprop="dateModified" datetime="2022-08-23T23:17:25+08:00">2022-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="mybatis-error"><a href="#mybatis-error" class="headerlink" title="mybatis error"></a>mybatis error</h3><h4 id="✅Mybatis-Exception-Translator-translateExceptionIfPossible"><a href="#✅Mybatis-Exception-Translator-translateExceptionIfPossible" class="headerlink" title="✅Mybatis Exception Translator.translateExceptionIfPossible"></a>✅Mybatis Exception Translator.translateExceptionIfPossible</h4><p>原因：插入时找不到参数，批量插入时传的list为空也会报此问题。</p>
<h3 id="resultMap和resultType"><a href="#resultMap和resultType" class="headerlink" title="resultMap和resultType"></a>resultMap和resultType</h3><p>ResultType和ResultMap都是执行查询语句时返回的结果集。<br>ResultType相对与ResultMap而言更简单一点。只有满足ORM（Object Relational Mapping，对象关系映射）时，即数据库表中的字段名和实体类中的属性完全一致时，才能使用，否则会出现数据不显示的情况。<br>ResultMap和ResultType的功能类似，但是ResultMap更强大一点，ResultMap可以实现将查询结果映射为复杂类型的pojo。</p>
<h4 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h4><p>1.java的基础类型及其包装类int,double和java.lang.Integer,java.lang.Double等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值为int，resultType为int ,java.lang.Integer也可以--&gt;</span><br><span class="line">&lt;select id=&quot;countUser&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">    select count(*) from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>2.自己定义的实体类,实体类和数据库字段需要一致，如果不一致需要使用resulMap自定义map，也可以直接使用map。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值为实体类，resultType为User--&gt;</span><br><span class="line">&lt;select id=&quot;getUser&quot; resultType=&quot;com.entity.User&quot;&gt;</span><br><span class="line">   select * from User where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>3.map类型，Dao层的返回类型为<code>Map&lt;String, Object&gt;</code>，key是对应的column值，value是数据中的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 返回值为Map&lt;String,Object&gt;，resultType为map--&gt;</span><br><span class="line">&lt;select id=&quot;getUserSelective&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">    select name,address,salary from User where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>4.List集合，其中该集合的类型可以为1,2,3中提到的类型。Dao层的返回类型为<code>List&lt;User&gt;</code>，这里只展示了实体类集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值为List&lt;User&gt;，resultType为User--&gt;</span><br><span class="line">&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>结果集的映射是 MyBatis 最强大的特性,通过使用resultMap或resultType可以解决复杂映射问题。基础简单的使用resultType就可以了，但是如果出现table中列和实体类中的属性不一致或者多表级联。那么这时resultMap就可以发挥作用了。</p>
<p>TestDao.xml:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.repository.TestDao&quot;&gt;</span><br><span class="line">    //定义映射</span><br><span class="line">    &lt;resultMap id=&quot;TestResultMap&quot; type=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">        &lt;result column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">        &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    //定义返回栏目</span><br><span class="line">    &lt;sql id=&quot;all_colum_without_id&quot;&gt;</span><br><span class="line">        name</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id=&quot;all_colum&quot;&gt;</span><br><span class="line">        name,&lt;include refid=&quot;all_colum_without_id&quot;/&gt;</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    //插入语句</span><br><span class="line">    &lt;insert id=&quot;insertOne&quot; parameterType=&quot;com.entity.TestDO&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">        insert into table (&lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">        values (#&#123;name&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    //批量插入</span><br><span class="line">    &lt;insert id=&quot;insertBatch&quot; parameterType=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">        insert into table (&lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">        values</span><br><span class="line">        &lt;foreach collection=&quot;testDOList&quot; separator=&quot;,&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">            (#&#123;item.name&#125;,</span><br><span class="line">            #&#123;item.age&#125;)</span><br><span class="line">            &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    //查询</span><br><span class="line">    &lt;select id=&quot;findById&quot; resultMap=&quot;TestResultMap&quot;&gt;</span><br><span class="line">        select &lt;include refid=&quot;all_colum&quot;/&gt; from table where id=#&#123;id&#125;</span><br><span class="line">        &lt;if test=&quot;age != null&quot;&gt;</span><br><span class="line">            and age=#&#123;age&#125;</span><br><span class="line">        &lt;if&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>TestDao.java接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface TestDao &#123;</span><br><span class="line">    //插入</span><br><span class="line">    Integer insertOne(TestDO testDO);</span><br><span class="line">    //批量插入</span><br><span class="line">    Integer insertBatch(List&lt;TestDO&gt; testDOList);</span><br><span class="line">    //查询</span><br><span class="line">    TestDO findById(Long id, Integer age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdbcType告诉框架如何解析这个属性（对应数据库中的类型），column是数据库中table的列名，property是实体类中对应的属性名字，type是对应的实体类，id=”TestResultMap”是这个resultMap的一个引用标志。</p>
<p>这样使用resultMap就像用resultType对应实体类，在select出来的语句中直接对字段就行as，as为实体类属性名，或驼峰形式就行。</p>
<p>resultMap更复杂的用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wobuaizhi/article/details/83104464">https://blog.csdn.net/wobuaizhi/article/details/83104464</a></p>
<h3 id="返回映射下划线转驼峰"><a href="#返回映射下划线转驼峰" class="headerlink" title="返回映射下划线转驼峰"></a>返回映射下划线转驼峰</h3><p>意思是返回值对应到对象，mysql返回的字段名（app_id），直接映射到对象属性名（appId）。</p>
<p>第一种 Spring Boot</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br></pre></td></tr></table></figure>

<p>第二种 mybatis-config.xml配置中加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 全局配置 --&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">    </span><br><span class="line">       &lt;!-- 是否开启自动驼峰命名规则映射</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt; </span><br></pre></td></tr></table></figure>

<h3 id="mybatis-useGeneratedKeys-keyProperty"><a href="#mybatis-useGeneratedKeys-keyProperty" class="headerlink" title="mybatis useGeneratedKeys keyProperty"></a>mybatis useGeneratedKeys keyProperty</h3><p>useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</p>
<p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置为目标属性就 OK 了。</p>
<p>作用：在inset时，可以不用管主键插入多少，而且插入后，还能直接用对象里的值，因为自动返回了。建表时必须设置主键自增。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;</span><br><span class="line">    keyProperty=&quot;id&quot;&gt;</span><br><span class="line">  insert into Author (username,password,email,bio)</span><br><span class="line">  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h3 id="DUPLICATE"><a href="#DUPLICATE" class="headerlink" title="DUPLICATE"></a>DUPLICATE</h3><p>duplicate在mybatis中的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertOne&quot; parameterType=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">    insert into table (id, &lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">    values (0, #&#123;name&#125;)</span><br><span class="line">    ON DUPLICATE KEY UPDATE name=values(name), age=values(age)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">values后面就是插入要查哪些。</span><br><span class="line">update后面是更新要更新哪些</span><br><span class="line">什么时候更新要看表的主键索引和唯一索引</span><br><span class="line">id可选，加了id，就传0</span><br></pre></td></tr></table></figure>

<p>因为更新的时候是不会返回id的，所以要去掉：<code>useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;</code><br>如果不去掉，会报<code>executorexception: error getting generated key or setting result to parameter object</code></p>
<h3 id="xml里面foreach标签里面的属性separator"><a href="#xml里面foreach标签里面的属性separator" class="headerlink" title="xml里面foreach标签里面的属性separator"></a>xml里面foreach标签里面的属性separator</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;if test=&quot;myList != null&quot;&gt;</span><br><span class="line">    AND dm in</span><br><span class="line">    &lt;foreach collection=&quot;myList &quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item , jdbcType=VARCHAR &#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>
<p>渲染为sql：<code>AND dm in ( &#39;03&#39; , &#39;04&#39;)</code></p>
<p>如果separator属性为or，渲染为：<code>AND ( dm  = &#39;01&#39;or dm   = &#39;02&#39; or dm   = &#39;03&#39;) </code></p>
<h3 id="where标签的作用"><a href="#where标签的作用" class="headerlink" title="where标签的作用"></a>where标签的作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;select&quot; resultType=&quot;DO&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line"> WHERE</span><br><span class="line"> &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line"> state = #&#123;state&#125;</span><br><span class="line"> &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>如果state参数为空时，最终生成SQL语句为<br>SELECT * FROM hdc WHERE<br>执行会出错，可以在where 后加一个1=1，但是累赘</p>
<p>用<code>&lt;where&gt;...&lt;/where&gt;</code>标签就好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectOne&quot; resultType=&quot;DO&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line"> &lt;where&gt;</span><br><span class="line">  &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  &lt;/if&gt;</span><br><span class="line"> &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>总结：<code>&lt;where&gt;</code>标签，1、在后面if null都是空时，可以自动删除where。2、在后面多个if null，第一个为null时，会自动删掉后面有的and。</p>
<h3 id="trim实现动态sql"><a href="#trim实现动态sql" class="headerlink" title="trim实现动态sql"></a>trim实现动态sql</h3><p>场景：想使用having，having后面用if null标签，如果后面的if null都是null，having会留着，导致出错。</p>
<p>trim 在英语中有“点缀物”，修剪的意思。可以把‘’标签为一个装饰sql的标签。trim标签常用于动态生成sql的场景下。</p>
<p>基本格式：<br><code>&lt;trim prefix=&quot;&quot; suffix=&quot;&quot; suffixOverrides=&quot;&quot; prefixOverrides=&quot;&quot;&gt;&lt;/trim&gt;</code><br>prefix：<br>表示在trim包裹的SQL语句前面添加的指定内容。<br>suffix：<br>表示在trim包裹的SQL末尾添加指定内容<br>prefixOverrides：<br>表示去掉（覆盖）trim包裹的SQL的指定首部内容<br>suffixOverrides：<br>表示去掉（覆盖）trim包裹的SQL的指定尾部内容</p>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/425922768">https://zhuanlan.zhihu.com/p/425922768</a></p>
<p>例子(查输入的list的元素是不是在查处的一个list字段里有)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">group by id</span><br><span class="line">&lt;trim prefix=&quot;having&quot; prefixOverrides=&quot;and&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;nameList != null and nameList.size() &gt; 0&quot;&gt;</span><br><span class="line">        &lt;foreach collection=&quot;nameList&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;name&quot; index=&quot;index&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            find_in_set(#&#123;name&#125;, names) &gt; 0</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line"></span><br><span class="line">    &lt;if test=&quot;nameList != null and nameList.size() &gt; 0&quot;&gt;</span><br><span class="line">        and</span><br><span class="line">        &lt;foreach collection=&quot;nameList&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;name&quot; index=&quot;index&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            find_in_set(#&#123;name&#125;, names) &gt; 0</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jade liu"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Jade liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">87</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jadeliuliu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jadeliuliu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jadeliu1998@163.com" title="E-Mail → mailto:jadeliu1998@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jadeliu1998" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;jadeliu1998" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5823044646" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5823044646" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jade liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
