<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jadeliu&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Jadeliu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jade liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jadeliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jadeliu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/20/myblog/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%8C%97%E9%82%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/20/myblog/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%8C%97%E9%82%AE/" class="post-title-link" itemprop="url">计算机视觉与深度学习-北邮</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-20 21:53:07" itemprop="dateCreated datePublished" datetime="2023-08-20T21:53:07+08:00">2023-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-08 23:25:56" itemprop="dateModified" datetime="2023-09-08T23:25:56+08:00">2023-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/08/20/myblog/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%8C%97%E9%82%AE/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/20/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E4%BA%8Etensorflow%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/20/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E4%BA%8Etensorflow%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">基于tensorflow的深度学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-08-20 15:57:17 / Modified: 16:47:01" itemprop="dateCreated datePublished" datetime="2023-08-20T15:57:17+08:00">2023-08-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>第一章 Numpy常用操作<br>tensorflow：深度学习框架<br>python本身含有列表list和数组array。<br>list列表的元素可以是任何对象，因此列表中保存的是对象的指针，浪费内存和CPU计算时间。<br>array不支持多维，没有各种运算函数。</p>
<p>numpy提供ndarray（存储单一数据类型的多维数组）和ufunc（对数组进行处理的函数）</p>
<p>1.将列表转换为ndarray。<br>2.np函数，截取ndarray<br>3.numpy中的random函数<br>4.numpy中的矩阵操作<br>5.ndarray的合并和展平<br>6.使用numpy和math的比较，使用向量化矩阵运算可以避免循环语句<br>7.numpy的广播机制：方便不同shape的数组进行数学运算。原则是对齐维度，对数组进行扩充到可以进行运算，利用自动复制等方法把低维数据补齐。</p>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p>第二章 Theano基础<br>Theano是python的一个库，对于解决大量数据的问题，使用Theano可以获取与手工用C实现差不多的性能。符号计算图。<br>conda install theano<br>符号变量=张量Tensor。<br>张量是标量、向量、矩阵的统称。<br>Theano是一个通用的符号计算框架，将复杂的符号表达式编译成函数模型。<br>1.定义符号变量<br>import theano<br>from theano import tensor<br>2.符号计算图模型来描述变量间的运算关系，把符号表达式转换为一个计算图来处理。<br>3.函数：提供一个接口，把函数计算图编译为可调用的函数对象。Theano进行了编译优化，执行的是优化后保存在图结构中的模型，提升速度，不好调试。<br>自动求导：对于每个op都定义了根据输入计算出偏导数，使用链式法则，就可以计算出梯度了。<br>更新共享变量参数：深度学习中通常需要迭代多次，每次迭代都需要更新参数。theano.function中的updates参数就是包含两个元素的列表或tuple。<br>条件：ifelse、switch<br>循环：scan用来构建循环Graph的方法<br>4.共享变量：是实现机器学习算法参数更新的重要机制。shared函数会返回共享变量，这种变量的值可以在多个函数中直接使用。用function中的updates参数进行更新。</p>
<h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><p>第三章 线性代数<br>1.标量、向量、矩阵、张量<br>2.可逆矩阵、对角矩阵、对称矩阵、单位向量、正交向量、正交矩阵<br>0范数(L0范数)-向量中非0元素的个数。<br>1范数(L1范数)-向量中各个元素绝对值之和。<br>2范数(L2范数)-向量的模长。<br>无穷范数(最大范数)-向量中各个元素绝对值的最大值。</p>
<p>3.向量组、线性组合、向量空间。向量组线性相关。最大线性无关组、向量组的秩。矩阵的行秩和列秩相等。<br>4.向量的大小用范数来表示。<br>5.特征值分解，特征值，特征向量。<br>6.奇异值分解：分解成三个矩阵的乘积。可以拓展矩阵求逆到非方矩阵上。SVD<br>7.迹运算：矩阵对角元素的和 Tr<br>8.主成分分析：PCA：通过正交变换将一组可能存在相关性的变量转换为一组线性不相关的变量，转换后的这组变量叫做主成分。属于特征降维。<br>在减少需要分析的指标或维度的同时，尽量减少原指标所含信息的损失，以达到对所收集数据进行全面分析的目的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/28/myblog/%E5%85%AB%E8%82%A1/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/28/myblog/%E5%85%AB%E8%82%A1/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" class="post-title-link" itemprop="url">每日一题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-28 09:28:04" itemprop="dateCreated datePublished" datetime="2023-06-28T09:28:04+08:00">2023-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-25 22:38:38" itemprop="dateModified" datetime="2023-11-25T22:38:38+08:00">2023-11-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/06/28/myblog/%E5%85%AB%E8%82%A1/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/01/myblog/%E5%85%AB%E8%82%A1/java%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/01/myblog/%E5%85%AB%E8%82%A1/java%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">java并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-01 18:23:05 / Modified: 18:24:00" itemprop="dateCreated datePublished" datetime="2023-05-01T18:23:05+08:00">2023-05-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>八股文 - java并发</p>
<h3 id="✅synchronized的使用及原理"><a href="#✅synchronized的使用及原理" class="headerlink" title="✅synchronized的使用及原理"></a>✅synchronized的使用及原理</h3><p>1.修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁。<br>2.修饰静态方法：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。<br>3.修饰代码块 ：指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。 synchronized(类.class) 表示进⼊同步代码前要获得 当前 class 的锁</p>
<p>实现原理：<br>1.jvm基于进入和退出Monitor对象来实现方法同步和代码块同步，monitor是一个对象的监视器。<br>2.synchronized修饰代码块时，JVM采用monitorenter、monitorexit两个字节码指令来实现同步，monitorenter 指令指向同步代码块的开始位置，尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁。 monitorexit 指令则指向同步代码块的结束位置。要从对象监视器中退出，也就是释放锁。<br>3.synchronized修饰同步方法时，JVM采用ACC_SYNCHRONIZED标记符来实现同步，这个标识指明了该方法是一个同步方法。<br>4.monitorenter、monitorexit或者ACC_SYNCHRONIZED都是基于Monitor实现的。<br>5.实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，这部分主要存储对象自身的运行数据，如Hashcode、gc分代年龄、对象锁，锁状态标志，偏向锁（线程）ID，偏向时间等等。64 位虚拟机 Mark Word 是 64bit。<br>6.所谓的Monitor其实是一种同步工具，也可以说是一种同步机制。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，可以叫做内部锁，或者Monitor锁。<br>7.其中有一个锁的计数器，如果对象没有锁定或者当前线程再次进入，锁的计数器+1，退出时-1.</p>
<h3 id="✅synchronized锁的升级"><a href="#✅synchronized锁的升级" class="headerlink" title="✅synchronized锁的升级"></a>✅synchronized锁的升级</h3><p>1.可见性</p>
<ul>
<li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li>
<li>线程加锁后，其它线程无法获取主内存中的共享变量。</li>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li>
</ul>
<p>2.有序性<br>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。<br>因为as-if-serial语义（不管怎么重排序，单线程的程序的执行结果不能被改变）的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。<br>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<p>3.可重入性<br>synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。<br>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。</p>
<p>4.非公平性<br>并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，这样做的目的是提高执行性能，缺点时可能会产生线程饥饿现象。</p>
<h3 id="✅synchronized锁的升级-1"><a href="#✅synchronized锁的升级-1" class="headerlink" title="✅synchronized锁的升级"></a>✅synchronized锁的升级</h3><p>Java对象头里，有一块结构，叫Mark Word标记字段，这块结构会随着锁的状态变化而变化。<br>在JDK6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁。依赖底层操作系统的互斥锁来实现，对线程阻塞和唤醒都需要操作系统的协助，需要从用户态切换到内核态来执行，代价昂贵。<br>从JDK6开始，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状 态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。</p>
<ol>
<li>偏向锁：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。</li>
<li>轻量级锁：如果有另一个线程试图锁定某个被偏斜过的对象，JVM会撤销偏向锁。线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁。自旋会消耗CPU。但是竞争的线程不会阻塞，提高了程序的响应速度。</li>
<li>重量级锁：当锁处于这个状态下，其他线程试图获取锁时， 都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。线程不使用自旋，不会消耗CPU，但是线程阻塞，响应时间缓慢。</li>
</ol>
<p>自旋锁：在线程进入阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，线程就无需执行阻塞操作，避免了用户态到内核态的切换。</p>
<p>锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。因为频繁地进行互斥同步操作会导致不必要的性能损耗，所以增大锁的作用域。</p>
<p>锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p>
<h3 id="✅volatile可见性的原理"><a href="#✅volatile可见性的原理" class="headerlink" title="✅volatile可见性的原理"></a>✅volatile可见性的原理</h3><p>volatile是轻量级的synchronized，在多处理器开发中保证了共享变量的可见性（所有线程看到的这个变量的值是一致的）。比synchronized执行成本低，不会引起线程上下文的切换和调度。<br>原理：<br>1.cpu不直接与内存进行通信，而是先将内存的数据读到自己的内存缓存（以缓存行为单位）中。<br>2.存储大体上分两种, 主存是堆内存, 工作内存是栈内存, 属于线程私有。volatile修饰的变量, 等于在堆中这个变量的内存区域上打了个标, 所有操作都必须从主存中读取, 由MESI&lt;缓存一致性协议&gt;实现。<br>3.jvm向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回系统内存。lock指令执行期间会锁住总线/缓存，保证不会同时多个cpu修改共享变量。<br>4.多处理下，实现缓存一致性协议，每个处理器使用嗅探技术，保证它的内部缓存和系统内存的数据在总线上保持一致（发现自己缓存行对应的内存地址被修改，首先将缓存行置为无效，重新从系统内存中将数据读到缓存）。<br>所以：volatile可以确保对某个变量的更新对其他线程马上可见：一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p>
<h3 id="✅volatile和static的可见性"><a href="#✅volatile和static的可见性" class="headerlink" title="✅volatile和static的可见性"></a>✅volatile和static的可见性</h3><p>volatile的可见性：是多个线程间的共享变量，当一个线程修改时，其他的线程能够知道这个修改。static不能知道变化，它的可见性：可访问。<br>volatile修饰的共享变量对其他线程具有可见性，可以保证原子性操作的线程安全。static修饰的变量为全局变量, 对所有线程可访问, 可用于线程间的通信，但是不能保证线程安全。</p>
<h3 id="✅volatile为什么是非原子的"><a href="#✅volatile为什么是非原子的" class="headerlink" title="✅volatile为什么是非原子的"></a>✅volatile为什么是非原子的</h3><p>count++ 就是非原子操作，读改写，分三步：从主存读取、在寄存器中自增操作、将计算后的值刷回主存。<br>t1线程与t2线程同时从主存中读取了count = 1,自增, 这时候两个线程的寄存器中存的计算后的值都是 2, 然后要写回count的主存, 假设这时 t1成功了, 那么主存中的count就是2, 然后根据MESI协议, t2需要重新从主存读取count值, 得到的是2, 再将寄存器中的计算结果2 赋值给count, 刷回主存, 此时主存中的count值还是2, 而不是期望中的3。</p>
<h3 id="✅volatile的有序性"><a href="#✅volatile的有序性" class="headerlink" title="✅volatile的有序性"></a>✅volatile的有序性</h3><p>volatile变量读写可以实现线程之间通信：A写，B读，实质就是A通过主内存向B发送消息，实现线程之间通信。<br>但是前提是：volatile禁止指令重排<br>为了实现volatile的内存语义，JMM会限制重排序类型。<br>1、当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到写之后。<br>2、当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到读之前。<br>3、当第一个操作是volatile写时，第二个操作是volatile读时，不能重排序。</p>
<p>Volatile实现限制指令重排的原理：<br>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。尽管内存屏障会降低效率，但是JMM（java内存模型）在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<h3 id="✅指令重排和as-if-serial语义和happens-before"><a href="#✅指令重排和as-if-serial语义和happens-before" class="headerlink" title="✅指令重排和as-if-serial语义和happens-before"></a>✅指令重排和as-if-serial语义和happens-before</h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<p>as-if-serial语义：不管怎么重排序，单线程的程序的执行结果不能被改变，为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。会对没有依赖关系的操作重排序，但是不影响结果和可见性。</p>
<p>happens - before：向程序员提供跨线程的内存可见性保证。<br>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见。<br>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。</p>
<p>happens-before的六大规则：<br>1、程序顺序规则：一个线程中的每个操作，happens - before 于该程序的任意后续操作。<br>2、监视器规则：对一个锁的解锁，happens - before 于随后对这个锁的加锁。<br>3、volatile 变量规则：对一个 volatile 域的写，happens - before 于任意后续对这个 volatile 域的读。<br>4、传递性，如果 A happens - before B， B happens - before C，那么 A happens - before C<br>5、start() 规则：如果线程 A 执行操作 ThreadB.start()（启动线程B），那么线程 A 的 ThreadB.start() 操作 happens - before 线程 B 中的任意操作。<br>6、join() 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens- before 于线程 A 从 Thread.join() 操作成功返回。</p>
<h3 id="✅Synchronized是悲观锁-CAS是乐观锁"><a href="#✅Synchronized是悲观锁-CAS是乐观锁" class="headerlink" title="✅Synchronized是悲观锁 CAS是乐观锁"></a>✅Synchronized是悲观锁 CAS是乐观锁</h3><p>Synchronized的并发策略是悲观的，不管是否会发生竞争，任何的数据操作都要加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。</p>
<p>随着硬件指令集的发展。可以使用基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程征用数据，就操作成功；如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略不需要线程挂起，所以被称为非阻塞同步。</p>
<p>乐观锁的核心算法是CAS(Compareand Swap，比较并交换)，它涉及到三个操作数;内存值、预期值、新值。当且仅当预期值和内存值相等时才将内存值修改为新值。（像改密码需要先验证旧密码一样）<br>这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样。如不一样则表示期问此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。<br>CAS 具有原子性，它的原子性由 CPU 硬件指令实现保证，即使用 JNI调用 Native 方法调用由 C++编写的硬件级别指令，JDK 中提供了 Unsafe类执行这些操作。</p>
<h3 id="✅CAS缺点"><a href="#✅CAS缺点" class="headerlink" title="✅CAS缺点"></a>✅CAS缺点</h3><p>乐观锁避免了悲观锁独占对象的现象，同时也提高了并发性能，但它也有缺点</p>
<ol>
<li>乐观锁只能保证一个共享变量的原子操作。如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解決，不管对象数量多少及对象颗粒度大小。</li>
<li>长时间自旋可能导致开销大。假如 CAS 长时间不成功而一直自旋，会给CPU 带来很大的开销。</li>
<li> ABA 问题。CAS 的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是 A，后来被一条线程改为 B，最后又被改成了 A，则CAS 认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情況对依赖过程值的情景的运算结果影响很大。解决思路是引入版本号，每次变量更新都把版本号加一。</li>
</ol>
<h3 id="✅Atomic原子类"><a href="#✅Atomic原子类" class="headerlink" title="✅Atomic原子类"></a>✅Atomic原子类</h3><p>在并发包 java.util.concurrent 的原子类。<br>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类：<br>基本类型：AtomicInteger、AtomicLong、AtomicLong<br>数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray<br>引用类型：AtomicReference、<br>AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来、<br>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。<br>对象的属性修改类型：<br>AtomicIntegerFieldUpdater:原子更新整型字段的更新器<br>AtomicLongFieldUpdater：原子更新长整型字段的更新器<br>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</p>
<p>使用方法：<br>public final int get() //获取当前的值<br>public final int getAndSet(int newValue)//获取当前的值，并设置新的值<br>publicfinal int getAndIncrement()//获取当前的值，并自增<br>public final int getAndDecrement() //获取当前的值，并自减<br>public final int getAndAdd(int delta) //获取当前的值，并加上预期的值<br>boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）<br>public final void lazySet(intnewValue) //最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</p>
<h3 id="✅AtomicInteger线程安全原理"><a href="#✅AtomicInteger线程安全原理" class="headerlink" title="✅AtomicInteger线程安全原理"></a>✅AtomicInteger线程安全原理</h3><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。<br>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset()方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h3 id="✅Lock接口和Synchronized"><a href="#✅Lock接口和Synchronized" class="headerlink" title="✅Lock接口和Synchronized"></a>✅Lock接口和Synchronized</h3><p>在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。</p>
<p>Lock具备的sychronized关键字不具备的特点：1、非阻塞地获取锁2、能被中断地获取锁（获取到锁的线程能响应中断，中断异常被抛出，同时锁释放）3、超时获取锁（截止时间无法获取锁，则返回）</p>
<h3 id="✅AQS"><a href="#✅AQS" class="headerlink" title="✅AQS"></a>✅AQS</h3><p>AQS(AbstractQvevedSvnchronizer 类)队列同步器是一个用来构建锁和同步器的框架，各种Lock 包中的锁(常用的有 PeentrantLock ReaaWrtelock)，以及其他如 Semaphore、CountDownLatcn，甚至是早期的 Futurerask等，都是基于 AQS 来构建。</p>
<ol>
<li>AQS 在内部定义了一个 volatile int state 变量，表示同步状态;当线程调用 lock 方法时，如果 state=0，说明没有任何线程占有共享资源的锁，可以获得锁并将 state=1;如果 state=1，则说明有线程目前正在 使用共享变量，其他线程必须加入同步队列进行等待。</li>
<li>AQS 通过 Node 内部类构成的一个双向链表结构的同步队列，来完成线程获取锁的排队工作，当有线程获取锁失败后，就被添加到队列未尾。这个加入队列的过程用CAS保证线程安全。被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。节点进入同步队列之后，就进入了一个自旋的过程。获取到了同步状态，就可以从这个自旋过程中退出，代表获取了锁。<br>•Node 类是对要访问同步代码的线程的封装，包含了线程本身及其状态WaitStatus(有五种不同取值，分别表示是否被阻塞，是否等待唤醒，是香已经被取消等)，每个 Node 结点关联其 prev 结点和 next 结点，方便线程释放锁后快速唤醒下一个在等待的线程，是一个FIFO 的过程。<br>•Node 类有两个常量，SHARED 和 EXCLUSIVE， 分别代表共享模式和独占模式。所谓共享模式是一个锁允许多条线程同时操作(信号量Semaphore 就是基子 AQS 的共享模式实现的)，独占模式是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待（如 ReentranLock)。</li>
<li>AQS 通过内部类 ConditionObject 构建等待队列（可有多个)，当Condition 调用 wait()方法后，线程将会加入等待队列中，而当Condition 调用 signal() 方法后，线程将从等待队列转移动同步队列中进行锁竞争。</li>
<li>AQS 和Condition 各自维护了不同的队列，在使用 Lock 和 Condition的时候，其实就是两个队列的互相移动。</li>
</ol>
<h3 id="✅AQS与Lock"><a href="#✅AQS与Lock" class="headerlink" title="✅AQS与Lock"></a>✅AQS与Lock</h3><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。锁是面向使用者的，它定义了使用者与锁交互的接口。同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。<br>同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法（tryAcquire独占式获取 非阻塞、tryAcquireShared共享式获取），随后将同步器作为静态内部类组合在自定义同步组件的实现中，并调用同步器提供的模板方法（acquire独占式获取同步状态 获取失败会进入同步队列等待、acquireShared共享式获取）。</p>
<p>lock和tryLock的区别：<br>lock是非阻塞的，会一直尝试或锁，用acquire方法（内部用tryAcquire方法）线程调用该方法获取同步状态失败后会被加入到同步队列中等待；<br>tryLock是阻塞的，获取一次，所以直接用tryAcquire方法。</p>
<h3 id="✅等待通知机制"><a href="#✅等待通知机制" class="headerlink" title="✅等待通知机制"></a>✅等待通知机制</h3><p>用的是Object对象的监视器方法，Synchronized、wait、notify、notifyAll。<br>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。（两个notify都是通知等待队列里的，不是阻塞状态的同步队列，notify通知一个，notifyAll通知所有）。</p>
<p>经典范式：<br>等待方：<br>synchronized(对象) {<br>    while(条件不满足) {<br>        对象.wait();<br>    }<br>    对应的处理逻辑;<br>}<br>通知方：<br>synchronized(对象) {<br>    改变条件(flag)<br>    对象.notifyAll();<br>}</p>
<p>等待/通知机制依托于同步机制<br>同步的目的：获取了锁才能wait和notify，同步的目的是把修改变量和notify包在一起，让wait出来的时候能感知到变量的变化。</p>
<p>1、wait线程首先获取锁，调用lock的wait方法，放弃了锁，进入等待队列，等待状态。（可以有很多个wait线程）<br>2、notify线程获取了锁，调用lock的notify方法，将wait线程从等待队列移动到了同步队列，是阻塞状态。（notify只能唤醒一个）<br>3、notify线程运行完了，释放锁，wait线程才有机会获取到锁，从wait方法返回并继续执行。</p>
<h3 id="✅Condition接口-等待通知机制"><a href="#✅Condition接口-等待通知机制" class="headerlink" title="✅Condition接口 等待通知机制"></a>✅Condition接口 等待通知机制</h3><p>Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。<br>Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。<br>调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前需要获取锁。</p>
<p>synchronized + Object监视器方法 - 实现等待通知 - 案例线程池（都可以）<br>Lock(队列同步器) + Condition接口 - 实现等待通知 - 案例有界队列</p>
<h3 id="✅ReentrantLock和Synchronized的区别"><a href="#✅ReentrantLock和Synchronized的区别" class="headerlink" title="✅ReentrantLock和Synchronized的区别"></a>✅ReentrantLock和Synchronized的区别</h3><p>ReentrantLock 实现了 Lock 接口，是一个可重入且独占式的锁，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。<br>ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。<br>￼<br>1.两者都是可重入锁<br>可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p>
<p>2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API<br>从锁释放角度， Synchronized 在JVM 层面上实现的，不但可以通过一些监控工具监控 Synchronized 的锁定，而旦在代码执行出现异常 时，JVM会自动释放锁定;但是使用 Lock 则不行，Lock 是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally()中。</p>
<p>3.ReentrantLock 比 synchronized 增加了一些高级功能<br>等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。<br>可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。<br>可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。synchronized关键字就相当于整个 Lock 对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而Condition实例的signalAll()方法，只会唤醒注册在该Condition实例中的所有等待线程。</p>
<p>4.性能<br>从性能角度，Synchronized 早期实现比较低效，对比ReentrantLock，大多数场景性能都相羞较大。<br>但是在 Java 6 中对其进行了非常多的改进，在竞争不激烈时，Synchronized 的性能要优于 ReetrantLock；在高竞争情况下，Synchronized 的性能会下降几十倍，但是ReetrantLock 的性能能维持常态。</p>
<h3 id="✅ReentrantLock如何实现可重入的"><a href="#✅ReentrantLock如何实现可重入的" class="headerlink" title="✅ReentrantLock如何实现可重入的"></a>✅ReentrantLock如何实现可重入的</h3><p>在于使用一个计数器来跟踪锁的持有次数，每次持有锁时计数器加一，释放锁时计数器减一，只有当计数器为0时，锁才能被完全释放。acquire方法获取锁时，如果当前线程已经拥有该锁，计数器加一并返回true，否则使用CAS原子操作来尝试获取锁。</p>
<h3 id="✅ReentrantReadWriteLock读写锁"><a href="#✅ReentrantReadWriteLock读写锁" class="headerlink" title="✅ReentrantReadWriteLock读写锁"></a>✅ReentrantReadWriteLock读写锁</h3><p>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升，提供写操作对读操作的可见性以及并发性的提升。</p>
<p>适用场景：在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。</p>
<p>static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();<br>static Lock r = rwl.readLock();<br>static Lock w = rwl.writeLock();</p>
<p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。<br>读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态。按位切割使用。</p>
<h3 id="✅读写锁的锁降级"><a href="#✅读写锁的锁降级" class="headerlink" title="✅读写锁的锁降级"></a>✅读写锁的锁降级</h3><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。</p>
<p>锁降级：先获取写锁，变更数据，再获取读锁，再释放写锁。此时还有读锁，还可以读数据，其他线程也可以获取读锁读数据。这样变更完数据之后，可以多个读线程一起读取数据。</p>
<h3 id="✅线程池"><a href="#✅线程池" class="headerlink" title="✅线程池"></a>✅线程池</h3><p>什么是线程池？<br>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>
<p>为什么要用线程池？<br>池化技术：线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。<br>线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p>￼<br>如何创建线程池？<br>方式一：通过ThreadPoolExecutor构造函数来创建（推荐）。<br>ThreadPoolExecutor(int corePoolSize,<br>int maximumPoolSize,<br>long keepAliveTime,<br>TimeUnit unit,<br>BlockingQueue workQueue,<br>RejectedExecutionHandler handler) </p>
<p>corePoolSize： 任务队列未达到队列容量时，最大可以同时运行的线程数量<br>maximumPoolSize：任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。<br>workQueue： 用于保存等待执行的任务的阻塞队列<br>keepAliveTime： 线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；<br>unit：keepAliveTime的单位<br>threadFactory： 设置创建线程的工厂，可以给线程命名<br>handler： 线程池对拒绝任务的处理策略 </p>
<p>ThreadPoolTaskExecutor定义的一些策略：<br>ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。（默认）<br>ThreadPoolExecutor.CallerRunsPolicy： 直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。<br>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。<br>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。</p>
<p>线程池常用的阻塞队列：<br>1、容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）：FixedThreadPool 和 SingleThreadExector。由于队列永远不会被放满，因此FixedThreadPool最多只能创建核心线程数的线程。<br>2、SynchronousQueue（同步队列） ：CachedThreadPool 。SynchronousQueue 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，CachedThreadPool 的最大线程数是 Integer.MAX_VALUE ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。<br>3、DelayedWorkQueue（延迟阻塞队列）：ScheduledThreadPool 和 SingleThreadScheduledExecutor。DelayedWorkQueue 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。DelayedWorkQueue 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 Integer.MAX_VALUE，所以最多只能创建核心线程数的线程。</p>
<p>方式二：通过 Executor 框架的工具类 Executors 来创建。<br>FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。<br>SingleThreadExecutor： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。<br>CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。<br>ScheduledThreadPool ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</p>
<p>为什么不推荐使用内置线程池？<br>Executors 返回线程池对象的弊端:<br>1、FixedThreadPool 和 SingleThreadExecutor ： 使用的是无界的 LinkedBlockingQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。<br>2、CachedThreadPool ：使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。<br>3、ScheduledThreadPool 和 SingleThreadScheduledExecutor : 使用的无界的延迟阻塞队列DelayedWorkQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</p>
<p>线程池处理任务的流程：<br>￼<br>1、如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。<br>2、如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。<br>3、如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。<br>4、如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用RejectedExecutionHandler.rejectedExecution()方法。</p>
<p>处理任务的优先级为：<br>核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。</p>
<h3 id="✅线程的生命周期和状态"><a href="#✅线程的生命周期和状态" class="headerlink" title="✅线程的生命周期和状态"></a>✅线程的生命周期和状态</h3><p>1、NEW: 初始状态，线程被创建出来但没有被调用 start() 。<br>2、RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。<br>3、BLOCKED ：阻塞状态，需要等待锁释放。当线程进入 synchronized 方法/块或者调用 wait 后（被 notify）重新进入 synchronized 方法/块，但是锁被其它线程占有，这个时候线程就会进入 BLOCKED（阻塞） 状态。<br>4、WAITING：等待状态，wait()方法之后进入，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。<br>5、TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。sleep（long millis）方法或 wait（long millis）方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。<br>6、TERMINATED：终止状态，表示该线程已经运行完毕。在执行完了 run()方法之后将会进入到 TERMINATED（终止） 状态。</p>
<p>￼</p>
<h3 id="✅线程相关的几个方法"><a href="#✅线程相关的几个方法" class="headerlink" title="✅线程相关的几个方法"></a>✅线程相关的几个方法</h3><p>thread.start 方法，启动线程<br>thread.suspend()、resume()和stop()方法，过时，终结一个线程时不会保证线程的资源正常释放。<br>thread.interrupt 中断线程<br>Object上的监视器方法：wait、notify、notifyAll<br>thread.join()：当前线程A等待thread线程终止之后才从thread.join()返回，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。<br>Thread.yield(): yield方法是Thread类的静态方法，重新分配。<br>会把当前线程从可运行状态变成就绪状态。<br>之后会cpu会从众多就绪状态的线程中选择一个来执行。<br>Thread.sleep(): 是Thread类的静态方法，</p>
<h3 id="✅thread的join方法原理"><a href="#✅thread的join方法原理" class="headerlink" title="✅thread的join方法原理"></a>✅thread的join方法原理</h3><p>【原理：等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）。加锁、循环和处理逻辑3个步骤。】<br>1、线程a执行线程b的join方法，相当于用线程b对象做同步，内部本线程wait进入等待，并用一个变量flag进行条件判断。<br>2、线程b终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。</p>
<h3 id="✅如何安全地终止线程"><a href="#✅如何安全地终止线程" class="headerlink" title="✅如何安全地终止线程"></a>✅如何安全地终止线程</h3><p>方法1：使用中断interrupt方法进行中断。<br>方法2：等待通知机制，使用一个volatile的boolean类型变量来控制，实际上是中断while方法，然后执行完run方法，终止。</p>
<h3 id="✅sleep-方法和-wait-方法对比"><a href="#✅sleep-方法和-wait-方法对比" class="headerlink" title="✅sleep() 方法和 wait() 方法对比"></a>✅sleep() 方法和 wait() 方法对比</h3><p>共同点 ：两者都可以暂停线程的执行。<br>区别 ：</p>
<ul>
<li>sleep() 方法没有释放锁，而 wait() 方法释放了锁 。</li>
<li>wait() 通常被用于线程间交互/通信，sleep()通常被用于暂停执行。</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll()方法，如果没获取锁进入阻塞状态。sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。</li>
<li>sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。</li>
</ul>
<h3 id="✅为什么-wait-方法不定义在-Thread-中？"><a href="#✅为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="✅为什么 wait() 方法不定义在 Thread 中？"></a>✅为什么 wait() 方法不定义在 Thread 中？</h3><p>wait() 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（Object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（Object）而非当前的线程（Thread）。<br>类似的问题：为什么 sleep() 方法定义在 Thread 中？<br>因为 sleep() 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
<h3 id="✅可以直接调用-Thread-类的-run-方法吗？"><a href="#✅可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="✅可以直接调用 Thread 类的 run 方法吗？"></a>✅可以直接调用 Thread 类的 run 方法吗？</h3><p>new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。<br>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</p>
<h3 id="✅Runnable和Thread的区别"><a href="#✅Runnable和Thread的区别" class="headerlink" title="✅Runnable和Thread的区别"></a>✅Runnable和Thread的区别</h3><p>Runnable是一个接口，它包含了一个run()方法，用来实现一个线程的具体操作。而Thread则是一个类，它实现了Runnable接口，并拥有其它一些方法，如start()、sleep()、yield()等。一个线程必须通过Thread类的构造函数来创建。因此，Runnable可以被认为是Thread的一个组成部分。在使用线程时，我们可以选择扩展Thread类或者实现Runnable接口来自定义线程类，这取决于具体的需求和设计。一般来说，实现Runnable接口的方式更为灵活。</p>
<p>Runnable更容易可以实现多个线程间的资源共享，提交给Thread同一个Runnable对象，共享其中的private对象。（只是共享，线程安全要加同步）。而Thread也是可以的，只不过是多个thread对象共享static变量，或者提交同一个Thread对象，并且static只是可见，还需要加同步才是线程安全的。</p>
<h3 id="✅Runnable和Callable区别"><a href="#✅Runnable和Callable区别" class="headerlink" title="✅Runnable和Callable区别"></a>✅Runnable和Callable区别</h3><p>Runnable接口和Callable接口都可以用来定义多线程的任务，它们都可以被线程执行，但是二者有几个区别。</p>
<ol>
<li>方法签名不同<br>Runnable接口定义了—个run()方法，该方法没有返回值，只能使用void类型来定义。<br>callable接口定 义了一个call()方法，该方法可以返回一个指定类型的结果，并旦可以抛出异常。</li>
<li>返回值类型不同<br>Rupnable接口的run()方法没有返回值，因此在执行任务后无法获得执行结果。<br>Callable接口的call()方法可以返回一个指定类型的结果对象，可以通过Future接口来获取执行结果。</li>
<li>异常处理不同<br>Runnable接口的run()方法无法抛出异常，只能在任务内部进行异常处理。<br>Callable接回的call()方法可以抛出异常，可以通过执行结果Future的get()方法来获取异常信息。<br>综上所述，Runnable接口适用于 不需要获取任务执行结果的情况，而Callable接口适用于需要获取任务执行结果并且可能会抛出异常的情况。</li>
</ol>
<p>1、Callable能接受一个泛型，然后在call方法中返回一个这个类型的值。而Runnable的run方法没有返回值<br>2、Callable的call方法可以抛出异常，而Runnable的run方法不会抛出异常。</p>
<h3 id="✅ThreadPoolExecutor的execute方法和submit方法"><a href="#✅ThreadPoolExecutor的execute方法和submit方法" class="headerlink" title="✅ThreadPoolExecutor的execute方法和submit方法"></a>✅ThreadPoolExecutor的execute方法和submit方法</h3><p>1、execute是Executor接口的方法，而submit是ExecutorService的方法，并且ExecutorService接口继承了Executor接口。<br>2、execute只接受Runnable参数，没有返回值；而submit可以接受Runnable参数和Callable参数，并且返回了Future对象，可以进行任务取消、获取任务结果、判断任务是否执行完毕/取消等操作。<br>3、submit会对Runnable或Callable入参封装成RunnableFuture对象（同时继承了Runnable接口和Future接口），调用execute方法并返回。FutureTask是实现了RunnableFuture接口<br>4、通过execute方法提交的任务如果出现异常则直接抛出原异常，是在线程池中的线程中；而submit方法是捕获了异常的，只有当调用Future的get方法时，才会抛出ExecutionException异常，且是在调用get方法的线程。</p>
<p>submit方法的异常可以在主线程中catch到。而使用execute方法执行任务是捕捉不到异常的。</p>
<p><T> Future<T> submit(Callable<T> task);<br><T> Future<T> submit(Runnable task, T result);<br>Future&lt;?&gt; submit(Runnable task);</T></T></T></T></T></p>
<h3 id="✅Future-类"><a href="#✅Future-类" class="headerlink" title="✅Future 类"></a>✅Future 类</h3><p>Future 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>
<p>这其实就是多线程中经典的 Future 模式，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。<br>在 Java 中，Future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>
<ul>
<li>取消任务；  cancel</li>
<li>判断任务是否被取消;  isCancelled</li>
<li>判断任务是否已经执行完成;  isDone</li>
<li>获取任务执行结果。  get</li>
</ul>
<p>简单理解就是：我有一个任务，提交给了 Future 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 Future 那里直接取出任务执行结果。</p>
<p>Future future = executor.submit(myCallable);<br>System.out.println(“获取返回值: “+future.get());</p>
<h3 id="✅Callable-和-Future-有什么关系？"><a href="#✅Callable-和-Future-有什么关系？" class="headerlink" title="✅Callable 和 Future 有什么关系？"></a>✅Callable 和 Future 有什么关系？</h3><p>可以通过 FutureTask 来理解 Callable 和 Future 之间的关系。<br>FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。ExecutorService.submit() 方法返回的其实就是 Future 的实现类 FutureTask 。<br>￼<br>FutureTask 不光实现了 Future接口，还实现了Runnable 接口，因此可以作为任务直接被线程执行。<br>FutureTask 有两个构造函数，可传入 Callable 或者 Runnable 对象。实际上，传入 Runnable 对象也会在方法内部转换为Callable 对象。<br>FutureTask相当于对Callable 进行了封装，管理着任务执行的情况，存储了 Callable 的 call 方法的任务执行结果。</p>
<h3 id="✅CompletableFuture-类"><a href="#✅CompletableFuture-类" class="headerlink" title="✅CompletableFuture 类"></a>✅CompletableFuture 类</h3><p>Future 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。<br>Java 8 才被引入CompletableFuture 类可以解决Future 的这些缺陷。CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。<br>￼<br>可以看到，CompletableFuture 同时实现了 Future 和 CompletionStage 接口。<br>CompletionStage 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。<br>CompletionStage 接口中的方法比较多，CompletableFuture 的函数式能力就是这个接口赋予的。</p>
<h3 id="✅ThreadLocal干嘛的"><a href="#✅ThreadLocal干嘛的" class="headerlink" title="✅ThreadLocal干嘛的"></a>✅ThreadLocal干嘛的</h3><p>成员变量：如果使用一个Runnable对象创建多个线程，多个线程共享成员变量，多个线程对该变量进行操作是彼此影响的，是线程不安全的。需要加锁，达到线程安全。</p>
<p>局部变量（方法块里的）：每个线程都会有局部变量的拷贝，一个线程对局部变量的操作不会影响其他线程。</p>
<p>ThreadLocal类：让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<p>使用：<br>public static class MyRunnable implements Runnable {<br>        private ThreadLocal<Integer> threadLocal = new ThreadLocal<Integer>();<br>        int local = 1;</Integer></Integer></p>
<pre><code>    @Override
    public void run() &#123;
        threadLocal.set((int) (Math.random() * 100D));
        local = (int) (Math.random() * 100D);
        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
        &#125;
        System.out.println(&quot;threadLocal:&quot; +threadLocal.get());
        System.out.println(&quot;local:&quot; +local);
    &#125;
&#125;
</code></pre>
<h3 id="✅ThreadLocal-原理"><a href="#✅ThreadLocal-原理" class="headerlink" title="✅ThreadLocal 原理"></a>✅ThreadLocal 原理</h3><p>从 Thread类源代码入手。<br>public class Thread implements Runnable {<br>     //与此线程有关的ThreadLocal值。由ThreadLocal类维护<br>    ThreadLocal.ThreadLocalMap threadLocals = null; </p>
<pre><code>//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护 
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; 
</code></pre>
<p>}</p>
<p>从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是 null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。</p>
<p>ThreadLocal类的set()方法：<br>public void set(T value) {<br>    //获取当前请求的线程<br>    Thread t = Thread.currentThread();<br>    //取出 Thread 类内部的 threadLocals 变量(哈希表结构)<br>    ThreadLocalMap map = getMap(t);<br>    if (map != null)<br>        // 将需要存储的值放入到这个哈希表中<br>        map.set(this, value);<br>    else<br>        createMap(t, value);<br>     }<br>ThreadLocalMap getMap(Thread t) { return t.threadLocals; }</p>
<p>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。 ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。<br>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。所以可以有多个ThreadLocal。</p>
<h3 id="✅ThreadLocal-内存泄露问题是怎么导致的？"><a href="#✅ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="✅ThreadLocal 内存泄露问题是怎么导致的？"></a>✅ThreadLocal 内存泄露问题是怎么导致的？</h3><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。<br>这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法</p>
<h3 id="✅强引用、软引用用、弱引用"><a href="#✅强引用、软引用用、弱引用" class="headerlink" title="✅强引用、软引用用、弱引用"></a>✅强引用、软引用用、弱引用</h3><p>是Jave中用来管理对象生命周期的三种引用方式。<br>1、强引用：是最普通的对象引用方式，只要一个对象被强引用引用，就不会被回收。例如：Object obj = new object().<br>2、软引用：是一种比强引用弱一些的引用方式，如果内存足够时，软引用不会被回收，如果内存不足时，就会被回收。可以通过SoftReference类来实现软引用。例如：SoftReterence<br>sra new SoftReference&lt;&gt; (new Object())。<br>3、弱引用：是一种比软引用更弱的引用方方式，只要被弱引用引用，没有被强引用或软引用所引用，就会被回收。<br>可以通过WeakReference类来实现弱引用。例如：WeakReference wr = new WeakPeference&lt;&gt; (new Object())。</p>
<p>总的来说，弱引用、软引用是为了解决内存泄漏问题而产生的技术手段，通过合理地使用它们可以更好地管理内存，提高程序的性能和稳定性。</p>
<h3 id="✅什么是Java-的内存模型，Java-中各个线程是怎么彼此看到-对方的变量的？"><a href="#✅什么是Java-的内存模型，Java-中各个线程是怎么彼此看到-对方的变量的？" class="headerlink" title="✅什么是Java 的内存模型，Java 中各个线程是怎么彼此看到 对方的变量的？"></a>✅什么是Java 的内存模型，Java 中各个线程是怎么彼此看到 对方的变量的？</h3><p>Java 的内存模型定义了程序中各个变量的访问规则，即在虛拟机中将 变量存储到内存和从内存中取出这样的底层细节。此处的变量包括实例字段、静态宇段和构成数组对象的元素，但是不包括局部变量和方法参数，因为这些是线程私有的，不会被共享，所以不存在竞争问题。</p>
<p>java 中各个线程是怎么彼此看到对方的变量的呢?<br>Java 中定义了主内存与工作内存的概念：<br>所有的变量都存储在主内存，每条线程还有自己的工作内存，保存了被该线程使用到的变量的主内存副本拷贝。</p>
<p>线程对变量的所有操作(读取、赋值)都必须在工作内存中进行，不能直接读写主内存的变量。不同的线程之间也无法直接访问对方工作内存的变量，线程间变量值的传递需要通过主内存。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/01/myblog/%E5%85%AB%E8%82%A1/java%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/01/myblog/%E5%85%AB%E8%82%A1/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="post-title-link" itemprop="url">java虚拟机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-01 18:19:42 / Modified: 18:21:15" itemprop="dateCreated datePublished" datetime="2023-05-01T18:19:42+08:00">2023-05-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>八股文 - java内存模型</p>
<h3 id="✅java内存模型"><a href="#✅java内存模型" class="headerlink" title="✅java内存模型"></a>✅java内存模型</h3><p>虚拟机自动内存管理机制：不再需要像 C/C++为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机。<br>JDK 1.8 之前 ：<br>￼<br>JDK 1.8 之后 ：<br>￼<br>线程私有的：</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈<br>线程共享的：</li>
<li>堆</li>
<li>方法区</li>
<li>直接内存 (非运行时数据区的一部分)<br>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</li>
</ul>
<p>1、程序计数器：<br>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<br>程序计数器主要有两个作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
<li>程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</li>
</ul>
<p>2、Java 虚拟机栈<br>1.存放：在函数中定义的一些基本类型的变量(8种，int, short, long, byte, float, double, boolean, char，不包含String)和对象的引用变量、main方法、方法函数、局部变量<br>2.Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。<br>3.栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。<br>4.方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。<br>5.栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。<br>6.局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。<br>7.操作数栈主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。<br>8.动态链接主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池（方法区里的）里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。<br>9.Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。<br>10.栈可能会出现两种错误：</p>
<ul>
<li>StackOverFlowError： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。（hotspot虚拟机的栈容量是不允许动态扩展的）</li>
<li>OutOfMemoryError： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。hotspot不支持扩展。</li>
</ul>
<p>3、本地方法栈<br>1.和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<br>2.本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。<br>3.方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p>
<p>4、堆<br>1.Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。<br>2.随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。<br>3.Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。<br>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永久代(Permanent Generation)<br>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存<br>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。<br>晋升到老年代的条件：<br>“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</li>
<li>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</li>
<li>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li>java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值</li>
</ol>
<p>5、方法区<br>1.方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。<br>2.当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。<br>3.方法区和永久代以及元空间是什么关系呢？<br>方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。<br>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</p>
<ol>
<li>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。当元空间溢出时会得到如下错误： java.lang.OutOfMemoryError: MetaSpace。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</li>
<li>元空间里面存放的是类的元数据，这样加载多少类的元数据就方法区大小控制, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</li>
<li>并非数据进入方法区后就“永久存在”了，元空间使用的是直接内存，与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存</li>
</ol>
<p>6、运行时常量池<br>1.Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 常量池表(Constant Pool Table) 。<br>2.字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量，符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。<br>3.常量池表会在类加载后存放到方法区的运行时常量池中。<br>5.运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。<br>6.既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>
<p>7、字符串常量池<br>1.字符串常量池是JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。<br>// 在堆中创建字符串对象”ab“<br>// 将字符串对象”ab“的引用保存在字符串常量池中<br>String aa = “ab”;<br>// 直接返回字符串常量池中字符串对象”ab“的引用<br>String bb = “ab”;<br>System.out.println(aa==bb);// true<br>2.HotSpot 虚拟机中字符串常量池的实现是 src/hotspot/share/classfile/stringTable.cpp ,StringTable 本质上就是一个HashSet<String> ,容量为 StringTableSize（可以通过 -XX:StringTableSize 参数来设置）<br>3.StringTable 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。<br>4.JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。<br>JDK 1.7 为什么要将字符串常量池移动到堆中？<br>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。还有：避免永久代溢出的问题。<br>5.JVM 常量池中存储的是对象还是引用呢？<br>目前认为是引用</String></p>
<p>8、直接内存<br>1.直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。<br>2.JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。<br>3.本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h3 id="✅string不可变"><a href="#✅string不可变" class="headerlink" title="✅string不可变"></a>✅string不可变</h3><p>1.什么是不可变对象？<br>在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ 可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。<br>String s = “123”;   s = “456”;<br>s只是一个String对象的引用，并不是对象本身。对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。当s=“456”; 这句代码执行过之后，又创建了一个新的对象“456”， 而引用s重新指向了这个新的对象，原来的对象“123”还在内存中存在，并没有改变。</p>
<p>2.java的引用和c++的指针<br>Java和C++的一个不同点是， 在Java中不可能直接操作对象本身，所有的对象都由一个引用指向，必须通过这个引用才能访问对象本身，包括获取成员变量的值，改变对象的成员变量，调用对象的方法等。而在C++中存在引用，对象和指针三个东西，这三个东西都可以访问对象。其实，Java中的引用和C++中的指针在概念上是相似的，他们都是存放的对象在内存中的地址值，只是在Java中，引用丧失了部分灵活性，比如Java中的引用不能像C++中的指针那样进行加减运算。</p>
<p>3.为什么String对象是不可变的？<br>JDK7中，String有： private final char value[]; 和private int hash; 是该String对象的哈希值的缓存。在Java中，数组也是对象，所以value也只是一个引用，它指向一个真正的数组对象。<br>被 final 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，final 关键字修饰的数组保存字符串并不是 String 不可变的根本原因，因为这个数组保存的字符串是可变的（final 修饰引用类型变量的情况）。<br>String 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。</li>
<li>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。</li>
</ol>
<p>4.在String中，存在一些方法，调用他们可以得到改变后的值。这些方法包括substring， replace， replaceAll， toLowerCase等，这些方法内部创建了一个新的String对象，并且返回这个新的对象，原来的对象是不会被改变的。这也是方法都存在返回值的原因。</p>
<p>6.String对象真的不可变吗？<br>String的成员变量是private final 的，也就是初始化之后不可改变。那么在这几个成员中， value比较特殊，因为他是一个引用变量，而不是真正的对象。value是final修饰的，也就是说final不能再指向其他数组对象，但是可以改变value指向的数组。<br>用反射， 可以反射出String对象中的value属性， 进而通过获得的value引用改变数组的结构。<br>public static void testReflection() throws Exception {</p>
<pre><code>//创建字符串&quot;Hello World&quot;， 并赋给引用s
String s = &quot;Hello World&quot;; 
    
System.out.println(&quot;s = &quot; + s);    //Hello World
    
//获取String类中的value字段
Field valueFieldOfString = String.class.getDeclaredField(&quot;value&quot;);
    
//改变value属性的访问权限
valueFieldOfString.setAccessible(true);
    
//获取s对象上的value属性的值
char[] value = (char[]) valueFieldOfString.get(s);
    
//改变value所引用的数组中的第5个字符
value[5] = &#39;_&#39;;
    
System.out.println(&quot;s = &quot; + s);  //Hello_World
</code></pre>
<p>}</p>
<p>在这个过程中，s始终引用的同一个String对象，但是再反射前后，这个String对象发生了变化， 也就是说，通过反射是可以修改所谓的“不可变”对象的。</p>
<p>7.字符串拼接用“+” 还是 StringBuilder?<br>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。<br>看对应的字节码就知道：字符串对象通过“+”的字符串拼接方式，实际上是通过创建StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。<br>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。如果直接使用 StringBuilder 对象进行字符串拼接的话，就不会存在这个问题了。</p>
<p>8.String s1 = new String(“abc”);这句话创建了几个字符串对象？<br>会创建 1 或 2 个字符串对象。<br>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。<br>ldc 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。<br>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>
<p>9.String的intern 方法<br>String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中。</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。（首次遇见的原则）</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<p>// 在堆中创建字符串对象”Java“<br>// 将字符串对象”Java“的引用保存在字符串常量池中<br>String s1 = “Java”;<br>// 直接返回字符串常量池中字符串对象”Java“对应的引用<br>String s2 = s1.intern();<br>// 会在堆中在单独创建一个字符串对象<br>String s3 = new String(“Java”);<br>// 直接返回字符串常量池中字符串对象”Java“对应的引用<br>String s4 = s3.intern();<br>// s1 和 s2 指向的是堆中的同一个对象<br>System.out.println(s1 == s2); // true<br>// s3 和 s4 指向的是堆中不同的对象<br>System.out.println(s3 == s4); // false<br>// s1 和 s4 指向的是堆中的同一个对象<br>System.out.println(s1 == s4); //true</p>
<p>String s5 = new StringBuilder(“hello”).append(“world”).toString();<br>//s5这种创建方式和String s = “sss”;  是一样的，在字符串常量池中<br>String s6 = s5.intern();<br>System.out.println(s5 == s6);  //true</p>
<p>10.String 类型的变量和常量做“+”运算时发生了什么？<br>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。<br>在编译过程中，Javac 编译器会进行一个叫做 常量折叠(Constant Folding) 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中。<br>只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。</li>
<li>final 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）<br>对于 String str3 = “str” + “ing”; 编译器会给你优化成 String str3 = “string”;<br>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</li>
</ul>
<h3 id="✅java对象的创建"><a href="#✅java对象的创建" class="headerlink" title="✅java对象的创建"></a>✅java对象的创建</h3><p>HotSpot 虚拟机在 Java 堆中对象的创建：</p>
<p>Step1:类加载检查<br>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>Step2:分配内存<br>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p>内存分配的两种方式 ：</p>
<ul>
<li>指针碰撞 ： <ul>
<li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li>空闲列表 ： <ul>
<li>适用场合 ： 堆内存不规整的情况下。</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p>
<p>内存分配并发问题<br>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li>CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li>
<li>TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<p>Step3:初始化零值<br>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>Step4:设置对象头<br>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>Step5:执行 init 方法<br>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</init></init></p>
<h3 id="✅java对象的内存布局"><a href="#✅java对象的内存布局" class="headerlink" title="✅java对象的内存布局"></a>✅java对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。</p>
<p>Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志、线程持有锁、偏向锁id、偏向时间戳等等）也叫Mark Word，32位虚拟机占32bit，64位占64bit，另一部分是类型指针，即对象指向它的类型元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是Java数组，还需要一块用于记录数组长度的数据。</p>
<p>实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</p>
<p>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="✅对象的访问定位"><a href="#✅对象的访问定位" class="headerlink" title="✅对象的访问定位"></a>✅对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。</p>
<p>句柄<br>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。<br>￼<br>直接指针<br>如果使用直接指针访问，reference 中存储的直接就是对象的地址。这样的话，java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息。<br>￼</p>
<p>这两种对象访问方式各有优势。<br>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。<br>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。<br>HotSpot 虚拟机主要使用的就是直接指针访问方式来进行对象访问。</p>
<h3 id="✅内存溢出和内存泄漏"><a href="#✅内存溢出和内存泄漏" class="headerlink" title="✅内存溢出和内存泄漏"></a>✅内存溢出和内存泄漏</h3><p>一、内存溢出 (OutOfMemory)<br>它是指程序在申请内存时，没有足够的内存空间供其使用，抛出OutOfMemory异常。<br>比如申请了一个8MB空间，但是当前内存可用空间只有5MB，那么就是内存溢出；<br>即：OutOfMemoryError，是指没有空闲内存，垃圾收集器回收后也不能提供更多的内存空间；</p>
<p>二、内存泄漏 (Memory Leak)<br>它是指程序运行后，没有释放所占用的内存空间（程序中有引用没有释放，不能被GC回收），一次内存泄漏可能不会有很大的影响，但长时间的内存泄漏，堆积到一定程度就会产生内存溢出。<br>（1）单例对象，生命周期和应用程序一样长，如果单例对象持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会产生内存泄漏。<br>（2）一些资源未关闭也会导致内存泄漏，比如数据库连接，网络连接socket的IO流的连接都必须在finally中close，否则不能被回收的。</p>
<p>内存泄漏的堆积最终会导致内存溢出，内存溢出，第一步要看导致OOM的对象是否是必要的，如果不是必要的，就有可能是内存泄漏。检查是否某些对象内存周期过长，持有状态时间过长，存储结构设计不合理等。</p>
<p>操作系统分配给每个进程的内存是有限的，32位windows是2GB。</p>
<h3 id="✅内存动态分配和垃圾收集技术"><a href="#✅内存动态分配和垃圾收集技术" class="headerlink" title="✅内存动态分配和垃圾收集技术"></a>✅内存动态分配和垃圾收集技术</h3><p>程序计数器、虚拟机栈、本地方法栈 随线程而生，随线程而灭。栈中的栈帧随方法的进入和退出执行出栈和入栈，每一个栈帧中分配多少内存载类结构确认下来时就已知了，在编译期间基本确定。<br>Java堆和方法区只有在运行期间才能知道要创建哪些对象多少对象，这部分内存的分配和回收是动态的。</p>
<p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收。<br>Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。<br>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p>
<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永久代(Permanent Generation)<br>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</li>
</ol>
<p>￼<br>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存 。</p>
<h3 id="✅死亡对象判断方法"><a href="#✅死亡对象判断方法" class="headerlink" title="✅死亡对象判断方法"></a>✅死亡对象判断方法</h3><p>对象已经死亡（即不能再被任何途径使用的对象）</p>
<p>1、引用计数法<br>给对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加 1；</li>
<li>当引用失效，计数器就减 1；</li>
<li>任何时候计数器为 0 的对象就是不可能再被使用的。<br>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</li>
</ul>
<p>2、可达性分析算法<br>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
<p>哪些对象可以作为 GC Roots 呢？</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<p>对象可以被回收，就代表一定会被回收吗？<br>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；<br>1.可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行finalize方法。<br>2.被判定为需要执行finalize方法的对象将会被放在一个队列中进行第二次标记，除非这个对象在finalize方法中与引用链上的任何一个对象建立关联。会被移出队列，否则就会被真的回收。</p>
<p>Object 类中的 finalize 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 finalize 方法会被逐渐弃用移除。用try-finally做外部资源的清理工作。</p>
<h3 id="✅对象的引用"><a href="#✅对象的引用" class="headerlink" title="✅对象的引用"></a>✅对象的引用</h3><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。<br>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）<br>1．强引用（StrongReference）<br>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj =new Object()”这种引用关系。无论任何情况下，是要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。<br>2．软引用（SoftReference）<br>软引用是用来描达一些还有用，但非必须的对象。只被软引用关联看的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出昇常。在JK 1.2版之后提供了SoftReference 类来实现软引用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。<br>3．弱引用（WeakReference）<br>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2 版之后提供了WeakReference 类来实现弱引用。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>4．虚引用（PhantomReference）<br>虚引用也称为“幽灵引用” 或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。</p>
<p>虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。<br>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</p>
<h3 id="✅回收方法区"><a href="#✅回收方法区" class="headerlink" title="✅回收方法区"></a>✅回收方法区</h3><p>方法区的垃圾收集回收两部分：废弃的常量和不再使用的类型。</p>
<p>1、如何判断一个常量是废弃常量？<br>运行时常量池主要回收的是废弃的常量。<br>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p>
<p>运行时常量池和字符串常量池关系：<br>1、JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代<br>2、JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。<br>3、JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</p>
<p>Java中的运行时常量池和字符串常量池是两个不同的概念，但它们之间存在一定的关系。<br>运行时常量池是位于方法区中的一块内存区域，用于存储编译期生成的各种字面量和符号引用。这些字面量包括整点、浮点数、字符、字符串等，符号引用包括类的全限定名、宇段名称、方法名称等。运行时常量池中的内容在类加载时被加载，并旦在运行期间不可更改。<br>字符串常量池是运行时常量池中的一部分，用于存储所有字符串字面量。当程序中使用字符串常量时，JVM会首先在字符串常量池中查找是否己经存在相同的宇符串，如果存在则直接返回常量池中的引用，否则将该字符串添加到常量池中。<br>因此，字符串常量池是运行时常池中的一个子集， 是用于存储字符串字面量的特殊区域。同时，由于字符串在Java中是非常常用的数据类型，因此字符串常量池在Java中也是一个比较重要的概念。<br>但是，不同的jdk版本字符串常量池的实现不同。</p>
<p>2、如何判断一个类是无用的类<br>类需要同时满足下面 3 个条件才能算是 “无用的类” ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</li>
</ul>
<h3 id="✅什么是java动态类"><a href="#✅什么是java动态类" class="headerlink" title="✅什么是java动态类"></a>✅什么是java动态类</h3><p>Java动态类是指在程序运行期间动态创建的类，在编写程序时不需要预先定义它们。这些类通常是通过反射机制创建的，并且可以在运行时添加、修改或删除类的属性和方法。<br>Java动态类可以有许多用途，例如在运行时生成代理类、动态加载类、实现动态代理等。它们通常使用java的反射机制和字节码操作技术实现，可以提供更加灵活和动态的程序设计方式。</p>
<p>在Java中，使用static关键字修饰的类被称为静态内部类，而不是静态类。静态内部类是指在类的内部定义的另一个类，与外部类同级别，但是可以使用static关键字修饰来标记为静态内部类，而不是非静态内部类。静态内部类可以直接通过外部类名来访问，无需通过外部类实例化对象，可以看做是外部类的一个静态成员。但需要注意的是，静态内部类不能访问外部类的非静态成员，只能访问静态成员。因此，静态内部类的作用范国只在外部类中，而不会影响到其他的类。</p>
<h3 id="✅垃圾收集算法"><a href="#✅垃圾收集算法" class="headerlink" title="✅垃圾收集算法"></a>✅垃圾收集算法</h3><p>根据如何判定对象消亡，分为引用计数式垃圾收集和追踪式垃圾收集。引用计数式垃圾收集在主流java虚拟机中未涉及。</p>
<h3 id="✅分代收集理论"><a href="#✅分代收集理论" class="headerlink" title="✅分代收集理论"></a>✅分代收集理论</h3><p>根据对象存活周期的不同将内存分为几块。一般将 java 堆根据对象年龄分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>
<p>基于的分代假说：<br>1.绝大多数对象朝生夕灭<br>2.熬过多次垃圾收集的对象越难以消亡<br>3.跨代引用相对于同代引用来说很少</p>
<p> 部分收集（Partial GC)：指目标不是完整收集整个Java堆的垃圾收集，其中分为：<br>◎新生代收集 (Minor GC/Young GC)：指目标只是新生代的垃圾收集。<br>◎老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。<br>◎混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1 收集器会有这种行为。<br>整堆收集(Full GC)：收集整个Java 堆和方法区的垃圾收集。</p>
<h3 id="✅标记-清除算法"><a href="#✅标记-清除算法" class="headerlink" title="✅标记-清除算法"></a>✅标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。或者标记需要回收的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。</p>
<p>这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li>效率问题（标记和清除的执行效率随着对象数量的增长而降低）</li>
<li>空间问题（标记清除后会产生大量不连续的碎片，后续分配较大对象无法找到足够的连续内存时会提前触发另一次垃圾收集动作）</li>
</ol>
<h3 id="✅标记-复制算法"><a href="#✅标记-复制算法" class="headerlink" title="✅标记-复制算法"></a>✅标记-复制算法</h3><p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>缺点：<br>1.如果内存中对象大多数数是存活的，将带来大量的内存间复制开销<br>2.可用内存缩小为原来的一半。</p>
<p>所以，主要用于新生代，新生代中98%的对象熬不过第一轮收集。<br>Appel式回收：新生代分为较大的（80%）Eden空间和两个较小的Survivor空间（10%）<br>可用的内存空间为Eden+其中一个Survivor。垃圾收集中存活的对象复制到另一个Survivor，如果空间容纳不下，有内存的分配担保：对象直接进入老年代。</p>
<h3 id="✅标记-整理算法"><a href="#✅标记-整理算法" class="headerlink" title="✅标记-整理算法"></a>✅标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>缺点：<br>移动存活对象并更新所以引用这些对象的地方负担大。即在内存回收时更复杂，且停顿时间长Stop the world。<br>但是，标记清除算法，不移动对象则在内存分配时更复杂。<br>和稀泥式：虚拟机平时多数时间都用标记-清除算法，暂时容忍内存碎片的存在，直到碎片化大到影响对象分配时，再标记-整理算法收集一次。</p>
<h3 id="✅垃圾收集器"><a href="#✅垃圾收集器" class="headerlink" title="✅垃圾收集器"></a>✅垃圾收集器</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<p>1、Serial 收集器<br>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。这个收集器是一个单线程收集器。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。<br>新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
<p>Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下管理内存不大的虚拟机来说是个不错的选择。</p>
<p>2、ParNew 收集器<br>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。<br>新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。但是G1出现之后，逐渐取代ParNew+CMS。</p>
<p>3、Parallel Scavenge 收集器<br>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样，但是Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 </p>
<p>Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。<br>新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
<p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p>
<p>4、Serial Old 收集器<br>Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<p>5、Parallel Old 收集器<br>Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<p>6、CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。<br>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>
<p>从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li>初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li>并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li>并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。<br>￼</li>
</ul>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：</p>
<ul>
<li>对 CPU 资源敏感（面向并发，所以处理器资源敏感，虽然不会导致用户线程停顿，但是因为占用处理器导致用户的应用程序执行变慢）</li>
<li>无法处理浮动垃圾（在并发标记和并发清理阶段，用户线程还在运行，产生的新的垃圾对象叫做浮动垃圾。并且还需要预留一部分内存空间供用户线程分配对象内存，但是预留的少的话会出现并发失败，这时虚拟机启用Serial Old收集器对老年代垃圾收集，导致full gc，停顿时间长。）；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。（导致没有足够大的连续空间分配给大对象，不得不触发一次full gc）</li>
</ul>
<p>7、G1 收集器<br>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间可控的同时,还具备高吞吐量性能特征.</p>
<p>G1目标是替换掉JDK5中发布的CMS收集器，JDK9发布时，G1宣告取代Parallel Scavenge + Parallel Old组合，成为服务端模式下的默认垃圾收集器。CMS沦为不推荐使用。</p>
<p>建立停顿时间模型，G1跳出垃圾收集范围要么是新生代Minor GC，要么是老年代Major GC，要么是整个堆Full GC，它面向内存任何部分来组成回收集。</p>
<p>G1 开创的基于 Region的堆内存布局是它能够实现这个目标的关键。虽然 G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1 不再坚持<br>固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region)，每一个 Region 都可以根据需要，扮演新生代的Eden室间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。<br>Resion中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象。每个Region 的大小可以通过参数-XX:G1HeapRegionSize 设定，取值范围为 IMB~32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的HumongousRegion<br>之中，G1 的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待。<br>虽然G1 仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，<br>是因力它将 Region 作力単次回收的最小単元，即每次收集到的内存空间都是 Region 大小<br>的整数倍，这样可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。更具体的处理<br>思路是让G1收集器去跟踪各个 Region 里面的垃圾堆积的〝价值” 大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据收集停顿时间优先处理回收价值收益大的gegion。<br>总之：G1使用Region划分内存空间，以及具有优先级的区域回收方式，保证G1收集器在有限时间内获取尽可能高的收集效率。</p>
<p>使用记忆集来避免全堆作为GC roots扫描。记录跨Region的引用对象。</p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p>
<ul>
<li>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li>空间整合：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
<li>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<p>1、初始标记(Initial Marking)：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC 的时候同生完成的，所以G1 收集器在这个阶段实际并没有额外的停顿。</p>
<p>2、并发标记 ( Concurrent Marking)：从GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理 SATB 记录下的在并发时有引用变动的对象。</p>
<p>3、 最终标记(Final Marking)：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。</p>
<p>4、筛选回收 (Live Data Counting and Evacnation)：负责更新 Region 的统计数据，对各个Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空问。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</p>
<p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<p>G1收集器的目标是用户指定期望的停顿时间（默认两百毫秒）的基础上，尽可能高的吞吐量，停顿用户线程可以提高垃圾回收效率，所以回收阶段没有做成与用户线程一起并非执行的，放在了ZGC里。</p>
<p>期望停顿时间如果设置很小，垃圾回收赶不上分配，会引发full gc。<br>（如果是新生代老年代都适用的收集器都有young gc full gc）</p>
<p>CMS和G1的对比：<br>1、相比 CMS, G1 的优点有很多，暂且不论可以指定最大停顿时间、分 Region 的内存布局、按收益动态确定回收集这些创新性设计带来的红利，单从最传统的算法理论上看，G1也更有发展潜力。与CMS 的“标记一清除”算法不同，G1从整体来看是基于“标记一整理” 算法实现的收集器，但从局部(两个 Region 之间）上看又是基于 “标记一复制”算法实现，无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。</p>
<p>2、不过，G1 相对于 CMS 仍然不是占全方位、压倒性优势的，从它出现几年仍不能在所有应用场景中代替 CMS 就可以得知这个结论。比起CMS， G1 的弱项也可以列举出不少，如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用 ( Footprint)还是程序运行时的额外执行负载(Overload）都要比 CMS 要高。<br>就内存占用来说，虽然G1 和 CMS 都使用卡表来处理跨代指针，但 G1 的卡表实现更为复杂，而且堆中每个 Region， 无论扮演的是新生代还是老年代角色，都必领有一份卡表，这导致 G1 的记忆集（和其他内存消耗）可能会占整个堆容量的 20% 乃至更多的内存空间；<br>相比起来 CMS 的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用，反过来则不需要，由于新生代的对象具有朝生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的。</p>
<p>结论：目前在小内存应用上CMS的表现大概率仍然要会优于 G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java 堆容量平衡点通常在 6GB至8GB 之间。</p>
<p>8、ZGC收集器<br>衡量垃圾收集齐的三项指标：内存占用、吞吐量、延迟。<br>随着硬件的发展，内存扩大，反而给延迟带来了负面效果。<br>CMS和G1虽然实现了标记阶段的并发，不会因为要标记的对象变多而导致停顿时间增长。但是CMS标记清除避免不了空间碎片的产生，最终逃不过Stop the world。<br>G1在标记整理阶段还是有暂停的。</p>
<p>Shenandoah收集器：被Oracle排斥在外的收集器。OpenJDK中会包含。<br>可以在任何堆内存下都实现10m以内的停顿时间。<br>与G1的区别：<br>1.支持并发的整理算法，意思是可以与用户线程并发<br>2.没有实现分代<br>3.摒弃了G1中耗费大量内存和计算资源维护的记忆集，改用全局的连接矩阵来记录跨Region的引用关系。</p>
<p>ZGC收集器：JDK11中新加入的具有实验性质的低延迟垃圾收集器。<br>可以实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。<br>ZGC是一款基于Region内存布局的，不设分代的，使用读屏障、染色指针和内存多重映射技术实现可并发标记整理算法的，以低延迟为首要目标的一款垃圾收集器。<br>ZGC的Region具有动态性（动态创建和销毁），以及动态的区域容量大小。<br>染色指针技术：一般情况下在对象头中增加额外的存储字段，如对象的哈希码、分代年龄、锁记录。染色指针是将少量额外的信息存储在引用对象的指针上的技术。缺点是由于占用了指针带宽，使得ZGC可以管理的内存变小。</p>
<p>9、Epsilon收集器<br>不能够进行垃圾收集的垃圾收集器。<br>垃圾收集器作为一个自动内存管理子系统，除了垃圾收集的本职工作外，它还负责堆的管理与布局、对象的分配、与解释器的协作、与监控子系统协作等职责，其中至少堆的管理和对象的分配是java虚拟机能够正常运作的必要支持。<br>Java体系的发展重心：面向长时间、大规模的企业级应用和服务端应用。近年来，大型系统从传统单体应用向微服务化、无服务化方向发展的趋势明显。传统java内存占用大、在容器中启动时间长、即时编译需要缓慢优化等特点。对短时间、小规模的服务形式有诸多不适。最近几个版本的jdk加入了提前编译、面向应用的类数据共享等支持。<br>Epsilon收集器适合运行时间短的虚拟机。</p>
<h3 id="✅自动内存管理：对象内存的分配、回收分配给对象的内存。"><a href="#✅自动内存管理：对象内存的分配、回收分配给对象的内存。" class="headerlink" title="✅自动内存管理：对象内存的分配、回收分配给对象的内存。"></a>✅自动内存管理：对象内存的分配、回收分配给对象的内存。</h3><p>对象分配原则：<br>1.对象优先在eden区中分配，当eden区没有足够的空间进行分配时，虚拟机会发生一次minor gc。如果没对象可以回收或者回收的对象少，eden区还是空间不够，会将存活对象移动至survivor区，如果survivor太小放不下，会通过分配担保机制提前转移到老年代。</p>
<p>2.大对象直接进入老年代<br>大对象：需要大量连续内存空间的java对象，例如很长的字符串、元素数量庞大的数组。<br>Java虚拟机中要避免大对象的原因：再分配空间时，大对象容易导致内存明明还有不少空间时就提前触发垃圾收集。以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。<br>所以，大对象直接进入老年代：目的是避免在eden区及两个survivor区之间来回复制，产生大量的内存复制操作。</p>
<p>3.长期存活的对象将进入老年代<br>虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在Eden区里诞生：如果经过第一次Minor Gc后仍然行活，并且能被 Survivor 容纳的话，该对象会被移动到 Survivor空间中，并且将其对象年龄设定为1岁。对象在 Survivor区中每熬过1次 Minor gc，年龄就增加1岁，当它的年龄增加到一定程度 （默认为 15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-Xx-MaXTenuring Threshold 设置。</p>
<p>4.动态对象年龄判定<br>为了更好适应程序的内存状况，如果survivor空间中满足同年龄对象大小总和达到survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。</p>
<p>5.空间分配担保<br>在发生minor gc之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，可以确保minor gc是安全的（所有对象存活需要老年代进行担保）。如果不成立，需要看虚拟机是否允许担保失败，允许的话检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小（经验值），如果大于，尝试进行一次minor gc（有风险的，担保失败则会重新发起一次full gc，停顿时间更长，但这么做是为了避免full gc过于频繁），如果小于或者不允许担保失败，直接full gc让老年代腾出空间。<br>（jdk6之后都是固定允许担保失败了）</p>
<h3 id="✅JDK-监控和故障处理工具"><a href="#✅JDK-监控和故障处理工具" class="headerlink" title="✅JDK 监控和故障处理工具"></a>✅JDK 监控和故障处理工具</h3><p>Java与c++之间：内存动态分配和垃圾收集技术的墙。<br>Jdk的bin目录下除了java.exe和javac.exe外还有很多工具。</p>
<p>1、jps<br>jps (JVM Process Status）: 类似 UNIX 的 ps 命令。用于查看所有 Java 进程的操作系统进程id、启动类、传入参数和 Java 虚拟机参数等信息；<br>-q 不输出类名、Jar名和传入main方法的参数<br>-m 输出传入main方法的参数<br>-l 输出main类或Jar的全限名<br>-v 输出传入JVM的参数</p>
<p>2、jstat<br>jstat（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据：类加载、垃圾收集、允许期编译状况<br>jstat -gc 进程id 250 4     //150ms一次，查4次<br>jstat -gcutil 23484 1000 5 监视内容基本与gc相同，但输出的主要是已占用的总空间的百分比。<br>S0     S1     E      O（老年代）     P（永久带）   YGC（young gc次数）  YGCT（young gc总耗时）    FGC    FGCT     GCT（所有gc总耗时）</p>
<p>3、jinfo<br>jinfo (Configuration Info for Java) : Configuration Info for Java,实时地查看和调整虚拟机各项参数;<br>例如查询CMSInitiatingOccupancyFraction的参数值：<br>jinfo -flag CMSInitiatingOccupancyFraction 进程id</p>
<p>4、jmap<br>jmap (Memory Map for Java) : 生成堆转储快照;<br>jmap 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。<br>jmap -dump:format=b,file=/tmp/dump.dat 进程id<br>jmap -heap pid查看进程堆内存使用情况，包括使用的GC算法、堆配置参数和各代中堆内存使用情况。</p>
<p>5、jhat<br>jhat (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;<br>jhat 用于分析 heapdump 文件。<br>一般工作中不用，因为要在自己机器上分析，可以用VisualVM等可视化工具。</p>
<p>6、jstack<br>jstack :生成虚拟机当前时刻的线程快照<br>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.<br>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。<br>jstack -l 进程id  ：除堆栈外，显示关于锁的附加信息<br>-F ： 当正常输出的请求不被响应时，强制输出线程堆栈<br>-m： 如果调用到本地方法的话，可以显示C/C++的堆栈</p>
<p>JDK5开始Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中的所有线程的StackTraceElement对象，可以完成jstack的大部分功能，实际项目中可以做个jsp管理员页面，在浏览器上就可以看线程堆栈。</p>
<h3 id="✅可视化故障处理工具"><a href="#✅可视化故障处理工具" class="headerlink" title="✅可视化故障处理工具"></a>✅可视化故障处理工具</h3><p>1、JHSDB：JDK提供的集成式多功能工具箱<br>jhsdb hsdb —pid 进程id    打开图形化模式<br>可以用来调试虚拟机进程或者dump出来的内存转储快照</p>
<p>2、JConsole<br>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出console命令启动或者在 JDK 目录下的 bin 目录找到jconsole.exe然后双击启动。<br>JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况。</p>
<p>3、Visual VM:多合一故障处理工具<br>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。<br>是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。<br>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。<br>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。<br>dump 以及分析堆转储快照（jmap、jhat）。<br>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。<br>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。<br>其他 plugins 的无限的可能性……</p>
<h3 id="✅java无关性"><a href="#✅java无关性" class="headerlink" title="✅java无关性"></a>✅java无关性</h3><p>平台无关性、语言无关性<br>平台无关性：<br>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。可以说.class文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</p>
<p>语言无关性：<br>以Class文件作为不同语言的交付媒介。<br>Kotlin、Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。不同的语言被不同的编译器编译成.class文件最终运行在 Java 虚拟机之上。<br>（《java虚拟机规范》描绘了共有设计：class文件格式和字节码指令集）</p>
<h3 id="✅Class类文件的结构"><a href="#✅Class类文件的结构" class="headerlink" title="✅Class类文件的结构"></a>✅Class类文件的结构</h3><p>Class文件结构很稳定，任何一个Class文件都对应唯一一个类/接口的定义信息。但是反过来，类或接口不一定都得定义在文件里（类或接口动态生成，直接送入类加载器中）。</p>
<p>根据 Java 虚拟机规范，Class 文件通过 ClassFile 定义，有点类似 C 语言的结构体的伪结构。只有两种数据结构：无符号数、表。</p>
<p>1、魔数与Class文件的版本<br>每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件。<br>使用魔数而不是扩展名来进行标识，主要是基于安全考虑。<br>Class文件的魔数是：CAFEBABE</p>
<p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是次版本号，第 7 和第 8 位是主版本号。<br>每当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。你可以使用 javap -v 命令来快速查看 Class 文件的版本号信息。<br>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。<br>jdk1.1 是45，jdk6是50.</p>
<p>2、常量池<br>紧接着主次版本号之后的是常量池，是Class文件结构中与其他项目关联最多的数据，通常是占用Class文件空间最大的数据项目之一，是表类型数据项目。常量池的数量是 constant_pool_count（常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”）。</p>
<p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符<br>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：开始的第一位是一个 u1 类型（1个字节）的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</li>
</ul>
<p>Java代码在虚拟机加载Class文件的时候进行动态连接，将会从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
<p>.class 文件可以通过javap -v class类名 指令来看一下其常量池中的信息(javap -v class类名-&gt; temp.txt ：将结果输出到 temp.txt 文件)。</p>
<p>3、访问标志(Access Flags)<br>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>
<p>4、当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合<br>Java 类的继承关系由类索引（u2两个字节）、父类索引（u2）和接口索引（一组u2）集合三项确定。类索引、父类索引和接口索引集合按照顺序排在访问标志之后，<br>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。<br>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implements (如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。</p>
<p>例如当前类索引，指向常量池中的一个常量，表示类名（不能无限长，64KB，因为一个u2表示长度）。</p>
<p>5、字段表（field info）<br>用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。<br>各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。例如字段的简单名称、字段和方法的描述符。<br>都是：前面一个容量计数器表示字段表数据，后面若干个固定格式。</p>
<p>Java中字段无法重载，但是Class文件中可以。</p>
<p>6、方法表（Method）<br>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。<br>因为volatile修饰符和transient修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了synchronized、native、abstract等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
<p>方法里的java代码经过javac编译器编译成字节码指令之后，存放在方法属性表集合中的一个code的属性中。属性表是class文件格式中最具扩展性的一种数据项目。</p>
<p>7、属性表集合（Attributes）<br>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h3 id="✅字节码指令"><a href="#✅字节码指令" class="headerlink" title="✅字节码指令"></a>✅字节码指令</h3><p>Java虚拟机的指令由一个字节长度的、 代表着某种特定操作含义的数字(称为操作码，Opcode)以及跟随其后的零至多个代表此操作所需参数(称为操作数，Operands)而构成。</p>
<p>Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码。<br>Java虚拟机操作码长度限制为一个字节（0-255），并且Class文件格式放弃类编译后代码的操作数长度对齐。所以虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体的数据的结构。这种操作会导致解释执行字节码时损失一些性能，但是这样意味着节省很多填充和间隔符号，编译代码也更加短小精干。这也是因为Java最初设计是面向网络、智能家电的技术背景，并且一直沿用至今。</p>
<p>字节码指令与数据类型<br>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。 例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。<br>这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。<br>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务，也有一些指令的助记符中没有明确地指明操作类型的字母，或与数据类型无关。</p>
<p>包括哪些指令：<br>1、加载和存储指令<br>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容。<br>将一个局部变量加载到操作栈：iload<br>将一个数值从操作数栈存储到局部变量表：istore<br>将一个常量加载到操作数栈：bipush</p>
<p>2、运算指令<br>运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。 大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令，无论是哪种算术指令，都使用Java虚拟机的数据类型，由于没有直接支持byte、short、 char和boolean类型的算术指令，对于这类数据的运算，应使用操作int类型的指令代替。 整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现。<br>加法指令：iadd、 ladd、 fadd、 dadd。<br>减法指令：isub</p>
<p>3、类型转换指令<br>类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作</p>
<p>4、对象创建与访问指令<br>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。 对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下。<br>创建类实例的指令：new。<br>创建数组的指令：newarray、 anewarray、 multianewarray。<br>访问类字段(static字段，或者称为类变量)和实例字段(非static字段，或者称为实例变量)的指令：getfield、 putfield、 getstatic、 putstatic。</p>
<p>5、控制转移指令<br>控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。<br>用于条件分支。</p>
<p>6、方法调用和返回指令<br>invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派(虚方法分派)，这也是Java语言中最常见的方法分派方式。<br>invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。<br>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn</p>
<p>7、异常处理指令</p>
<p>在Java程序中显式抛出异常的操作(throw语句)都由athrow指令来实现，除了用throw语句显式抛出异常情况之外，Java虚拟机规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。 例如，整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。</p>
<p>而在Java虚拟机中，处理异常(catch语句)不是由字节码指令来实现的(很久之前曾经使用jsr和ret指令来实现，现在已经不用了)，而是采用异常表来完成的。</p>
<p>8、同步指令</p>
<p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程(Monitor，就是锁)来支持的。</p>
<p>方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。 虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。 当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成(无论是正常完成还是非正常完成)时释放管程。 在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。 如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。</p>
<p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持（编译器保证两个指令一定成对出现）。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36380063/article/details/114746916">https://blog.csdn.net/weixin_36380063/article/details/114746916</a></p>
<h3 id="✅类加载的时机"><a href="#✅类加载的时机" class="headerlink" title="✅类加载的时机"></a>✅类加载的时机</h3><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>
<p>Java语言中，类的加载、连接、初始化过程都是在程序运行期间完成的。这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p>
<p>Class文件：一串二进制字节流。</p>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期如下图所示：<br>￼<br>如上图，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>
<p>虚拟机规范严格规定了有且只有6种情况必须对类进行“初始化”，当然初始化前的三个阶段（加载、验证、准备）就必须在此之前开始执行了。</p>
<p>1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有初始化，则需要先触发其初始化；这4条指令对应的的常见场景分别是：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</p>
<p>2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>注：反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。（一个接口在初始化时，并不要求其父接口全部完成初始化）<br>注：子类执行构造函数前需先执行父类构造函数。</p>
<p>4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
<p>5）当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化。则需要先触发其初始化。<br>注：JDK1.7的一种新增的反射机制，都是对类的一种动态操作。</p>
<p>6）当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p>
<p>这6种场景中的行为称为对类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。例如：</p>
<p>1）通过子类引用父类的静态字段，不会导致子类初始化<br>2）通过数组定义来引用类，不会触发此类的初始化<br>3）常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化<br>（在编译阶段通过常量传播优化，已经将此常量的值存储到类的常量池中，以后Test类对常量SuperClass.value的引用实际上都转化为Test类对自身常量池的引用了。）</p>
<h3 id="✅类加载的过程：加载"><a href="#✅类加载的过程：加载" class="headerlink" title="✅类加载的过程：加载"></a>✅类加载的过程：加载</h3><p>“加载”是“类加载”过程的一个阶段，最好不要被字眼迷惑。在加载阶段，虚拟机需要完成以下3件事情：<br>1）通过一个类的全限定名来获取此类的二进制字节流；<br>虚拟机规范并没有明确说明类的二进制字节流从何而来（一般是由java源码编译而来），所以这里可以有非常灵活的实现空间，例如可以用过ZIP包（如JAR、EAR、WAR格式）读取，从网络中获取，运行时计算生成（如动态代理技术，Proxy中，ProxyGenerator.generateProxyClass()来为特定接口生成形式为*$Proxy的代理类的二进制字节流），从数据库中读取，从加密文件中获取等等。</p>
<p>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；<br>方法区与Java堆一样，是各线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。而方法区中的数据存储结构格式虚拟机自行定义。</p>
<p>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。<br>注：加载阶段完成后，虚拟机在内存中实例化一个java.lang.Class类的对象（Class是一个实实在在的对象，是记录着类成员、接口等信息的对象）。Class对象时存在方法区还是堆中？方法区中存类型数据，堆中存Class类的对象）</p>
<p>非数组类和数据类的加载阶段有有所不同，数组类的应用是不会对该类进行初始化，而是虚拟机通过字节码指令“newarray”去创建一个Object”对象。</p>
<p>数组类加载过程要遵循的规则：<br>1）如果数组的组件类型（去掉一个维度）是引用类型（非基础类型），那就递归去加载这个组件类型。<br>2）如果数组组件类型不是引用类型（例如int[]数组），Java虚拟机将会把该数组标记为与引导类加载器关联。<br>3）数组类的可见性与他的组件类型可见性一致，如果组件类型不是引用类型，那数组的可见性将默认为public。</p>
<h3 id="✅类加载的过程：验证"><a href="#✅类加载的过程：验证" class="headerlink" title="✅类加载的过程：验证"></a>✅类加载的过程：验证</h3><p>加载阶段可以说是字节码进入Java虚拟机的入口，类加载过程的“验证阶段”是对类文件的字节码进行验证，才能确保Java虚拟机不受恶意代码的攻击。从性能上讲，这无疑是给虚拟机带来额外的性能消耗，但这也是无可厚非要付出的代价。</p>
<p>（java语言比C/C++要安全，如果使用java代码访问数组边界之外的数据，对象转换为它并未实现的类型，跳转到不存在的代码行，这些编译器都会抛出异常拒绝编译，但是Class文件不一定都是由java源码编译而来，所以以上java代码层面无法做到的，class文件可以做到）</p>
<p>验证阶段大致上会完成下面4个阶段的检查动作：</p>
<p>1）文件格式验证<br>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。目的是保证输入的字节流能够正确地解析并存储于方法区，该验证基于二进制字节流。<br>l  是否以魔数0xCAFEBABE开头；<br>l  主、次版本号是否在当前虚拟机处理范围内；<br>l  常量池的常量中是否有不被支持的常量类型（检查常量tag标志）；</p>
<p>2）元数据验证，保证不存在不符合Java语言规范的元数据信息，语义分析，基于方法区的存储结构进行的。<br>l  这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）；<br>l  这个类的父类是否继承了不允许被继承的类（被final修饰的类）；<br>l  如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法；</p>
<p>3）字节码验证，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件<br>l  保证任意时刻操作栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载如本地变量中；<br>l  保证跳转指令不会跳转到方法体以外的字节码指令上；<br>l  保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不安全）；<br>“字节码验证”是整个验证阶段最消耗时间的，虽然如此但也不能保证绝对安全。jdk6之后，把校验挪到了javac编译器中，方法体Code属性的属性表增加了StackMapTable的新属性（描述了方法体基本块开始时本地变量表和操作栈应有的状态），字节码验证期间不需要做类型推导，只需要类型检查。</p>
<p>4）符号引用验证，确保在后续的“解析”阶段能正常执行<br>l  符号引用中通过字符串描述的全限定名是否能找到对应的类；<br>l  在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段；<br>l  在符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问；<br>其实我们的IDE也虚拟机规范的检查，所以我们的代码加载几乎没有不通过的。</p>
<h3 id="✅类加载的过程：准备"><a href="#✅类加载的过程：准备" class="headerlink" title="✅类加载的过程：准备"></a>✅类加载的过程：准备</h3><p>准备阶段是正式为类变量（静态变量）分配内存设置类变量初始化值的阶段，这些变量所使用的内存都将在方法区中进行分配（方法区是一个逻辑上的区域，JDK及之前，永久代是方法区的实现，JDK8及之后类变量随着Class对象一起存放在java堆中）。这个阶段中有两个容易产生混淆的概念需要强调一下。首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值（final变量除外）</p>
<h3 id="✅类加载的过程：解析"><a href="#✅类加载的过程：解析" class="headerlink" title="✅类加载的过程：解析"></a>✅类加载的过程：解析</h3><p>解析阶段是虚拟机将常量池的符号引用直接替换为直接引用的过程。</p>
<p>l  符号引用（Symbolic References）：<br>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。<br> <br>l  直接引用（Direct References）：<br>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接点位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
<p>例如符号引用：“java/lang/Object;”这是我们熟知的Object类的全限定名。解析阶段就是要把这个“class”的字符引用换成直接指向这个Object类在内存中的地址（如指针 ）。那就说明，这个Object类必须同时也需要加载到内存中来。</p>
<p>虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。但对于invokedynamic指令，上面规则则不成立。当碰到某个前面已经由invokedynamic指令触发过解析的符号引用时，并不意味着这个解析结果对其他invokedynamic指令也同样生效。因为invokedynamic指令是JDK1.7新加入的指令，目的用于动态语言支持（还有jdk8中的lambda表达式和接口的默认方法）。</p>
<p>invokedynamic必须等到程序实际运行到这条指令的时候，解析动作才能进行。其余可触发解析的指令可以在还没有执行代码时就进行解析。</p>
<p>Java语言本身是一门静态类型语言。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号进行引用。</p>
<h3 id="✅类加载的过程：初始化"><a href="#✅类加载的过程：初始化" class="headerlink" title="✅类加载的过程：初始化"></a>✅类加载的过程：初始化</h3><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器之外，其余动作完全是由虚拟机主导和控制。初始化阶段将主导权移交给应用程序。</p>
<p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划其余初始化变量和其他资源，或者从另一个角度来表达，初始化阶段是执行类构造器<clinit>()方法（javac编译器的自动生成物）的过程。</clinit></p>
<p><clinit>()方法是有编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是有语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。</clinit></p>
<p><clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕；父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作；</clinit></clinit></clinit></init></clinit></p>
<p><clinit>()方法对于类和接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法；</clinit></clinit></p>
<p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</clinit></clinit></clinit></clinit></p>
<p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。</clinit></clinit></clinit></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/26/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/%E6%9D%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/26/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/%E6%9D%82/" class="post-title-link" itemprop="url">比较杂的东西</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-26 11:35:30 / Modified: 19:06:36" itemprop="dateCreated datePublished" datetime="2023-03-26T11:35:30+08:00">2023-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>MD5：Message-Digest Algorithm 5（信息摘要5），确保信息的完整性。其算法是1992年公开的，设计者是罗纳德·李维斯特，美国密码学家，后来发明了非对称秘钥RSA算法，因这个算法的在信息安全中的突破与重要性而获得了2002年的图灵奖。</p>
<p>MD5是一种加密算法，用于将任意长度的消息压缩成128位长度的数据，用于验证数据的完整性和安全性。MD5算法被广泛应用于数宇签名、数据验证、安全传输等领域。但是由于MD5算法存在安全漏洞，已破推荐使用更安全的加密算法SHA-256和SHA-3等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">String input = &quot;hello world&quot;;</span><br><span class="line">String md5Hex = DigestUtils.md5Hex(input);</span><br><span class="line">System.out.println(&quot;Md5 hash for input:&quot; + md5Hex);</span><br></pre></td></tr></table></figure>

<h2 id="ssh和跳板机"><a href="#ssh和跳板机" class="headerlink" title="ssh和跳板机"></a>ssh和跳板机</h2><p>SSH是一种加密的协议，用于在本地计算机和远程服务器之间建立安全的连接。通过SSH协议，用户可以在不暴露密码的情况下远程登录到目标服务器，并可以在该服务器上执行命令和操作。</p>
<p>跳板机是一种中间节点，用于连接两个不同的网络或系统。通过跳板机，用户可以在不直接连接到目标系统的情况下访问该系统。跳板机通常会安装在公共网络上，以便用户可以通过该跳板机安全地访问内部网络。</p>
<p>因此，SSH和跳板机的区别在于：SSH是一种加密的协议，用于建立本地计算机和远程服务器之问的安全连接；而跳板机是一种中问节点，用于连接两个不同的网络或系统，使用户可以安全地访问内部网络。</p>
<p>✅它俩的关系：<br>SSH是一种安全的远程登录协议，用于在网络中安全地远程管理计算机系统。而跳板机是一种通过中转服务器来连接目标服务器的方式，以实现远程访问目标服务器的方法。<br>通过SSH协议，管理员可以直接登录到目标服务器进行操作，但对于一些安全性高的服务器，为了避免直接暴露在公网上，可以使用跳板机来进行中转，即先通过SSH连接到跳板机，再从跳板机上通过SSH连接到目标服务器。这样的话，目标服务器的IP地址不会直接暴露在公网上，从而提高了安全性。<br>使用跳板机的好处还在于，管理员可以通过控制跳板机的访问权限，来控制对目标服务器的访问权限，从而增强了安全性。同时，跳板机还可以对目标服务器进行隔离，使得外部网络不能直接访问目标服务器，进一步增强了安全性。</p>
<p>SSH是一种协议，用于在网络中安全地远程管理计算机系统，而跳板机则是一种通过中转服务器来连接目标服务器的方式，以实现远程访问目标服务器的方法。<br>因此，SSH和跳板机是密不可分的，它们的结合可以提供更高级别的远程访问和管理机制，保障了系统的安全性和可靠性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/20/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/20/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/shell/" class="post-title-link" itemprop="url">shell常规</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-20 22:32:07 / Modified: 22:47:02" itemprop="dateCreated datePublished" datetime="2023-02-20T22:32:07+08:00">2023-02-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> !/bin/bash  #表示当前脚本使用的shell解释器为bash</span><br><span class="line">echo &quot;hello!&quot;</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">sum=$(($a+$b))  #注意=前后不能有空格</span><br><span class="line">multi=$(($a*$b))</span><br><span class="line">echo $sum</span><br><span class="line">echo $multi</span><br><span class="line">res=`expr $a \* $b`  #注意\*前后有空格</span><br><span class="line">echo $res</span><br></pre></td></tr></table></figure>

<p>shell用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_28836875/article/details/113707668">https://blog.csdn.net/weixin_28836875/article/details/113707668</a></p>
<p>expr命令：expr命令计算给定表达式并显示其相应的输出，其被使用用于：基本操作像加法、减法、乘法、除法和模等等整数，求值正则表达式，字符串操作，如子字符串，字符串长度等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">加法：expr 12 + 9</span><br><span class="line"></span><br><span class="line">乘法：expr 12 \* 2</span><br></pre></td></tr></table></figure>

<p>对shell脚本中的变量执行操作，注意保存成.sh文件并赋权限755再执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Enter two numbers&quot;</span><br><span class="line">read x </span><br><span class="line">read y</span><br><span class="line">sum=`expr $x + $y`</span><br><span class="line">echo &quot;Sum = $sum&quot;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/19/myblog/%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/19/myblog/%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="post-title-link" itemprop="url">《深入理解java虚拟机》笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-19 14:30:11" itemprop="dateCreated datePublished" datetime="2023-02-19T14:30:11+08:00">2023-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-25 23:52:17" itemprop="dateModified" datetime="2023-02-25T23:52:17+08:00">2023-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一章-走进java"><a href="#第一章-走进java" class="headerlink" title="第一章 走进java"></a>第一章 走进java</h2><h4 id="1-java体系"><a href="#1-java体系" class="headerlink" title="1.java体系"></a>1.java体系</h4><p>java技术体系：<br>1.Java程序运行的虚拟机<br>2.java类库<br>3.java编程语言<br>4.第三方框架 spring、mybatis</p>
<p>虚拟机层面隐藏了底层技术的复杂性以及机器与操作系统的差异性。虚拟机完成对硬件平台的兼容和对内存等资源的管理工作。</p>
<p>程序性能、稳定性、扩展性上，需要知道虚拟机的特性及调节方式。</p>
<p>java语言 + java虚拟机 + java类库 = jdk（支持java程序开发的最小环境）<br>java类库中java se api + java虚拟机 = jre（java程序运行的标准环境）</p>
<p>1991年 james gosling 目标开发一种在电子产品上运行的程序架构。1995年改名为java，口号：write once， run anywhere。<br>1998年sun将java体系分为三个方向：面向桌面应用开发的j2se，面向企业级开发的j2ee，面向手机等移动终端开发的j2me。<br>2006年sun将java开源，建立openjdk组织进行管理源码，2009年oracle收购sun。<br>2013年java8发布，有lambda表达式（拥有函数式表达能力）、移除hotspot的永久代。<br>2018年oracle放弃java，所有权直接赠送给eclipse基金会。redhat（ibm的）负责了jdk历史版本的维护。</p>
<p>为什么喜欢用java8？<br>java8是一个功能强大的版本，新特性例如lambda表达式、stream api、新的日期/时间api，这些可以提高开发效率。其次，java8可以兼容早期的java版本，提高开发效率。基于可维护的考量，java8可以保证程序的可维护性。</p>
<h4 id="2-java虚拟机家族"><a href="#2-java虚拟机家族" class="headerlink" title="2.java虚拟机家族"></a>2.java虚拟机家族</h4><p>1996年，sun发布的jdk1.0中携带的虚拟机：Classic VM，只能使用纯解释器方式来执行，需要外挂编译器。Exact VM：热点探测、准确内存管理，摒弃掉Classic VM中基于句柄的对象查找方式。</p>
<p>HotSpot是Sun/Oracle JDK和OpenJDK中的默认java虚拟机。开始由小公司研发，热点代码探测技术、即时编译。2014年JDK 8 中移除了永久带。</p>
<p>BEA JRockit 专注于服务器硬件和服务端应用，不关心启动速度，里面不包含解释器。</p>
<p>IBM J9 VM。</p>
<p>Apache Harmony 没有大规模商用，但是他的许多java类库被吸纳。</p>
<h4 id="3-展望java的技术"><a href="#3-展望java的技术" class="headerlink" title="3.展望java的技术"></a>3.展望java的技术</h4><p>java：庞大的用户群和及其成熟的软件生态。</p>
<p>在hotspot基础上增强而成的跨语言全栈虚拟机：Graal VM，可以作为任何语言的运行平台使用。原理是用解释器来解释中间代码。（无语言倾向）</p>
<p>即时编译器：Graal编译器，代替C2。已经在java10中引入，不过要改参数来启用。</p>
<p>跑个helloworld也需要百兆的JRE，在近几年大型单体应用架构向小型微服务应用架构发展的技术潮流下，java不适应。在微服务架构视角下，应用拆分，高可用的服务集群，不需要单个服务不间断运行。但是java启动时间长，需要预热才能达到最高性能，有悖于微服务场景。所以发展提前编译。</p>
<p>hotspot虚拟机拥有了组合拆分功能的特性，源码中是接口与实现的分离。开放了编译器接口，重构了java虚拟机的垃圾回收器接口。</p>
<p>语言特性和语法糖：协程、不可变类型、JNI调用本地代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/22/myblog/spring/springboot%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/22/myblog/spring/springboot%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">springboot学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-22 18:37:23" itemprop="dateCreated datePublished" datetime="2022-12-22T18:37:23+08:00">2022-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 15:40:41" itemprop="dateModified" datetime="2023-08-20T15:40:41+08:00">2023-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="springboot创建工程"><a href="#springboot创建工程" class="headerlink" title="springboot创建工程"></a>springboot创建工程</h2><p>微服务体系下不可或缺。<br>ssm(spring+springMvc+mybatis) -&gt; springboot -&gt; springcloud</p>
<p>springboot：约定优于配置，不用专注于配置。2014年发布。</p>
<p>springboot的位置：是spring的顶级项目，和springFramework(ioc、aop)是同等级的。</p>
<p>springboot使用最小配置快速构建spring项目。springboot不是spring功能上的增强，而是提供一种快速开发spring项目的方式。</p>
<p>spring缺点：<br>&lt;1&gt; 写配置文件，繁琐<br>&lt;2&gt; 依赖繁琐，maven坐标版本问题</p>
<p>springboot提供的优点：<br>&lt;1&gt; 自动配置，应用程序启动时的过程<br>&lt;2&gt; 起步依赖，坐标pom打包到一起，对其他库的依赖传递<br>&lt;3&gt; 其他：嵌入式服务器，安全，健康检测</p>
<hr>
<p>✅ 用springboot搭建一个web项目：<br>&lt;1&gt; 创建maven项目<br>&lt;2&gt; 引入起步依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--springboot工程需要继承的父工程   --&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--  web开发的起步依赖  --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>&lt;3&gt; 写一个controller</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-12-22 23:28</span><br><span class="line"> **/</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/h&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;4&gt; 写引导类，springboot项目入口，然后运行main方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-12-22 23:38</span><br><span class="line"> **/</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(StartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>✅ 快速构建</p>
<p>用idea，选Spring Initializr，选maven project，选jar打包方式，勾选依赖。</p>
<h2 id="springboot起步依赖"><a href="#springboot起步依赖" class="headerlink" title="springboot起步依赖"></a>springboot起步依赖</h2><p>spring-boot-starter-parent，往里看源码，最终是spring-boot-dependency包，其中pom文件中<code>&lt;dependencyManagement&gt;</code> 是版本锁定，父工程中定义的版本信息，自己工程中就可以不写版本号。</p>
<p>spring-boot-starter-web，往里看，发现引入了spring-web、spring-webmvc。</p>
<p>总结：<br>1.在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。<br>2.在各种starter中，定义了完成该功能的坐标合集，其中大部分版本信息来自于父工程。<br>3.我们工程继承自parent，引入starter，通过依赖传递，就可以简单方便获取需要的jar包，并且不会存在版本冲突问题。</p>
<h2 id="springboot配置"><a href="#springboot配置" class="headerlink" title="springboot配置"></a>springboot配置</h2><p>配置文件分类：properties文件、yaml/yml文件。<br>profile文件，三种环境动态切换。</p>
<p>springboot基于约定，配置有默认值，替换的话，用application.properties/application.yml文件来配置。resource根目录下，application.properties/yml/yaml 文件里面放程序自动识别的内容，也可以写自己定义的内容。</p>
<p>同一级目录下，配置文件的加载顺序：properties &gt; yml &gt; yaml</p>
<p>yaml：不是一个标记语言，是直观的能被电脑识别的数据序列化格式，以数据为核心，比xml更加简洁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xml:</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line"></span><br><span class="line">yml:</span><br><span class="line">server:</span><br><span class="line">    port: 8080</span><br><span class="line"></span><br><span class="line">properties:</span><br><span class="line">server.port=8080</span><br></pre></td></tr></table></figure>

<p>yaml语法：大小写敏感、数据值前必须有空格（至少一个）、缩进表示层级关系，缩进空格个数不重要，但要左对齐、#注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line"></span><br><span class="line">person:</span><br><span class="line">  name: liu</span><br><span class="line">  address: [beijing, shanghai]</span><br><span class="line"></span><br><span class="line">msg1: &quot;hello \n world&quot;  #双引号识别转义字符</span><br><span class="line">msg2: &#x27;hello \n world&#x27;  #单引号原样输出</span><br><span class="line"></span><br><span class="line">参数引用：$&#123;name&#125;</span><br></pre></td></tr></table></figure>


<p>读取配置文件内容：</p>
<p>1.@Value方法，单个属性注入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;person.name&#125;&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;person.address[0]&#125;&quot;)</span><br><span class="line">private String address;</span><br></pre></td></tr></table></figure>

<p>2.Environment</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Environment env;    </span><br><span class="line"></span><br><span class="line">env.getProperty(&quot;person.name&quot;)</span><br></pre></td></tr></table></figure>

<p>3.@ConfigurationProperties，对象和配置的绑定</p>
<p>在实体类Person上加注解 <code>@ConfigurationProperties(prefix=&quot;person&quot;)</code></p>
<hr>
<p>profile：一套程序通常需要部署在不同的环境下，开发测试生产，如果每次打包都要修改配置文件，麻烦，profile提供进行动态配置切换的方式。</p>
<p>配置方式：<br>1.多profile文件方式：提供多个配置文件，每个代表一个环境<br>application-dev.properties/yml<br>application-test.properties/yml<br>application-pro.properties/yml</p>
<p>2.yml单文件方式<br>用—分割不同环境配置</p>
<p>激活方式：<br>1.配置方式：<br><code>spring.profiles.active=dev</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    profiles:</span><br><span class="line">        active: dev</span><br></pre></td></tr></table></figure>

<p>2.虚拟机参数<br>在VM option中输入：<code>-Dspring.profiles.active=test</code></p>
<p>3.命令行参数<br>先package打包<br><code>java -jar ...jar --spring.profiles.active=test</code></p>
<hr>
<p>打包过程中，遇到：jar中没有主清单属性</p>
<p>原因：打包后的jar文件中的MANIFEST.MF缺少项目启动项，即没有Main-Class</p>
<p>解决方案：<br>1、指定MANIFEST.MF路径<br>项目打包前：<br>第一步 file–&gt;project structure 弹框后选中Atifacts—&gt; + —-&gt;jar—-&gt;from module with dependenceis<br>第二步 选择一个Main Class，选的StartApplication文件</p>
<p>2、项目pom.xml文件中添加插件spring-boot-maven-plugin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>内部配置加载顺序：</p>
<p>1.项目根目录下的config文件夹下<br>2.项目根目录（idea点project files的根目录）下<br>3.classPath（resource目录下）的config文件夹下<br>4.classPath（resource目录下）下</p>
<p>前两个不会打进jar包里</p>
<hr>
<p>外部配置加载顺序：</p>
<p>1.命令行指定端口号：<code>java -jar spring-boot-study-api-1.0-SNAPSHOT.jar --server.port=8086</code><br>指定默认前缀路径：<code>--server.servlet.context-path=/default</code><br>2.指定外部配置文件路径：<code>--spring.config.location=路径</code><br>3.在jar包同目录下（target文件夹下），加一个配置文件<code>application.properties</code>，同样生效，外部配置优先生效</p>
<h2 id="springboot整合其他框架"><a href="#springboot整合其他框架" class="headerlink" title="springboot整合其他框架"></a>springboot整合其他框架</h2><h3 id="springboot整合Junit"><a href="#springboot整合Junit" class="headerlink" title="springboot整合Junit"></a>springboot整合Junit</h3><p>1.引入spring-boot-starter-test 起步依赖<br>2.在测试类上加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class) //springboot2不用加</span><br><span class="line">@SpringBootTest(classes = StartApplication.class) //如果与StartApplication在一个包下，可以不加括号里的</span><br></pre></td></tr></table></figure>


<h3 id="springboot整合redis"><a href="#springboot整合redis" class="headerlink" title="springboot整合redis"></a>springboot整合redis</h3><p>1.引入spring-boot-starter-data-redis依赖<br>2.连接本地的redis，不需要任何配置<br>3.直接用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;liu&quot;);</span><br><span class="line">Object o = redisTemplate.boundValueOps(&quot;name&quot;).get();</span><br></pre></td></tr></table></figure>
<p>4.其他ip的，需要配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br></pre></td></tr></table></figure>


<h3 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h3><p>1.引入mybatis起步依赖 <code>mybatis-spring-boot-starter</code> （不同于其他，这个是mybatis提供的，用3.0.1的有点问题，改用2.1.0），添加mysql驱动 <code>mysql-connector-java</code><br>2.配置datasource和mybatis</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:///test?serverTimezone=UTC</span><br><span class="line">    #db.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    username: liuxuan</span><br><span class="line">    password: jade</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>3.创建表，并编写实体类<br>4.纯注解开发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from student&quot;)</span><br><span class="line">    public List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 .xml映射文件形式开发<br>Mapper接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface StudentXmlMapper &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.liuxuan.repository.mapper.StudentXmlMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.liuxuan.repository.domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>增加mybatis配置(不在spring下)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  # Mapper映射文件路径</span><br><span class="line">  mapper-locations: classpath:mapper/*Mapper.xml</span><br><span class="line">  # 包扫描</span><br><span class="line">  type-aliases-package: com.liuxuan.repository.domain</span><br></pre></td></tr></table></figure>


<h2 id="springboot原理分析"><a href="#springboot原理分析" class="headerlink" title="springboot原理分析"></a>springboot原理分析</h2><h3 id="springboot自动配置"><a href="#springboot自动配置" class="headerlink" title="springboot自动配置"></a>springboot自动配置</h3><p>Condition是spring4.0增加的条件判断功能，可以实现选择性地创建Bean操作。</p>
<h4 id="✅需求1-创建bean增加条件"><a href="#✅需求1-创建bean增加条件" class="headerlink" title="✅需求1:创建bean增加条件"></a>✅需求1:创建bean增加条件</h4><p>1.自定义条件类，继承Condition接口，实现matches方法，方法中进行逻辑判断，参数context可以获取上下文容器等，metadata可以获取注解属性。<br>2.判断条件，初始化bean时使用@Conditional(条件类.class)注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">需要加注解@Conditional：</span><br><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @Conditional(ClassCondition.class)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">自己定义一个实现了Condition接口的类，里面实现条件判断matches方法：</span><br><span class="line">public class ClassCondition implements Condition &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 写创建bean的条件：导入jedis坐标后创建bean</span><br><span class="line">        try &#123;</span><br><span class="line">            Class cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获取bean：</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 启动springboot应用，获取spring的ioc容器</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 获取bean</span><br><span class="line">        Object user = context.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="✅需求2-用自定义注解实现动态Condition"><a href="#✅需求2-用自定义注解实现动态Condition" class="headerlink" title="✅需求2:用自定义注解实现动态Condition"></a>✅需求2:用自定义注解实现动态Condition</h4><p>定义自定义注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Conditional(ClassCondition.class)</span><br><span class="line">public @interface ConditionOnClass &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Config中加注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">//    @Conditional(ClassCondition.class)</span><br><span class="line">    @ConditionOnClass(&quot;redis.clients.jedis.Jedis&quot;)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承Condition接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ClassCondition implements Condition &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param context  上下文对象。用于获取环境、Ioc容器、classLoader对象</span><br><span class="line">     * @param metadata 注解元对象，可以用于获取注解定义的属性值</span><br><span class="line">     * @return boolean</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 需求1：写创建bean的条件：导入jedis坐标后创建bean</span><br><span class="line">//        try &#123;</span><br><span class="line">//            Class cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);</span><br><span class="line">//        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">//            return false;</span><br><span class="line">//        &#125;</span><br><span class="line">//        return true;</span><br><span class="line"></span><br><span class="line">        // 需求2：通过注解属性值value指定坐标后创建bean</span><br><span class="line">        Map&lt;String, Object&gt; map = metadata.getAnnotationAttributes(ConditionOnClass.class.getName());</span><br><span class="line">        String[] value = (String[])map.get(&quot;value&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            for (String className : value) &#123;</span><br><span class="line">                Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看包spring-boot-anto-configuration中，springboot已经定义好了很多condition注解，例如：@ConditionalOnClass。</p>
<hr>
<h4 id="✅切换内置服务器"><a href="#✅切换内置服务器" class="headerlink" title="✅切换内置服务器"></a>✅切换内置服务器</h4><p>spring-boot-starter-web</p>
<p>spring-boot-autoconfiguration 包的web的embedded中内置了四种服务器，包括jetty、netty、tomcat、undertom。</p>
<p>里面还有个类负责选择web服务器，原理也是用了@ConditionalOnClass注解，看导入了什么坐标来选择服务器。</p>
<p>用<exclusions> 把spring-boot-starter-web 中的 spring-boot-starter-tomcat 排除掉。再引入jetty的依赖，就会切换为jetty服务器。</exclusions></p>
<hr>
<h4 id="✅-Enable-注解"><a href="#✅-Enable-注解" class="headerlink" title="✅ @Enable*注解"></a>✅ @Enable*注解</h4><p>SpringBoot提供了很多@Enable开头的注解，用于动态启动某些功能(获取一些bean)，其底层原理是使用@Import注解导入一些配置类，实现Bean的动态加载。</p>
<p>看注解 @SpringBootApplication</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration --内部@Configuration可配置bean</span><br><span class="line">@EnableAutoConfiguration --重点</span><br><span class="line">@ComponentScan(   --包扫描</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication</span><br><span class="line"></span><br><span class="line">其中Enable注解下：</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">重要的是Import注解</span><br></pre></td></tr></table></figure>

<p>⚠️启动子模块的启动类，无法启动父工程的controller。</p>
<p>springboot工程不可以直接获取其他jar包中定义的bean，比如redisTemplate。</p>
<p>原因：@ComponentScan 包扫描的范围是：当前引导类所在包及其子包，其他项目配置Bean的包不在该范围内。</p>
<p>尝试：另外创建一个子模块，子模块引入另一个子模块的pom，然后尝试获取另一个子模块的bean。<br>报错：NoSuchBeanDefinitionException。</p>
<p>如何获取Bean：<br>1.在启动类上加@ComponentScan注解，扫描要引入Bean的包。<br>缺点：要写包太累赘<br>2.使用@Import注解加载要导入bean的配置类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Import &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value中的这些类会被spring创建并放入IOC容器中。<br>缺点：要记类的名字<br>3.对Import注解进行封装<br>自定义一个Enable注解，把Import注解封装进去，要想用这个bean的时候，直接用Enable注解就可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(UserConfig.class)</span><br><span class="line">public @interface EnableUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) //排除此类的AutoConfig</span><br><span class="line">//@ComponentScan(&quot;com.liuxuan.condition&quot;)</span><br><span class="line">//@Import(UserConfig.class)</span><br><span class="line">@EnableUser</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 启动springboot应用，获取spring的ioc容器</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 获取bean</span><br><span class="line">        Object user = context.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>😊<code>@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;)</code></p>
<p>exclude，排除此类的AutoConfig，即禁止 SpringBoot 自动注入数据源配置。</p>
<p>DataSourceAutoConfiguration.class 会自动查找 application.yml 或者 properties 文件里的 spring.datasource.* 相关属性并自动配置单数据源「注意这里提到的单数据源」。</p>
<p>那么问题来了，排除了自动配置，Spring还怎么识别到数据库配置呢？</p>
<p>答：显然接下来就需要手动配置，如果你发现项目中存在这个排除的操作，可以在项目中搜一下Java关键字@ConfigurationProperties(“spring.datasource)，你可能会发现手动配置数据源的类。</p>
<p>再来回答为何要手动配置数据源，因为要配置多数据源，上边有提到DataSourceAutoConfiguration.class默认会帮我们自动配置单数据源，所以，如果想在项目中使用多数据源就需要排除它，手动指定多数据源。</p>
<p>@SpringBootApplication注解中exclude参数使用及原理:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_20150804/article/details/116104742">https://blog.csdn.net/csdn_20150804/article/details/116104742</a></p>
<h4 id="✅-Import注解"><a href="#✅-Import注解" class="headerlink" title="✅ @Import注解"></a>✅ @Import注解</h4><p>@Enable*底层依赖@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中，@Import提供四种用法：</p>
<p>1.导入Bean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StartApplication上：</span><br><span class="line">@Import(User.class)</span><br><span class="line"></span><br><span class="line">StartApplication中：</span><br><span class="line">// 根据类型获取bean</span><br><span class="line">Object user = context.getBean(User.class);</span><br><span class="line">System.out.println(user);</span><br><span class="line">// 获取bean名称</span><br><span class="line">Map&lt;String, User&gt; map = context.getBeansOfType(User.class);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<p>2.导入配置类<br>这种方式，配置类上的@Configuration注解可以不加</p>
<p>3.导入ImportSelect实现类。一般用于加载配置文件中的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Import(MyImportSelector.class)</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class MyImportSelector implements ImportSelector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        return new String[]&#123;&quot;com.liuxuan.condition.User&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.导入ImportBeanDefinitionRegistrar实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Import(MyImportBeanDefinitionRegistrar.class)</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(User.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(&quot;beanName&quot;, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="✅-EnableAutoConfiguration注解"><a href="#✅-EnableAutoConfiguration注解" class="headerlink" title="✅@EnableAutoConfiguration注解"></a>✅@EnableAutoConfiguration注解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@EnableAutoConfiguration</span><br><span class="line"></span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line"></span><br><span class="line">AutoConfigurationImportSelector中：</span><br><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return NO_IMPORTS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">核心代码：getAutoConfigurationEntry</span><br><span class="line">List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"></span><br><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">意思是：从spring-boot-autoconfiguration的jar包下面的META-INF/spring.factories文件中加载。</span><br><span class="line">看到这个文件中可以看到：</span><br><span class="line"> # Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">有很多配置文件类</span><br></pre></td></tr></table></figure>

<p>总结：<br>@EnableAutoConfiguration 如何实现自动配置<br>1.@EnableAutoConfiguration注解内部使用@Import({AutoConfigurationImportSelector.class}) 来加载配置类<br>2.配置文件位置：META-INF/spring.factories，该配置文件中定义了大量的配置类，当springboot应用启动时，会自动加载这些配置类，初始化bean<br>3.并不是所有的bean都会被初始化，在配置类中使用Condition来加载满足条件的bean</p>
<h4 id="✅自定义starter实现"><a href="#✅自定义starter实现" class="headerlink" title="✅自定义starter实现"></a>✅自定义starter实现</h4><p>看mybatis-spring-boot-starter如何实现：<br>1.看到mybatis-spring-boot-starter包下没什么，只有一个pom文件，里面引入mybatis-spring-boot-autoconfigure包<br>2.mybatis-spring-boot-autoconfigure包的META-INF/spring.factories文件中定义了MybatisAutoConfiguration<br>3.@EnableAutoConfiguration会自动识别到META-INF/spring.factories文件，从而识别到MybatisAutoConfiguration，模块中初始化的bean就创建出来</p>
<p>需求：自定义redis-starter，当导入redis-starter坐标时，springboot自动创建jedis的bean。</p>
<p>1.创建一个redis-autoconfiguration模块，在里面提供jedis的bean，并实现自动配置。</p>
<p>⚠️亲测，一个模块的配置了8082端口，另一个模块没配置端口，但是运行该模块的StartApplication，要用的是8082端口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RedisAutoConfiguration.class:</span><br><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class) //RedisProperties被spring识别，创建bean</span><br><span class="line">@ConditionalOnClass(Jedis.class)  //疑问：没有Jedis坐标则不配置，创建之前不是没这个Bean吗？导入坐标和有bean的关系？</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(name = &quot;jedis&quot;)  //已经定义了就不定义</span><br><span class="line">    public Jedis getJedisBean(RedisProperties redisProperties) &#123;</span><br><span class="line">        System.out.println(&quot;RedisAutoConfiguration...&quot;);</span><br><span class="line">        return new Jedis(redisProperties.getIp(), redisProperties.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RedisProperties.class:</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ConfigurationProperties(prefix = &quot;redis&quot;) //与配置文件中对应</span><br><span class="line">public class RedisProperties &#123;</span><br><span class="line">    private String ip = &quot;localhost&quot;; //没提供时给默认值</span><br><span class="line">    private Integer port = 6379;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建META-INF/spring.factories文件，其中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">    com.liuxuan.redis.configuration.RedisAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>3.创建redis-starter模块，pom文件中引入redis-configuration依赖。</p>
<p>4.在另一个模块中，pom文件中引入redis-starter依赖。在StartApplication中尝试获取bean。这个模块中导入了Jedis依赖，但是并没有Jedis的bean的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line">Jedis jedis = context.getBean(Jedis.class);</span><br><span class="line">System.out.println(jedis);</span><br><span class="line"></span><br><span class="line">jedis.set(&quot;hello&quot;, &quot;hi&quot;);</span><br><span class="line">System.out.println(jedis.get(&quot;hello&quot;));</span><br></pre></td></tr></table></figure>

<p>5.可以在使用的模块中进行配置redis的ip和host</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis.port=6379</span><br><span class="line">redis.ip=localhost</span><br></pre></td></tr></table></figure>

<p>总结：StartApplication上的@SpringBootApplication注解中的@EnableAutoConfiguration中的@Import({AutoConfigurationImportSelector.class})中会自动去找jar包中的META-INF/spring.factories文件，识别到需要加载的配置类，再获取配置类创建的bean，从而实现自动配置bean。</p>
<p>看spring-boot-autoconfiguration包下的data下的redis下的文件中，就定义了RedisAutoConfiguration，和上面实现类似。</p>
<h3 id="springboot监听机制"><a href="#springboot监听机制" class="headerlink" title="springboot监听机制"></a>springboot监听机制</h3><p>springboot的监听机制，其实是对java提供的事件监听机制的封装。</p>
<p>java中的事件监听机制定义了以下几个角色：<br>1.事件：Event，继承java.util.EventObject类的对象<br>2.事件源：Source，任意对象Object<br>3.监听器：Listener，实现java.util.EventListener接口的对象</p>
<p>springboot不需要这么麻烦，springboot在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作。</p>
<p>ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner</p>
<p>1 .继承这些接口，重写方法，并打印对应操作，@Component注册bean。</p>
<p>2 .启动发现只有后两个有打印。<br>CommandLineRunner、ApplicationRunner在项目启动后执行run方法，可以帮助做一些事情，比如：缓存预热(提前把数据库的数据加到缓存)<br>打印这两个方法的args，发现是空数组，在配置中的environment中的program arguments中添加hello world，就会返回[hello, world]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyCommandLineRunner implements CommandLineRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyCommandLineRunner run...&quot;);</span><br><span class="line">        System.out.println(&quot;MyCommandLineRunner args:&quot; + Arrays.asList(args));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyApplicationRunner implements ApplicationRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner run...&quot;);</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner args:&quot; + Arrays.asList(args.getSourceArgs()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3 .其他两个监听器怎么用：在META-INF/spring.factories（固定的写法，工程启动时会被自动扫描到）中配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">  com.liuxuan.listener.MyApplicationContextInitializer</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">  com.liuxuan.listener.MySpringApplicationRunListener</span><br></pre></td></tr></table></figure>

<p>MyApplicationContextInitializer的initialize方法：项目还没有准备ioc容器之前，可以检测一些资源是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyApplicationContextInitializer implements ApplicationContextInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void initialize(ConfigurableApplicationContext applicationContext) &#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationContextInitializer project start..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>MySpringApplicationRunListener 报错：<code>java.lang.NoSuchMethodException: com.liuxuan.listener.MySpringApplicationRunListener.&lt;init&gt;(org.springframework.boot.SpringApplication, [Ljava.lang.String;)</code><br>表示需要一个构造方法。<br>看一下代码中提供的一个实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//入参SpringApplication表示项目启动时的事件源</span><br><span class="line">public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123;</span><br><span class="line">    private final SpringApplication application;</span><br><span class="line">    private final String[] args;</span><br><span class="line">    private final SimpleApplicationEventMulticaster initialMulticaster;</span><br><span class="line"></span><br><span class="line">    public EventPublishingRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">        this.application = application;</span><br><span class="line">        this.args = args;</span><br><span class="line">        this.initialMulticaster = new SimpleApplicationEventMulticaster();</span><br><span class="line">        Iterator var3 = application.getListeners().iterator();</span><br><span class="line"></span><br><span class="line">        while(var3.hasNext()) &#123;</span><br><span class="line">            ApplicationListener&lt;?&gt; listener = (ApplicationListener)var3.next();</span><br><span class="line">            this.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，加一个构造方法，并把@Component去掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class MySpringApplicationRunListener implements SpringApplicationRunListener &#123;</span><br><span class="line"></span><br><span class="line">    public MySpringApplicationRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void starting(ConfigurableBootstrapContext bootstrapContext) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 环境对象开始准备中(还不能获取配置信息)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 上下文对象开始准备(还没加载ioc容器)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 上下文对象开始加载(创建springboot启动的bean)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context, Duration timeTaken) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 加载完成...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void ready(ConfigurableApplicationContext context, Duration timeTaken) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动完成开始运行...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动失败...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看spring-boot包下的context下的event包下的一些定义好的事件Event，往里看都是继承自java的util包下的EventObject的。所以说springboot的事件监听是对java事件监听的封装。</p>
<h3 id="springboot启动流程"><a href="#springboot启动流程" class="headerlink" title="springboot启动流程"></a>springboot启动流程</h3><p>观察者模式：观察者和被观察者，被观察者：事件和事件源，观察者：监听器。</p>
<h4 id="✅初始化"><a href="#✅初始化" class="headerlink" title="✅初始化"></a>✅初始化</h4><p>debug一下启动类StartApplication中的<code>SpringApplication.run</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;</span><br><span class="line">    return (new SpringApplication(primarySources)).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个SpringApplication对象（事件源对象）。</p>
<p>SpringApplication构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    this.sources = new LinkedHashSet();</span><br><span class="line">    this.bannerMode = Mode.CONSOLE;</span><br><span class="line">    this.logStartupInfo = true;</span><br><span class="line">    this.addCommandLineProperties = true;</span><br><span class="line">    this.addConversionService = true;</span><br><span class="line">    this.headless = true;</span><br><span class="line">    this.registerShutdownHook = true;</span><br><span class="line">    this.additionalProfiles = Collections.emptySet();</span><br><span class="line">    this.isCustomEnvironment = false;</span><br><span class="line">    this.lazyInitialization = false;</span><br><span class="line">    this.applicationContextFactory = ApplicationContextFactory.DEFAULT;</span><br><span class="line">    this.applicationStartup = ApplicationStartup.DEFAULT;</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));  //有没有主类</span><br><span class="line">    this.webApplicationType = WebApplicationType.deduceFromClasspath();   //是否是web环境</span><br><span class="line">    this.bootstrapRegistryInitializers = new ArrayList(this.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line">    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));  //从springfactory文件中加载initializers</span><br><span class="line">    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));  //从springfactory配置文件中加载listener（放到set集合中）</span><br><span class="line">    this.mainApplicationClass = this.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/springboot%E5%90%AF%E5%8A%A8.png"></p>
<h4 id="✅run方法"><a href="#✅run方法" class="headerlink" title="✅run方法"></a>✅run方法</h4><p>StartApplication的run方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    long startTime = System.nanoTime();  //监控耗时，也可以用StopWatch</span><br><span class="line">    DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();</span><br><span class="line">    ConfigurableApplicationContext context = null;  //定一个容器</span><br><span class="line">    this.configureHeadlessProperty();  //加载东西</span><br><span class="line">    SpringApplicationRunListeners listeners = this.getRunListeners(args);  //获取RunListener</span><br><span class="line">    listeners.starting(bootstrapContext, this.mainApplicationClass);  //调用runListener的starting方法</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);  //准备环境，回调runListener的prepareEnvironment方法，环境对象Environment就有信息了</span><br><span class="line">        this.configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = this.printBanner(environment);  //打印spring图标，可以替换banner.txt</span><br><span class="line">        context = this.createApplicationContext();  //创建ioc容器</span><br><span class="line">        context.setApplicationStartup(this.applicationStartup);</span><br><span class="line">        this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);  //加载ioc容器</span><br><span class="line">        // 可以看context里的beanFactory里的beanDefinitionMap，里面是真正的bean，这时还没加载bean</span><br><span class="line">        this.refreshContext(context);  //这里从配置文件里找，创建bean（耗时操作）</span><br><span class="line">        this.afterRefresh(context, applicationArguments);</span><br><span class="line">        Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        if (this.logStartupInfo) &#123;</span><br><span class="line">            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), timeTakenToStartup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.started(context, timeTakenToStartup);  //项目启动成功，加载成功</span><br><span class="line">        this.callRunners(context, applicationArguments);  //commandLineRunner和applicationRunner 回调执行</span><br><span class="line">    &#125; catch (Throwable var12) &#123;</span><br><span class="line">        this.handleRunFailure(context, var12, listeners);</span><br><span class="line">        throw new IllegalStateException(var12);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        listeners.ready(context, timeTakenToReady);</span><br><span class="line">        return context;</span><br><span class="line">    &#125; catch (Throwable var11) &#123;</span><br><span class="line">        this.handleRunFailure(context, var11, (SpringApplicationRunListeners)null);</span><br><span class="line">        throw new IllegalStateException(var11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>以上，通过debug源码的方式，探索了springboot启动流程，看了监听器方法在哪里执行回调。</p>
<h2 id="springboot监控"><a href="#springboot监控" class="headerlink" title="springboot监控"></a>springboot监控</h2><h3 id="url方式"><a href="#url方式" class="headerlink" title="url方式"></a>url方式</h3><p>SpringBoot自带监控功能Actuator，可以帮助实现对程序内部运行情况监控，比如监控状况、Bean加载情况、配置属性 、日志信息等。</p>
<p>使用步骤</p>
<p>① 导入依赖坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>② 访问<a target="_blank" rel="noopener" href="http://localhost:8080/actuator">http://localhost:8080/actuator</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_links&quot;:&#123;</span><br><span class="line">        &quot;self&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator&quot;,</span><br><span class="line">            &quot;templated&quot;:false</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health-path&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator/health/&#123;*path&#125;&quot;,</span><br><span class="line">            &quot;templated&quot;:true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator/health&quot;,</span><br><span class="line">            &quot;templated&quot;:false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">路径	描述</span><br><span class="line">/beans	描述应用程序上下文里全部的Bean，以及它们的关系</span><br><span class="line">/env	获取全部环境属性</span><br><span class="line">/env/&#123;name&#125;	根据名称获取特定的环境属性值</span><br><span class="line">/health	报告应用程序的健康指标，这些值由HealthIndicator的实现类提供</span><br><span class="line">/info	获取应用程序的定制信息，这些信息由info打头的属性提供</span><br><span class="line">/mappings	描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系</span><br><span class="line">/metrics	报告各种应用程序度量信息，比如内存用量和HTTP请求计数</span><br><span class="line">/metrics/&#123;name&#125;	报告指定名称的应用程序度量值</span><br><span class="line">/trace	提供基本的HTTP请求跟踪信息(时间戳、HTTP头等)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">info:</span><br><span class="line">  name: hello</span><br><span class="line">  age: 23</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  #开启健康检查的完整信息</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: always</span><br><span class="line">  #将所有的监控endPoints暴漏出来</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: *</span><br></pre></td></tr></table></figure>

<h3 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h3><p>监控的可视化界面，只不过需要自己再起个监控服务。</p>
<p>Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。</p>
<p>Spring Boot Admin 有两个角色，客户端(Client)和服务端(Server)。</p>
<p>应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册</p>
<p>Spring Boot Admin Server 的UI界面将Spring Boot Admin Client的Actuator Endpoint上的一些监控信息.</p>
<p>使用步骤：</p>
<p>admin-server（监控服务）</p>
<p>① 创建 admin-server 模块</p>
<p>② 导入依赖坐标 admin-starter-server</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>③ 在引导类上启用监控功能@EnableAdminServer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableAdminServer</span><br><span class="line">public class SpringbootAdminServerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootAdminServerApplication.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>admin-client（被监控服务）</p>
<p>① 创建 admin-client 模块</p>
<p>② 导入依赖坐标 admin-starter-client</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>③ 配置相关信息：server地址等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指定admin.server地址，server在9000端口号，相当于向server注册</span><br><span class="line">spring.boot.admin.client.url=http://localhost:9000</span><br><span class="line">展示健康检查详细详细展示出来</span><br><span class="line">management.endpoint.health.show-details=always</span><br><span class="line">开启所有配置</span><br><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure>

<p>④ 启动server和client服务，访问server<br><a target="_blank" rel="noopener" href="http://localhost:9000/applications">http://localhost:9000/applications</a></p>
<hr>
<p>出现问题：<br>Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured.</p>
<p>原因：当前项目没有配置DataSource相关配置。springboot自动配置时，检测到添加了mysql的依赖包，但是配置文件中却没添加数据库的相关配置。<br>该案例中：mysql依赖在父pom中引入，该子工程不用mysql。</p>
<p>解决办法：@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) 排除自动注入数据库配置</p>
<hr>
<p>不知道是不是包的版本不对，有的版本报错，有的版本运行了却没显示。<br>idea中点EndPoins就可以图形化界面的方式来监控，不用那么麻烦，</p>
<h2 id="springboot项目部署"><a href="#springboot项目部署" class="headerlink" title="springboot项目部署"></a>springboot项目部署</h2><p>SpringBoot 项目开发完毕后，支持两种方式部署到服务器：</p>
<p>① jar包(官方推荐) 用内置的tomcat启动</p>
<p>② war包</p>
<h3 id="jar打包方式"><a href="#jar打包方式" class="headerlink" title="jar打包方式"></a>jar打包方式</h3><p>将当前模块打包：idea右边maven中选择要打包的模块，点lifecycle，点package。</p>
<p>打好的jar包在项目的target目录下。直接<code>java -jar .\jar包名称</code>，启动成功。</p>
<h3 id="war打包方式"><a href="#war打包方式" class="headerlink" title="war打包方式"></a>war打包方式</h3><p>pom.xml里更改打包方式：<code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>如果想改war包的名字：<code>&lt;finalName&gt;</code>标签</p>
<p>在引导类继承SpringBootServletInitializer类，并重写configure方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootDeployApplication extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootDeployApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">        return builder.sources(SpringBootDeployApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，打好的war包可以被外部tomcat识别，将其放在tomcat目录下的webapps目录下，启动tomcat即可（startup.bat），浏览器访问需要加项目的包名称，因为WEB-INF文件在其之下。并且，内置项目的端口号配置就不生效了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/22/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/sqlite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/22/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/sqlite/" class="post-title-link" itemprop="url">sqlite</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-22 11:49:15" itemprop="dateCreated datePublished" datetime="2022-12-22T11:49:15+08:00">2022-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-05 12:19:43" itemprop="dateModified" datetime="2023-02-05T12:19:43+08:00">2023-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是sqlite"><a href="#什么是sqlite" class="headerlink" title="什么是sqlite"></a>什么是sqlite</h2><p>SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 SQL 数据库引擎。</p>
<p>它是一个零配置的数据库，这意味着与其他数据库不一样，您不需要在系统中配置。</p>
<hr>
<p>sqlite的优点：</p>
<p>&lt;1&gt; 不需要一个单独的服务器进程或操作的系统（无服务器的）<br>&lt;2&gt; SQLite 不需要配置，这意味着不需要安装或管理。<br>&lt;3&gt; 一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。<br>&lt;4&gt; SQLite 是非常小的，是轻量级的，完全配置时小于 400KB<br>&lt;5&gt; SQLite 是自给自足的，这意味着不需要任何外部的依赖。<br>&lt;6&gt; SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。</p>
<h2 id="安装sqlite"><a href="#安装sqlite" class="headerlink" title="安装sqlite"></a>安装sqlite</h2><p>linux和macOS，基本都系统预装了。<br>输入<code>sqlite3</code>检查是否安装。</p>
<p>如果未安装，下载网址：<a target="_blank" rel="noopener" href="https://www.sqlite.org/download.html">https://www.sqlite.org/download.html</a><br>下载<code>sqlite-autoconf-*.tar.gz。</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tar xvzf sqlite-autoconf-3071502.tar.gz</span><br><span class="line">$ cd sqlite-autoconf-3071502</span><br><span class="line">$ ./configure --prefix=/usr/local</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<h2 id="sqlite命令"><a href="#sqlite命令" class="headerlink" title="sqlite命令"></a>sqlite命令</h2><p><code>.show </code>命名，查看 SQLite 命令提示符的默认设置。</p>
<p>更改配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt;.header on    </span><br><span class="line">sqlite&gt;.mode column</span><br><span class="line">sqlite&gt;.timer on</span><br></pre></td></tr></table></figure>

<p>创建数据库：<br><code>$ sqlite3 DatabaseName.db </code> 或 <code>sqlite&gt;.open test.db </code></p>
<p>创建的数据库文件位于 sqlite3 命令同一目录下。<br>打开已存在数据库也是用 .open 命令，以上命令如果 test.db 存在则直接会打开，不存在就创建它。</p>
<p><code>.databases</code> 展示数据库列表<br><code>.quit</code> 退出<br><code>testDB.db .dump &gt; testDB.sql</code> 导出完整的数据库到文本文件中<br><code>testDB.db &lt; testDB.sql</code> 恢复db文件</p>
<p><code>attach database file_name AS database_name;</code> 将同一文件夹下的db文件附加进来，并给个别名。<br>数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加。</p>
<p><code>detach database &#39;database_name&#39;;</code> 断开给定名称的连接，而其余的仍然有效</p>
<p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE database_name.table_name(</span><br><span class="line">   ID INT PRIMARY KEY     NOT NULL,</span><br><span class="line">   NAME           TEXT    NOT NULL,</span><br><span class="line">   AGE            INT     NOT NULL,</span><br><span class="line">   ADDRESS        CHAR(50),</span><br><span class="line">   SALARY         REAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>.tables</code> 查看创建的表</p>
<p><code>.schema tableName</code> 得到表的完整信息（建表语句）</p>
<h2 id="java使用sqlite"><a href="#java使用sqlite" class="headerlink" title="java使用sqlite"></a>java使用sqlite</h2><p>SQLite相比大多数数据库而言，具有免安装等优势，广泛应用于测试、Android等领域。通过一个.db文件就能实现数据库连接、DDL操作语句、DML命令。</p>
<p>导入<code>sqlite-jdbc</code>依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.xerial&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.40.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>软件：DB Browser for SQLite</p>
<p>sqlite没有像mysql使用comment增加字段/表名注释，使用–注释内容。</p>
<p>✅建表、插入、查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan.service;</span><br><span class="line"></span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.ToString;</span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2023-01-20 09:41</span><br><span class="line"> **/</span><br><span class="line">@Service</span><br><span class="line">public class SqliteService &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String filePath = &quot;/Users/liuxuan/Downloads/test.db&quot;;</span><br><span class="line">        Connection conn = createConnection(filePath);</span><br><span class="line">        // 创建表</span><br><span class="line">        String query = &quot;create table if not exists table_test (\n&quot; +</span><br><span class="line">                &quot;id integer PRIMARY KEY AUTOINCREMENT,\n&quot; +</span><br><span class="line">                &quot;num INTEGER(11),\n&quot; +</span><br><span class="line">                &quot;`desc` varchar(10) not null);&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            Statement stmt = conn.createStatement();</span><br><span class="line">            stmt.executeUpdate(query);</span><br><span class="line">            stmt.close();</span><br><span class="line">//            conn.commit();</span><br><span class="line">//            conn.close();</span><br><span class="line">        &#125; catch (SQLException e)&#123;</span><br><span class="line">            System.out.println(&quot;建立表存在异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 插入数据</span><br><span class="line">        String sql = &quot;insert into table_test (num, desc) &quot; +</span><br><span class="line">                &quot;values(1, &#x27;one&#x27;);&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            Statement stmt = conn.createStatement();</span><br><span class="line">            stmt.executeUpdate(sql);</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125; catch (SQLException e)&#123;</span><br><span class="line">            System.out.println(&quot;插入数据存在异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 查询数据</span><br><span class="line">        try &#123;</span><br><span class="line">            Statement stmt = conn.createStatement();</span><br><span class="line">            ResultSet rs = stmt.executeQuery( &quot;SELECT * FROM table_test;&quot; );</span><br><span class="line">            while (rs.next() ) &#123;</span><br><span class="line">                int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">                int num = rs.getInt(&quot;num&quot;);</span><br><span class="line">                String desc = rs.getString(&quot;desc&quot;);</span><br><span class="line">                System.out.println(id + &quot;,&quot; + num + &quot;,&quot; + desc);</span><br><span class="line">            &#125;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; catch (SQLException e)&#123;</span><br><span class="line">            System.out.println(&quot;查询数据存在异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 分页查询 用commons-dbutils包下的QueryRunner</span><br><span class="line">        String selectSql = &quot;select * from table_test&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;SqliteDO&gt; list = selectList(selectSql, conn, SqliteDO.class, 1, 10);</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            System.out.println(&quot;查询数据list存在异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取数据库连接</span><br><span class="line">     **/</span><br><span class="line">    public static Connection createConnection(String filePath) &#123;</span><br><span class="line">        Connection conn = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            Class.forName(&quot;org.sqlite.JDBC&quot;);</span><br><span class="line">            conn = DriverManager.getConnection(String.format(&quot;jdbc:sqlite:%s&quot;, filePath));</span><br><span class="line">        &#125;catch(ClassNotFoundException e)&#123;</span><br><span class="line">            System.out.println(&quot;不存在sqlite驱动包！&quot;);</span><br><span class="line">        &#125;catch (SQLException e)&#123;</span><br><span class="line">            System.out.println(&quot;与sqlite数据库连接失败！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; List&lt;T&gt; selectList(String sql, Connection connection, Class&lt;T&gt;objType, int currentPage, int pageSize) throws SQLException &#123;</span><br><span class="line">        sql = sql + &quot; limit ?,?&quot;;</span><br><span class="line">        QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">        List&lt;T&gt; dataList = queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(objType), pageSize * (currentPage - 1), pageSize);</span><br><span class="line">        return dataList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ToString</span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    public static class SqliteDO &#123;</span><br><span class="line">        private Integer id;</span><br><span class="line">        private Integer num;</span><br><span class="line">        private String desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅线程安全</p>
<p>sqlite是线程安全的，可以多线程插入。</p>
<p>✅sqlite在java中批量插入数据巨慢</p>
<p>开始是插入一条就构造一条insert语句，一条一条插入，慢。<br>后来改成多线程插入，还是慢。<br>再后来，一条insert语句插入1000条，快了很多。</p>
<p>一个说事务控制批量插入的：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiao-tangyuan/p/9556114.html">https://www.cnblogs.com/xiao-tangyuan/p/9556114.html</a></p>
<hr>
<p>SQLite——Java使用：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38322527/article/details/125717093">https://blog.csdn.net/qq_38322527/article/details/125717093</a></p>
<p>SQLite数据库基本使用（Java）：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44102521/article/details/119884521">https://blog.csdn.net/weixin_44102521/article/details/119884521</a></p>
<p>查询获取list：<br><a target="_blank" rel="noopener" href="https://m.runoob.com/sqlite/sqlite-java.html?ivk_sa=1024320u">https://m.runoob.com/sqlite/sqlite-java.html?ivk_sa=1024320u</a></p>
<p>sqlite没有comment：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qinxu0611/article/details/128609756">https://blog.csdn.net/qinxu0611/article/details/128609756</a></p>
<p>SQLite 线程安全和并发：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/feng9exe/p/10682567.html">https://www.cnblogs.com/feng9exe/p/10682567.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jade liu"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Jade liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jadeliuliu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jadeliuliu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jadeliu1998@163.com" title="E-Mail → mailto:jadeliu1998@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jadeliu1998" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;jadeliu1998" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5823044646" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5823044646" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jade liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
