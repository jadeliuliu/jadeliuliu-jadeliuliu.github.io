<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jadeliu&#39;s blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Jadeliu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jade liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jadeliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jadeliu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/10/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/elasticsearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/10/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/elasticsearch/" class="post-title-link" itemprop="url">elasticsearch</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-10 15:22:27" itemprop="dateCreated datePublished" datetime="2022-12-10T15:22:27+08:00">2022-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-22 11:49:00" itemprop="dateModified" datetime="2022-12-22T11:49:00+08:00">2022-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是elasticsearch"><a href="#什么是elasticsearch" class="headerlink" title="什么是elasticsearch"></a>什么是elasticsearch</h2><p>ES=elaticsearch简写， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。<br>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，通过面向文档从而让全文搜索变得简单。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45081813/article/details/113061113">https://blog.csdn.net/weixin_45081813/article/details/113061113</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/27/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/27/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-11-27 19:31:18 / Modified: 22:10:25" itemprop="dateCreated datePublished" datetime="2022-11-27T19:31:18+08:00">2022-11-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是用工厂方法代替new操作的一种模式。例如，Executors创建线程池ExecutorService的方法，就是工厂模式。</p>
<p>工厂模式在Java程序系统可以说是随处可见。因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A()，工厂模式也是用来创建实例对象。使用工厂模式创建实例对象，会给你系统带来更大的可扩展性和尽量少的修改量（降低耦合）。</p>
<h3 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h3><p>简单工厂模式不属于GOF的23种经典设计模式，相当于一种编程习惯。</p>
<p>简单工厂模式包含如下三种角色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">抽象产品：定义了产品的规范，描述了产品的主要特性和功能。（可以是接口）</span><br><span class="line">具体产品：实现或者继承抽象产品的子类。</span><br><span class="line">具体工厂：提供了创建产品的方法，使用者通过该方法来获取产品。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 在工厂方法中根据类型创建不同的具体对象</span><br><span class="line">**/</span><br><span class="line">public class SimpleCoffeeFactory &#123;</span><br><span class="line">	// 根据type判断类型，实例化并返回对应对象</span><br><span class="line">    public Coffee createCoffee(String type) &#123;</span><br><span class="line">        Coffee coffee = null;</span><br><span class="line">        if(&quot;americano&quot;.equals(type)) &#123;</span><br><span class="line">            coffee = new AmericanoCoffee();</span><br><span class="line">        &#125; else if(&quot;latte&quot;.equals(type)) &#123;</span><br><span class="line">            coffee = new LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        return coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂处理创建对象的细节，一旦有了工厂，后期如果需要对象直接从工厂中获取即可。这样也就解除了和实现类的耦合，不需要关注创建对象的细节，但同时又产生了新的耦合。后期如果再添加新的类，就必须修改工厂类的代码，违反了开闭原则。</p>
<hr>
<p>静态工厂模式：在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleCoffeeFactory &#123;</span><br><span class="line">    public static Coffee createCoffee(String type) &#123;</span><br><span class="line">        Coffee coffee = null;</span><br><span class="line">        if(&quot;americano&quot;.equals(type)) &#123;</span><br><span class="line">            coffee = new AmericanoCoffee();</span><br><span class="line">        &#125; else if(&quot;latte&quot;.equals(type)) &#123;</span><br><span class="line">            coffee = new LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        return coffe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h3><p>针对简单工厂模式的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p>
<p>工厂方法模式（FACTORY METHOD）是一种常用的类创建型设计模式,此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。它的核心结构有四个角色，分别是抽象工厂、具体工厂、抽象产品、具体产品。</p>
<p>四个角色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</span><br><span class="line">具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</span><br><span class="line">抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</span><br><span class="line">具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 抽象工厂</span><br><span class="line">**/</span><br><span class="line">public interface CoffeeFactory &#123;</span><br><span class="line">    Coffee createCoffee();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 具体工厂</span><br><span class="line">* </span><br><span class="line">* 抽象产品为coffee，具体产品为LatteCoffee和AmericanCoffee</span><br><span class="line">* 这种工厂模式可以通过不同的具体工厂创建出不同的具体产品</span><br><span class="line">**/</span><br><span class="line">public class LatteCoffeeFactory implements CoffeeFactory &#123;</span><br><span class="line">    public Coffee createCoffee() &#123;</span><br><span class="line">        return new LatteCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AmericanCoffeeFactory implements CoffeeFactory &#123;</span><br><span class="line">    public Coffee createCoffee() &#123;</span><br><span class="line">        return new AmericanCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要增加产品类时不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点，但要相应地增加工厂类。</p>
<p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p>
<p>优点：<br>在获取对象时只需要知道具体工厂的名称就可以得到对应的对象，无须知道具体创建过程；在系统增加新的类时只需要添加对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</p>
<p>缺点：<br>每增加一个类就要增加一个对应的具体工厂类，增加了系统的复杂度。</p>
<h3 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h3><p>抽象工厂模式（Abstract Factory Pattern）隶属于设计模式中的创建型模式，用于产品族的构建。抽象工厂是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂是指当有多个抽象角色时使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体情况下，创建<strong>多个产品族</strong>中的产品对象。</p>
<p>工厂模式中的每一个形态都是针对一定问题的解决方案，工厂方法针对的是多个产品系列结构；而抽象工厂模式针对的是多个产品族结构，一个产品族内有多个产品系列。</p>
<p>抽象工厂模式的主要角色如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</span><br><span class="line">具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</span><br><span class="line">抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</span><br><span class="line">具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 抽象工厂</span><br><span class="line">**/</span><br><span class="line">public interface DessertFactory &#123;</span><br><span class="line">    Coffee createCoffee();</span><br><span class="line">    Dessert createDessert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 具体工厂</span><br><span class="line">**/</span><br><span class="line">public class AmericanDessertFactory implements DessertFactory &#123;</span><br><span class="line">    public Coffee createCoffee() &#123;</span><br><span class="line">        return new AmericanCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">    public Dessert createDessert() &#123;</span><br><span class="line">        return new MatchaMousse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ItalyDessertFactory implements DessertFactory &#123;</span><br><span class="line">    public Coffee createCoffee() &#123;</span><br><span class="line">        return new LatteCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">    public Dessert createDessert() &#123;</span><br><span class="line">        return new Tiramisu();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。</p>
<p>优点：<br>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p>缺点：<br>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<h3 id="四、模式扩展（简单工厂-配置文件解除耦合）"><a href="#四、模式扩展（简单工厂-配置文件解除耦合）" class="headerlink" title="四、模式扩展（简单工厂+配置文件解除耦合）"></a>四、模式扩展（简单工厂+配置文件解除耦合）</h3><p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接获取即可。</p>
<p>创建配置文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">american=cn.com.supercoder.pattern.AmericanCoffee</span><br><span class="line">latte=cn.com.supercoder.pattern.LatteCoffee</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CoffeeFactory &#123;</span><br><span class="line">    private static Map&lt;String,Coffee&gt; map = new HashMap();</span><br><span class="line">    // 加载配置文件</span><br><span class="line">    static &#123;</span><br><span class="line">        Properties p = new Properties();</span><br><span class="line">        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            p.load(is);</span><br><span class="line">            // 遍历Properties集合对象</span><br><span class="line">            Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">            for (Object key : keys) &#123;</span><br><span class="line">                // 根据键获取值（全类名）</span><br><span class="line">                String className = p.getProperty((String) key);</span><br><span class="line">                // 获取Class对象</span><br><span class="line">                Class clazz = Class.forName(className);</span><br><span class="line">                // 实例化对象</span><br><span class="line">                Coffee obj = (Coffee) clazz.newInstance();</span><br><span class="line">                // 将对象以键值对的形式存入map</span><br><span class="line">                map.put((String)key,obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	* 获取对象时直接根据配置文件中的key获取对应的对象</span><br><span class="line">	**/</span><br><span class="line">    public static Coffee createCoffee(String name) &#123;</span><br><span class="line">        return map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45867375/article/details/124597130">https://blog.csdn.net/qq_45867375/article/details/124597130</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/05/myblog/JAVA/Page%E5%88%86%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/05/myblog/JAVA/Page%E5%88%86%E9%A1%B5/" class="post-title-link" itemprop="url">Page分页</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-05 12:55:45" itemprop="dateCreated datePublished" datetime="2022-11-05T12:55:45+08:00">2022-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-23 23:09:22" itemprop="dateModified" datetime="2023-02-23T23:09:22+08:00">2023-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h2><p>新建一个子工程web-repository。</p>
<p>mybatis依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.35&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--web-repository</span><br><span class="line"> --src</span><br><span class="line">  --main</span><br><span class="line">   --java</span><br><span class="line">     --config</span><br><span class="line">       --SpringConfig.java</span><br><span class="line">     --domain</span><br><span class="line">       --StudentDO.java</span><br><span class="line">     --StudentDao.java</span><br><span class="line">   --resource</span><br><span class="line">     --mapper</span><br><span class="line">  --test</span><br></pre></td></tr></table></figure>

<p>✅spring配置类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;org.example&quot;&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要引入spring依赖。</p>
<p>spring配置：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengyupinglan/p/14517267.html">https://www.cnblogs.com/fengyupinglan/p/14517267.html</a></p>
<p>✅spring整合mybatis</p>
<p>首先，spring配置文件可以是xml文件在resource文件夹下，也可以是注解方式的java文件。先写一个spring配置文件，自动装配搞上去。还有mybatis的一些bean要配置上去。</p>
<h3 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h3><p>xml文件方式，spring-mybatis.xml<br>开启自动扫描和配置bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描,扫描多个包用,隔开--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启Aspect生成代理对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--加载properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">ignore-unresolvable</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">location</span>=<span class="string">&#x27;classpath:dbconfig.properties&#x27;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.配置阿里druid连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置数据库基本信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.maxActive&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.配置spring的数据源，声明事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3.配置 mybatis，扫描mapper.xml文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3.1 配置 mybatis config --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3.2 配置扫描mybatis映射文件路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.类似于 jdbcTemplate 帮助类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描了所有的*Mapper.xml对应的mapper接口文件，这样就不用一个一个手动配置Mapper的映射了，只要Mapper接口类和Mapper映射文件对应起来就可以了。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.example.mysql&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>druid需要依赖包：druid<br>SqlSessionFactoryBean 需要依赖包：spring-jdbc<br>还需要 ibatis-common</p>
<p>dbconfig.properties:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">db.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">db.password=jade</span><br><span class="line">db.username=liuxuan</span><br><span class="line">db.maxActive=5</span><br><span class="line">db.initialSize=1</span><br></pre></td></tr></table></figure>

<p>mybatis配置文件，mybatis-config.xml<br>一些configuration setting</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//ybatis.org//DTD SQL Map Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;REUSE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml方式spring整合mybatis，mybatis配置项的意义：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45797116/article/details/117105095">https://blog.csdn.net/qq_45797116/article/details/117105095</a></p>
<p>xml文件中如果想引入其他xml文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;import resource=&quot;.../...xml&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>注解方式，SpringConfig.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package org.example.mysql.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;org.example&quot;&#125;)</span><br><span class="line">@ImportResource(&quot;classpath:spring-mybatis.xml&quot;) //导入xml配置项</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，可以用@Import导入其他注解方式的配置文件，以及用@ImportResource导入xml方式的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Import(CDPlayerConfig.class)  </span><br><span class="line">@ImportResource(&quot;classpath:cons-injec.xml&quot;) //导入xml配置项</span><br></pre></td></tr></table></figure>

<p>注解方式倒入配置文件：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42107384/article/details/116475637">https://blog.csdn.net/weixin_42107384/article/details/116475637</a></p>
<p>纯注解方式的整合spring和mybatis配置：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44226181/article/details/127343597">https://blog.csdn.net/weixin_44226181/article/details/127343597</a></p>
<p>还有一个一行代码的基于注解整合的：<br><a target="_blank" rel="noopener" href="https://www.pudn.com/news/62f1dcb95425817ffc22c172.html">https://www.pudn.com/news/62f1dcb95425817ffc22c172.html</a></p>
<h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">public class StudentDaoTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectById() &#123;</span><br><span class="line"></span><br><span class="line">        // xml：</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        UserMapper mapper = (UserMapper) context.getBean(&quot;userMapper&quot;);</span><br><span class="line"></span><br><span class="line">        // 注解：</span><br><span class="line">        ApplicationContext context =new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        StudentDao studentDao = (StudentDao) context.getBean(&quot;studentDao&quot;);</span><br><span class="line"></span><br><span class="line">        StudentDO studentDO = studentDao.selectById(1L);</span><br><span class="line">        System.out.println(studentDO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试验证及xml中配置SqlSessionFactory的bean和扫描的bean：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28082757/article/details/103488364">https://blog.csdn.net/qq_28082757/article/details/103488364</a></p>
<p>配置数据库连接池有几种方法，上面用的是ali的druid连接池，关于Druid连接池：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chy18883701161/p/12594889.html">https://www.cnblogs.com/chy18883701161/p/12594889.html</a></p>
<p>注解方式配置JdbcConfig中 PlatformTransactionManager 是事务管理，在spring-jdbc包下。<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/903c01cb2a77">https://www.jianshu.com/p/903c01cb2a77</a></p>
<p>@Mapper注解，难道是spring-boot才能用的？<br>mybatis支持的映射方式有基于xml的mapper.xml文件、基于java的使用Mapper接口class。<br>从mybatis3.4.0开始加入了@Mapper注解，目的就是为了不再写mapper映射文件。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46369022/article/details/122755858">https://blog.csdn.net/weixin_46369022/article/details/122755858</a><br>需要依赖包：mybatis-spring-boot-starter</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>✅ @Value里的字段报红</p>
<p>原因：自动导入了lombok里的@Value，要用的是SpringFramework下的@Value。</p>
<p>✅ xml配置文件加载不到properties属性问题</p>
<p>原因：spring中没有成功加载相应的配置文件</p>
<p>解决：进入File-Project Struccture，进入Facets中进行配置，.在右边的spring目录下，找到对应的爆红问题所在配置文件，选择xml文件，点击修改符合（下图中的小铅笔），在跳出来的弹框中，选择添加（加号），然后选择Additioonal properties files。然后找到需要加载进spring中的配置文件，点击OK，添加成功。</p>
<p>来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaogot/article/details/103224088">https://blog.csdn.net/zhaogot/article/details/103224088</a></p>
<p>✅ xml配置文件中的问题：根元素 “beans” 必须匹配 DOCTYPE 根 “null”</p>
<p>在<code>&lt;beans&gt;</code>标签那里报出来。</p>
<p>原因：mybatis在扫描Mapper.xml文件时，扫描到非mapper文件。比如本次报错扫描到了自己。spring.xml的根元素是<code>&lt;beans&gt;&lt;/beans&gt;</code>当然不会有DOCTYPE了。<br>所以当Mybatis扫描到了Spring.xml这个非Mapper.xml文件时，自然找不到DOCTYPE，所以会有“DOCTYPE 根 “null””这个错误。</p>
<p>粗心：应该扫的是mybatis-config.xml文件，结构写成了自己。</p>
<p>来自：<a target="_blank" rel="noopener" href="https://www.codeleading.com/article/7746743165/">https://www.codeleading.com/article/7746743165/</a></p>
<p>✅ org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)</p>
<p>原因：mapper接口和xml文件没匹配上，有可能是文件名方法名没匹配上，这里是在配置文件里没加扫描接口，加了就好了。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43570367/article/details/103147854">https://blog.csdn.net/weixin_43570367/article/details/103147854</a></p>
<p>✅ properties文件 java.lang.NumberFormatException</p>
<p>明明是数字类型，但是说我从String转为int发生异常。</p>
<p>需要在xml配置文件中加载properties配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载properties文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">ignore-unresolvable</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">location</span>=<span class="string">&#x27;classpath:dbconfig.properties&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring加载properties文件的几种方式：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/chuige2013/article/details/121759088">https://blog.csdn.net/chuige2013/article/details/121759088</a></p>
<p>✅ java.sql.SQLException: com.mysql.cj.jdbc.Driver</p>
<p>mysql连接驱动依赖的版本不匹配问题，一般出现在使用低版本连接驱动连接高版本mysql情况下，解决方法是在maven中央仓库中下载高版本的mysql连接驱动.</p>
<p>mysql-connector-java 换8.0.21的包，自动引入没成功，手动下载装到.m2的。</p>
<p>✅ init datasource error, url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8</p>
<p>db.url换成：<code>jdbc:mysql://localhost:3306/mysql?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</code></p>
<p>✅ Table ‘mysql.student’ doesn’t exist</p>
<p>上面mysql换成库名。</p>
<p>😄终于成功了，不容易。</p>
<h2 id="com-github-pagehelper"><a href="#com-github-pagehelper" class="headerlink" title="com.github.pagehelper"></a>com.github.pagehelper</h2><p>背景：使用Pige时，从数据库中获取到list之后，removeIf筛选，但是分页得到的效果不对，条目总数total是从数据库得到的list size。</p>
<p>原因：Page与Mybatis强耦合，不是先从数据库获取再分页，而是先获取某页要获取的条目，耦合到sql中查询。</p>
<p>难道只能是spring-boot用的？ pagehelper-spring-boot-starter 依赖包中。</p>
<p>PageHelper分页：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43958747/article/details/103822761">https://blog.csdn.net/weixin_43958747/article/details/103822761</a></p>
<p>其中有个参数为CallBack接口。</p>
<p>⚠️使用中的一个case：<br>Pageed中的list的元素得和数据库dao返回的数据结构一样，得是DO。获取了Paged之后再转为vo，因为分页Page和mybatis是强耦合的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/22/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/leeco%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/leeco%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">javaのleecode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-22 09:27:14" itemprop="dateCreated datePublished" datetime="2022-10-22T09:27:14+08:00">2022-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-24 22:02:38" itemprop="dateModified" datetime="2023-11-24T22:02:38+08:00">2023-11-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>题目：给个数组和目标值，给出数组中两个数之和等于目标值的数的索引。<br>思想：哈希映射，利用map的快速查找key特性（<code>map.containsKey(key)</code>）来实现遍历一次就够了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 两数之和</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-20 23:39</span><br><span class="line"> **/</span><br><span class="line">public class TwoNumSum &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = new int[]&#123;2,7,11,15&#125;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        int[] res = solution.twoSum(nums, 9);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">            HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">                if (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                    return new int[]&#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new IllegalArgumentException(&quot;no result&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        d = dict()  #字典，相当于map</span><br><span class="line">        for i, num in enumerate(nums):  #遍历获取索引和内容</span><br><span class="line">            if target - num in d:</span><br><span class="line">                return [i, d[target - num]]</span><br><span class="line">            else:</span><br><span class="line">                d[num] = i</span><br><span class="line">        return []</span><br></pre></td></tr></table></figure>

<h2 id="两链表表示的数相加"><a href="#两链表表示的数相加" class="headerlink" title="两链表表示的数相加"></a>两链表表示的数相加</h2><p>题目：两个链表表示的数，1-&gt;2-&gt;3 表示 123，相加得到和的链表。<br>思想：相加遍历进位即可，carry表示进位，要在while循环外定义，要先算和再算进位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计算两个琏表表示的数的和</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-22 10:18</span><br><span class="line"> **/</span><br><span class="line">public class TwoLinkNumSum &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 构造链表</span><br><span class="line">        ListNode listNode1 = ListNode.inputList(1, 2, 3);</span><br><span class="line">        ListNode.printList(listNode1);</span><br><span class="line">        ListNode.printList(ListNode.reverseList(listNode1));</span><br><span class="line">        ListNode l1 = ListNode.inputList(2, 4, 3);</span><br><span class="line">        ListNode l2 = ListNode.inputList(5, 6, 4);</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        ListNode sum = s.addTwoNumbers(l1, l2);</span><br><span class="line">        ListNode.printList(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">            // 定义pre节点，保证头节点也参与循环</span><br><span class="line">            ListNode pre = new ListNode(0);</span><br><span class="line">            ListNode cur = pre;</span><br><span class="line">            int carry = 0;</span><br><span class="line">            while (l1 != null || l2 != null) &#123;</span><br><span class="line">                int x = l1 == null ? 0 : l1.val;</span><br><span class="line">                int y = l2 == null ? 0 : l2.val;</span><br><span class="line">                int sum = (x + y + carry) % 10;</span><br><span class="line">                carry = (x + y + carry) / 10;</span><br><span class="line">                cur.next = new ListNode(sum);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                if (l1 != null) &#123;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if (l2 != null) &#123;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (carry != 0) &#123;</span><br><span class="line">                cur.next = new ListNode(carry);</span><br><span class="line">            &#125;</span><br><span class="line">            return pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ListNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;;</span><br><span class="line">        ListNode(int val) &#123;this.val = val;&#125;</span><br><span class="line">        ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"></span><br><span class="line">        /** 向队尾添加节点 */</span><br><span class="line">        private void addNode(ListNode newNode) &#123;</span><br><span class="line">            if (this.next == null) &#123;</span><br><span class="line">                this.next = newNode;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.next.addNode(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /** 使用方法可变参数把一串数字变成链表 */</span><br><span class="line">        public static ListNode inputList(int ...data) &#123;</span><br><span class="line">            ListNode listHead = null;</span><br><span class="line">            for (int temp : data) &#123;</span><br><span class="line">                ListNode newNode = new ListNode(temp);</span><br><span class="line">                if (listHead == null) &#123;</span><br><span class="line">                    listHead = newNode;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    listHead.addNode(newNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return listHead;</span><br><span class="line">        &#125;</span><br><span class="line">        /** 打印链表 */</span><br><span class="line">        public static void printList(ListNode head) &#123;</span><br><span class="line">            while (head != null) &#123;</span><br><span class="line">                System.out.print(head.val + &quot;-&gt;&quot;);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        /** 翻转链表 */</span><br><span class="line">        public static ListNode reverseList(ListNode head) &#123;</span><br><span class="line">            ListNode pre = null;</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            while (cur != null) &#123;</span><br><span class="line">                ListNode next = cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            return pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串的最长无重复字符子串"><a href="#字符串的最长无重复字符子串" class="headerlink" title="字符串的最长无重复字符子串"></a>字符串的最长无重复字符子串</h2><p>题目：一个字符串，给出字符串的连续子串中其中无重复字符的子串的最大长度。<br>思想：滑动窗口，或者叫做双指针，两个指针的差+1表示窗口的长度，用一个map记录某字符最晚出现的位置的下一个位置。如果在start指针后面出现过就需要移动start到map该字符的value的位置了。如果要子串本身，还得记录开始位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 无重复字符的最长子串</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-22 12:29</span><br><span class="line"> **/</span><br><span class="line">public class MaxNoRepeatString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;abcabc&quot;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        System.out.println(solution.lengthOfLongestSubstring(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">            // 用map表示字符对应的下一个位置</span><br><span class="line">            Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            int res = 0;</span><br><span class="line">            String sub = null;</span><br><span class="line">            for (int start = 0, end = 0; end &lt; s.length(); end ++) &#123;</span><br><span class="line">                char c = s.charAt(end);</span><br><span class="line">                if (map.containsKey(c)) &#123;</span><br><span class="line">                    start = Math.max(start, map.get(c));</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果存在key，会更新</span><br><span class="line">                map.put(c, end + 1);</span><br><span class="line">                //res = Math.max(res, end - start + 1);</span><br><span class="line">                if (end - start + 1 &gt; res) &#123;</span><br><span class="line">                    res = end - start + 1;</span><br><span class="line">                    sub = s.substring(start, end + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;sub字符串：&quot; + sub);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap();</span><br><span class="line">        int maxSize = 0;</span><br><span class="line">        int l = 0;</span><br><span class="line">        String res = null;</span><br><span class="line">        for (int r = 0; r &lt; s.length(); r ++) &#123;  //String是.length() 数组是.length</span><br><span class="line">            char c = s.charAt(r);  //不是.get，是.charAt</span><br><span class="line">            if (map.containsKey(c)) &#123;</span><br><span class="line">                l = Math.max(map.get(c) + 1, l);  //需要取大的，不然会回退</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, r);</span><br><span class="line">            if (r - l + 1 &gt; maxSize) &#123;</span><br><span class="line">                maxSize = r - l + 1;</span><br><span class="line">                res = s.substring(l, r + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;res:&quot; + res);</span><br><span class="line">        return maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s: str) -&gt; int:</span><br><span class="line">        dic, res, i = &#123;&#125;, 0, 0</span><br><span class="line">        for j in range(len(s)):</span><br><span class="line">            if s[j] in dic:</span><br><span class="line">                i = max(i, dic[s[j]] + 1)</span><br><span class="line">            dic[s[j]] = j</span><br><span class="line">            res = max(res, j - i + 1)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><p>题目：给两个正序排列的数组，返回这两个数组合起来的数组的中位数。<br>思路1：遍历，在两个数组间横跳，遍历(m+n)/2+1次就好了。时间复杂度是O(m+n)<br>思路2：遍历是挨个排除不可能的值，那么如果用二分法就可以一半一半地排除不可能的值。其实是找第K小的数，要比两个数组的K/2位置的数，小的那个数组K/2及前面的数就可以排除掉，这样递归查找。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 寻找两个正序数组的中位数</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-23 10:10</span><br><span class="line"> **/</span><br><span class="line">public class MedianOfTwoArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array1 = new int[]&#123;1, 2&#125;;</span><br><span class="line">        int[] array2 = new int[]&#123;3, 4&#125;;</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        System.out.println(s.findMedianSortedArrays(array1, array2));</span><br><span class="line">        System.out.println(s.findMedianSortedArrays2(array1, array2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        // 方法一：在两个数组间遍历，移动(m+n)/2+1步</span><br><span class="line">        public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">            int index1 = 0, index2 = 0, left = 0, right = 0;</span><br><span class="line">            int size = nums1.length + nums2.length;</span><br><span class="line">            for (int i = 0; i &lt;= size / 2; i++) &#123;</span><br><span class="line">                // left慢一步</span><br><span class="line">                left = right;</span><br><span class="line">                if (index1 &lt; nums1.length &amp;&amp; (index2 == nums2.length || nums1[index1] &lt;= nums2[index2])) &#123;</span><br><span class="line">                    right = nums1[index1++];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right = nums2[index2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (size % 2 == 0) &#123;</span><br><span class="line">                return (left + right) / 2.0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 方法二：二分法</span><br><span class="line">        public double findMedianSortedArrays2(int[] nums1, int[] nums2) &#123;</span><br><span class="line">            int n = nums1.length;</span><br><span class="line">            int m = nums2.length;</span><br><span class="line">            int left = (n + m + 1) / 2;</span><br><span class="line">            int right = (n + m + 2) / 2;</span><br><span class="line">            return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取两正序数组的第k大的值</span><br><span class="line">        private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) &#123;</span><br><span class="line">            // 要进行比较的数组的长度</span><br><span class="line">            int len1 = end1 - start1 + 1;</span><br><span class="line">            int len2 = end2 - start2 + 1;</span><br><span class="line">            if (len1 + len2 &lt; k) &#123;throw new IllegalArgumentException(&quot;no result&quot;);&#125;</span><br><span class="line">            // 出递归条件</span><br><span class="line">            if (len1 == 0) return nums2[start2 + k - 1];</span><br><span class="line">            if (len2 == 0) return nums1[start1 + k - 1];</span><br><span class="line">            if (k == 1) return Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">            // 要比较的两个数组的索引</span><br><span class="line">            int i = start1 + Math.min(len1, k / 2) - 1;</span><br><span class="line">            int j = start2 + Math.min(len2, k / 2) - 1;</span><br><span class="line">            if (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int size = nums1.length + nums2.length;</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        int left = 0, right = 0;</span><br><span class="line">        for (int m = 0; m &lt;= size/2; m ++) &#123;</span><br><span class="line">            left = right;</span><br><span class="line">            if (i &lt; nums1.length &amp;&amp; (j == nums2.length || nums1[i] &lt;= nums2[j])) &#123;  //注意越界</span><br><span class="line">                right = nums1[i ++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right = nums2[j ++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (size % 2 == 0) &#123;</span><br><span class="line">            return (left + right) / 2.0; //注意除以2.0</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 二分法的思想：在有序数组中查找，每次缩小一半的查找范围</span><br><span class="line">    // 就要看怎么淘汰：扩展一下，找第k大数，两个数组k/2位置，小的那个数组之前的就能淘汰</span><br><span class="line">    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int len = nums1.length + nums2.length;</span><br><span class="line">        if (len % 2 == 0) &#123;</span><br><span class="line">            return (getK(nums1, 0, nums1.length - 1, nums2, 0, nums2.length - 1, len/2) + getK(nums1, 0, nums1.length - 1, nums2, 0, nums2.length - 1, len/2 + 1)) / 2.0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return getK(nums1, 0, nums1.length - 1, nums2, 0, nums2.length - 1, len/2 + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Integer getK(int[] nums1, int s1, int e1, int[] nums2, int s2, int e2, int k) &#123;</span><br><span class="line">        System.out.println(s1+&quot;.&quot;+e1+&quot;.&quot;+s2+&quot;.&quot;+e2+&quot;.&quot;+k);</span><br><span class="line">        // 递归第一步：出递归条件</span><br><span class="line">        if (s1 &gt; e1) return nums2[s2 + k - 1]; // 注意这里得加s2</span><br><span class="line">        if (s2 &gt; e2) return nums1[s1 + k - 1]; // 注意k是第k个，索引又是从0开始的</span><br><span class="line">        if (k == 1) return nums1[s1] &lt; nums2[s2] ? nums1[s1]:nums2[s2];</span><br><span class="line">        // 递归第二步：缩小范围</span><br><span class="line">        // 需要注意数组可能没k/2那么大了，没那么大只能选边界</span><br><span class="line">        int i = Math.min(s1 + k/2 - 1, e1); // 注意-1</span><br><span class="line">        int j = Math.min(s2 + k/2 - 1, e2);</span><br><span class="line">        if (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            // 应该找第几个了</span><br><span class="line">            int find = k - (i - s1 + 1);</span><br><span class="line">            return getK(nums1, i + 1, e1, nums2, s2, e2, find);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int find = k - (j - s2 + 1);</span><br><span class="line">            return getK(nums1, s1, e1, nums2, j + 1, e2, find);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>题目：给一个字符串，返回该字符串的最长回文子串，例如：aba，abba。<br>思想1：可以挨个遍历每个字符，从字符开始向左右散发，如果不相等了就停止，并且分两种散发：一个中心字符，两个一样的作为中心字符。记录开始位置和结束位置。<br>思想2：回文子串也是该字符串与它倒过来的字符串的最长公共子串，可以用动态规划维护一个二维数组来做。动态规划就是为了减少重复计算的问题。动态规划听起来很高大上。其实说白了就是空间换时间，将计算结果暂存起来，避免重复计算。作用和工程中用 redis 做缓存有异曲同工之妙。<br>求出最长公共子串后，并不一定是回文串，我们还需要判断该字符串倒置前的下标和当前的字符串下标是不是匹配</p>
<blockquote>
<p>整体思想就是，申请一个二维的数组初始化为 0，然后判断对应的字符是否相等，相等的话<br>arr [ i ][ j ] = arr [ i - 1 ][ j - 1] + 1 。<br>当 i = 0 或者 j = 0 的时候单独分析，字符相等的话 arr [ i ][ j ] 就赋为 1 。<br>arr [ i ][ j ] 保存的就是公共子串的长度，表示以i为结尾和以j为结尾的前arr[i][j]个字符是公共子串。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最长回文子串</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-29 20:43</span><br><span class="line"> **/</span><br><span class="line">public class HuiWenString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;aacabdkacaa&quot;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        System.out.println(solution.longestPalindrome(s));</span><br><span class="line">        System.out.println(solution.longestPalindrome1(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public String longestPalindrome(String s) &#123;</span><br><span class="line">            if (null == s || s.length() &lt; 2) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">            int max = 0;</span><br><span class="line">            String res = null;</span><br><span class="line">            for (int i = 0; i &lt; s.length() - 1; i ++) &#123;</span><br><span class="line">                int l = i, r = i;</span><br><span class="line">                while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                    l --;</span><br><span class="line">                    r ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (r - l + 1 &gt; max) &#123;</span><br><span class="line">                    max = r - l + 1;</span><br><span class="line">                    res = s.substring(l + 1, r);</span><br><span class="line">                &#125;</span><br><span class="line">                l = i;</span><br><span class="line">                r = i + 1;</span><br><span class="line">                while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                    l --;</span><br><span class="line">                    r ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (r - l + 1 &gt; max) &#123;</span><br><span class="line">                    max = r - l + 1;</span><br><span class="line">                    res = s.substring(l + 1, r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String longestPalindrome1(String s) &#123;</span><br><span class="line">            if (null == s || s.length() &lt; 2) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">            String res = null;</span><br><span class="line">            int max = 0;</span><br><span class="line">            int length = s.length();</span><br><span class="line">            int[][] arr = new int[length][length];</span><br><span class="line">            String rev = new StringBuffer(s).reverse().toString(); //字符串翻转</span><br><span class="line">            for (int i = 0; i &lt; length; i ++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; length; j ++) &#123;</span><br><span class="line">                    //如果不想等可以不赋值为0，表示以这个字符为公共最后字符没有公共字符，动态规划也用不上</span><br><span class="line">                    if (s.charAt(i) == rev.charAt(j)) &#123;</span><br><span class="line">                        //为0的边界</span><br><span class="line">                        if (i == 0 || j == 0) &#123;</span><br><span class="line">                            arr[i][j] = 1;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            arr[i][j] = arr[i - 1][j - 1] + 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (arr[i][j] &gt; max) &#123;</span><br><span class="line">                        int beforeRev = length - 1 - j; //倒置前的坐标</span><br><span class="line">                        if (beforeRev + arr[i][j] - 1 == i) &#123; //判断下标是否对应</span><br><span class="line">                            max = arr[i][j];</span><br><span class="line">                            res = s.substring(i - arr[i][j] + 1, i + 1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        //遍历每个元素，用双指针前后拓展，直到不一样就停止</span><br><span class="line">        int maxSize = 0;</span><br><span class="line">        String res = &quot;&quot;;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            // 1.一个点为中心</span><br><span class="line">            int jump = 0;</span><br><span class="line">            while (i - jump &gt;= 0 &amp;&amp; i + jump &lt; s.length() &amp;&amp; s.charAt(i - jump) == s.charAt(i + jump)) &#123;</span><br><span class="line">                if (jump*2+1 &gt; maxSize) &#123;</span><br><span class="line">                    maxSize = jump*2+1;</span><br><span class="line">                    res = s.substring(i - jump, i + jump +1);</span><br><span class="line">                &#125;</span><br><span class="line">                jump ++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 2.以两个点为中心</span><br><span class="line">            jump= 0; // 注意从0开始</span><br><span class="line">            while (i - jump &gt;= 0 &amp;&amp; i + 1 + jump &lt; s.length() &amp;&amp; s.charAt(i - jump) == s.charAt(i + 1 + jump)) &#123;</span><br><span class="line">                if (jump*2+2 &gt; maxSize) &#123;</span><br><span class="line">                    maxSize = jump*2+2;</span><br><span class="line">                    res = s.substring(i - jump, i + jump +2);  //注意是substring</span><br><span class="line">                &#125;</span><br><span class="line">                jump ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        //动态规划的思想：以空间换时间，保存计算结果，避免重复计算</span><br><span class="line">        //需要明确[i][j]表示的含义，以及怎么传递下去，以及最开始怎么算</span><br><span class="line">        // 1.初始化动态规划矩阵</span><br><span class="line">        int length = s.length();</span><br><span class="line">        int[][] nums = new int[length][length]; //矩阵初始化方法</span><br><span class="line">        String res = &quot;&quot;;</span><br><span class="line">        int max = 0;</span><br><span class="line">        // 2.遍历方向要依据传递条件</span><br><span class="line">        for (int i = length - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">            int maxj = i;</span><br><span class="line">            for (int j = i; j &lt; length; j++) &#123;</span><br><span class="line">                if (i == j) &#123;</span><br><span class="line">                    // 3.代表的含义应该是：是否回文</span><br><span class="line">                    nums[i][j] = 1;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    if (j == i + 1) &#123;</span><br><span class="line">                        nums[i][j] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 4.上面是初始条件，下面是传递条件</span><br><span class="line">                        nums[i][j] = nums[i + 1][j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxj = nums[i][j] == 1 &amp;&amp; j &gt; maxj ? j: maxj;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    nums[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (maxj - i + 1 &gt; max) &#123;</span><br><span class="line">                max = maxj - i + 1;</span><br><span class="line">                res = s.substring(i, maxj + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Z字形变换"><a href="#Z字形变换" class="headerlink" title="Z字形变换"></a>Z字形变换</h2><p>题目：将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>思路：根据行数可以得出多少个循环一次半Z，然后第一行就是除以几余几的，看有咩用方法可以获取一个字符串中位置是/n余i的字符组成的字符串。String的split方法尽管可以按照正则表达式来分割，但是貌似无法实现隔位分割。<br>所以只能是新建一个<code>List&lt;StringBuilder&gt;</code>，然后遍历字符串来append进去。比取余更好的做法是用一个index标注，往下是+1，遇到拐角就-1.</p>
<p>遍历字符串中的字符：<code>char c : s.toCharArray()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package leeco.string;</span><br><span class="line"></span><br><span class="line">import com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-12 12:08</span><br><span class="line"> **/</span><br><span class="line">public class ZTransform &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;PAYPALISHIRING&quot;;</span><br><span class="line">        Solution so = new Solution();</span><br><span class="line">        String res = so.convert(s, 3);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public String convert(String s, int numRows) &#123;</span><br><span class="line">            if (numRows &lt; 2) return s;</span><br><span class="line">            List&lt;StringBuilder&gt; rows = Lists.newArrayList();</span><br><span class="line">            //List&lt;StringBuilder&gt; rows = new ArrayList&lt;StringBuilder&gt;();</span><br><span class="line">            //需要写入numRows个StringBuilder到List</span><br><span class="line">            for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                rows.add(sb);</span><br><span class="line">            &#125;</span><br><span class="line">            int index = 0;</span><br><span class="line">            int step = -1;</span><br><span class="line">            for (char c : s.toCharArray()) &#123;</span><br><span class="line">                rows.get(index).append(c);</span><br><span class="line">                //遇到拐点，方向就反</span><br><span class="line">                if (index == 0 || index == numRows - 1) &#123;</span><br><span class="line">                    step = -step;</span><br><span class="line">                &#125;</span><br><span class="line">                index += step;</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder res = new StringBuilder();</span><br><span class="line">            for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class="line">                res.append(rows.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            return res.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String convert(String s, int numRows) &#123;</span><br><span class="line">        //很简单，规律性的东西，两个方向：往上走和往下走</span><br><span class="line">        if (numRows == 1) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;StringBuilder&gt; sbList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i&lt; numRows; i++) &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            sbList.add(sb);</span><br><span class="line">        &#125;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i ++) &#123;</span><br><span class="line">            sbList.get(index).append(s.charAt(i));</span><br><span class="line">            if (i % (2 * numRows - 2) &lt; numRows - 1) &#123;</span><br><span class="line">                index ++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                index --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i&lt;numRows; i++) &#123;</span><br><span class="line">            sbList.get(0).append(sbList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return sbList.get(0).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h2><p>题目：给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。-123 变 -321<br>Integer整数区间：[−2^31,  2^31 − 1]<br>思路1：变成一个字符串，然后反转，然后加符号。<br>思路2：对int一步一步/10，然后拿到结果一步一步*10<br>思路3：用栈stack，也得先变字符串，本质上也是字符串反转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-12 22:38</span><br><span class="line"> **/</span><br><span class="line">public class IntegerReverse &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Integer.MAX_VALUE);</span><br><span class="line">        System.out.println(Math.pow(2, 31) - 1);</span><br><span class="line">        int i = -33;</span><br><span class="line">        System.out.println(~(i-1));  //和-i一样</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        System.out.println(s.reverse(-123));</span><br><span class="line">        System.out.println(s.reverse2(-123));</span><br><span class="line">        System.out.println(s.reverse2(-123));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int reverse(int x) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                if (x &lt; 0) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x = -x;</span><br><span class="line">                &#125;</span><br><span class="line">                String old = String.valueOf(x);</span><br><span class="line">                String newS = new StringBuilder(old).reverse().toString();</span><br><span class="line">                int res = Integer.parseInt(newS);</span><br><span class="line">                if (flag) res = -res;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int reverse2(int x) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                if (x &lt; 0) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x = -x;</span><br><span class="line">                &#125;</span><br><span class="line">                int res = 0;</span><br><span class="line">                while (x &gt; 0) &#123;</span><br><span class="line">                    res = res * 10 + x % 10;</span><br><span class="line">                    x = x / 10;</span><br><span class="line">                &#125;</span><br><span class="line">                if (flag) res = - res;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int reverse3(int x) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                if (x &lt; 0) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x = -x;</span><br><span class="line">                &#125;</span><br><span class="line">                String old = String.valueOf(x);</span><br><span class="line">                Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">                for (char c : old.toCharArray()) stack.push(c);</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                while (!stack.empty()) sb.append(stack.pop());</span><br><span class="line">                int res = Integer.parseInt(sb.toString());</span><br><span class="line">                if (flag) res = -res;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int reverse(int x) &#123;</span><br><span class="line">        // 用String进行反转，java的幂运算用Math.pow(2,2)</span><br><span class="line">        boolean isFu = false;</span><br><span class="line">        if(x &lt; 0) &#123;</span><br><span class="line">            isFu = true;</span><br><span class="line">            // 如果是-2^31，负的接不住。</span><br><span class="line">            if (x == Integer.MIN_VALUE) return 0;</span><br><span class="line">            x = -x;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = new StringBuilder(String.valueOf(x)).reverse().toString();</span><br><span class="line">        long l = Long.valueOf(s);</span><br><span class="line">        // 原来正的，反过来正的，不能大于2^ 31-1</span><br><span class="line">        if ((isFu &amp;&amp; l &gt; Math.pow(2, 31)) || !isFu &amp;&amp; l &gt; Math.pow(2, 31)-1)</span><br><span class="line">            return 0;</span><br><span class="line">        return isFu? -Integer.valueOf(String.valueOf(l)) : Integer.valueOf(String.valueOf(l));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ErFen &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;输入有序数组，逗号分隔：&quot;);</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        str = str.replace(&quot; &quot;, &quot;&quot;);</span><br><span class="line">        String[] strArray = str.split(&quot;,&quot;);</span><br><span class="line">        int[] array = new int[strArray.length];</span><br><span class="line">        for(int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = Integer.parseInt(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;输入目标值：&quot;);</span><br><span class="line">        int target = sc.nextInt();</span><br><span class="line">        System.out.println(&quot;array:&quot; + Arrays.toString(array));</span><br><span class="line">        int min = 0;</span><br><span class="line">        int max = array.length - 1;</span><br><span class="line">        int middle = min + (max - min) / 2; //防止越界</span><br><span class="line">        while(min &lt;= max) &#123;</span><br><span class="line">            if (array[middle] == target) &#123;</span><br><span class="line">                System.out.println(middle);</span><br><span class="line">                return;</span><br><span class="line">            &#125; else if (array[middle] &lt; target) &#123;</span><br><span class="line">                min = middle + 1;</span><br><span class="line">                middle = min + (max - min) / 2;</span><br><span class="line">            &#125; else if (array[middle] &gt; target) &#123;</span><br><span class="line">                max = middle - 1;</span><br><span class="line">                middle = min + (max - min) / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="字符串转换为整数"><a href="#字符串转换为整数" class="headerlink" title="字符串转换为整数"></a>字符串转换为整数</h2><p>“   -42” 变为-42.<br>“4193 with words” 变为4193。<br>遇到非数字的字符串就停止，如果超过int表示范围了就返回正负的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int myAtoi(String s) &#123;</span><br><span class="line">        // 去掉头尾空白符，中间的不去</span><br><span class="line">        char[] c = s.trim().toCharArray();</span><br><span class="line">        if (c.length == 0) return 0;</span><br><span class="line">        int res = 0, bndry = Integer.MAX_VALUE / 10; //最大是2147483647</span><br><span class="line">        int i = 1, sign = 1;</span><br><span class="line">        if (c[0] == &#x27;-&#x27;) sign = -1;</span><br><span class="line">        else if (c[0] != &#x27;+&#x27;) i = 0; //从0开始</span><br><span class="line">        for (int j = i; j &lt; c.length; j++) &#123;</span><br><span class="line">            if (c[j] &lt; &#x27;0&#x27; || c[j] &gt; &#x27;9&#x27;) break;</span><br><span class="line">            if (res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; &#x27;7&#x27;) &#123;</span><br><span class="line">                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * 10 + (c[j] - &#x27;0&#x27;); //字符变数字</span><br><span class="line">        &#125;</span><br><span class="line">        return sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="到最近的人的最大距离"><a href="#到最近的人的最大距离" class="headerlink" title="到最近的人的最大距离"></a>到最近的人的最大距离</h2><p>给你一个数组 seats 表示一排座位，其中 seats[i] = 1 代表有人坐在第 i 个座位上，seats[i] = 0 代表座位 i 上是空的（下标从 0 开始）。</p>
<p>找一个距离两边人最近的一个位置，找坑位。返回他到离他最近的人的最大距离。</p>
<p>双指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistToClosest(int[] seats) &#123;</span><br><span class="line">        //双指针：左右指针为相邻的有人座位，则最大距离是r-l/2</span><br><span class="line">        //但是要考虑两边没座位的情况</span><br><span class="line">        int res = 0;</span><br><span class="line">        int l = 0;</span><br><span class="line">        while(seats[l] == 0) &#123;</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, l);</span><br><span class="line">        while(l &lt; seats.length - 1) &#123;</span><br><span class="line">            int r = l + 1;</span><br><span class="line">            while(r &lt; seats.length &amp;&amp; seats[r] == 0) &#123;</span><br><span class="line">                r ++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (r == seats.length) &#123;</span><br><span class="line">                res = Math.max(res, r - l - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res = Math.max(res, (r - l)/2);</span><br><span class="line">            &#125;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><p>1.变成String之后反转比较是否跟之前的数相等，但是要注意Integer溢出。<br>2.变成String之后，双指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPalindrome(int x) &#123;</span><br><span class="line">        if (x &lt; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        long y = Long.valueOf(new StringBuilder(new Long(x).toString()).reverse().toString());</span><br><span class="line">        return x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        // 双指针：一个最前一个最后，谁小就移动谁</span><br><span class="line">        int l = 0, r = height.length-1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        while(l &lt; r) &#123;</span><br><span class="line">            // 选择小的移动</span><br><span class="line">            if (height[l] &lt; height[r]) &#123;</span><br><span class="line">                max = Math.max(max, (r - l) * height[l]);</span><br><span class="line">                l ++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                max = Math.max(max, (r - l) * height[r]);</span><br><span class="line">                r --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>1.5.10.50…有特定的符号，但是4.9.40.90…也比较特殊，所以把它们也作为特定的符号。从大到小遍历。不会出现80变为两个40的情况，因为之前一定会先拆出一个50.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int[] values = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">    String[] symbols = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    public String intToRoman(int num) &#123;</span><br><span class="line">        StringBuffer roman = new StringBuffer();</span><br><span class="line">        for (int i = 0; i &lt; values.length; ++i) &#123;</span><br><span class="line">            int value = values[i];</span><br><span class="line">            String symbol = symbols[i];</span><br><span class="line">            while (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman.append(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            if (num == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p>给两个递增的数组，其中nums1后面的nums2的长度是有的，填充的0.将nums2填充到nums1中，并且是排好序的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        //用双指针进行替换，如果是第二个队列的元素大，就替换</span><br><span class="line">        //替换出来的第一个队列的元素放在哪，放哪都不行，所以从后往前移动</span><br><span class="line">        // 方法一：先合并，直接Arrays.sort(nums1)</span><br><span class="line">        // 方法二：开一个新数组，从前往后双指针</span><br><span class="line">        // 方法三：不用重开，直接从后往前双指针</span><br><span class="line">        int tail = m + n - 1;</span><br><span class="line">        int p1 = m - 1;</span><br><span class="line">        int p2 = n - 1;</span><br><span class="line">        while(p1 &gt;= 0 || p2 &gt;= 0) &#123;</span><br><span class="line">            if (p1 &lt; 0) &#123;</span><br><span class="line">                nums1[tail] = nums2[p2--];</span><br><span class="line">            &#125; else if (p2 &lt; 0) &#123;</span><br><span class="line">                nums1[tail] = nums1[p1--];</span><br><span class="line">            &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                nums1[tail] = nums1[p1--];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums1[tail] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不能使用额外的空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        //双指针，一前一后，前面的不是val，就往后走，如果是就替换，并前后都移动，其实不用替换</span><br><span class="line">        int l = 0;</span><br><span class="line">        int r = nums.length - 1;</span><br><span class="line">        while(l &lt;= r) &#123;</span><br><span class="line">            if (l == r) &#123;</span><br><span class="line">                if (nums[l] != val) l ++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[l] == val &amp;&amp; nums[r] != val) &#123;</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">                l ++;</span><br><span class="line">                r --;</span><br><span class="line">            &#125; else if (nums[l] == val &amp;&amp; nums[r] == val) &#123;</span><br><span class="line">                r --;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                l ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h2><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。nums 的其余元素与 nums 的大小不重要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        //双指针，移除重复的元素其实就是把不重复的元素移到最前面</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = 1;</span><br><span class="line">        while(j &lt; nums.length) &#123;</span><br><span class="line">            if (nums[i] == nums[j]) &#123;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除有序数组中的重复项-II"><a href="#删除有序数组中的重复项-II" class="headerlink" title="删除有序数组中的重复项 II"></a>删除有序数组中的重复项 II</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p>
<p>和上面的相比，多了保留两个重复的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        // 同样是相当于将元素向前移动，无非是加个标识位表示第一个</span><br><span class="line">        int i = 0, j = 1;</span><br><span class="line">        boolean isFirst = true;</span><br><span class="line">        while (j &lt; nums.length) &#123;</span><br><span class="line">            if (nums[i] == nums[j]) &#123;</span><br><span class="line">                if (isFirst) &#123;</span><br><span class="line">                    i ++;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    isFirst = false;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                j ++;</span><br><span class="line">                isFirst = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h2><p>摩尔投票法：<br>候选人(cand_num)初始化为 nums[0]，票数 count 初始化为 1。<br>当遇到与 cand_num 相同的数，则票数 count = count + 1，否则票数 count = count - 1。当票数 count 为 0 时，更换候选人，并将票数 count 重置为 1。遍历完数组后，cand_num 即为最终答案。</p>
<p>投票法是遇到相同的则 票数 + 1，遇到不同的则 票数 - 1。<br>且“多数元素”的个数 &gt; ⌊ n/2 ⌋，其余元素的个数总和 &lt;= ⌊ n/2 ⌋。<br>因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 &gt;= 1。<br>这就相当于每个 “多数元素” 和其他元素 两两相互抵消，抵消到最后肯定还剩余 至少1个 “多数元素”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int majorityElement(int[] nums) &#123;</span><br><span class="line">        // 排序之后的nums.length/2元素一定是多数元素</span><br><span class="line">        // 摩尔投票法：先选一个，往后遍历，如果不一样就减一，直到0就换</span><br><span class="line">        int res = nums[0];</span><br><span class="line">        int score = 1;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            if (num == res) score ++;</span><br><span class="line">            else if (--score == 0) &#123;</span><br><span class="line">                res = num;</span><br><span class="line">                score = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h2><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。<br>使用空间复杂度为 O(1) 的 原地 算法解决这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[] nums, int k) &#123;</span><br><span class="line">        // 使用额外的数组很简单，问题是怎么用O1的空间</span><br><span class="line">        // 被替换的元素保存在变量temp中，从而避免了额外数组的开销</span><br><span class="line">        // 怎么遍历？跳跃式替换，回到原点时应该从下一个元素开始跳跃</span><br><span class="line">        // 什么时候结束？用一个元素记录遍历了多少次</span><br><span class="line">        if (k == 0 || nums.length &lt; 2) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = 0;</span><br><span class="line">        int index = 0;</span><br><span class="line">        int temp = nums[index];</span><br><span class="line">        int pre;</span><br><span class="line">        int start = 0;</span><br><span class="line">        while (count &lt; nums.length) &#123;</span><br><span class="line">            index = (index + k) % nums.length;</span><br><span class="line">            pre = nums[index];</span><br><span class="line">            nums[index] = temp;</span><br><span class="line">            temp = pre;</span><br><span class="line">            count ++;</span><br><span class="line">            if (count &lt; nums.length &amp;&amp; index == start) &#123;</span><br><span class="line">                index = start + 1;</span><br><span class="line">                start = index;</span><br><span class="line">                temp = nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        // 一次遍历便可得到，每次遍历得到之前最小的数，以及目前为止最大利润</span><br><span class="line">        int cost = Integer.MAX_VALUE, profile = 0;</span><br><span class="line">        for (int price : prices) &#123;</span><br><span class="line">            profile = Math.max(price - cost, profile);</span><br><span class="line">            cost = Math.min(cost, price);</span><br><span class="line">        &#125;</span><br><span class="line">        return profile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用动态规划：</p>
<p>状态定义：dp[i][j]：下标为 i 这一天结束的时候，手上持股状态为 j 时，我们持有的现金数。换种说法：dp[i][j] 表示天数 [0, i] 区间里，下标 i 这一天状态为 j 的时候能够获得的最大利润。</p>
<p>推导状态转移方程：<br>dp[i][0]：规定了今天不持股，有以下两种情况：<br>昨天不持股，今天什么都不做；<br>昨天持股，今天卖出股票（现金数增加）</p>
<p>dp[i][1]：规定了今天持股，有以下两种情况：<br>昨天持股，今天什么都不做（现金数与昨天一样）；<br>昨天不持股，今天买入股票（注意：只允许交易一次，因此手上的现金数就是当天的股价的相反数）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        // 特殊判断</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] dp = new int[len][2];</span><br><span class="line"></span><br><span class="line">        // dp[i][0] 下标为 i 这天结束的时候，不持股，手上拥有的现金数</span><br><span class="line">        // dp[i][1] 下标为 i 这天结束的时候，持股，手上拥有的现金数</span><br><span class="line"></span><br><span class="line">        // 初始化：不持股显然为 0，持股就需要减去第 1 天（下标为 0）的股价</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line">        dp[0][1] = -prices[0];</span><br><span class="line"></span><br><span class="line">        // 从第 2 天开始遍历</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</span><br><span class="line">            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len - 1][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机2"><a href="#买卖股票的最佳时机2" class="headerlink" title="买卖股票的最佳时机2"></a>买卖股票的最佳时机2</h2><p>与第一题只能进行一次交易不同，这里可以进行多次交易。</p>
<p>方法一：在每一天都有操作/不操作（买入还是卖出）的选择。所以用树形结构进行回溯搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private int res;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        this.res = 0;</span><br><span class="line">        dfs(prices, 0, len, 0, res);</span><br><span class="line">        return this.res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param prices 股价数组</span><br><span class="line">     * @param index  当前是第几天，从 0 开始</span><br><span class="line">     * @param status 0 表示不持有股票，1表示持有股票，</span><br><span class="line">     * @param profit 当前收益</span><br><span class="line">     */</span><br><span class="line">    private void dfs(int[] prices, int index, int len, int status, int profit) &#123;</span><br><span class="line"></span><br><span class="line">        if (index == len) &#123;</span><br><span class="line">            this.res = Math.max(this.res, profit);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(prices, index + 1, len, status, profit);</span><br><span class="line"></span><br><span class="line">        if (status == 0) &#123;</span><br><span class="line">            // 可以尝试转向 1</span><br><span class="line">            dfs(prices, index + 1, len, 1, profit - prices[index]);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 此时 status == 1，可以尝试转向 0</span><br><span class="line">            dfs(prices, index + 1, len, 0, profit + prices[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：动态规划，与上一题在状态转移的时候会有所不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        // 特殊判断</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] dp = new int[len][2];</span><br><span class="line"></span><br><span class="line">        // dp[i][0] 下标为 i 这天结束的时候，不持股，手上拥有的现金数</span><br><span class="line">        // dp[i][1] 下标为 i 这天结束的时候，持股，手上拥有的现金数</span><br><span class="line"></span><br><span class="line">        // 初始化：不持股显然为 0，持股就需要减去第 1 天（下标为 0）的股价</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line">        dp[0][1] = -prices[0];</span><br><span class="line"></span><br><span class="line">        // 从第 2 天开始遍历</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</span><br><span class="line">            // 这里持股，并不是这天持股的收益，与只买卖一次就这里的差别</span><br><span class="line">            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len - 1][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于当前行只参考上一行，每一行就 2 个值，因此可以考虑使用「滚动变量」</p>
<p>方法三：贪心算法</p>
<p>求解最优化问题的算法通常需要经过一系列的步骤，在每个步骤都面临生种选择。对于许多最优化问题，使用动态规划算法来求最优解有些杀鸡用牛力了，可以使用更简单、更高效的算法。贪心算法(greedy algorithm)就是这样的算法，它在每一步都做出当时看起来最佳的选择。也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。</p>
<p>贪心算法和动态规划相比，它既不看前面（也就是说它不需要从前面的状态转移过来），也不看后面（无后效性，后面的选择不会对前面的选择有影响），因此贪心算法时间复杂度一般是线性的，空间复杂度是常数级别的。</p>
<p>这道题 「贪心」 的地方在于，对于 「今天的股价 - 昨天的股价」，得到的结果有 3 种可能：① 正数，② 0，③负数。贪心算法的决策是： 只加正数 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            res += Math.max(prices[i] - prices[i - 1], 0);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机3"><a href="#买卖股票的最佳时机3" class="headerlink" title="买卖股票的最佳时机3"></a>买卖股票的最佳时机3</h2><p>与上面不同，这里只允许最多完成两笔交易，并且必须在再次购买前出售掉之前的股票。</p>
<p>结合上面两道题，第一题是交易一次就不交易，第二题是还可以交易。这里设定三维数组，增加一维表示交易次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第 2 维的 0 没有意义，1 表示交易进行了 1 次，2 表示交易进行了 2 次</span><br><span class="line">        // 为了使得第 2 维的数值 1 和 2 有意义，这里将第 2 维的长度设置为 3</span><br><span class="line">        int[][][] dp = new int[len][3][2];</span><br><span class="line"></span><br><span class="line">        // 理解如下初始化</span><br><span class="line">        // 第 3 维规定了必须持股，因此是 -prices[0]</span><br><span class="line">        dp[0][1][1] = -prices[0];</span><br><span class="line">        // 还没发生的交易，持股的时候应该初始化为负无穷</span><br><span class="line">        dp[0][2][1] = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            // 转移顺序先持股，再卖出</span><br><span class="line">            dp[i][1][1] = Math.max(dp[i - 1][1][1], -prices[i]) ;</span><br><span class="line">            dp[i][1][0] = Math.max(dp[i - 1][1][0], dp[i - 1][1][1] + prices[i]);</span><br><span class="line">            dp[i][2][1] = Math.max(dp[i - 1][2][1], dp[i - 1][1][0] - prices[i]);</span><br><span class="line">            dp[i][2][0] = Math.max(dp[i - 1][2][0], dp[i - 1][2][1] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[len - 1][1][0], dp[len - 1][2][0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机4"><a href="#买卖股票的最佳时机4" class="headerlink" title="买卖股票的最佳时机4"></a>买卖股票的最佳时机4</h2><p>最多可以完成 k 笔交易。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">         int len = prices.length;</span><br><span class="line">        if (k &gt;= len / 2) &#123;</span><br><span class="line">            int res = 0;</span><br><span class="line">            for (int i = 1; i &lt; len; i ++) &#123;</span><br><span class="line">                res += Math.max(0, prices[i] - prices[i - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dpHold = new int[k + 1];</span><br><span class="line">        int[] dpNoHold = new int[k + 1];</span><br><span class="line">        for (int i = 0; i &lt;= k; i++) &#123;</span><br><span class="line">            dpHold[i] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int price : prices) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= k; j++) &#123;</span><br><span class="line">                // 持有 = max(前一天持有，前一天不持有今天持有)</span><br><span class="line">                // 持有表示交易次数+1，需要考虑交易次数-1的情况</span><br><span class="line">                dpHold[j] = Math.max(dpHold[j], dpNoHold[j - 1] - price);</span><br><span class="line">                // 不持有 = max(前一天不持有， 今天卖掉)</span><br><span class="line">                // 不持有，卖掉，交易次数还是原来的</span><br><span class="line">                dpNoHold[j] = Math.max(dpNoHold[j], dpHold[j] + price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dpNoHold[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="买卖股票含冷冻期"><a href="#买卖股票含冷冻期" class="headerlink" title="买卖股票含冷冻期"></a>买卖股票含冷冻期</h2><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        // 一维表示天，二维表示 不持有、持有、冷冻</span><br><span class="line">        int[][] dp = new int[len + 1][3];</span><br><span class="line">        for (int i = 0; i &lt;= len; i++) &#123;</span><br><span class="line">            dp[i][1] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= len; i++) &#123;</span><br><span class="line">            // 不持有：前一天不持有/前一天持有今天卖掉</span><br><span class="line">            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i-1]);</span><br><span class="line">            // 持有：前一天持有/前一天冷冻今天持有</span><br><span class="line">            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][2] - prices[i-1]);</span><br><span class="line">            // 冷冻：前一天不持有/前一天冷冻</span><br><span class="line">            dp[i][2] = Math.max(dp[i-1][2], dp[i-1][0]);</span><br><span class="line">            System.out.println(dp[i][0] + &quot;==&quot; + dp[i][1] + &quot;==&quot; + dp[i][2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[len][0], dp[len][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票含手续费"><a href="#买卖股票含手续费" class="headerlink" title="买卖股票含手续费"></a>买卖股票含手续费</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices, int fee) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        int[][] dp = new int[len+1][2];</span><br><span class="line">        for (int i = 0; i&lt;=len; i++) &#123;</span><br><span class="line">            dp[i][1] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= len; i++) &#123;</span><br><span class="line">            // 不持有</span><br><span class="line">            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i-1]);</span><br><span class="line">            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i-1] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p>
<p>解法：从前往后遍历，在当前点时，可以知道当前点最远可以到达哪里，在遍历下一个的时候，对比能不能达到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canJump(int[] nums) &#123;</span><br><span class="line">        int reach = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (i &gt; reach) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            reach = Math.max(reach, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏2"><a href="#跳跃游戏2" class="headerlink" title="跳跃游戏2"></a>跳跃游戏2</h2><p>给一个数组，表示在该位置上的最大跳跃长度。现在要给出最少跳跃步数。</p>
<p>标签：贪心、动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 方法1：动态规划，正向遍历到达每一个位置需要的最少步数，时间复杂度On2</span><br><span class="line">    public static int jump(int[] nums) &#123;</span><br><span class="line">        int[] res = new int[nums.length];</span><br><span class="line">        for (int i = 1; i&lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt;= i + nums[i] &amp;&amp; j &lt; nums.length; j++) &#123;</span><br><span class="line">                res[j] = Math.min(res[i] + 1, res[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[res.length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 方法2：贪心，反向查找出发位置，具体哪个位置跳最好需要从前往后遍历</span><br><span class="line">    // ps：因为不是固定步数跳，所以可行</span><br><span class="line">    public static int jump(int[] nums) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int pos = len - 1;</span><br><span class="line">        int step = 0;</span><br><span class="line">        while (pos &gt; 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                if (i + nums[i] &gt;= pos) &#123;</span><br><span class="line">                    step += 1;</span><br><span class="line">                    pos = i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 方法3：贪心地正向查找，每次可到达的最远位置</span><br><span class="line">    public static int jump(int[] nums) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int end = 0; //边界</span><br><span class="line">        int maxPos = 0; //能到达的最远位置</span><br><span class="line">        int step = 0;</span><br><span class="line">        // 注意：遍历到最后元素的前一个就好</span><br><span class="line">        for (int i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            maxPos = Math.max(maxPos, nums[i] + i);</span><br><span class="line">            // 到达边界了就需要走一步了，并且更新边界</span><br><span class="line">            if (i == end) &#123;</span><br><span class="line">                end = maxPos;</span><br><span class="line">                step ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="跳跃游戏3"><a href="#跳跃游戏3" class="headerlink" title="跳跃游戏3"></a>跳跃游戏3</h2><p>这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。判断自己是否能够跳到对应元素值为 0 的 任一 下标处。</p>
<p>标签：深度优先搜索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 跳跃游戏3：可以左右跳跃，只能跳跃固定值，从给定开始位置，能不能跳到元素值为0的地方</span><br><span class="line">    // 深度优先搜索：DFS，可以用递归实现，也可以用栈实现</span><br><span class="line">    // 比如二叉树，向下遍历直到叶子节点，然后向上回溯，再向下遍历。用栈就是出栈和入栈。</span><br><span class="line">    public static boolean canReach(int[] nums, int start) &#123;</span><br><span class="line">        // 用一个数组表示是否访问过</span><br><span class="line">        boolean[] visit = new boolean[nums.length];</span><br><span class="line">        return dfs(nums, start, visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean dfs(int[] nums, int start, boolean[] visit) &#123;</span><br><span class="line">        if (start &lt; 0 || start &gt;= nums.length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果之前访问过，一定到不了</span><br><span class="line">        if (visit[start]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 出递归条件</span><br><span class="line">        if (nums[start] == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[start] = true;</span><br><span class="line">        return dfs(nums, start - nums[start], visit) || dfs(nums, start + nums[start], visit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>这个题目要求打印出来。</p>
<p>标签：深度优先搜索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = new ArrayList();</span><br><span class="line">        int[] place = new int[n];</span><br><span class="line">        List&lt;int[]&gt; resList = new ArrayList();</span><br><span class="line">        int resNum = queueDfs(0, place, n, res);</span><br><span class="line">        for (int[] resPlace : resList) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(resPlace));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; print(int[] place) &#123;</span><br><span class="line">        List&lt;String&gt; ss = new ArrayList();</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int j = 0; j &lt; place.length; j++) &#123;</span><br><span class="line">            sb.append(&#x27;.&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int column : place) &#123;</span><br><span class="line">            // 这里也得新建一个</span><br><span class="line">            StringBuilder pre = new StringBuilder(sb);</span><br><span class="line">            pre.setCharAt(column, &#x27;Q&#x27;);</span><br><span class="line">            ss.add(pre.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // row代表第row行皇后的放置</span><br><span class="line">    private int queueDfs(int row, int[] place, int n, List&lt;List&lt;String&gt;&gt; resList) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if (row == n) &#123;</span><br><span class="line">            // 注意这里加入的是数组的引用，之后会变</span><br><span class="line">            resList.add(print(place));</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第row行可以放到第0到n-1列</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            if (isValid(row, place, i)) &#123;</span><br><span class="line">                place[row] = i;</span><br><span class="line">                res += queueDfs(row + 1, place, n, resList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查第row行皇后放在column列有没有问题</span><br><span class="line">    private static boolean isValid(int row, int[] place, int column) &#123;</span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            if (place[i] == column || row - i == Math.abs(column - place[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(row + &quot;:&quot; + column + &quot;:&quot; + Arrays.toString(place));</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还有一种构建”…Q”字符串的方法，更优雅，用char数组创建String：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char[] row = new char[n];</span><br><span class="line">Arrays.fill(row, &#x27;.&#x27;);</span><br><span class="line">row[queens[i]] = &#x27;Q&#x27;;</span><br><span class="line">board.add(new String(row));</span><br></pre></td></tr></table></figure>

<h2 id="N皇后2"><a href="#N皇后2" class="headerlink" title="N皇后2"></a>N皇后2</h2><p>这个N皇后之需要给出有几种解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public static int totalNQueens(int n) &#123;</span><br><span class="line">        // 皇后问题，在于DFS，表现形式：int[] 表示每列上皇后的位置</span><br><span class="line">        int[] place = new int[n];</span><br><span class="line">        return queueDfs(0, place, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // column代表第row列的放置</span><br><span class="line">    private static int queueDfs(int column, int[] place, int n) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if (column == n) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第row列可以放到第0到n-1行</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            if (isValid(column, place, i)) &#123;</span><br><span class="line">                place[column] = i;</span><br><span class="line">                res += queueDfs(column + 1, place, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查第column列皇后放在row行有没有问题</span><br><span class="line">    private static boolean isValid(int column, int[] place, int row) &#123;</span><br><span class="line">        for (int i = 0; i &lt; column; i++) &#123;</span><br><span class="line">            if (place[i] == row || column - i == Math.abs(row - place[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
<p>标签：DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class BracketAlgo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(generateBracket(3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 给出一个n，返回可能的括号组合</span><br><span class="line">    public static List&lt;String&gt; generateBracket(int n) &#123;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList();</span><br><span class="line">        String s = &quot;&quot;;</span><br><span class="line">        dfs(n, n, s, res);</span><br><span class="line">        return  res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 入参：剩余左括号数、剩余右括号数、当前String、结果</span><br><span class="line">    private static void dfs(int left, int right, String curStr, List&lt;String&gt; res) &#123;</span><br><span class="line">        // 出递归条件</span><br><span class="line">        if (left == 0 &amp;&amp; right == 0) &#123;</span><br><span class="line">            res.add(curStr);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 左括号还有就可以继续放左括号，剩余右括号大于剩余左括号，就可以放右括号</span><br><span class="line">        // 这里没有感觉有回溯呢，就感觉不需要回溯</span><br><span class="line">        if (left &gt; 0) &#123;</span><br><span class="line">            dfs(left - 1, right, curStr + &quot;(&quot;, res);</span><br><span class="line">        &#125;</span><br><span class="line">        if (right &gt; left) &#123;</span><br><span class="line">            dfs(left, right - 1, curStr + &quot;)&quot;, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
<p>标签：DFS、并查集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan.lee;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class IslandAlgo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char[][] lands = new char[][]&#123;&#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;&#125;;</span><br><span class="line">        System.out.println(islandNum(lands));</span><br><span class="line">        lands = new char[][]&#123;&#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;&#125;;</span><br><span class="line">        System.out.println(islandNum2(lands));</span><br><span class="line">        lands = new char[][]&#123;&#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;&#125;;</span><br><span class="line">        System.out.println(islandNum3(lands));</span><br><span class="line">        lands = new char[][]&#123;&#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;&#125;;</span><br><span class="line">        System.out.println(maxIsland(lands));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1表示陆地，0表示水，四周也是水，斜线相接的不是一座岛屿，返回总共有几个岛屿</span><br><span class="line">    // 方法一：DFS解法：</span><br><span class="line">    //遍历整个二维网格，当遇到一个岛屿（值为1）时，计数器加1，然后调用DFS函数，将相邻的岛屿都标记为已遍历（可以将其值置为0）。</span><br><span class="line">    //在DFS函数中，首先判断当前位置是否越界或者已经遍历过，如果是，直接返回。</span><br><span class="line">    //如果当前位置是岛屿，则将其值置为0，并递归调用DFS函数，分别向上、向下、向左、向右四个方向进行搜索。</span><br><span class="line">    //最后，返回计数器的值即为岛屿的数量。</span><br><span class="line">    public static int islandNum(char[][] lands) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; lands.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; lands[0].length; j++) &#123;</span><br><span class="line">                // 有一块陆地就表示一定是一个岛屿，只需要把周围的都变成水</span><br><span class="line">                // 递归的目的是将周围的陆地变为水，并且是在遍历下一块儿地之前</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    dfs(i, j, lands);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void dfs(int i, int j, char[][] lands) &#123;</span><br><span class="line">        // 越界则出递归</span><br><span class="line">        if (i &lt; 0 || i &gt;= lands.length || j &lt; 0 || j &gt;= lands[0].length) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 是水则出递归</span><br><span class="line">        if (lands[i][j] == &#x27;0&#x27;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 这里将陆地变为水，所以下面即使递归回到该位置也直接return了</span><br><span class="line">        lands[i][j] = &#x27;0&#x27;;</span><br><span class="line">        dfs(i - 1, j, lands);</span><br><span class="line">        dfs(i + 1, j, lands);</span><br><span class="line">        dfs(i, j - 1, lands);</span><br><span class="line">        dfs(i, j + 1, lands);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有点问题：不一定都是往左上角靠拢的，比如工字型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public static int numIslands(char[][] lands) &#123;</span><br><span class="line">        // 1.首先初始化，用一个数组表示每个节点的根结点</span><br><span class="line">        int n = lands.length;</span><br><span class="line">        int m = lands[0].length;</span><br><span class="line">        int[] roots = new int[n * m];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    roots[i * m + j] = i * m + j;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.合并，往四个方向走，如果也是1的话就合并节点（将当前节点的根结点变为相邻节点的根结点），在合并的过程中就完成计数</span><br><span class="line">        int[][] directs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j ++) &#123;</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    for (int[] direct : directs) &#123;</span><br><span class="line">                        // 如果相邻也是1，且根结点不相同则进行合并：将相邻节点的根节点变为当前节点的根结点，这样向下向右遍历的时候，就不会再变原来的根结点了</span><br><span class="line">                        // 正常合并需要考虑节点深度，如果两个集合的深度不同，为了保持并查集的平衡性，应该将深度较小的集合合并到深度较大的集合上</span><br><span class="line">                        // 但是这里由于遍历的有序性，所以先遍历的深度大</span><br><span class="line">                        int newRow = i + direct[0];</span><br><span class="line">                        int newColumn = j + direct[1];</span><br><span class="line">                        if (newRow &lt; 0 || newRow &gt;= n || newColumn &lt; 0 || newColumn &gt;= m) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 这里还是由于遍历的有序性，找root，根结点一定是左上角的1</span><br><span class="line">                        if (lands[newRow][newColumn] == &#x27;1&#x27; &amp;&amp; roots[i * m + j] != roots[newRow * m + newColumn]) &#123;</span><br><span class="line">                            roots[newRow * m + newColumn] = roots[i * m + j];</span><br><span class="line">                            res --;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有点问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 并查集-规范完整版</span><br><span class="line">    public static int numIslands(char[][] lands) &#123;</span><br><span class="line">        // 1.首先初始化，用一个数组表示每个节点的根结点</span><br><span class="line">        int n = lands.length;</span><br><span class="line">        int m = lands[0].length;</span><br><span class="line">        // 记录节点的根结点</span><br><span class="line">        int[] roots = new int[n * m];</span><br><span class="line">        // 记录节点深度</span><br><span class="line">        int[] ranks = new int[n * m];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    roots[i * m + j] = i * m + j;</span><br><span class="line">                    ranks[i * m + j] = 0;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.合并，往四个方向走，如果也是1的话就合并节点（将当前节点的根结点变为相邻节点的根结点），在合并的过程中就完成计数</span><br><span class="line">        int[][] directs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j ++) &#123;</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    for (int[] direct : directs) &#123;</span><br><span class="line">                        int newRow = i + direct[0];</span><br><span class="line">                        int newColumn = j + direct[1];</span><br><span class="line">                        if (newRow &lt; 0 || newRow &gt;= n || newColumn &lt; 0 || newColumn &gt;= m) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        int curRoot = find(roots, i * n + j);</span><br><span class="line">                        int newRoot = find(roots, newRow * m + newColumn);</span><br><span class="line">                        if (lands[newRow][newColumn] == &#x27;1&#x27; &amp;&amp; curRoot != newRoot) &#123;</span><br><span class="line">                            // 深度小的往深度大的合并，除非相邻节点深度大才当前节点合并到相邻节点，这个里面不存在</span><br><span class="line">                            // 将rank较小的根节点指向rank较大的根节点，以保持树的平衡。如果两个根节点的rank相同，则可以将其中一个根节点作为另一个根节点的子节点，并将rank增加1。</span><br><span class="line">                            if (ranks[i * m + j] &lt; ranks[newRow * m + newColumn]) &#123;</span><br><span class="line">                                // 验证不存在此情况</span><br><span class="line">                                System.out.println(&quot;相邻节点深度更大&quot;);</span><br><span class="line">                                roots[i * n + j] = roots[newRow * n + newColumn];</span><br><span class="line">                            &#125; else if (ranks[i * m + j] &gt; ranks[newRow * m + newColumn])&#123;</span><br><span class="line">                                roots[newRow * m + newColumn] = roots[i * m + j];</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                roots[newRow * m + newColumn] = roots[i * m + j];</span><br><span class="line">                                ranks[i * m + j] ++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            res --;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((Arrays.toString(ranks)));</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int find(int[] roots, int k) &#123;</span><br><span class="line">        if (roots[k] == k) &#123;</span><br><span class="line">            return k;</span><br><span class="line">        &#125;</span><br><span class="line">        return find(roots, roots[k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 岛屿的最大面积</span><br><span class="line">    // ps：将area作为参数传递时，int不行、Integer也不行、返回出去需要在连续四个dfs上加上返回再传入下一个</span><br><span class="line">    // 用一个全局变量表示area比较好</span><br><span class="line">    public static int maxAreaOfIsland(int[][] lands) &#123;</span><br><span class="line">        // 和获取数量一样，递归，但是同时记录岛屿最大面积</span><br><span class="line">        int maxArea = 0;</span><br><span class="line">        for (int i = 0; i &lt; lands.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; lands[0].length; j++) &#123;</span><br><span class="line">                if (lands[i][j] == 1) &#123;</span><br><span class="line">                    int area = dfs(lands, i , j, 0);</span><br><span class="line">                    maxArea = Math.max(area, maxArea);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int dfs(int[][] lands, int i, int j, int area) &#123;</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;= lands.length || j &gt;= lands[0].length) &#123;</span><br><span class="line">            return area;</span><br><span class="line">        &#125;</span><br><span class="line">        if (lands[i][j] == 0) &#123;</span><br><span class="line">            return area;</span><br><span class="line">        &#125;</span><br><span class="line">        lands[i][j] = 0;</span><br><span class="line">        area += 1;</span><br><span class="line">        area = dfs(lands, i - 1, j, area);</span><br><span class="line">        area = dfs(lands, i + 1, j, area);</span><br><span class="line">        area = dfs(lands, i, j - 1, area);</span><br><span class="line">        area = dfs(lands, i, j + 1, area);</span><br><span class="line">        return area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h3><p>有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p>
<p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p>输入：nums = [1,5]<br>输出：10</p>
<p>标签：深度优先搜索、动态规划</p>
<p>超出时间限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 戳气球：一组数代表气球的值，戳一个气球收益是左气球*自己*右气球，戳破后左右两个变为相邻的，求最大收益</span><br><span class="line">    // 方法一：深度优先搜索，到最后一个气球时记录收益记录下来，最后对比最大值</span><br><span class="line">    public static int maxCoins(int[] nums) &#123;</span><br><span class="line">        // 注意：List是一个对象类型的集合，需要用Integer</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return dfs(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int dfs(List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (list.size() == 0) return 0;</span><br><span class="line">        // 在哪里取最大值：在这里取，因为这里就是最终的最大值</span><br><span class="line">        int max = 0;</span><br><span class="line">        int left, cur, right;</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            left = i == 0 ? 1 : list.get(i - 1);</span><br><span class="line">            right = i == list.size() - 1 ? 1 : list.get(i + 1);</span><br><span class="line">            cur = list.get(i);</span><br><span class="line">            // 这里会报warning：再循环中修改List，可以使用一个临时List，每次传入临时List</span><br><span class="line">            list.remove(i);</span><br><span class="line">            max = Math.max(left * cur * right + dfs(list), max);</span><br><span class="line">            list.add(i, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个不对的DFS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 方法二：另一个深度优先搜索，上一个是先戳破再递归计算剩下的，这里可以先拆开计算左右的再加起来</span><br><span class="line">    // 这样的好处是：List没有被破坏，只需给个边界</span><br><span class="line">    // !!! 这个方法不对，忽略了气球戳破后两边气球就变成相邻气球的事实</span><br><span class="line">    private static int maxProfit2(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return dfs2(list, 0, nums.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int dfs2(List&lt;Integer&gt; list, int left, int right) &#123;</span><br><span class="line">        if (left == right) return 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        int l, r, cur;</span><br><span class="line">        for (int i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            l = i == 0 ? 1 : list.get(i - 1);</span><br><span class="line">            r = i == list.size() - 1 ? 1 : list.get(i + 1);</span><br><span class="line">            cur = list.get(i);</span><br><span class="line">            int profit = l * cur * r + dfs2(list, left, i - 1) + dfs2(list, i + 1, right);</span><br><span class="line">            max = Math.max(max, profit);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正确的动态规划：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 方法三：动态规划</span><br><span class="line">    // 1.定义数据 2.初始化 3.状态转移</span><br><span class="line">    // 两边各加一个辅助气球，是1，用k表示最后戳破的气球</span><br><span class="line">    // dp[i][j]表示戳破i-j区间内气球获得的收益，两边是包含辅助气球的，辅助气球不戳破</span><br><span class="line">    // 因此：状态转移：dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + list[k] * list[i] * [j])</span><br><span class="line">    // 注意：k是最后戳破的，所以乘以最两边的辅助气球</span><br><span class="line">    // 辅助气球不戳破，所以这样拆分之后k是辅助气球，为两边算收益用，但本身不被戳破</span><br><span class="line">    // Max的过程是在选最后戳破哪个气球的过程中选择的</span><br><span class="line">    // 因为该状态方程，所以长度短的应该先算好，所以最外层循环为长度</span><br><span class="line">    public static int maxCoins(int[] nums) &#123;</span><br><span class="line">        // 定义数据</span><br><span class="line">        int len =nums.length + 2;</span><br><span class="line">        int[][] dp = new int[len][len];</span><br><span class="line">        int[] arr = new int[len];</span><br><span class="line">        arr[0] = 1;</span><br><span class="line">        arr[len - 1] = 1;</span><br><span class="line">        System.arraycopy(nums, 0, arr, 1, len - 2);</span><br><span class="line">        // 初始化，因为在状态转移过程中会取值，所以为0就好</span><br><span class="line">        // 一层循环为长度，最小长度为3，两边是辅助气球</span><br><span class="line">        for (int l = 3; l &lt;= len; l ++) &#123;</span><br><span class="line">            // 二层循环为开始位置</span><br><span class="line">            for (int i = 0; i &lt;= len - l; i ++) &#123;</span><br><span class="line">                // 结束位置</span><br><span class="line">                int j = i + l - 1;</span><br><span class="line">                // 最后戳破气球的位置k</span><br><span class="line">                for (int k = i + 1; k &lt; j; k ++) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], arr[i] * arr[k] * arr[j] + dp[i][k] + dp[k][j]);</span><br><span class="line">                    // 为什么不能正向先戳破k？</span><br><span class="line">                    // 因为戳破之后k就不存在了，所以不能在算两边时加k而是加k左右两边的，是一个k断开的状态</span><br><span class="line">                    // 最后戳破k就可以用k算两边，因为算完两边最后才戳破k</span><br><span class="line">//                    dp[i][j] = Math.max(dp[i][j], arr[k] * arr[k - 1] * arr[k + 1] + dp[i][k] + dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][len - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/mysql%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/mysql%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Mysql技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-25 16:25:11" itemprop="dateCreated datePublished" datetime="2022-09-25T16:25:11+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-04 15:12:40" itemprop="dateModified" datetime="2023-06-04T15:12:40+08:00">2023-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="mysql日期函数"><a href="#mysql日期函数" class="headerlink" title="mysql日期函数"></a>mysql日期函数</h2><p>✅datepart()</p>
<p>获取日期中的年月日<br>datepart(‘2022-11-11 12:12:12’, ‘yyyy’)<br>得到：2022，也可以是mm、dd</p>
<p>✅datetrunc()</p>
<p>获取日期的指定起始日期，比如一天的开始<br>datetrunc(‘2022-11-11 12:12:12’, ‘yyyy‘)<br>得到：2022-01-01 00:00:00</p>
<p>✅quarter()</p>
<p>获取日期的季度<br>quarter(‘2022-11-11 00:00:00’)<br>得到：4</p>
<p>✅subdate函数</p>
<p>MySQL中的SUBDATE()函数用于从给定日期减去某间隔时间。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SUBDATE(date, INTERVAL expr, unit)</span><br><span class="line"></span><br><span class="line">此函数接受以下三个参数：</span><br><span class="line">日期：第一个指定的日期。</span><br><span class="line">expr：要减去的时间/日期间隔的值。负的表示该时间之后</span><br><span class="line">单位：间隔的类型。MICROSECOND\SECOND\MINUTE\HOUR\DAY\WEEK\MONTH\QUARTER\YEAR</span><br></pre></td></tr></table></figure>

<p>例子：<br><code>select subdate(&quot;2020-11-25&quot;, INTERVAL 30 DAY)</code></p>
<p>今天的日期：<br><code>select curdate();  2022-10-30</code><br>现在的时间：<br><code>select curtime();   13:13:54</code></p>
<p>✅mysql计算时间差函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.timestampdiff(interval, datetime1,datetime2)</span><br><span class="line">返回（时间2-时间1）的时间差，结果单位由interval参数给出</span><br><span class="line">select timestampdiff(MINUTE,&#x27;2012-10-01&#x27;,&#x27;2013-01-13&#x27;); # 149760</span><br><span class="line">不是四舍五入时间差，而是直接取整数部分，1.9天算1天。</span><br><span class="line">如果前面加avg想求平均值，注意如果两个时间字段中有一个为null，则timestampdiff函数会返回null，而avg函数会忽略null值并计算剩余时间差的平均值（为null的那一行忽略）。</span><br><span class="line">为了避免这种情况，coalesce(timediff,0) 或者 ifnull(timediff, 0)</span><br><span class="line">但是要注意timestampdiff(second, &quot;2023-04-30 00:00:00&quot;, 0) 返回的将是很大的负数。</span><br><span class="line"></span><br><span class="line">2.天数差函数 datediff</span><br><span class="line">语法：传入两个日期参数，比较DAY天数，第一个参数减去第二个参数的天数值。</span><br><span class="line">select datediff(‘2013-01-13’,‘2012-10-01’); # 104</span><br><span class="line"></span><br><span class="line">3.时间差函数：timediff</span><br><span class="line">语法：timediff(time1,time2)</span><br><span class="line">结果：返回两个时间相减得到的差值，time1-time2，如果其中一个是null，返回也是null。</span><br><span class="line">select timediff(‘2018-05-21 14:51:43’,‘2018-05-19 12:54:43’);</span><br><span class="line"></span><br><span class="line">4.其他求时间的函数</span><br><span class="line">select now(); //2022-11-26 16:18:45</span><br><span class="line">select curdate(); //2022-11-26</span><br><span class="line">select curtime();</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_53370274/article/details/122122628">https://blog.csdn.net/weixin_53370274/article/details/122122628</a></p>
<p>✅日期转换为时间戳</p>
<p>10位的时间戳精确到s<br>13位的时间戳精确到ms毫秒</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNIX_TIMESTAMP函数:日期转时间戳(10位)</span><br><span class="line">select unix_timestamp(now()); //1669452093</span><br><span class="line"></span><br><span class="line">FROM_UNIXTIME函数：时间戳转日期（第二个参数非必填，默认：%Y-%m-%d %H:%i:%s）</span><br><span class="line">select from_unixtime(unix_timestamp(now()));</span><br><span class="line">select from_unixtime(unix_timestamp(now()), &#x27;%Y~%m~%d %H:%i:%S&#x27;);  //2022~11~26 16:48:38</span><br></pre></td></tr></table></figure>

<p>✅日期和字符串相互转化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">日期转化为指定格式字符串：</span><br><span class="line">select date_format(now(),&#x27;%Y-%m-%d %H:%i:%S&#x27;); //2022-11-26 16:45:59</span><br><span class="line"></span><br><span class="line">指定格式字符串转化为日期：</span><br><span class="line">select str_to_date(&#x27;2022-11-29&#x27;, &#x27;%Y-%m-%d %H:%i:%S&#x27;); //2022-11-29 00:00:00</span><br></pre></td></tr></table></figure>

<h2 id="mySQL-with-as用法"><a href="#mySQL-with-as用法" class="headerlink" title="mySQL - with as用法"></a>mySQL - with as用法</h2><p>如果一整句查询中多个子查询都需要使用同一个子查询的结果，那么就可以用with as，将共用的子查询提取出来，加个别名。后面查询语句可以直接用，对于大量复杂的SQL语句起到了很好的优化作用。</p>
<p>构造数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 分类表</span><br><span class="line">CREATE TABLE category ( cid VARCHAR ( 32 ) PRIMARY KEY, cname VARCHAR ( 50 ) );</span><br><span class="line"></span><br><span class="line">-- 商品表</span><br><span class="line">CREATE TABLE products (</span><br><span class="line">	pid VARCHAR ( 32 ) PRIMARY KEY,</span><br><span class="line">	pname VARCHAR ( 50 ),</span><br><span class="line">	price INT,</span><br><span class="line">	flag VARCHAR ( 2 ),-- 是否上架标记为：1表示上架、0表示下架</span><br><span class="line">	category_id VARCHAR ( 32 ),</span><br><span class="line">	FOREIGN KEY ( category_id ) REFERENCES category ( cid ) </span><br><span class="line">);</span><br><span class="line">-- 分类数据</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c001&#x27;,&#x27;家电&#x27;);</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c002&#x27;,&#x27;鞋服&#x27;);</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c003&#x27;,&#x27;化妆品&#x27;);</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c004&#x27;,&#x27;汽车&#x27;);</span><br><span class="line"></span><br><span class="line">-- 商品数据</span><br><span class="line">INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#x27;p001&#x27;,&#x27;小米电视机&#x27;,5000,&#x27;1&#x27;,&#x27;c001&#x27;);</span><br><span class="line">INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#x27;p002&#x27;,&#x27;格力空调&#x27;,3000,&#x27;1&#x27;,&#x27;c001&#x27;);</span><br><span class="line">INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#x27;p003&#x27;,&#x27;美的冰箱&#x27;,4500,&#x27;1&#x27;,&#x27;c001&#x27;);</span><br></pre></td></tr></table></figure>

<p>查询两个商品的平均价格：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WITH xm_gl AS ( SELECT * FROM products WHERE pname IN ( &#x27;小米电视机&#x27;, &#x27;格力空调&#x27; ) ) </span><br><span class="line">SELECT avg( price ) FROM xm_gl;</span><br></pre></td></tr></table></figure>

<p>使用with as还可以创建多个临时表，但是要注意同一个查询语句前写一个with就够了，另外子查询需要逗号隔开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WITH a AS ( SELECT * FROM category WHERE cname = &#x27;家电&#x27; ),</span><br><span class="line">b AS ( SELECT * FROM products WHERE pname IN ( &#x27;小米电视机&#x27;, &#x27;格力空调&#x27; ) ) </span><br><span class="line">SELECT * FROM	a	LEFT JOIN b ON a.cid = b.category_id;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、with as 相当于一个临时表，但是不同于视图（create table as），不会存储起来，要与select配合使用。<br>2、同一个select前可以有多个临时表，写一个with就可以，用逗号隔开，最后一个with语句不要用逗号。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/397195826">https://zhuanlan.zhihu.com/p/397195826</a></p>
<p>实战总结：<br><code>with as</code>不能单独加<code>;</code>一句单独使用，需要后面跟select一起使用。第一个<code>with as</code>得到的临时表可以在第二个临时表里用。好处是可以分步骤生成表，不用嵌套很多层。</p>
<p>如果<code>create table as</code> ，是要加在<code>with as</code>之前的。</p>
<h2 id="mysql-case-when-用法"><a href="#mysql-case-when-用法" class="headerlink" title="mysql case when 用法"></a>mysql case when 用法</h2><p>MySQL 的 case when 的语法有两种：</p>
<p>简单函数<br><code>CASE [col_name] WHEN [value1] THEN [result1]…ELSE [default] END</code></p>
<p>搜索函数<br><code>CASE WHEN [expr] THEN [result1]…ELSE [default] END</code></p>
<p>简单函数用法：根据case字段when已知可能值，then列出已知装备（也可以是表的某个字段）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    NAME &#x27;英雄&#x27;,</span><br><span class="line">    CASE NAME</span><br><span class="line">        WHEN &#x27;德莱文&#x27; THEN</span><br><span class="line">            &#x27;斧子&#x27;</span><br><span class="line">        WHEN &#x27;德玛西亚-盖伦&#x27; THEN</span><br><span class="line">            &#x27;大宝剑&#x27;</span><br><span class="line">        WHEN &#x27;暗夜猎手-VN&#x27; THEN</span><br><span class="line">            &#x27;弩&#x27;</span><br><span class="line">        ELSE</span><br><span class="line">            &#x27;无&#x27;</span><br><span class="line">    END &#x27;装备&#x27;</span><br><span class="line">FROM</span><br><span class="line">    user_info;</span><br></pre></td></tr></table></figure>

<p>搜索函数用法：case when 某个字段的函数 then某值（也可以是表的字段）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># when 表达式中可以使用 and 连接条件</span><br><span class="line">SELECT</span><br><span class="line">    NAME &#x27;英雄&#x27;,</span><br><span class="line">    age &#x27;年龄&#x27;,</span><br><span class="line">    CASE</span><br><span class="line">        WHEN age &lt; 18 THEN</span><br><span class="line">            &#x27;少年&#x27;</span><br><span class="line">        WHEN age &lt; 30 THEN</span><br><span class="line">            &#x27;青年&#x27;</span><br><span class="line">        WHEN age &gt;= 30</span><br><span class="line">        AND age &lt; 50 THEN</span><br><span class="line">            &#x27;中年&#x27;</span><br><span class="line">        ELSE</span><br><span class="line">            &#x27;老年&#x27;</span><br><span class="line">    END &#x27;状态&#x27;</span><br><span class="line">FROM</span><br><span class="line">    user_info;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenduzizhong/p/9590741.html">https://www.cnblogs.com/chenduzizhong/p/9590741.html</a></p>
<h2 id="mysql批量删除大量数据"><a href="#mysql批量删除大量数据" class="headerlink" title="mysql批量删除大量数据"></a>mysql批量删除大量数据</h2><p>假设有一个表(syslogs)有1000万条记录，需要在业务不停止的情况下删除其中statusid=1的所有记录，差不多有600万条， 直接执行 DELETE FROM syslogs WHERE statusid=1 会发现删除失败，因为lock wait timeout exceed的错误。</p>
<p>因为这条语句所涉及的记录数太多，因此我们通过LIMIT参数分批删除，比如每10000条进行一次删除，那么我们可以利用 MySQL这样的语句来完成:<br><code>DELETE FROM syslogs WHERE status=1 ORDER BY statusid LIMIT 10000;</code></p>
<p>如果要用order by 必须要和 limit 联用，否则被优化掉。然后分多次执行就可以把这些记录成功删除。</p>
<p>注意：<br>执行大批量删除的时候注意要使用上limit。因为如果不用limit，删除大量数据很有可能造成死锁。<br><strong>如果delete的where语句不在索引上，可以先找主键，然后根据主键删除数据库。</strong><br>平时update和delete的时候最好也加上limit 1 来防止误操作。</p>
<p>mybatis中的delete语句可以有返回，返回结果int是删除的条数，如果没删除，返回0.</p>
<h2 id="delete和truncate，drop的区别"><a href="#delete和truncate，drop的区别" class="headerlink" title="delete和truncate，drop的区别"></a>delete和truncate，drop的区别</h2><p>1、delete删除数据的原理:(delete属于DML语句)</p>
<p>表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放。<br>这种删除表的优点是：支持回滚，后悔了可以恢复数据，可以带where条件删除部分数据，灵活性强。<br>缺点：删除效率比较低</p>
<p><code>delete from user;  //删除user表中的数据，但是这种删除数据的方式有点慢。</code></p>
<p>2、truncate删除数据的原理:(DDL)</p>
<p>可以理解为，drop table然后再create table。<br>效率比较高，表被一次截断，物理删除<br>优点：快速，不走事务，不会锁表，也不会产生大量日志写入日志文件<br>缺点：不支持回滚，只能删除表中所有数据，不能删单条数据<br>如果说公司项目里面有一张大表，数据非常多，几亿条记录：<br>删除的时候，使用delete，也许执行一个小时才能删除完，效率极其低；<br>可以选择使用truncate删除表中的数据。只需要不到1s的时间就能删除结束，效率较高。<br>但是使用truncate之前，必须仔细询问客户是否真的需要删除，并警告删除之后不可恢复。</p>
<p><code>truncate table user; //删除user表中的数据，快速。</code></p>
<p><strong>truncate和delete的差异</strong></p>
<blockquote>
<p>1、truncate是DDL语句，它不存在所谓的“事务回滚”；<br>delete是DML语句，它执行完是可以rollback的。<br>2、truncate table返回值是0；<br>delete from table返回值是被删除的行数。<br>3、InnoDB支持一个表一个文件时：<br>truncate会一次性把表干掉，且不会激活触发器，速度非常快；<br>delete from table则会一行一行删除，会激活触发器，速度比较慢。<br>delete数据，是要记录日志的，truncate表不需要记录日志。<br>4、当表中有列被其它表作为外键(foreign key)时：<br>truncate会是失败； delete则会成功。<br>5、当表中有自增列时：<br>truncate会使得自增列计数复原；<br>delete所有数据后，自增列计数并不会复原，而是保持原来的顺序自增。</p>
</blockquote>
<p>3、drop删除表操作</p>
<p>truncate和delete是删除表中的数据，表还在。</p>
<p><code>drop table 表名；// 删除表，不是删除表中的数据</code></p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jike11231/article/details/126551510">https://blog.csdn.net/jike11231/article/details/126551510</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jkzyx123/article/details/127223589">https://blog.csdn.net/jkzyx123/article/details/127223589</a></p>
<h2 id="mysql的空间"><a href="#mysql的空间" class="headerlink" title="mysql的空间"></a>mysql的空间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类型	    占用空间	  取值范围</span><br><span class="line">tinyint	      1个字节	    -128~127</span><br><span class="line">smallint	2个字节	    -32768~32767</span><br><span class="line">mediumint	3个字节	    -223~ 223 - 1</span><br><span class="line">int	        4个字节	    -231~ 231- 1</span><br><span class="line">bigint	    8个字节	    -263~ 263- 1</span><br></pre></td></tr></table></figure>

<p>mysql数据类型及占用空间：<a target="_blank" rel="noopener" href="https://blog.csdn.net/why_still_confused/article/details/125945285">https://blog.csdn.net/why_still_confused/article/details/125945285</a></p>
<h2 id="分库分表的表怎么查询"><a href="#分库分表的表怎么查询" class="headerlink" title="分库分表的表怎么查询"></a>分库分表的表怎么查询</h2><p>逻辑库查询暂不支持join查询。</p>
<h2 id="Lindorm云原生多模数据库"><a href="#Lindorm云原生多模数据库" class="headerlink" title="Lindorm云原生多模数据库"></a>Lindorm云原生多模数据库</h2><p>Lindorm是面向物联网、互联网、车联网等设计和优化的云原生多模超融合数据库，支持宽表、时序、文本、对象、流、空间等多种数据的统一访问和融合处理，并兼容SQL、HBase/Cassandra/S3、TSDB、HDFS、Solr、Kafka等多种标准接口和无缝集成三方生态工具，适用于日志、监控、账单、广告、社交、出行、风控等场景，Lindorm也是为阿里巴巴核心业务提供支撑的数据库之一。</p>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/174640.html">https://help.aliyun.com/document_detail/174640.html</a></p>
<h2 id="mysql查出来的数据转换为json格式-用ResultSet"><a href="#mysql查出来的数据转换为json格式-用ResultSet" class="headerlink" title="mysql查出来的数据转换为json格式 用ResultSet"></a>mysql查出来的数据转换为json格式 用ResultSet</h2><p>单纯mysql语句没得办法。<br>只能在java里操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.ResultSetMetaData;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">import org.json.JSONArray;</span><br><span class="line">import org.json.JSONObject;</span><br><span class="line"></span><br><span class="line">public class MysqlToJSON &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String driver = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/ontology&quot;;</span><br><span class="line">        String user = &quot;root&quot;;</span><br><span class="line">        String pwd = &quot;123456&quot;;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            Connection con =DriverManager.getConnection(url,user,pwd);</span><br><span class="line">            Statement stet = con.createStatement();</span><br><span class="line"></span><br><span class="line">            String sql = &quot;select * from class_tab&quot;;</span><br><span class="line">            ResultSet rs = stet.executeQuery(sql);</span><br><span class="line">            ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line">            int columnCount= metaData.getColumnCount();</span><br><span class="line">            JSONArray array = new JSONArray();</span><br><span class="line">            while(rs.next())&#123;</span><br><span class="line">                JSONObject jsonObj = new JSONObject();</span><br><span class="line">                for(int i = 1; i &lt;= columnCount;i++)&#123;</span><br><span class="line">                    String columnName = metaData.getColumnLabel(i);</span><br><span class="line">                    String value =rs.getString(columnName);</span><br><span class="line">                    jsonObj.put(columnName, value);</span><br><span class="line">                &#125;</span><br><span class="line">                array.put(jsonObj);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;转换JSON数据：&quot;);</span><br><span class="line">            System.out.println(array.toString());</span><br><span class="line">            </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mysql的json数据格式"><a href="#mysql的json数据格式" class="headerlink" title="mysql的json数据格式"></a>mysql的json数据格式</h2><p>mysql5.7以上提供了一种新的字段格式json，大概是mysql想把非关系型和关系型数据库一口通吃，所以推出了这种非常好用的格式，这样，我们的很多基于mongoDB的业务都可以用mysql去实现了。当然了，5.7的版本只是最基础的版本，对于海量数据的效率是远远不够的，不过这些都在mysql8.0解决了。</p>
<p>✅创建表，插入数据</p>
<p>先创建一个简单的含json格式的数据库表，其中json_value就为json格式的字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `dept` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `dept` varchar(255) DEFAULT NULL,</span><br><span class="line">  `json_value` json DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">insert into dept VALUES(1,&#x27;部门1&#x27;,&#x27;&#123;&quot;deptName&quot;: &quot;部门1&quot;, &quot;deptId&quot;: &quot;1&quot;, &quot;deptLeaderId&quot;: &quot;3&quot;&#125;&#x27;);</span><br><span class="line">insert into dept VALUES(2,&#x27;部门2&#x27;,&#x27;&#123;&quot;deptName&quot;: &quot;部门2&quot;, &quot;deptId&quot;: &quot;2&quot;, &quot;deptLeaderId&quot;: &quot;4&quot;&#125;&#x27;);</span><br><span class="line">insert into dept VALUES(3,&#x27;部门3&#x27;,&#x27;&#123;&quot;deptName&quot;: &quot;部门3&quot;, &quot;deptId&quot;: &quot;3&quot;, &quot;deptLeaderId&quot;: &quot;5&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure>

<p>✅基础查询操作</p>
<p>如果json字符串不是数组，则直接使用<code>$.字段名</code><br>如果json字符串是数组<code>[Array]</code>，则直接使用<code>$[对应元素的索引id]</code></p>
<p>使用 <code>json字段名-&gt;’$.json属性’</code> 进行查询条件<br>举个例子：如果想查询deptLeaderId=5 的数据，那么sql语句如下：<br><code>SELECT * from dept WHERE json_value-&gt;&#39;$.deptLeaderId&#39;=&#39;5&#39;;</code></p>
<p>多条件查询，想查dept为“部门3”和deptLeaderId=5的数据，sql如下：<br><code>SELECT * from dept WHERE json_value-&gt;&#39;$.deptLeaderId&#39;=&#39;5&#39; and dept=&#39;部门3&#39;;</code></p>
<p>json中的多条件查询，想查询json格式中deptLeaderId=5和deptId=5的数据:<br><code>SELECT * from dept WHERE json_value-&gt;&#39;$.deptLeaderId&#39;=&#39;5&#39; and json_value-&gt;&#39;$.deptId&#39;=&#39;5&#39;;</code></p>
<p>两个有json字段的表关联查询，一样的：<br><code>SELECT * from dept,dept_leader  WHERE dept.json_value-&gt;&#39;$.deptLeaderId&#39;=dept_leader.json_value-&gt;&#39;$.id&#39; ;</code></p>
<p>转自：mysql之json操作以及一些json函数：<br><a target="_blank" rel="noopener" href="http://events.jianshu.io/p/40b153000fb2">http://events.jianshu.io/p/40b153000fb2</a></p>
<h2 id="mysql表数据迁移"><a href="#mysql表数据迁移" class="headerlink" title="mysql表数据迁移"></a>mysql表数据迁移</h2><p>不是一个库只能先select出来，然后构造insert</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从一个表复制数据，然后把数据插入到另一个新表中：</span><br><span class="line">create  table 新表  as select * from 旧表</span><br><span class="line"></span><br><span class="line">INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中：</span><br><span class="line">insert into 新表 (select * from 旧表)</span><br><span class="line"></span><br><span class="line">只复制希望的列插入到另一个已存在的表中：</span><br><span class="line">insert into 新表(字段1, 字段2, 字段n)  select  字段1, 字段2, 字段n from 旧表</span><br></pre></td></tr></table></figure>


<h2 id="mysql中geometry类型的插入"><a href="#mysql中geometry类型的插入" class="headerlink" title="mysql中geometry类型的插入"></a>mysql中geometry类型的插入</h2><p>得加个<code>geoFromText(‘lineString(...)’)</code></p>
<p>geometry那篇博客里也有。</p>
<p>MySQL中地理位置数据扩展geometry的使用心得：<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2074765">https://cloud.tencent.com/developer/article/2074765</a></p>
<h2 id="mysql的mediumtext和text"><a href="#mysql的mediumtext和text" class="headerlink" title="mysql的mediumtext和text"></a>mysql的mediumtext和text</h2><p>MysQL中的mediumtext是一种文本数据类型，可以存储最长16777215个字符的文本数据。它是longtext和text类型之间的中间类型，比text类型更大，但比longtext类型更小。mediumtext 通常用于存储大量文本数据，例如文章、博客站子和评论等。</p>
<p>在msQL中，text是一种文本类型，可以存健最长 65535个字符的文本数据。 text类型通常用于存储的大量文本的数据。例如短信、邮件内容、简短的评论等。如果需要存储更长的文本数据，可以使用 longtext类型或 mediumtext类型。</p>
<h2 id="mysql的tinyint-unsigned能存多大"><a href="#mysql的tinyint-unsigned能存多大" class="headerlink" title="mysql的tinyint unsigned能存多大"></a>mysql的tinyint unsigned能存多大</h2><p>mysql的 tinyint unsigned能存多大：<br>MySQL的tinyint unsigned 数据类型可以存储0到255之间的整数。它使用8位(1字节）存储数据。由于它是无符号的，因此它不能存储负数，但可以存储比有符号的tinyint（-128 - 127）更大的正数值。</p>
<h2 id="NOT-NULL-DEFAULT-quot-quot"><a href="#NOT-NULL-DEFAULT-quot-quot" class="headerlink" title="NOT NULL DEFAULT &quot;&quot;"></a><code>NOT NULL DEFAULT &quot;&quot;</code></h2><p>在数据库表中，<code>NOT NULL DEFAULT &quot;&quot;</code> 表示该字段不能为空且如果没有指定值，将使用默认值””(空宇符串)。当使用MyBatis 插入数据时，如果该字段传递了null值，它将尝试将其插入数据库。由于该字段被指定为 NOT NULL，因此数据库会拒绝插入null 值，并返回错误消息。因此，建议在插入数据之前检查每个字段是否具有有效值，特别注意传的对象，如果没赋值为null，将报错。</p>
<p>总之：<code>NOT NULL DEFAULT &quot;&quot;</code>，要么不传，要么传非null。传null会报错，而不是传null给默认值。</p>
<h2 id="插入之后想获取id"><a href="#插入之后想获取id" class="headerlink" title="插入之后想获取id"></a>插入之后想获取id</h2><p>useGeneratedkeys 获取id，不是从insert返回，而是插入实体类的id。</p>
<p>Long insertNum = myDao.insert(myDO);<br>Long id = myDO.getId();</p>
<h2 id="关联表分条件关联"><a href="#关联表分条件关联" class="headerlink" title="关联表分条件关联"></a>关联表分条件关联</h2><p>例如a关联b表，a表status=1时用task_id关联，否则用flow_id<br>关联。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from a left join b on </span><br><span class="line">case</span><br><span class="line">    when a.status=1 then a.task_id = b.task_id</span><br><span class="line">    else a.flow_id = b.flow_id</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这样貌似运行时间长，看一下是否用<code>from a, b where (条件1) or (条件2)</code></p>
<h2 id="分组计数"><a href="#分组计数" class="headerlink" title="分组计数"></a>分组计数</h2><p>有一张表，有city、status字段，相统计各个城市不同status的数量和比例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">已知各status的情况下，分列显示：</span><br><span class="line">select city, count(1) as total, sum(status=0) as status_0, sum(status=1) as status_1</span><br><span class="line">from table</span><br><span class="line">group by city;</span><br><span class="line"></span><br><span class="line">不明status是什么，分行显示：</span><br><span class="line">select city, status, count(1) as count</span><br><span class="line">group by city, status;</span><br><span class="line"></span><br><span class="line">求两个数的商，并保留两位小数：</span><br><span class="line">rount(num1 / num2, 2)</span><br></pre></td></tr></table></figure>

<h2 id="想将另一张表的数据按照映射更新到另一张表："><a href="#想将另一张表的数据按照映射更新到另一张表：" class="headerlink" title="想将另一张表的数据按照映射更新到另一张表："></a>想将另一张表的数据按照映射更新到另一张表：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update table_a</span><br><span class="line">left join table_b</span><br><span class="line">on table_a.task_id = table_b.task_id</span><br><span class="line">set table_a.status = table_b.status</span><br><span class="line">where table_a.task_id in ()</span><br></pre></td></tr></table></figure>
<p>仅更新table_a的数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/11/myblog/JAVA/java%20web/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/11/myblog/JAVA/java%20web/" class="post-title-link" itemprop="url">java web相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-11 14:46:24" itemprop="dateCreated datePublished" datetime="2022-09-11T14:46:24+08:00">2022-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 15:33:03" itemprop="dateModified" datetime="2023-08-20T15:33:03+08:00">2023-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网页502"><a href="#网页502" class="headerlink" title="网页502"></a>网页502</h2><p>502 Bad Gateway是指错误网关，无效网关；在互联网中表示一种网络错误。表现在WEB浏览器中给出的页面反馈。</p>
<p>服务端代码下掉，重新部署的间隙，访问接口会502.</p>
<h2 id="504错误"><a href="#504错误" class="headerlink" title="504错误"></a>504错误</h2><p>504错误代表网关超时 （Gateway timeout），是指服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p>
<p>接口504超时，是服务端这边超时断开请求了，需要看一下nginx配置。如果是tomcat，看一下conf中配置的请求超时时间。</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="✅nginx是什么？"><a href="#✅nginx是什么？" class="headerlink" title="✅nginx是什么？"></a>✅nginx是什么？</h3><blockquote>
<p>Nginx是十分轻量级的HTTP服务器。Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器。</p>
<p>Ngnix 是互联网企业使用最为广泛的代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。</p>
<p>Nginx是lgor Sysoev为俄罗斯访问量第二的rambler.ru站点设计开发的。从2004年发布至今，凭借开源的力量，已经接近成熟与完善。<br>Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。<br>Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p>
</blockquote>
<p>nginx是服务器，代理服务器，负载均衡，反向代理，服务器架构。</p>
<p>Nginx凭借其稳定性、低资源消耗、简单配置和丰富的功能，从十多年前名不见经传的Web服务器软件，发展到如今能够跟Apache匹敌的地位。</p>
<p>1、作为Web服务器，Nginx处理静态文件、索引文件，自动索引的效率非常高</p>
<p>2、作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度</p>
<p>3、作为负载均衡服务器，Nginx既可以在内部直接支持Rails和PHP，也可以支持HTTP代理服务器对外进行服务，同时还支持简单的容错和利用算法进行负载均衡</p>
<p>4、在性能方面，Nginx是专门为性能优化而开发的，实现上非常注重效率。它采用内核Poll模型，可以支持更多的并发连接，最大可以支持对5万个并发连接数的响应，而且只占用很低的内存资源</p>
<p>5、在稳定性方面，Nginx采取了分阶段资源分配技术，使得CPU与内存的占用率非常低。Nginx官方表示，Nginx保持1万个没有活动的连接，而这些连接只占用2.5MB内存，因此，类似DOS这样的攻击对Nginx来说基本上是没有任何作用的</p>
<p>6、在高可用性方面，Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到7x24小时不间断地运行<br>————————————————<br>解读nginx：<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_60274825/article/details/122101640">https://blog.csdn.net/weixin_60274825/article/details/122101640</a></p>
<h3 id="✅什么是代理服务器？"><a href="#✅什么是代理服务器？" class="headerlink" title="✅什么是代理服务器？"></a>✅什么是代理服务器？</h3><p>代理服务器是介于客户端和Web服务器之间的另一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页，而是通过向代理服务器发送请求，信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p>
<p><img src="/images/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p>
<p>代理位于Web客户端和Web服务器之间，扮演“中间人”的角色。<br>HTTP的代理服务器既是Web服务器又是Web客户端。</p>
<h3 id="✅什么是正反向代理"><a href="#✅什么是正反向代理" class="headerlink" title="✅什么是正反向代理"></a>✅什么是正反向代理</h3><p>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取的内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端，客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p>正向代理代理的对象是客户端，正向代理中，proxy和client同属一个LAN，对server透明 （客户端服务端多对一？）</p>
<p>反向代理服务器：在服务器端接收客户端的请求，然后把请求分发给具体的服务器进行处理，然后再将服务器的响应结果反馈给客户端。Nginx就是其中的一种反向代理服务器软件。</p>
<p>反向代理代理的对象是服务端，反向代理中，proxy和server同属一个LAN，对client透明  （客户端服务端多对多）</p>
<p>正向代理客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。<br>反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间中的内容发送普通请求，接着反向代理将判断向哪个原始服务器转交请求，并将获得的内容返回给客户端。<br>————————————————<br>解读nginx：<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_60274825/article/details/122101640">https://blog.csdn.net/weixin_60274825/article/details/122101640</a></p>
<h3 id="✅nginx与tomcat什么关系"><a href="#✅nginx与tomcat什么关系" class="headerlink" title="✅nginx与tomcat什么关系"></a>✅nginx与tomcat什么关系</h3><p>nginx是上面做web代理服务器的，而tomcat是上面做真正web服务器的。</p>
<p>nginx常用做静态内容服务和代理服务器，直面外来请求转发给后面的应用服务（tomcat，django什么的），tomcat更多用来做做一个应用容器，让java web app跑在里面的东西，对应同级别的有jboss,jetty等东西。</p>
<p>但是事无绝对，nginx也可以通过模块开发来提供应用功能，tomcat也可以直接提供http服务，通常用在内网和不需要流控等小型服务的场景。</p>
<p>严格的来说，Apache/Nginx 应该叫做「HTTP Server」；而 Tomcat 则是一个「Application Server」，或者更准确的来说，是一个「Servlet/JSP」应用的容器（Ruby/Python 等其他语言开发的应用也无法直接运行在 Tomcat 上）。</p>
<p>一个 HTTP Server 关心的是 HTTP 协议层面的传输和访问控制，所以在 Apache/Nginx 上你可以看到代理、负载均衡等功能。客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。通过 CGI 技术，也可以将处理过的内容通过 HTTP Server 分发，但是一个 HTTP Server 始终只是把服务器上的文件如实的通过 HTTP 协议传输给客户端。</p>
<p>而应用服务器，则是一个应用执行的容器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。对于 Tomcat 来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44517990/article/details/100712182">https://blog.csdn.net/weixin_44517990/article/details/100712182</a></p>
<h3 id="✅-springboot内置tomcat-和-tomcat"><a href="#✅-springboot内置tomcat-和-tomcat" class="headerlink" title="✅ springboot内置tomcat 和 tomcat"></a>✅ springboot内置tomcat 和 tomcat</h3><p>1.内置的tomcat没有tomcat的主页页面<a target="_blank" rel="noopener" href="http://localhost:9999/%EF%BC%8C%E8%80%8C%E6%88%91%E4%BB%AC%E5%B9%B3%E6%97%B6%E7%94%A8%E7%9A%84%E5%A4%96%E7%BD%AE%E7%9A%84tomcat%E6%98%AF%E6%9C%89%E7%9A%84">http://localhost:9999/，而我们平时用的外置的tomcat是有的</a></p>
<p>2.内置的tomcat可以用main跑项目，而如果要用外置的tomcat就需要把项目打成war包，然后拷贝到webapp下进行运行</p>
<p>Tomcat：<br>Tomcat是一个Web应用服务器，也是Servlet容器。它的作用是，解析客户端client发起的request，并组装出HttpRequest、创建HttpResponse，将二者交于内部的HttpServlet处理和填充</p>
<p>Tomcat映射处理请求的Servlet是通过web.xml做的。</p>
<p>SpringMVC使用一个DispatcherServlet来接收所有的请求，并把它们分发到不同的controller中来做进一步处理。</p>
<p>SpringMVC = Spring + Web框架，Spring这部分主要是AOP/IOC容器。</p>
<p>SpringBoot是Spring的扩展，简化了Spring的配置，通过starter的方式简化了常用组件依赖的引入，使其更加易用。</p>
<p>SpringBoot内置了tomcat。</p>
<h3 id="✅tomcat和spring-mvc"><a href="#✅tomcat和spring-mvc" class="headerlink" title="✅tomcat和spring mvc"></a>✅tomcat和spring mvc</h3><p>tomcat既是Http服务器（不用代理的话，其实是应用服务器），Http服务器与Servlet容器的功能界限是：可以把HTTP服务器想象成前台的接待，负责网络通信和解析请求，Servlet容器是业务部门，负责处理业务请求。</p>
<p>Tomcat和Servlet作为Web服务器和Servlet容器的结合，可以接受网络http请求解析为Servlet规范的请求对象和响应对象。比如，HttpServletRequest对象是Tomcat提供的，Servlet是规范，Tomcat是实现规范的Servlet容器。tomcat监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理;然后调用那个servlet的service方法，service方法返回一个response对象;<br>tomcat再把这个response返回给客户端。</p>
<p>SpringMVC是处理Servlet请求的应用，其中DispatcherServlet实现了Servlet接口，Tomcat负责加载和调用DispatcherServlet。同时，DispatcherServlet有自己的容器（SpringMVC）容器，这个容器负责管理SpringMVC相关的bean，比如Controler和ViewResolver等。同时，Spring中还有其他的Bean比如Service和DAO等，这些由全局的Spring IOC容器管理，因此，Spring有两个IOC容器。</p>
<p>如果只是使用spring(不包含springmvc)，那么是tomcat容器解析xml文件，通过反射实例化对应的类，根据这些servlet规范实现类，触发对应的代码处理逻辑，这个时候tomcat负责http报文的解析和servlet调度的工作。</p>
<p>如果使用spring mvc，那么tomcat只是解析http报文，然后将其转发给dispatchsetvlet，然后由springmvc根据其配置，实例对应的类，执行对应的逻辑，然后返回结果给dispatchservlet，最后由它转发给tomcat,由tomcat负责构建http报文数据。</p>
<p>DispatcherServlet：是Spring MVC中的一个类，实现了Servlet接口。所以部署在Tomcat中的Spring项目，对Tomcat来说，都是一个servlet。</p>
<p>————————————————<br>spring mvc还需要tomcat吗？<br>版权声明：本文为CSDN博主「黄泥川水猴子」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40277163/article/details/124730530">https://blog.csdn.net/qq_40277163/article/details/124730530</a></p>
<h3 id="✅nginx与域名解析DNS什么关系"><a href="#✅nginx与域名解析DNS什么关系" class="headerlink" title="✅nginx与域名解析DNS什么关系"></a>✅nginx与域名解析DNS什么关系</h3><p>首先，nginx是web服务器和反向代理服务器。 dns是域名解析服务器。nginx不带dns。</p>
<p>作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。访问域名，dns帮忙解析到ip，然后访问这个地址的资源呈现给你。hosts和nginx在后面用到。</p>
<p>hosts文件：<br>hosts文件是个本地域名解析文件，不管你是windwos还是linux，那都是有的，他里面的有效内容，就是一个个的ip和域名映射关系。<br>windows一般在：C:/Windows/System32/drivers/etc/hosts<br>Linux的hosts文件路径一般：/etc/hosts<br>比如：127.0.0.1 localhost<br>这个文件其实也是配置了ip和域名之间的映射关系的数据库，本地要是有这个文件，就优先用这个文件中的配置去解析，如果没有，那就通过dns解析。<br>注意：hosts文件只能配置ip和域名的映射关系，但是不能配置端口号，默认访问80端口</p>
<p>因为要解决端口问题，这里就得使用反向代理软件nginx，nginx中的每个server就是一个反向代理配置，可以有多个server。</p>
<p>理解：<em><strong>客户端请求 - dns解析域名 - 解析到nginx服务器的ip - nginx代理到tomcat服务器+端口 - tomcat将请求给servlet - servlet的service处理请求。</strong></em></p>
<h3 id="✅nginx与CDN内容分发网络什么关系"><a href="#✅nginx与CDN内容分发网络什么关系" class="headerlink" title="✅nginx与CDN内容分发网络什么关系"></a>✅nginx与CDN内容分发网络什么关系</h3><p>cdn是网络，nginx是服务器也是负载均衡。</p>
<p>cdn：<br>1、CDN的全称是Content Delivery Network，即内容分发网络。<br>2、其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。<br>3、通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。<br>4、其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度**。<br>5、内容分发网络是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。</p>
<p>cdn的工作原理：<br>CDN这个技术其实说起来并不复杂，最初的核心理念，就是将内容缓存在终端用户附近。</p>
<p>内容源不是远么？那么，我们就在靠近用户的地方，建一个缓存服务器，把远端的内容，复制一份，放在这里，不就OK了？</p>
<p>具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓吧？）</p>
<p>大家可能觉得，这个不就是“镜像服务器”嘛？其实不一样。镜像服务器是源内容服务器的完整复制。而CDN，是部分内容的缓存，智能程度更高。</p>
<p><img src="/images/CDN.png"></p>
<p>借用阿里云官网的例子，来简单介绍CDN的工作原理。</p>
<p>假设通过CDN加速的域名为 <a href="http://www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：">www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：</a></p>
<p>1、当终端用户（北京）向<a target="_blank" rel="noopener" href="http://www.a.com下的指定资源发起请求时,首先向ldns(本地dns)发起域名解析请求./">www.a.com下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。</a></p>
<p>2、LDNS检查缓存中是否有<a target="_blank" rel="noopener" href="http://www.a.com的ip地址记录.如果有,则直接返回给终端用户;如果没有,则向授权dns查询./">www.a.com的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。</a></p>
<p>3、当授权DNS解析<a target="_blank" rel="noopener" href="http://www.a.com时,返回域名cname/">www.a.com时，返回域名CNAME</a> <a target="_blank" rel="noopener" href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></p>
<p>4、域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</p>
<p>5、LDNS获取DNS返回的解析IP地址。</p>
<p>6、用户获取解析IP地址。</p>
<p>7、用户向获取的IP地址发起对该资源的访问请求。</p>
<p>8、如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</p>
<p>9、如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。</p>
<p>所以：<br>（1）CDN的加速资源是跟域名绑定的。<br>（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP<br>（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。</p>
<hr>
<p>nginx负载均衡：负载均衡实际上就是将大量请求进行分布式处理的策略</p>
<p>Nginx 作为一个基于 C 实现的高性能 Web 服务器，可以通过系列算法解决上述的负载均衡问题。并且由于它具有高并发、高可靠性、高扩展性、开源等特点，成为开发人员常用的反向代理工具</p>
<p>1、正向代理</p>
<p>正向代理（Forward Proxy）最大的特点是，客户端非常明确要访问的服务器地址，它代理客户端，替客户端发出请求。比如：科学上网。</p>
<p>假设客户端想要访问 Google，它明确知道待访问的服务器地址是 <a target="_blank" rel="noopener" href="https://www.google.com/%EF%BC%8C%E4%BD%86%E7%94%B1%E4%BA%8E%E6%9D%A1%E4%BB%B6%E9%99%90%E5%88%B6%EF%BC%8C%E5%AE%83%E6%89%BE%E6%9D%A5%E4%BA%86%E4%B8%80%E4%B8%AA%E8%83%BD%E5%A4%9F%E8%AE%BF%E9%97%AE%E5%88%B0">https://www.google.com/，但由于条件限制，它找来了一个能够访问到</a> Google 的”朋友”：代理服务器。客户端把请求发给代理服务器，由代理服务器代替它请求 Google，最终再将响应返回给客户端。这便是一次正向代理的过程，该过程中服务器并不知道真正发出请求的是谁。<br>（客户端 - 正向代理 - 服务器）</p>
<p>2、反向代理</p>
<p>随着请求量的爆发式增长，服务器觉得自己一个人始终是应付不过来，需要兄弟服务器们帮忙，于是它喊来了自己的兄弟以及代理服务器朋友。此时，来自不同客户端的所有请求实际上都发到了代理服务器处，再由代理服务器按照一定的规则将请求分发给各个服务器。这就是反向代理（Reverse Proxy），反向代理隐藏了服务器的信息，它代理的是服务器端，代其接收请求。换句话说，反向代理的过程中，客户端并不知道具体是哪台服务器处理了自己的请求。如此一来，既提高了访问速度，又为安全性提供了保证<br>（一堆客户端 - 反向代理 - 一堆服务器）</p>
<p>在这之中，反向代理需要考虑的问题是，如何进行均衡分工，控制流量，避免出现局部节点负载过大的问题。通俗的讲，就是如何为每台服务器合理的分配请求，使其整体具有更高的工作效率和资源利用率。</p>
<p>3、负载均衡常用算法</p>
<p>轮询 （round-robin）<br>轮询为负载均衡中较为基础也较为简单的算法，它不需要配置额外参数。假设配置文件中共有 台服务器，该算法遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。特点：由于该算法中每个请求按时间顺序逐一分配到不同的服务器处理，因此适用于服务器性能相近的集群情况，其中每个服务器承载相同的负载。但对于服务器性能不同的集群而言，该算法容易引发资源分配不合理等问题。</p>
<p>加权轮询<br>为了避免普通轮询带来的弊端，加权轮询应运而生。在加权轮询中，每个服务器会有各自的 weight。一般情况下，weight 的值越大意味着该服务器的性能越好，可以承载更多的请求。该算法中，客户端的请求按权值比例分配，当一个请求到达时，优先为其分配权值最大的服务器。特点：加权轮询可以应用于服务器性能不等的集群中，使资源分配更加合理化。</p>
<p>IP 哈希（IP hash）<br>ip_hash 依据发出请求的客户端 IP 的 hash 值来分配服务器，该算法可以保证同 IP 发出的请求映射到同一服务器，或者具有相同 hash 值的不同 IP 映射到同一服务器。特点：该算法在一定程度上解决了集群部署环境下 Session 不共享的问题。</p>
<p>所以：<br>Nginx 作为一款优秀的反向代理服务器，可以通过不同的负载均衡算法来解决请求量过大情况下的服务器资源分配问题。较为常见的负载均衡算法有轮询、加权轮询、IP 哈希等等，可分别应对不同的请求场景。</p>
<p>————————————————<br>好文章：从对CDN的理解到Nginx负载均衡<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40409143/article/details/118330238">https://blog.csdn.net/qq_40409143/article/details/118330238</a></p>
<h3 id="✅nginx与RPC远程过程调用什么关系？"><a href="#✅nginx与RPC远程过程调用什么关系？" class="headerlink" title="✅nginx与RPC远程过程调用什么关系？"></a>✅nginx与RPC远程过程调用什么关系？</h3><p>RPC是远程过程调用，是一种计算机通信思想。</p>
<p>nginx是代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。</p>
<p>Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互。也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</p>
<p>讲RPC、RPC与nginx、RPC与HTTP间的关系的好文章：<br><a target="_blank" rel="noopener" href="https://www.kancloud.cn/machh03/server/2096716">https://www.kancloud.cn/machh03/server/2096716</a></p>
<h3 id="✅与gateway有什么关系？"><a href="#✅与gateway有什么关系？" class="headerlink" title="✅与gateway有什么关系？"></a>✅与gateway有什么关系？</h3><p>网关(Gateway)就是一个网络连接到另一个网络的“关口”。</p>
<p><img src="/images/gateway.png"></p>
<p>1、nginx也可以做网关，是用户访问的总入口，也就是前端页面的容器，流量网关。</p>
<p>流量网关是定义全局性的、跟具体的后端业务应用和服务完全无关的策略网关。<br>流量网关通常只专注于全局的Api管理策略，比如全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等，有点类似防火墙。</p>
<p>2、gateway的定义是针对每一个业务微服务来得，属于业务网关。是介于nignx以及业务应用之间的中间层，主要负责将请求路由到不同的微服务中以及对请求的合法性进行校验。</p>
<p>业务网关针对具体的业务需要提供特定的流控策略、缓存策略、鉴权认证策略等等。<br>业务网关一般部署在流量网关之后、业务系统之前，比流量网关更靠近业务系统。通常API网指的是业务网关。 有时候我们也会模糊流量网关和业务网关，让一个网关承担所有的工作,所以这两者之间并没有严格的界线。</p>
<hr>
<p>网关可以看做系统与外界联通的入口，我们可以在网关进行处理一些非业务逻辑的逻辑，比如权限验证，监控，缓存，请求路由等等。</p>
<p>1、nginx是用户到 前端工程 的网关，对外网关<br>nginx是用C语言写的<br>nginx做网关，更多的是做总流量入口，反向代理，负载均衡等，还可以用来做web服务器。<br>Nginx在其中扮演的角色是什么？<br>反向代理<br>负载均衡</p>
<p>2、gateway 是前端工程 到 后台服务器之间的一个 对内网关<br>gateway是java语言的一个框架，可以在框架上进行代码的扩展与控制，例如：安全控制，统一异常处理，XXS,SQL注入等；权限控制，黑白名单，性能监控，日志打印等<br>gateway的主要功能有，路由，断言，过滤器，利用它的这些特性，可以做流控。<br>SpringGateway在其中扮演的角色是什么？<br>统一鉴权</p>
<p>nginx与gateway：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yangbindxj/article/details/125040773">https://blog.csdn.net/yangbindxj/article/details/125040773</a></p>
<hr>
<p>网关服务的端口号默认是80或者443.<br>相同点：都是可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等，可以实现和网关一样的效果。<br>Nginx实现负载均衡的原理属于服务器端负载均衡器。<br>Gateway实现负载均衡原理采用本地负载均衡器的形式。</p>
<h3 id="✅nginx与统一接入有什么关系？"><a href="#✅nginx与统一接入有什么关系？" class="headerlink" title="✅nginx与统一接入有什么关系？"></a>✅nginx与统一接入有什么关系？</h3><p>统一接入层是：指的是设置专属一层，统一接入所有流量，包括 PC 流量、无线流量、IoT 流量。在应用层之上的一层。</p>
<p>如果没有统一接入层，之前的业务方，例如购物车、商品等都要自己维护一个网关，这就涉及到维护成本和机器成本。例如卸载 HTTPS，如果所有业务方都要申请证书，那造成的应用成本是非常高的。可如果将所有功能全放在这一层进行，好处非常明显：一方面是机器集中管理节省成本；另外一方面，如果遇到新的瓶颈可以在统一接入层集中优化，如请求响应 Body 统一在这一层进行压缩减少带宽消耗，压缩会消耗 CPU，可以在这一层通过硬件加速的方式集中优化等。</p>
<p>阿里统一接入层：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96510277?hmsr=toutiao.io">https://zhuanlan.zhihu.com/p/96510277?hmsr=toutiao.io</a></p>
<p>统一接入层方案：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Leo_wl/archive/2012/10/17/2728541.html">https://www.cnblogs.com/Leo_wl/archive/2012/10/17/2728541.html</a></p>
<p>统一接入层是网关中最前端的服务，统一接入到集群中。<br>所以，统一接入层应该是在web代理服务器nginx前的。</p>
<h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><h3 id="nginx配置文件结构"><a href="#nginx配置文件结构" class="headerlink" title="nginx配置文件结构"></a>nginx配置文件结构</h3><p>Main 位于 nginx.conf 配置文件的最高层；<br>Main 层下可以有 Event、HTTP 层；<br>Http 层下面允许有多个 Server 层，用于对不同的网站做不同的配置；<br>Server 层下面允许有多个 Location，用于对不同的路径进行不同模块的配置。</p>
<p>1、main（最上面）<br>全局配置部分用来配置对整个 server 都有效的参数。主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等<br>全局Main配置<br>user nginx;<br>worker_processes 1; #设置值和CPU核心数一致</p>
<p>error_log /var/log/nginx/error.log warn; #日志位置和日志级别<br>pid       /var/run/nginx.pid;</p>
<p>2.event<br>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 worker process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 worker process 可以同时支持的最大连接数等。<br>Event配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、http<br>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。<br>http配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  include       /etc/nginx/mime.types;</span><br><span class="line">  default_type application/octet-stream;</span><br><span class="line">  log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                    &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                    &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">  access_log /var/log/nginx/access.log main;</span><br><span class="line">  sendfile       on;</span><br><span class="line">  #tcp_nopush     on;</span><br><span class="line">  keepalive_timeout 65;</span><br><span class="line">  #gzip on;</span><br><span class="line">  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、server<br>Server 块也被叫做“虚拟主机”部分，它描述的是一组根据不同 server_name 指令逻辑分割的资源，这些虚拟服务器响应 HTTP 请求，因此都包含在 http 部分。最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。一个 server 块可以配置多个 location 块。<br>server配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  location / &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">      index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">  error_page   500 502 503 504 /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nginx配置结构：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1729793004418584302&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1729793004418584302&amp;wfr=spider&amp;for=pc</a></p>
<p>菜鸟nginx配置：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">https://www.runoob.com/w3cnote/nginx-setup-intro.html</a></p>
<p>nginx配置详细介绍：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_12218973/2457715">https://blog.51cto.com/u_12218973/2457715</a></p>
<h3 id="nginx超时配置"><a href="#nginx超时配置" class="headerlink" title="nginx超时配置"></a>nginx超时配置</h3><p>Nginx主要有四类超时设置：客户端超时设置、DNS解析超时设置、代理超时设置，如果使用ngx_lua，则还有lua相关的超时设置。</p>
<p>1、客户端超时</p>
<p>客户端超时主要设置有读取请求头超时时间、读取请求体超时时间、发送响应超时时间、长连接超时时间。通过客户端超时设置避免客户端恶意或者网络状况不佳造成连接长期占用，影响服务端的可处理的能力。</p>
<p><strong>client_header_timeout time</strong>：设置读取客户端请求头超时时间，默认为60s，如果在此超时时间内客户端没有发送完请求头，则响应408（RequestTime-out）状态码给客户端。</p>
<p><strong>client_body_timeout time</strong>：设置读取客户端内容体超时时间，默认为60s，此超时时间指的是两次成功读操作间隔时间，而不是发送整个请求体的超时时间，如果在此超时时间内客户端没有发送任何请求体，则响应408（RequestTime-out）状态码给客户端。</p>
<p><strong>send_timeout time</strong>：设置发送响应到客户端的超时时间，默认为60s，此超时时间指的也是两次成功写操作间隔时间，而不是发送整个响应的超时时间。如果在此超时时间内客户端没有接收任何响应，则Nginx关闭此连接。</p>
<p>**keepalive_timeout timeout [header_timeout]**：设置HTTP长连接超时时间，其中，第一个参数timeout是告诉Nginx长连接超时时间是多少，默认为75s。第二个参数header_timeout是用于设置响应头“Keep-Alive: timeout=time”，即告知客户端长连接超时时间。如果timeout设置为0，则表示禁用长连接。</p>
<p>2、DNS解析超时</p>
<p><strong>resolver_timeout 30s</strong>：设置DNS解析超时时间，默认为30s</p>
<p>3、代理超时</p>
<p>主要有三组配置：网络连接/读/写超时设置、失败重试机制设置、upstream存活超时设置</p>
<p><strong>proxy_connect_timeout time</strong>：与后端/上游服务器建立连接的超时时间，默认为60s，此时间不超过75s。</p>
<p><strong>proxy_read_timeout time</strong>：设置从后端/上游服务器读取响应的超时时间，默认为60s，此超时时间指的是两次成功读操作间隔时间，而不是读取整个响应体的超时时间，如果在此超时时间内上游服务器没有发送任何响应，则Nginx关闭此连接。</p>
<p><strong>proxy_send_timeout time</strong>：设置往后端/上游服务器发送请求的超时时间，默认为60s，此超时时间指的是两次成功写操作间隔时间，而不是发送整个请求的超时时间，如果在此超时时间内上游服务器没有接收任何响应，则Nginx关闭此连接。</p>
<p><strong>proxy_next_upstream_tries number</strong>：设置重试次数，默认0表示不限制，注意此重试次数指的是所有请求次数（包括第一次和之后的重试次数之和）。</p>
<p><strong>proxy_next_upstream_timeout time</strong>：设置重试最大超时时间，默认0表示不限制。</p>
<p>Nginx超时配置：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiao__jia__jia/article/details/124075274">https://blog.csdn.net/xiao__jia__jia/article/details/124075274</a></p>
<h2 id="PoolingHttpClientConnectionManager"><a href="#PoolingHttpClientConnectionManager" class="headerlink" title="PoolingHttpClientConnectionManager"></a>PoolingHttpClientConnectionManager</h2><p>HttpClien高并发请求连接池 - PoolingHttpClientConnectionManager</p>
<p>连接池：<br>连接池技术作为创建和管理连接的缓冲池技术，目前已广泛用于诸如数据库连接等长连接的维护和管理中，能够有效减少系统的响应时间，节省服务器资源开销。其优势主要有两个：其一是减少创建连接的资源开销，其二是资源的访问控制。连接池管理的对象是长连接。</p>
<p>PoolingHttpClientConnectionManager是通过租用连接和收回链接的方式来实现的。解决了http请求的多线程问题。</p>
<p>依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>实现http连接池：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34484062/article/details/109470135">https://blog.csdn.net/qq_34484062/article/details/109470135</a></p>
<h2 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h2><p>远程过程调用（Remote Procedure Call，缩写为 RPC）允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，比如 Java RMI。</p>
<p>远程过程调用是一个分布式计算的客户端-服务器（Client/Server）的例子，它简单而又广受欢迎。 远程过程调用总是由客户端对服务器发出一个执行若干过程请求，并用客户端提供的参数。执行结果将返回给客户端。 由于存在各式各样的变体和细节差异，对应地派生了各式远程过程调用协议，而且它们并不互相兼容。</p>
<p>为了允许不同的客户端均能访问服务器，许多标准化的 RPC 系统应运而生了。其中大部分采用接口描述语言（Interface Description Language，IDL），方便跨平台的远程过程调用。<br>有些实现扩展了远程调用的模型，实现了双向的服务调用，但是不管怎样，调用过程还是由一个客户端发起，服务器端提供响应，基本模型没有变化。</p>
<p>服务的调用过程为：<br>1、client调用client stub，这是一次本地过程调用<br>2、client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做 marshalling<br>3、client所在的系统将消息发送给server<br>4、server的的系统将收到的包传给server stub<br>5、server stub解包得到参数。 解包也被称作 unmarshalling<br>6、最后server stub调用服务过程. 返回结果按照相反的步骤传给client</p>
<hr>
<p>RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存。</p>
<p>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。<strong>HTTP 调用其实也可以看成是一种特殊的 RPC，只不过传统意义上的 RPC 是指长连接数据交互，而 HTTP 一般是指即用即走的短链接。</strong></p>
<p>RPC 在我们熟知的各种中间件中都有它的身影。Nginx/Redis/MySQL/Dubbo/Hadoop/Spark/Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的，我们<strong>这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术</strong>。RPC 在技术中的地位好比我们身边的空气，它无处不在，但是又有很多人根本不知道它的存在。</p>
<p>例如数据库：<br>子系统和数据库之间的交互也是通过 RPC 进行的，只不过这里是三个子系统之间复杂的组合消息交互罢了。如果再深入进去，你会发现，这里的数据库不是那种单机数据库，而是具备主从复制功能的数据库，比如 MySQL。在互联网企业里一般都会使用这种主从读写分离的数据库。一个业务子系统将数据写往主库，主库再将数据同步到从库，然后另一个业务子系统又从从库里将数据取出来。这时又可以进一步将它们看成是四个子系统之间进行的更加复杂的 RPC 数据交互。</p>
<hr>
<p>一些分布式场景中RPC的使用：（广义上的RPC）</p>
<p>✅nginx<br>Ngnix 是互联网企业使用最为广泛的代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互。也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。不过 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</p>
<p>✅Hadoop<br>在大数据技术领域，RPC 也占据了非常重要的地位。大数据领域广泛应用了非常多的分布式技术，分布式意味着节点的物理隔离，隔离意味着需要通信，通信意味着 RPC 的存在。大数据需要通信的量比业务系统更加庞大，所以在数据通信优化上做的更深。比如最常见的 Hadoop 文件系统 hdfs，一般包括一个 NameNode 和多个 DataNode，NameNode 和 DataNode 之间就是通过一种称为 Hadoop RPC 的二进制协议进行通讯。</p>
<p>✅TensorFlow<br>在人工智能领域，RPC 也很重要，著名的 TensorFlow 框架如果需要处理上亿的数据，就需要依靠分布式计算力，需要集群化，当多个分布式节点需要集体智慧时，就必须引入 RPC 技术进行通讯。Tensorflow Cluster 的 RPC 通讯框架使用了 Google 内部自研的 gRPC 框架。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/machh03/server/2096716">https://www.kancloud.cn/machh03/server/2096716</a><br>里面还有实现rpc</p>
<h2 id="理解http和rpc"><a href="#理解http和rpc" class="headerlink" title="理解http和rpc"></a>理解http和rpc</h2><p>HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 KeepAlive 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</p>
<p>当 HTTP 协议进化到 2.0 之后，Google 开源了一个建立在 HTTP2.0 协议之上的通信框架直接取名为 gRPC，也就是 Google RPC，这时 HTTP 和 RPC 之间已经没有非常明显的界限了。</p>
<p>HTTP 与 RPC 的关系就好比普通话与方言的关系。要进行跨企业服务调用时，往往都是通过 HTTP API，也就是普通话，虽然效率不高，但是通用，没有太多沟通的学习成本。但是在企业内部还是 RPC 更加高效，同一个企业公用一套方言进行高效率的交流，要比通用的 HTTP 协议来交流更加节省资源。整个中国有非常多的方言，正如有很多的企业内部服务各有自己的一套交互协议一样。好比开源 RPC 协议中 Protobuf 和 Thrift 一样，它们两应该是 RPC 协议中使用最为广泛的两个。</p>
<p>rpc基于什么实现网络传输？<br>1.rpc可以基于tcp直接开发自己的协议，这个是可以保持长连接的，tcp的传输效率高，并且可以一直维持链接</p>
<p>2.自定义协议可以优化数据的传输，例如更大的压缩比。分布式系统中非常有用。</p>
<p>3.http协议1.x一般情况下一个来回就关闭连接，虽然提供了keep-alive可以保持长连接，但是依然不方便，所以就出现了http2.0， http2.0基本上可以当做tcp协议使用了。所以grpc就会使用http2.0开发。</p>
<h2 id="rest和restful"><a href="#rest和restful" class="headerlink" title="rest和restful"></a>rest和restful</h2><p>REST，英文全称Representational State Transfer（表述性状态转移），是一组架构约束条件和原则（注意，REST是设计风格而不是标准）。满足这些约束条件和原则的应用程序或设计就是RESTful。可以降低开发的复杂性，提高系统的可伸缩性。体现在Web开发中就是通过HTTP方法中的POST、DELETE、PUT、GET来对资源进行操作。</p>
<p>一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>在 REST 样式的 Web 服务中，每个资源都有一个地址。资源本身都是方法调用的目标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 HTTP GET、POST、PUT、DELETE，还可能包括 HEADER 和 OPTIONS。</p>
<p>Representation（表现层）<br>资源的信息载体形式。它可以是文本、XML、JSON或者是一个二进制文件。它的表现形式应该在HTTP请求的头信息中用Accept和Content-Type字段指定描述。</p>
<p>State Transfer（状态转移）<br>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转移”。</p>
<p>在 HTTP 中，我们一般通过四种 HTTP 动词来对应资源的变化：<br>POST（新建资源，也可用于更新资源）<br>DELETE（删除资源）<br>PUT（更新资源）<br>GET（获取资源）</p>
<p>REST架构原则：<br>对网络上所有资源都有一个资源标识符<br>对资源的操作不会改变标识符<br>同一资源有多种表现形式，如XML、JSON…<br>所有操作都是无状态的（Stateless）</p>
<p>RESTful，是一种网络应用程序的设计风格和开发方式。RESTful可以通过一套统一的接口为Web，iOS和Android提供服务。比如微博开放平台，微信开放平台等，它们不需要有显式的前端，只需要一套提供服务的接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">在使用RESTful风格之前，我们通常是这样操作用户数据:</span><br><span class="line">//创建用户信息</span><br><span class="line">http://localhost:8080/user/createUser</span><br><span class="line">//删除id为1的用户信息</span><br><span class="line">http://localhost:8080/user/deleteUser/1</span><br><span class="line">//修改id为2的用户信息</span><br><span class="line">http://localhost:8080/user/updateUser/2</span><br><span class="line">//获取所有用户信息</span><br><span class="line">http://localhost:8080/user/getUsers</span><br><span class="line"></span><br><span class="line">使用RESTful风格之后:</span><br><span class="line">//创建用户信息</span><br><span class="line">POST http://localhost:8080/user</span><br><span class="line">//删除id为1的用户信息</span><br><span class="line">DELETE http://localhost:8080/user/1</span><br><span class="line">//修改id为2的用户信息</span><br><span class="line">PUT http://localhost:8080/user/2</span><br><span class="line">//获取所有用户信息</span><br><span class="line">GET http://localhost:8080/user获取所有用户信息</span><br><span class="line">通过约定不同的HTTP方法来实现不同的业务，有一个更加直观的了解。</span><br><span class="line">1、看URL就知道要操作什么</span><br><span class="line">2、看HTTP方法就知道要如何操作</span><br><span class="line">3、看HTTP状态码就知道返回结果如何</span><br></pre></td></tr></table></figure>

<p>参考：<br>rest与restful：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44316527/article/details/106276655">https://blog.csdn.net/weixin_44316527/article/details/106276655</a></p>
<hr>
<p>rpc与restful：</p>
<p>RPC（Remote Procedure Call Protocol）就是远程调用。最简单的想法，应该就是把HTTP协议当做RPC来用。比如我们把网址作为一个借口，传入的参数作为函数参数，response的数据作为返回信息。这其实就是一个调用。</p>
<p>RESTful和RPC最大的区别应该就是面向对象了。<br>从设计上来看，RPC，所谓的远程过程调用 ，是面向方法的 ；<br>REST：所谓的 Representational state transfer ，是面向资源的；<br>除此之外，还有一种叫做 SOA，所谓的面向服务的架构，它是面向消息的。<br>很多人只知道GET和POST，因为现在最常用的就是GET和POST了。虽说这应该是违背了HTTP设计的初衷。</p>
<p>序列化协议的区别：<br>接口调用通常包含两个部分，序列化和通信协议。<br>通信协议，上面已经提及了，REST 是 基于 HTTP 协议，而 RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输的。<br>常见的序列化协议，有：json、xml、hession、protobuf、thrift、text、bytes等，REST 通常使用的是 JSON或者XML，而 RPC 使用的是 JSON-RPC，或者 XML-RPC。</p>
<p>什么时候用？<br>REST 接口更加规范，通用适配性要求高，建议对外的接口都统一成 REST。而组件内部的各个模块，可以选择 RPC，一个是不用耗费太多精力去开发和维护多套的HTTP接口，一个RPC的调用性能更高。从性能角度看，由于HTTP本身提供了丰富的状态功能与扩展功能，但也正由于HTTP提供的功能过多，导致在网络传输时，需要携带的信息更多，从性能角度上讲，较为低效。而RPC服务网络传输上仅传输与业务内容相关的数据，传输数据更小，性能更高。</p>
<p>转自：<br><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/53677">https://developer.aliyun.com/article/53677</a></p>
<hr>
<p>restful和http：</p>
<p>REST 是一种软件架构风格。这种风格的典型应用，就是HTTP。其因为简单、扩展性强的特点而广受开发者的青睐。</p>
<p>某种意义下，我们说 REST 可以其实就是指代 HTTP 协议。</p>
<hr>
<p>总结：rpc、http、rest</p>
<p>rpc是一种协议还是，还是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想？更是后者<br>rpc包含：服务发现、负载、容器、网络传输、序列化等组件。<br>rpc指明了程序如何进行网络传输和序列化。</p>
<p>关于rpc和http的比较：<br>rpc的网络传输是如何实现的，rpc是连接，http是短连接。<br>http是一种rpc（广义上），还是rpc可以基于http实现？<br>RPC可以基于TCP协议也可以基于HTTP协议。<br>HTTP需要携带的信息更多，低效，RPC仅传输与业务相关的数据，传输数据更小，性能更高</p>
<p>关于rpc和restful的比较：<br>rpc面向方法，restful面向资源。<br>日常写的接口，更多基于rpc面向方法的，虽然有的是rpc接口，有的是http接口。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/10/myblog/JAVA/java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/10/myblog/JAVA/java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">java诊断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-10 23:39:58" itemprop="dateCreated datePublished" datetime="2022-09-10T23:39:58+08:00">2022-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-18 17:10:54" itemprop="dateModified" datetime="2023-01-18T17:10:54+08:00">2023-01-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="java诊断工具arthas"><a href="#java诊断工具arthas" class="headerlink" title="java诊断工具arthas"></a>java诊断工具arthas</h2><h3 id="✅简介"><a href="#✅简介" class="headerlink" title="✅简介"></a>✅简介</h3><p>Arthas 是Alibaba开源的Java诊断工具。安装在系统所在服务器。可以帮助开发人员或者运维人员查找问题，分析性能，bug追踪。</p>
<p>解决问题：<br>1、以全局视角来查看系统的运行状况、健康状况。<br>2、反编译源码，查看jvm加载的是否为预期的文件内容。<br>3、查看某个方法的返回值，参数等等。<br>4、方法内调用路径及各方法调用耗时。<br>5、查看jvm运行状况。<br>6、外部.class文件重新加载到jvm里。<br>等等…..</p>
<p>场景：<br>1）调用接口时，接口返回异常信息，如果该异常信息没有清晰的定位到代码，那么我们通常只能依靠大脑回忆代码，来估计错误发生地了，如果无法估计，一般情况下就会进入测试环境，模拟复现，如果无法复现。<br>2）这个查询，耗时20s，我们想要分析一下到底是哪些代码导致的。但是该方法内部又穿插调用了其它业务功能方法，难道手写System.currentTimeMillis()自己做减运算，还是guava的StopWatch亦或是commons的StopWatch？这几种方式需要我们手动嵌入代码，容易遗漏、费力还费时。<br>等等<br>arthas可以为我们解决上述问题，帮助程序员尽早下班，尽早交代。</p>
<h3 id="✅安装启动"><a href="#✅安装启动" class="headerlink" title="✅安装启动"></a>✅安装启动</h3><p>下载: wget <a target="_blank" rel="noopener" href="https://alibaba.github.io/arthas/arthas-boot.jar">https://alibaba.github.io/arthas/arthas-boot.jar</a><br>启动: java -jar arthas-boot.jar</p>
<p>退出arthas<br>quit —— 退出当前 Arthas 客户端，其他 Arthas 客户端不受影响<br>shutdown —— 关闭 Arthas 服务端，所有 Arthas 客户端全部退出 &amp; 重置所有增强过的类，就不用单独调用reset</p>
<h3 id="✅应用"><a href="#✅应用" class="headerlink" title="✅应用"></a>✅应用</h3><p>1、查看某方法耗时</p>
<p><code>trace cn.asae.e.contract.web.ContractController getContract</code></p>
<p>2、显示进程相关信息，仪表盘</p>
<p><code>dashboard</code></p>
<p>3、查看类里某个方法的返回值和入参</p>
<p>命令+类完全限定名+监测方法+表达式<br><code>watch cn.asae.e.contract.web.ContractSubjectController getContractSubjectLogs &quot;&#123;params,returnObj&#125;&quot;</code></p>
<p>4、时空隧道</p>
<p>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</p>
<p><code>tt -t cn.asae.e.contract.web.ContractSubjectController getContractSubjectLogs</code><br>-t 代表记录下每次方法执行情况</p>
<p>5、查看JVM已加载的类信息</p>
<p><code>sc -d cn.asae.e.contract.web.ContractSubjectController</code></p>
<p>-d 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。<br>如果一个类被多个ClassLoader所加载，则会出现多次</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiawen010/p/15513454.html">https://www.cnblogs.com/jiawen010/p/15513454.html</a></p>
<p>其他：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37650458/article/details/123561000">https://blog.csdn.net/weixin_37650458/article/details/123561000</a></p>
<h2 id="fullGC"><a href="#fullGC" class="headerlink" title="fullGC"></a>fullGC</h2><h3 id="✅什么是GC-amp-heap分区"><a href="#✅什么是GC-amp-heap分区" class="headerlink" title="✅什么是GC &amp; heap分区"></a>✅什么是GC &amp; heap分区</h3><p>Java垃圾回收机制，Java通过可达性分析一个对象的引用是否存在，当不存在的时候，将回收堆中的对象。回收无用内存空间</p>
<p>一般而言，GC主要是针对运行的数据区的。作为程序员要关注的区域主要有5块，分别是方法区(Method Area)，Java栈(Java stack)，本地方法栈(Native Method Stack)，堆(Heap)，程序计数器(Program Counter Register)。实际jvm在管理内存的时候，比这个分的更细致，只不过做应用程序开发，我们只需要关注这5块就可以了。</p>
<p>“堆”，也就是Heap了，它是Jvm管理的内存中最大的一块。程序的主要数据也都是存放在堆内存中的，也就是说程序所创建的对象基本上都在该区域进行内存分配，这一块区域被所有的线程所共享，通常出现线程安全问题的一般都是这个区域的数据出现的问题。通常我们所说的gc主要是针对java heap这块区域的。</p>
<p>Heap区在设计上是分代设计的，其划分为了Eden、Survivor 和 Tenured/Old ，其中Eden区、Survivor(存活)属于年轻代，Tenured/Old区属于老年代或者持久代。</p>
<p>一般我们将年轻代发生的GC称为Minor GC，对老年代进行GC称为Major GC。</p>
<p>而FullGC是对整个堆来说的，在最近几个版本的JDK里默认包括了对永生带即方法区的回收(JDK8中无永生带了)，出现Full GC的时候经常伴随至少一次的Minor GC,但非绝对的。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<hr>
<p>JVM的堆区对象分配的一般规则：</p>
<ol>
<li><p>对象优先在Eden区分配，当eden不够分配时，进行一次minor gc。（java对象大多很快没掉，所以minor gc很频繁）</p>
</li>
<li><p>大对象直接进入老年代(-XX:PretenureSizeThreshold=3145728 这个参数来定义多大的对象直接进入老年代)</p>
</li>
<li><p>长期存活的对象将进入老年代(-XX:MaxTenuringThreshold=1设置晋升老年代的年龄阈值)</p>
</li>
<li><p>动态对象年龄判定：虚拟机并不会永远地要求对象的年龄都必须达到MaxTenuringThreshold才能晋升老年代，如果Survivor空间中相同年龄的所有对象的大小总和大于Survivor的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</p>
</li>
<li><p>空间分配担保：计算新生代minor gc后剩下的对象若survivor无法容纳，是否能通过老年代来担保分配空间，如果不能，需要触发一次full gc。HandlePromotionFailure=false设置是否允许老年代担保。</p>
</li>
<li><p>只要老年代的连续空间大于(新生代所有对象的总大小或者历次晋升的平均大小)就会进行minor GC，否则会进行full GC。</p>
</li>
</ol>
<h3 id="✅FullGC的触发条件"><a href="#✅FullGC的触发条件" class="headerlink" title="✅FullGC的触发条件"></a>✅FullGC的触发条件</h3><p>FullGC是针对整个Heap区而言的，它将在以下几种情况被触发：</p>
<p>1、在程序中调用了System.gc()方法。此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过<code>-XX:+ DisableExplicitGC</code>来禁止RMI(Java远程方法调用)调用System.gc。</p>
<p>2、老年代空间不足。老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误【java.lang.OutOfMemoryError: Java heap space】，而为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<p>3、Permanet Generation空间满了。也就是以前所说的方法区，Permanet Generation中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC（concurrent mark sweep 标记清除算法）的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出错误信息：java.lang.OutOfMemoryError: PermGen space 。为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
<p>4、通过Minor GC后进入老年代的平均大小大于老年代的可用内存。如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。分配很大的对象。所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但停顿时间不得不变长了，JVM设计者们还提供了另外一个参数 <code>-XX:CMSFullGCsBeforeCompaction</code>，这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。</p>
<h3 id="✅分代收集算法"><a href="#✅分代收集算法" class="headerlink" title="✅分代收集算法"></a>✅分代收集算法</h3><p>针对年轻代和老年代，JVM将使用不同的垃圾收集算法进行收集，达到高效的垃圾回收。</p>
<p>1、年轻代采用的是标记-复制算法，将需要回收的对象标记，将不需要的对象移动到Survivor空间，然后将标记对象回收，该算法可以实现对大多数会失效的对象进行回收，对少部分不需要回收的对象进行转移，保证eden区拥有连续的内存空间，而且复制的效率高。</p>
<p>因为在年轻代不需要回收的对象一般是很少的，每次垃圾收集时都有大批对象死去，只有少量存活，选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>2、老年代采用的是标记-整理算法，将需要回收的对象标记，将不需要的对象进行移动整理，使不需要回收的对象占用连续的内存空间，再清除回收对象，保证老年代拥有连续的内存空间，而且整理效率高。</p>
<p>因为在老年代需要回收的对象一般是很少的，其存活率较高、没有额外空间对它进行分配担保。</p>
<p>3、CMS GC（concurrent mark sweep 标记清除算法）老年代中使用：标记所有需要回收的对象，在标记完后统一回收。缺点：标记清除效率不高，产生碎片多。但是并发收集，低停顿。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_35291771/article/details/114075710">https://blog.csdn.net/weixin_35291771/article/details/114075710</a></p>
<p>探秘Java虚拟机——内存管理与垃圾回收：<br><a target="_blank" rel="noopener" href="http://www.blogjava.net/chhbjh/archive/2012/01/28/368936.html">http://www.blogjava.net/chhbjh/archive/2012/01/28/368936.html</a></p>
<h3 id="✅什么是fullgc"><a href="#✅什么是fullgc" class="headerlink" title="✅什么是fullgc"></a>✅什么是fullgc</h3><p>一些概念：</p>
<p>GC<br>GC 全称为garbage collection,中文含义为垃圾回收，在jvm中的含义为回收无用内存空间</p>
<p>Young space<br>中文名为年轻代或者新生代，为JVM 堆的一部分，由分代GC概念划分而来，保存生命周期较短的对象</p>
<p>Tenured space<br>中文名为老年代或年老代，为JVM 堆的一部分，由分代GC概念划分而来，保存生命周期较长的对象</p>
<p>Minor GC<br>minor gc指的是发生在年轻代或者说新生代（Young space）中的gc，也有人称其为young gc或者ygc,在下文中我们统一使用minor gc表示</p>
<p>Major GC<br>major gc指的是发生在老年代（Tenured space）中的gc，也有人称为old gc,o gc,cms gc等，在下文我们统一使用major gc表示</p>
<p>stop the world<br>指的是用户线程在运行至安全点（safe point）或安全区域（safe region）之后，就自行挂起，进入暂停状态，对外的表现看起来就像是全世界都停止运转了一样,而不论何种gc算法，不论是minor gc还是major gc都会stop the world，区别只在于stop the world的时间长短。</p>
<p><strong>什么是Full GC</strong></p>
<p>先说一下结论，Full GC这个概念是没有官方定义的，而且含义还特别混乱，在不同地方表达的含义是不同的，需要就不同的场景分别进行讨论。</p>
<p>大众认知上：<br>在通常意义上人们口中说的Full GC为一次特殊GC行为的描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace等，这个是最常见的一种认知，很多人也就了解到这个程度，因此在遇到一些特殊场景的时候就会发现实际情况和自己的认知会发生冲突</p>
<p>从GC日志上：<br>在gc.log中会发现在部分gc日志头中也有Full GC这样的字眼，这里表示的含义是在这次GC的全过程中，都是Stop The world的状态，也就是说在这次GC的全过程中所有用户线程都是处于暂停的状态</p>
<p>阿里老哥总结的：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kep159/article/details/103088438">https://blog.csdn.net/kep159/article/details/103088438</a></p>
<h3 id="✅jstat查看GC"><a href="#✅jstat查看GC" class="headerlink" title="✅jstat查看GC"></a>✅jstat查看GC</h3><p><strong>使用jstat 查出来的FGC 次数和时间，实际上指的是老年代的收集器发生Stop the world 的次数和持续时间</strong></p>
<p>1、查询GC使用情况：<br><code>jstat -gcutil 23484 1000 5</code></p>
<p>1000是间隔时间，5是总共打印5次，可缺省。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">68.75   0.00  62.73   0.17  96.39  90.54      2    0.010     0    0.000    0.010</span><br><span class="line"></span><br><span class="line">S0: 新生代中Survivor space 0区已使用空间的百分比</span><br><span class="line">S1: 新生代中Survivor space 1区已使用空间的百分比</span><br><span class="line">E: 新生代已使用空间的百分比</span><br><span class="line">O: 老年代已使用空间的百分比</span><br><span class="line">M：元数据区使用比例</span><br><span class="line">CCS：压缩使用比例</span><br><span class="line">YGC: 从应用程序启动到当前，发生Yang GC 的次数</span><br><span class="line">YGCT: 从应用程序启动到当前，Yang GC所用的时间【单位秒】</span><br><span class="line">FGC: 从应用程序启动到当前，发生Full GC的次数</span><br><span class="line">FGCT: 从应用程序启动到当前，Full GC所用的时间</span><br><span class="line">GCT: 从应用程序启动到当前，用于垃圾回收的总时间【单位秒】</span><br></pre></td></tr></table></figure>

<p>2、垃圾总体回收统计<br><code>jstat -gc 91185 1000 5</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 68.75   0.00  62.73   0.17  96.39  90.54      2    0.010     0    0.000    0.010</span><br><span class="line"></span><br><span class="line">S0C：第一个幸存区的大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">S0U：第一个幸存区的使用大小</span><br><span class="line">S1U：第二个幸存区的使用大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">EU：伊甸园区的使用大小</span><br><span class="line">OC：老年代大小</span><br><span class="line">OU：老年代使用大小</span><br><span class="line">MC：方法区大小</span><br><span class="line">MU：方法区使用大小</span><br><span class="line">CCSC:压缩类空间大小</span><br><span class="line">CCSU:压缩类空间使用大小</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">YGCT：年轻代垃圾回收消耗时间</span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure>

<p>3、新生代垃圾回收统计<br><code>jstat -gcnew 91185 1000 5</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line">5120.0 5120.0 3520.2    0.0  7  15 5120.0  33280.0  20877.8      2    0.010</span><br><span class="line"></span><br><span class="line">S0C：第一个幸存区大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">S0U：第一个幸存区的使用大小</span><br><span class="line">S1U：第二个幸存区的使用大小</span><br><span class="line">TT:对象在新生代存活的次数</span><br><span class="line">MTT:对象在新生代存活的最大次数</span><br><span class="line">DSS:期望的幸存区大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">EU：伊甸园区的使用大小</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">YGCT：年轻代垃圾回收消耗时间</span><br></pre></td></tr></table></figure>

<p>4、堆内存统计<br><code>jstat -gccapacity 18528 1000 5 //整体统计</code><br><code>jstat -gcnewcapacity 18528 1000 5 //新生代统计</code><br><code>jstat -gcoldcapacity 18528 1000 5 //老年代统计</code></p>
<h2 id="java堆栈"><a href="#java堆栈" class="headerlink" title="java堆栈"></a>java堆栈</h2><h3 id="✅java内存空间"><a href="#✅java内存空间" class="headerlink" title="✅java内存空间"></a>✅java内存空间</h3><p>JAVA在程序运行时，在内存中划分5片空间进行数据的存储。分别是：1：程序计数器。2：本地方法栈。3：方法区。4：栈。5：堆。<br>堆和栈都是Java用来在RAM中存放数据的地方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">程序计数器：线程私有，存储当前线程所执行的字节码行号指示器。</span><br><span class="line">循环、跳转、异常处理、线程恢复等基础功能都依赖该计数器。溢出概率极低。</span><br><span class="line"></span><br><span class="line">java虚拟机栈：线程私有。局部变量表的大小在编译器确定。</span><br><span class="line">方法的相关调用信息、变量信息，对象的引用。</span><br><span class="line">会抛出：StackOverflowError和OutOfMemoryError</span><br><span class="line"></span><br><span class="line">本地方法栈：为本地方法所服务</span><br><span class="line"></span><br><span class="line">java堆：线程共享区域，存储对象实例及数组。有可能抛出OutOfMemoryError</span><br><span class="line"></span><br><span class="line">方法区：线程共享区域，存储已被虚拟机加载的类信息、常量、静态变量，即时变异后的代码。</span><br><span class="line">又叫永久代，java8中逐步取消，被metaspace元数据区取代。有可能抛出OutOfMemoryError</span><br><span class="line"></span><br><span class="line">直接内存：NIO机制，使用Native函数库直接分配堆外内存。</span><br></pre></td></tr></table></figure>

<p>1、堆</p>
<p>可以把堆理解为一家餐厅，里面有200张桌子，也就是最多能同时容纳200桌客人就餐，来一批客人就为他们安排一些桌子，如果某天来的客人特别多，超过200桌了，那就不能再接待超出的客人了。</p>
<p>当然，进来吃饭的客人不可能是同时的，有的早，有的晚，先吃好的客人，老板会安排给他们结账走人，然后空出来的桌子又能接待新的客人。</p>
<p>这里，堆就是餐厅，最大容量200桌就是堆内存的大小，老板就相当于GC(垃圾回收)，给客人安排桌子就相当于java创建对象的时候分配堆内存，结账就相当于GC回收对象占用的空间。</p>
<p>2、栈</p>
<p>接着把栈比作一口废井，这口井多年不用已经没水了，主人现在把它作为贮存自酿酒的地方，存酒的时候就用绳子勾着酒坛子慢慢放下去，后面再存就一坛一坛堆着放上去，取酒的时候就先取最上面的坛子。</p>
<h3 id="✅什么时候存到堆Heap里"><a href="#✅什么时候存到堆Heap里" class="headerlink" title="✅什么时候存到堆Heap里"></a>✅什么时候存到堆Heap里</h3><p>存放：存放由new创建的对象和数组。</p>
<p>在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，会在栈中定义一个引用变量，这个变量的取值等于数组或者对象在堆内存中的首地址，引用变量相当于为数组或者对象起的一个别名，或者代号。</p>
<p>数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!</p>
<p>堆内存的特点是什么？<br>第一点：堆其实可以类似的看做是管道，或者说是平时去排队买票的情况差不多，所以堆内存的特点就是：先进先出，后进后出，也就是你先排队好，你先买票。<br>第二点：堆可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，但缺点是，由于要在运行时动态分配内存，存取速度较慢。<br>new对象在堆中如何分配？<br>由Java虚拟机的自动垃圾回收器来管理。</p>
<h3 id="✅什么时候存到栈Stack里"><a href="#✅什么时候存到栈Stack里" class="headerlink" title="✅什么时候存到栈Stack里"></a>✅什么时候存到栈Stack里</h3><p>存放：在函数中定义的一些基本类型的变量(8种，int, short, long, byte, float, double, boolean, char，不包含String)和对象的引用变量、main方法、方法函数</p>
<p>当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。</p>
<p>栈内存的特点<br>第一点：栈内存就好像一个矿泉水瓶，往里面放入东西，那么先放入的沉入底部，所以它的特点是：先进后出，后进先出<br>第二点：存取速度比堆要快，仅次于寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p>
<p>栈中主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和对象句柄。<br>栈内存分配机制<br>栈内存可以称为一级缓存，由垃圾回收器自动回收<br>例子：<br>int a = 3;<br>int b = 3;</p>
<h3 id="✅堆栈的区别"><a href="#✅堆栈的区别" class="headerlink" title="✅堆栈的区别"></a>✅堆栈的区别</h3><p>JVM是基于堆栈的虚拟机，JVM为新创建的线程都分配一个堆栈，也就是说，对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作：以帧为单位的压栈和出栈操作。</p>
<p>差异：<br>1). 堆内存用来存放由new创建的对象和数组<br>2). 栈内存用来存放方法或者局部变量等<br>3). 堆是先进先出，后进后出<br>4). 栈是先进后出，后进先出<br>5). 共享性的不同：栈内存是线程私有的，<strong>堆内存是所有线程共有的</strong><br>6). 生存空间不同：栈中数据的生存空间一般在当前scopes内(就是由{…}括起来的区域).</p>
<p>栈：</p>
<p>函数中定义的基本类型变量，对象的引用变量都在函数的栈内存中分配。<br>栈内存特点，数数据一执行完毕，变量会立即释放，节约内存空间。<br>栈内存中的数据，没有默认初始化值，需要手动设置。</p>
<p>堆：</p>
<p>堆内存用来存放new创建的对象和数组。<br>堆内存中所有的实体都有内存地址值。<br>堆内存中的实体是用来封装数据的，这些数据都有默认初始化值。<br>堆内存中的实体不再被指向时，JVM启动垃圾回收机制，自动清除，这也是JAVA优于C++的表现之一（C++中需要程序员手动清除）</p>
<h3 id="✅String-str-“abc”的内部工作"><a href="#✅String-str-“abc”的内部工作" class="headerlink" title="✅String str = “abc”的内部工作"></a>✅String str = “abc”的内部工作</h3><p>(1)先定义一个名为str的对String类的对象引用变量：String str；</p>
<p>(2)在栈中查找有没有存放值为”abc”的地址（引用），如果没有，则在栈中开辟一个存放字面值为”abc”的地址，接着在堆中创建一个新的String类的对象“abc”，并将该字符串指向这个地址，而且在栈中这个地址旁边记下这个引用的对象“abc”。如果已经有了值为”abc”的地址，则查找对象“abc”，并返回“abc”的地址。</p>
<p>(3)将str指向对象“abc”的地址。</p>
<p>值得注意的是，一般String类中字符串值都是直接存值的。但像String str = “abc”；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！<br><strong>（有点问题，指向的是堆中的字符串常量池里的字符串吧？？）</strong></p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = “abc”;  </span><br><span class="line">String str2 = “abc”;  </span><br><span class="line">System.out.println(str1==str2); //true</span><br></pre></td></tr></table></figure>

<p>str1.equals(str2)；的方式是将比较两个字符串的值是否相等。==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。<br>结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。实现堆中数据的共享。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = “abc”;  </span><br><span class="line">String str2 = “abc”;  //没创建新对象，创建了一个新引用变量</span><br><span class="line">str1 = “bcd”;   //改变值，只能创建一个新对象，引用变量指向新的对象</span><br><span class="line">System.out.println(str1 + “,” + str2); //bcd, abc  </span><br><span class="line">System.out.println(str1==str2); //false</span><br></pre></td></tr></table></figure>

<p>赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为”bcd”时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。</p>
<p>💡原因：事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = new String(“abc”);</span><br><span class="line">String str2 = “abc”;</span><br><span class="line">System.out.println(str1==str2); //false</span><br></pre></td></tr></table></figure>

<p>💡原因：只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。<br><strong>（与字符串常量池共享吧？）</strong></p>
<p><strong>意思是：String str = “abc” 的创建对象方式，会在栈中保存“abc”。（字符串常量池中吧？）如果多次这样创建一个值的String对象，会先去栈里看有没有，如果有，堆里就不新建对象了，栈里新建一个引用变量指向那个对象，如果没有就新建，但是new方式不会看，都是新建。</strong></p>
<p>结论：</p>
<p>(1)我们在使用诸如String str = “abc”; 的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为”abc”的String对象。</p>
<p>(2)使用String str = “abc”; 的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(“abc”); 的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。</p>
<p>(3)当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==。</p>
<p>(4)由于String类的不可改变immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。</p>
<p>参考：<br>程序中堆栈空间加载过程：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/229958.htm">https://www.jb51.net/article/229958.htm</a><br>堆栈区别、String创建过程：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/529280783">https://zhuanlan.zhihu.com/p/529280783</a></p>
<h3 id="String不可变怎么理解"><a href="#String不可变怎么理解" class="headerlink" title="String不可变怎么理解"></a>String不可变怎么理解</h3><p>看了一圈优点模糊，主要几个疑问：<br>1、<code>String s = &quot;abc&quot;;</code>，到底怎么个流程，已有的字符串怎么找到的。<br>2、字符串常量池在哪里存的。初步结论是java8在堆中。<br>3、运行时常量池和字符串常量池？</p>
<p><strong>看看jvm虚拟机再解惑吧</strong></p>
<p>string类为什么是不可变的：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuqinhou/article/details/126160186">https://blog.csdn.net/liuqinhou/article/details/126160186</a></p>
<p>String源码角度分析为什么不可变，通过反射的方法改变：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjg_blog/article/details/18319521">https://blog.csdn.net/zhangjg_blog/article/details/18319521</a></p>
<p>浅谈为什么Java里面String类是不可变的：<br><a target="_blank" rel="noopener" href="https://www.jb51.net/article/157814.htm">https://www.jb51.net/article/157814.htm</a></p>
<p>String是如何实现其对象不可变：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/498718374">https://zhuanlan.zhihu.com/p/498718374</a></p>
<p>Java 常量池详解（一）字符串常量池：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Prior_SX/article/details/123463430">https://blog.csdn.net/Prior_SX/article/details/123463430</a></p>
<p>字符串常量池和运行时常量池是在堆还是在方法区？<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cosmos-wong/p/12925299.html">https://www.cnblogs.com/cosmos-wong/p/12925299.html</a></p>
<p>Java8中字符串常量池到底是在哪里：<br><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_14234228/2489846">https://blog.51cto.com/u_14234228/2489846</a></p>
<h3 id="✅堆内存共享性问题"><a href="#✅堆内存共享性问题" class="headerlink" title="✅堆内存共享性问题"></a>✅堆内存共享性问题</h3><p>问题来源：既然各个java进程共享堆内存，那么看fullgc的情况跟哪个进程线程有什么关系呢？</p>
<p>没错，堆是全局共享的，但是会存在一些问题</p>
<p>就是多个线程在堆上同时申请空间，如果在并发的场景中，两个线程先后把对象引用指向了同一个堆的内存区域，那可能就会出现问题；为了解决这个问题呢，就得进行同步控制，说到同步控制，就会影响到效率。</p>
<p>为了解决这个并发问题，对象的内存分配过程就必须进行同步控制。<br>HotSpot虚拟机（HotSpot虚拟机是目前最流行的虚拟机）的方案：<br>每个线程在Java堆中预先分配一小块内存，然后在给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。<br>这种方案被称之为TLAB分配，即Thread Local Allocation Buffer。这部分Buffer是从堆中划分出来的，但是是本地线程独享的。</p>
<p><strong>TLAB</strong></p>
<p>TLAB是虚拟机在堆内存的eden划分出来的一块专用空间，是<strong>线程专属</strong>的。在虚拟机的TLAB功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，<strong>只给当前线程使用</strong>，这样<strong>每个线程都单独拥有一个空间</strong>，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。</p>
<p><strong>所以说，因为有了TLAB技术，堆内存并不是完完全全的线程共享，其eden区域中还是有一部分空间是分配给线程独享的。</strong></p>
<p>⚠️TLAB是线程独享的，但是只是在“分配”这个动作上是线程独享的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。也就是说，虽然每个线程在初始化时都会去堆内存中申请一块TLAB，并不是说这个TLAB区域的内存其他线程就完全无法访问了，其他线程的读取还是可以的，只不过无法在这个区域中分配内存而已。并且，在TLAB分配之后，并不影响对象的移动和回收，也就是说，虽然对象刚开始可能通过TLAB分配内存，存放在Eden区，但是还是会被垃圾回收或者被移到Survivor Space、Old Gen等。</p>
<p>⚠️TLAB带来的问题：<br>TLAB是在eden区分配的，因为eden区域本身就不太大，而且TLAB空间的内存也非常小，默认情况下仅占有整个Eden空间的1%。所以，必然存在一些大对象是无法在TLAB直接分配。<br>遇到TLAB中无法分配的大对象，对象还是可能在eden区或者老年代等进行分配的，但是这种分配就需要进行同步控制，这也是为什么我们经常说：小的对象比大的对象分配起来更加高效。<br>————————————————<br>为了解决这两个方案存在的问题，虚拟机定义了一个refill_waste的值，这个值可以翻译为“最大浪费空间”。</p>
<p>当请求分配的内存大于refill_waste的时候，会选择在堆内存中分配。若小于refill_waste值，则会废弃当前TLAB，重新创建TLAB进行对象内存分配。</p>
<p>总结：<br>为了保证对象的内存分配过程中的线程安全性，HotSpot虚拟机提供了一种叫做TLAB(Thread Local Allocation Buffer)的技术。</p>
<p>在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，当需要分配内存时，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。</p>
<p>所以，“堆是线程共享的内存区域”这句话并不完全正确，因为TLAB是堆内存的一部分，他在读取上确实是线程共享的，但是在内存分配上，是线程独享的。</p>
<p>TLAB的空间其实并不大，所以大对象还是可能需要在堆内存中直接分配。那么，对象的内存分配步骤就是先尝试TLAB分配，空间不足之后，再判断是否应该直接进入老年代，然后再确定是再eden分配还是在老年代分配。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jiey0407/article/details/125190629">https://blog.csdn.net/jiey0407/article/details/125190629</a></p>
<h2 id="jvm性能监控工具"><a href="#jvm性能监控工具" class="headerlink" title="jvm性能监控工具"></a>jvm性能监控工具</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>java virtual machine process status tool<br>jps 主要用来输出 JVM 中运行的进程状态信息</p>
<p>语法格式：<code>jps [options] [hostid]</code><br>如果不指定 hostid 就默认为当前主机或服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-q 不输出类名、Jar名和传入main方法的参数</span><br><span class="line">-m 输出传入main方法的参数</span><br><span class="line">-l 输出main类或Jar的全限名</span><br><span class="line">-v 输出传入JVM的参数</span><br></pre></td></tr></table></figure>

<p>jps命令获取实际的进程id，是去用户的临时目录下去拿进程id的。<br>文件路径：/tmp/hsperfdata_{userName}/，存储了当前用户的进程信息。</p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>stack trace for java 显示虚拟机的线程快照。<br>jstack 主要用来查看某个 Java 进程内的线程堆栈信息。</p>
<p>语法格式：<code>jstack [option] pid</code><br>如果是在64位机器上，需要指定选项”-J-d64”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</span><br><span class="line">-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）</span><br></pre></td></tr></table></figure>

<p>jstack 可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在 JVM 性能调优中使用得非常多。例如：找出某个 Java 进程中最耗费 CPU 的 Java 线程并定位堆栈信息。</p>
<p>第一步先找出 Java 进程 ID<br><code>ps -ef | grep 应用 | grep -v grep</code></p>
<p>第二步找出该进程内最耗费 CPU 的线程<br>可以使用 <code>ps -Lfp pid </code>或者 <code>ps -mp pid -o THREAD, tid, time</code> 或者 <code>top -Hp pid</code> .【有没有可以输出按时间排序的，且区分daemon的】</p>
<p>使用<code>printf &quot;%x\n&quot; 线程id</code> 将线程id转换为16进制值。</p>
<p><code>jstack 进程id | grep 16进制线程id</code><br>从而定位代码，可能是哪里wait时间长了。</p>
<p><code>jstack -l 进程id 查看进程下所有线程</code></p>
<hr>
<p>jstack打印的信息怎么看：<br>dump 文件里，值得关注的线程状态有：<br>死锁，Deadlock（重点关注）<br>执行中，Runnable<br>等待资源，Waiting on condition（重点关注）<br>等待获取监视器，Waiting on monitor entry（重点关注）<br>暂停，Suspended<br>对象等待中，Object.wait() 或 TIMED_WAITING<br>阻塞，Blocked（重点关注）<br>停止，Parked</p>
<hr>
<p><strong>实例一：Waiting to lock 和 Blocked</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI TCP Connection(267865)-172.16.5.25&quot; daemon prio=10 tid=0x00007fd508371000 nid=0x55ae waiting for monitor entry [0x00007fd4f8684000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at org.apache.log4j.Category.callAppenders(Category.java:201)</span><br><span class="line">- waiting to lock &lt;0x00000000acf4d0c0&gt; (a org.apache.log4j.Logger)</span><br><span class="line">at org.apache.log4j.Category.forcedLog(Category.java:388)</span><br><span class="line">at org.apache.log4j.Category.log(Category.java:853)</span><br><span class="line">at org.apache.commons.logging.impl.Log4JLogger.warn(Log4JLogger.java:234)</span><br><span class="line">at com.tuan.core.common.lang.cache.remote.SpyMemcachedClient.get(SpyMemcachedClient.java:110)</span><br></pre></td></tr></table></figure>

<p>说明：<br>1）线程状态是 Blocked，阻塞状态。说明线程等待资源超时！<br>2）“ waiting to lock &lt;0x00000000acf4d0c0&gt;”指，线程在等待给这个 0x00000000acf4d0c0 地址上锁（英文可描述为：trying to obtain  0x00000000acf4d0c0 lock）。<br>3）在 dump 日志里查找字符串 0x00000000acf4d0c0，发现有大量线程都在等待给这个地址上锁。如果能在日志里找到谁获得了这个锁（如locked &lt; 0x00000000acf4d0c0 &gt;），就可以顺藤摸瓜了。<br>4）“waiting for monitor entry”说明此线程通过 synchronized(obj) {……} 申请进入了临界区，从而进入了下图1中的“Entry Set”队列，但该 obj 对应的 monitor 被其他线程拥有，所以本线程在 Entry Set 队列中等待。<br>5）第一行里，”RMI TCP Connection(267865)-172.16.5.25”是 Thread Name 。tid指Java Thread id。nid指native线程的id。prio是线程优先级。[0x00007fd4f8684000]是线程栈起始地址。</p>
<hr>
<p><strong>实例二：Waiting on condition 和 TIMED_WAITING</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI TCP Connection(idle)&quot; daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2 waiting on condition [0x00007fd4f1a59000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)</span><br><span class="line">at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:424)</span><br><span class="line">at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:323)</span><br><span class="line">at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:874)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:945)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)</span><br><span class="line">at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1）“TIMED_WAITING (parking)”中的 timed_waiting 指等待状态，但这里指定了时间，到达指定的时间后自动退出等待状态；parking指线程处于挂起中。</p>
<p>2）“waiting on condition”需要与堆栈中的“parking to wait for  &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)”结合来看。首先，本线程肯定是在等待某个条件的发生，来把自己唤醒。其次，SynchronousQueue 并不是一个队列，只是线程之间移交信息的机制，当我们把一个元素放入到 SynchronousQueue 中时必须有另一个线程正在等待接受移交的任务，因此这就是本线程在等待的条件。<br>3）别的就看不出来了。</p>
<hr>
<p><strong>实例三：in Obejct.wait() 和 TIMED_WAITING</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI RenewClean-[172.16.5.19:28475]&quot; daemon prio=10 tid=0x0000000041428800 nid=0xb09 in Object.wait() [0x00007f34f4bd0000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)</span><br><span class="line">- locked &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:516)</span><br><span class="line">at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1）“TIMED_WAITING (on object monitor)”，对于本例而言，是因为本线程调用了 java.lang.Object.wait(long timeout) 而进入等待状态。</p>
<p>2）“Wait Set”中等待的线程状态就是“ in Object.wait() ”。当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃了 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll() ，“ Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到运行态。</p>
<p>3）RMI RenewClean 是 DGCClient 的一部分。DGC 指的是 Distributed GC，即分布式垃圾回收。</p>
<p>4）请注意，是先 locked &lt;0x00000000aa672478&gt;，后 waiting on &lt;0x00000000aa672478&gt;，之所以先锁再等同一个对象，请看下面它的代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static private class  Lock &#123; &#125;;</span><br><span class="line">private Lock lock = new Lock();</span><br><span class="line">public Reference&lt;? extends T&gt; remove(long timeout)</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        Reference&lt;? extends T&gt; r = reallyPoll();</span><br><span class="line">        if (r != null) return r;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            lock.wait(timeout);</span><br><span class="line">            r = reallyPoll();</span><br><span class="line">            ……</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即，线程的执行中，先用 synchronized 获得了这个对象的 Monitor（对应于  locked &lt;0x00000000aa672478&gt; ）；当执行到 lock.wait(timeout);，线程就放弃了 Monitor 的所有权，进入“Wait Set”队列（对应于  waiting on &lt;0x00000000aa672478&gt; ）。<br>5）从堆栈信息看，是正在清理 remote references to remote objects ，引用的租约到了，分布式垃圾回收在逐一清理呢。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/nexiyi/p/java_thread_jstack.html">https://www.cnblogs.com/nexiyi/p/java_thread_jstack.html</a></p>
<h3 id="jmap和jhat"><a href="#jmap和jhat" class="headerlink" title="jmap和jhat"></a>jmap和jhat</h3><p>jmap（Memory Map）和jhat（Java Heap Analysis Tool）</p>
<p>jmap用来查看<strong>堆内存</strong>使用状况，一般结合jhat使用。<br>jmap语法格式：<code>jmap [option] pid</code>  pid为进程id</p>
<p>打印进程的类加载器和类加载器加载的持久代对象信息，输出：类加载器名称、对象是否存活（不可靠）、对象地址、父类加载器、已加载的类大小等信息</p>
<p>使用<strong>jmap -heap pid</strong>查看进程堆内存使用情况，包括使用的GC算法、堆配置参数和各代中堆内存使用情况。</p>
<p>使用<code>jmap -histo pid</code> / <code>jmap -histo:live pid</code>查看堆内存中的对象数目、大小统计直方图，如果带上live则只统计活对象.<br>加上<code>| more</code> 按类别统计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live 21711 | more </span><br><span class="line">num     #instances         #bytes  class name------------</span><br><span class="line">   1:         38445        5597736  &lt;constMethodKlass&gt;</span><br><span class="line">   2:         38445        5237288  &lt;methodKlass&gt;</span><br><span class="line"></span><br><span class="line">class name是对象类型</span><br></pre></td></tr></table></figure>

<p>还有一个很常用的情况是：用jmap把进程内存使用情况dump到文件中，再用jhat分析查看。jmap进行dump命令格式如下：<code>jmap -dump:format=b,file=dumpFileName pid</code></p>
<p>例如：<code>jmap -dump:format=b,file=/tmp/dump.dat 进程id</code></p>
<p>dump.dat文件很大。<br>dump出来的文件可以用MAT、VisualVM等工具查看，这里用jhat查看：<code>jhat -port 9998 /tmp/dump.dat</code><br>然后就可以在浏览器中输入主机地址：9998 查看了。##### ###</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>JVM统计监测工具<br>jvm statistics monitoring tool：用于收集虚拟机各方面的运行数据。</p>
<p>语法格式：<code>jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]</code></p>
<p>vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID。interval是采样时间间隔。count是采样数目。 例如：<code>jstat -gc 进程id 250 4</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 21711 250 4 </span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   1854.9   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br><span class="line"></span><br><span class="line">S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）</span><br><span class="line">运行以来，总耗时，单位s</span><br><span class="line">EC、EU：Eden区容量和使用量</span><br><span class="line">OC、OU：年老代容量和使用量</span><br><span class="line">PC、PU：永久代容量和使用量</span><br><span class="line">YGC、YGT：年轻代GC次数和GC耗时</span><br><span class="line">FGC、FGCT：Full GC次数和Full GC耗时</span><br><span class="line">GCT：GC总耗时</span><br></pre></td></tr></table></figure>

<p>JVM堆内存布局：<br>堆内存 = 年轻代 + 年老代 + 永久代<br>年轻代 = Eden区 + 两个Survivor区（From和To）</p>
<p><code>jstat -gcutil 23484 1000 5</code> 监视内容基本与gc相同，但输出的主要是已占用的总空间的百分比。</p>
<p><code>jstat -gccause 23484 1000 5</code> 查询gc的原因。</p>
<h3 id="hprof"><a href="#hprof" class="headerlink" title="hprof"></a>hprof</h3><p>（Heap/CPU Profiling Tool）<br>hprof能够展现CPU使用率，统计堆内存使用情况。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:hprof[=options] ToBeProfiledClass</span><br><span class="line">java -Xrunprof[:options] ToBeProfiledClass</span><br><span class="line">javac -J-agentlib:hprof[=options] ToBeProfiledClass</span><br></pre></td></tr></table></figure>

<p>例如：<code>java -agentlib:hprof=cpu=samples,interval=20,depth=3 主类</code><br>每隔20毫秒采样CPU消耗信息，堆栈深度为3，生成的profile文件名称是java.hprof.txt，在当前目录。</p>
<p>例如：<code>javac -J-agentlib:hprof=cpu=times Hello.java</code><br>能够获得更加细粒度的CPU消耗信息，能够细到每个方法调用的开始和结束，它的实现使用了字节码注入技术（BCI）。</p>
<p>JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/294950372?utm_medium=social&amp;utm_oi=690843302169178112">https://zhuanlan.zhihu.com/p/294950372?utm_medium=social&amp;utm_oi=690843302169178112</a></p>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>虚拟机配置信息，<code>jinfo 进程id</code></p>
<h3 id="图像化界面分析工具"><a href="#图像化界面分析工具" class="headerlink" title="图像化界面分析工具"></a>图像化界面分析工具</h3><p>VisualVM、JProfile、MAT</p>
<h2 id="几种排查思路"><a href="#几种排查思路" class="headerlink" title="几种排查思路"></a>几种排查思路</h2><h3 id="线程cpu占用高"><a href="#线程cpu占用高" class="headerlink" title="线程cpu占用高"></a>线程cpu占用高</h3><p>1.<code>ps -ef|grep java</code> 或者 jps 查找出进程id<br>2.<code>top -Hp 进程id</code> 查找出最耗cpu的线程id <code>top -c</code>看进程的<br>3.<code>printf &quot;%x\n&quot;</code> 线程id  转换为16进制的id<br>4.使用<code>jstack 进程id | grep 16进制线程id</code>  查找出堆栈信息，分析</p>
<p>另外，arthas也可以打印出前多少个线程及占有cpu情况<br><code>thread -n 5</code></p>
<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p>除了程序计数器，其他内存存储都可能OOM。<br>有可能：数据量大、JVM内存容量参数分配不合理、代码bug死循环无限分配容量<br>1、内存泄露，对象已经死了，无法通过垃圾收集器进行自动回收，通过找出泄露的代码位置和原因，才好确定解决方案；<br>2、内存溢出，内存中的对象都还必须存活着，这说明Java堆分配空间不足，检查堆设置大小（-Xmx与-Xms），检查代码是否存在对象生命周期太长、持有状态时间过长的情况。</p>
<p>1.先使用jmap看一下堆内存使用情况<br>2.<code>jmap -dump:format=b,file=/tmp/dump.dat 进程id</code> dump文件<br>3.使用MAT工具分析<br>mat工具的使用：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/44641">https://developer.aliyun.com/article/44641</a></p>
<h3 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h3><p>1.<code>jstat -gcutil 进程id 1000 40</code>查看gc情况，1s一次，40次动态看gc增长<br>2.找到gc.log<br>里面有gc前堆使用空间&gt;gc后堆已使用空间，还有用户态消耗的cpu时间、内核态消耗的cpu时间、操作从开始到结束经过的时间。</p>
<p>模拟gc看日志：<br><a target="_blank" rel="noopener" href="https://javastack.blog.csdn.net/article/details/109006521">https://javastack.blog.csdn.net/article/details/109006521</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/25/myblog/%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/25/myblog/%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/" class="post-title-link" itemprop="url">《java并发编程的艺术》笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-25 23:05:34" itemprop="dateCreated datePublished" datetime="2022-08-25T23:05:34+08:00">2022-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 15:43:39" itemprop="dateModified" datetime="2023-08-20T15:43:39+08:00">2023-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一章-并发编程的挑战"><a href="#第一章-并发编程的挑战" class="headerlink" title="第一章 并发编程的挑战"></a>第一章 并发编程的挑战</h2><h3 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1.上下文切换"></a>1.上下文切换</h3><p>CPU通过给每个线程分配CPU时间片来实现多线程，时间片一般几十毫秒。</p>
<p>上下文切换是指切换前需要保存上一个任务的状态。</p>
<p>由于线程有创建和上下文切换的开销，并发执行的速度不一定比串行快。</p>
<p>上下文每1s切换1000多次。</p>
<p>如何减少上下文切换？<br>1、无锁并发编程，多线程竞争锁时会引起上下文切换，可以将数据id根据hash算法取模分段，不同线程处理不同段的数据。<br>2、CAS算法，Atomic包下，不需要加锁。<br>3、避免创建不需要的线程。每次从waiting到runnable都需要进行一次上下文切换。<br>4、协程：在单线程中实现多任务调度，维持多个任务间的切换。</p>
<h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2.死锁"></a>2.死锁</h3><p>线程a和线程b互相等待对方释放锁。</p>
<p>一旦出现死锁，业务可感知，使用jstack命令dump线程。</p>
<p>避免死锁的几个方法：<br>1、避免一个线程同时获取多个锁。<br>2、避免一个线程在锁内同时占用多个资源。<br>3、尝试使用定时锁，使用lock.tryLock(timeout)来替代内部锁机制<br>4、对于数据库锁，加锁和解锁必须在一个数据库连接中，否则会出现解锁失败。</p>
<h3 id="3-资源限制"><a href="#3-资源限制" class="headerlink" title="3.资源限制"></a>3.资源限制</h3><p>并发编程时的资源限制：<br>硬件限制：带宽的上传/下载速度（2Mb/s）、硬盘读写速度、CPU处理速度<br>软件限制：数据库连接数、socket连接数<br>例如：线程数比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。</p>
<p>使用等待超时模式模拟数据库连接池：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52043808/article/details/125759727">https://blog.csdn.net/m0_52043808/article/details/125759727</a></p>
<p>受到资源限制时，并发执行可能会编程串行执行，但是增加了上下文切换和资源调度的时间，比串行还慢。</p>
<p>如何解决？<br>1、对于硬件约束，考虑使用集群并行执行程序，不同机器处理不同数据。<br>2、对于软件限制，考虑使用资源池将资源复用。</p>
<h3 id="4-jstack命令dump线程"><a href="#4-jstack命令dump线程" class="headerlink" title="4.jstack命令dump线程"></a>4.jstack命令dump线程</h3><h4 id="✅什么是jstack？"><a href="#✅什么是jstack？" class="headerlink" title="✅什么是jstack？"></a>✅什么是jstack？</h4><p>如果有一天，你的Java程序长时间停顿，也许是它病了，需要用jstack拍个片子分析分析，才能诊断具体什么病症，是死锁综合征，还是死循环等其他病症。</p>
<p>jstack是JVM自带的Java堆栈跟踪工具，它用于打印出给定的java进程ID、core file、远程调试服务的Java堆栈信息.</p>
<pre><code>1、jstack命令用于生成虚拟机当前时刻的线程快照。
2、线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因， 如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。
3、线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。
4、如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。
5、另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。
</code></pre>
<h4 id="✅怎么用："><a href="#✅怎么用：" class="headerlink" title="✅怎么用："></a>✅怎么用：</h4><p>首先使用 jps命令查看需要打印线程栈的java进程号pid。<br>然后 jstack pid。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-F	当正常输出的请求不被响应时，强制输出线程堆栈</span><br><span class="line">-m	如果调用到本地方法的话，可以显示C/C++的堆栈</span><br><span class="line">-l	除堆栈外，显示关于锁的附加信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</span><br></pre></td></tr></table></figure>

<p>输出解读：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;jstack 9348</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.281-b09 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x0000018da5881000 nid=0x34c8 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">[通过 jstack查看线程栈信息时通常看到的最多的是RUNNABLE,BLOCKED,WAITING和TIMED_WAITING这几种状态，</span><br><span class="line">我们一般看不到线程的NEW和TERMINATED状态，是因为在代码的运行过程中这两种状态只占很小一部分，</span><br><span class="line">我们捕捉到这两种状态前这两种状态已经一闪而过了。</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x0000000002e7e800 nid=0x2a1c in Object.wait() [0x0000000002f7f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line"></span><br><span class="line">其中开头是线程名称，后面的为线程信息：</span><br><span class="line"> #1 表示当前线程ID，从 main线程开始，JVM 根据线程创建的顺序为线程编号.</span><br><span class="line">prio 是priority优先级的缩写，表名了当前线程的优先级，取值范围为[1-10]，默认为 5。在虚拟机进行线程调度的时候会参考该优先级为线程分配计算资源，这个数值越低越有优先获取到计算资源，一般不设置直接使用默认的优先级。</span><br><span class="line">os_prio为线程对应系统的优先级。</span><br><span class="line">nid 本地线程编号NativeID的缩写,对应JVM 虚拟机中线程映射在操作系统中的线程编号。我们可以使用 top 查看进程对应的线程情况进行相关映射。</span><br></pre></td></tr></table></figure>

<p>nid表示的是线程对应的系统本地的线程编号.</p>
<h4 id="✅案例：jstack-分析死锁问题"><a href="#✅案例：jstack-分析死锁问题" class="headerlink" title="✅案例：jstack 分析死锁问题"></a>✅案例：jstack 分析死锁问题</h4><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法进行下去</p>
<p>死锁demo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Java 死锁demo</span><br><span class="line"> */</span><br><span class="line">public class DeathLockTest &#123;</span><br><span class="line">    private static Lock lock1 = new ReentrantLock();</span><br><span class="line">    private static Lock lock2 = new ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    public static void deathLock() &#123;</span><br><span class="line">        Thread t1 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock1.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock1&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    lock2.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock2&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock2.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock2&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    lock1.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock1&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //设置线程名字，方便分析堆栈信息</span><br><span class="line">        t1.setName(&quot;mythread-jay&quot;);</span><br><span class="line">        t2.setName(&quot;mythread-tianluo&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        deathLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排查步骤：<br>1、在终端中输入jsp查看当前运行的java程序<br>2、使用 jstack -l pid 查看线程堆栈信息<br>3、分析堆栈信息</p>
<p>会出现：Found one Java-level deadlock: 信息。</p>
<p>当一个线程占有一个锁的时候，线程堆栈会打印一个－locked&lt;0x22bffb60&gt;<br>当一个线程正在等在其他线程释放该锁，线程堆栈会打印一个－waiting to lock&lt;0x22bffb60&gt;<br>当一个线程占有一个锁，但又执行在该锁的wait上，线程堆栈中首先打印blocked,然后打印－waiting on &lt;0x22c03c60&gt;</p>
<h4 id="✅案例：分析CPU过高"><a href="#✅案例：分析CPU过高" class="headerlink" title="✅案例：分析CPU过高"></a>✅案例：分析CPU过高</h4><p>导致CPU过高的demo程序，一个死循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 有个导致CPU过高程序的demo，死循环</span><br><span class="line"> */</span><br><span class="line">public class JstackCase &#123;</span><br><span class="line"> </span><br><span class="line">     private static ExecutorService executorService = Executors.newFixedThreadPool(5);</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        Task task1 = new Task();</span><br><span class="line">        Task task2 = new Task();</span><br><span class="line">        executorService.execute(task1);</span><br><span class="line">        executorService.execute(task2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Object lock = new Object();</span><br><span class="line"> </span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line"> </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                long sum = 0L;</span><br><span class="line">                while (true)&#123;</span><br><span class="line">                    sum += 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排查步骤：<br>1、jps 命令获取目标 java 进程号<br>2、在服务器上，我们可以通过top命令查看各个进程的cpu使用情况，它默认是按cpu使用率由高到低排序的，拿到pid<br>top -Hp pid 【奇怪，不能用，只能top -p pid】<br>通过top -Hp pid可以查看该进程下，各个线程的cpu使用情况<br>3、把线程pid换成nid<br>将该线程好打印成 16进制的<br><code>printf &quot;%x\n&quot; 19343</code><br>4、jstack -l [PID] &gt;/tmp/log.txt<br>一般在生成环境，我们可以把这些堆栈信息打到一个文件里，再回头仔细分析<br>jstack 进程pid | grep -10 线程<br>nid<br>可以看到目标线程的线程堆栈信息了</p>
<p>转自：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44588186/article/details/124680586">https://blog.csdn.net/weixin_44588186/article/details/124680586</a><br>【jstack案例】<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19922839/article/details/115379649">https://blog.csdn.net/qq_19922839/article/details/115379649</a><br>【里面还有pstree 查看进程树，jvm 监控工具Liberica Mission Control】</p>
<h4 id="✅dump线程"><a href="#✅dump线程" class="headerlink" title="✅dump线程"></a>✅dump线程</h4><p>线程dump的目的是转存线程快照。快照中是当前JVM所有线程正在执行方法的堆栈信息。</p>
<p>通过线程dump来分析定位线程出现长时间停顿的原因，如线程死锁、线程死循环、线程请求外部资源长时间等待等。</p>
<p>可以用arthas获取dump文件，dump文件很大，几个G，可以用IDEA打开，或者用其他分析工具。arthas也可以输出所有线程。</p>
<p>线程dump：<a target="_blank" rel="noopener" href="https://blog.csdn.net/HaierFiller/article/details/117367228">https://blog.csdn.net/HaierFiller/article/details/117367228</a></p>
<h2 id="第二章-java并发机制的底层实现原理"><a href="#第二章-java并发机制的底层实现原理" class="headerlink" title="第二章 java并发机制的底层实现原理"></a>第二章 java并发机制的底层实现原理</h2><p>.java代码 -编译为- .class字节码文件 -加载到- jvm -执行字节码- 转化为汇编语言在cpu执行。</p>
<p>java的并发机制依赖于jvm的实现和cpu的执行。</p>
<h3 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1.volatile"></a>1.volatile</h3><h4 id="✅volatile底层"><a href="#✅volatile底层" class="headerlink" title="✅volatile底层"></a>✅volatile底层</h4><p>volatile是轻量级的synchronized，在多处理器开发中保证了共享变量的可见性（所有线程看到的这个变量的值是一致的）。比synchronized执行成本低，不会引起线程上下文的切换和调度。</p>
<p>首先，了解一下cpu处理逻辑：<br>为了提高处理速度，cpu不直接与内存进行通信，而是先将内存的数据读到自己的内存缓存（以缓存行为单位）中。</p>
<p>处理器 - 高速缓存 - 缓存   \<br>处理器 - 高速缓存 - 一致性  - 总线 - 主内存<br>处理器 - 高速缓存 - 协议   /</p>
<p>存储大体上分两种, 主存是堆内存, 工作内存是栈内存, 属于线程私有。<br>对字段操作都需要先从主存读取数据加载进工作内存, 工作内存对这个副本数据进行操作<br>volatile修饰的变量, 等于在堆中这个变量的内存区域上打了个标, 所有操作都必须从主存中读取, 由MESI&lt;缓存一致性协议&gt;实现</p>
<p>对volatile声明的变量进行写操作会发生什么：<br>1、jvm向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回系统内存。lock指令执行期间会锁住总线/缓存，保证不会同时多个cpu修改共享变量。<br>2、多处理下，实现缓存一致性协议，每个处理器使用嗅探技术，保证它的内部缓存和系统内存的数据在总线上保持一致（发现自己缓存行对应的内存地址被修改，首先将缓存行置为无效，重新从系统内存中将数据读到缓存）。</p>
<p>volitale的使用优化：<br>jdk7中的LinkedTransferQueue，使用volitale时，采用追加字节的方式优化出队入队效率。</p>
<p>为什么？<br>因为处理器的高速缓存行是64个字节宽，不支持部分填充缓存行。这样头节点和尾节点在一个高速缓存行中，多处理器下，一个处理器修改头节点，会将整个缓存行锁定，在缓存一致性的作用下，导致其他处理器不能访问自己高速缓存行中的尾节点。<br>节点追加到64字节，可以避免头尾节点加载到同一个缓存行中，修改时不会相互锁定。</p>
<p>注意：缓存行非64字节的别这么做，共享变量不会被频繁写的话别这么做。</p>
<h4 id="✅volatile使用"><a href="#✅volatile使用" class="headerlink" title="✅volatile使用"></a>✅volatile使用</h4><p>⚠️注意：volatile能保证可见性，但不能保证原子性。<br>在 volatile 字段上进行了非原子类操作，会idea提示：<code>Non-atomic operations on volatile fields</code><br>比如：count++ 就是非原子操作，分三步：<br>1、从主存读取 i<br>2、在寄存器中进行加一运算, 自增操作, 此时已经修改工作内存中的值<br>3、将计算后的值赋给 i, 也就是刷回主存</p>
<p><strong>可见性</strong></p>
<p>volatile和static的可见性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//private boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">//private static boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">private volatile  boolean tag = false; //会运行tag is true,exit</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void visibleTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //当tag标志变为true时结束循环并打印退出信息</span><br><span class="line">            while(!tag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;tag is true,exit......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            tag = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>volatile的可见性：是多个线程间的共享变量，当一个线程修改时，其他的线程能够知道这个修改。<br>static不能知道变化，它的可见性：可访问。</p>
<p>volatile修饰的共享变量对其他线程具有可见性，可以保证线程安全。<br>static修饰的变量为全局变量, 对所有线程可访问, 可用于线程间的通信，但是不能保证线程安全。</p>
<p>static线程安全测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int count = 0;</span><br><span class="line"></span><br><span class="line">    private static void count() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            es.execute(VolatileDemo::count);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (es.isTerminated()) &#123;</span><br><span class="line">                System.out.println(&quot;end...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long end = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;count:&quot; + count);</span><br><span class="line">        System.out.println(&quot;cost:&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动一个缓存线程池进行对static字段进行自增，结果不是100.<br>t1线程与 t2线程读取 count 值, 然后同步修改为 1, 再写回内存, 写了两遍 1。</p>
<p>因此，static修饰的变量确实可以在线程间通信, 对各个线程都是可见的。但是不能保证线程安全。</p>
<p>那么用volatile，相当于每次修改volatile变量都需要重新读取数据。<br>但是结果依然不是100.</p>
<p>volatile的可见性测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//private boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">//private static boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">private volatile  boolean tag = false; //会运行tag is true,exit</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void visibleTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //当tag标志变为true时结束循环并打印退出信息</span><br><span class="line">            while(!tag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;tag is true,exit......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            tag = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非原子性</strong></p>
<p>t1线程与t2线程同时从主存中读取了count = 1,自增, 这时候两个线程的寄存器中存的计算后的值都是 2, 然后要写回count的主存, 假设这时 t1成功了, 那么主存中的count就是2, 然后根据MESI协议, t2需要重新从主存读取count值, 得到的是2, 再将寄存器中的计算结果2 赋值给count, 刷回主存, 此时主存中的count值还是2, 而不是期望中的3。</p>
<p>怎么解决？<br>synchronized关键字，或者 atomic原子类 + volatile</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private volatile static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">private static void count() &#123;</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-12 20:14</span><br><span class="line"> **/</span><br><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    private volatile AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testVolatile() throws InterruptedException &#123;</span><br><span class="line">        Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                    System.out.println(Thread.currentThread() + &quot; count:&quot; + count);</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                    System.out.println(Thread.currentThread() + &quot; count:&quot; + count);</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(&quot;count:&quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、static修饰的变量是静态变量, 表示不管对象有多少实例, 只有这一个变量, 强调变量的唯一性<br>2、volatile是基于JMM与MESI提出的一种内存一致性解决方案, 强调的是对共享变量的修改是可见的, 变量值是唯一的<br>3、volatile 可以保证对其所修饰的共享变量的原子性操作是线程安全的</p>
<p>转自：<br>volatile的可见性和非原子性：<a target="_blank" rel="noopener" href="https://www.codenong.com/js5a773b9fb9cb/">https://www.codenong.com/js5a773b9fb9cb/</a></p>
<h3 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2.synchronized"></a>2.synchronized</h3><p>synchronized之前被称为重量级锁，但是java se 1.6 对synchronized进行优化：减少获取锁和释放锁带来的性能消耗而引入偏向锁、轻量级锁。</p>
<h4 id="✅synchronized锁三种形式"><a href="#✅synchronized锁三种形式" class="headerlink" title="✅synchronized锁三种形式"></a>✅synchronized锁三种形式</h4><p>1.对于普通同步⽅法：锁的是当前实例对象，通常指this，所有的普通同步⽅法⽤的都是同⼀把锁，即实例对象本身。</p>
<p>2.对于静态同步⽅法：锁的是当前类的Class对象。</p>
<p>3.对于同步⽅法块：锁的是synchronized 括号内的对象。</p>
<p>⚠️几个锁的区别：<br>1.静态方法同步和静态代码块同步：所有的静态同步⽅法⽤的也是同⼀把锁——类对象本身，⼀旦⼀个静态同步⽅法获取锁后，其他的静态同步⽅法都必须等待该⽅法释放锁后才能获取锁。（和实例没关系）</p>
<p>2.静态同步和普通同步：具体实例对象this和唯⼀模板Class，这两把锁是两个不同的对象，所以静态同步⽅法与普通同步⽅法之间是不会有竞态条件的</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-17 14:11</span><br><span class="line"> **/</span><br><span class="line">//资源类</span><br><span class="line">class Phone&#123;</span><br><span class="line">    //1.静态方法（加锁）</span><br><span class="line">    public static synchronized void sendEmail() &#123;</span><br><span class="line">        //暂停几秒钟线程</span><br><span class="line">        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------sendEmail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //2.普通方法（加锁）</span><br><span class="line">    public synchronized void sendSMS() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------sendSMS&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 普通方法不加锁</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主方法</span><br><span class="line">public class SynchronizedDemo&#123;</span><br><span class="line">    //一切程序的入口，主线程</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Phone phone = new Phone();//资源类1</span><br><span class="line">        Phone phone2 = new Phone();//资源类2</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //phone.sendSMS(); //1、2</span><br><span class="line">                //phone.hello();</span><br><span class="line">                phone.sendEmail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //phone.sendSMS(); //1、2</span><br><span class="line">                //phone.hello();</span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">        try &#123; TimeUnit.MILLISECONDS.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅synchronized锁的实现原理"><a href="#✅synchronized锁的实现原理" class="headerlink" title="✅synchronized锁的实现原理"></a>✅synchronized锁的实现原理</h4><p>反编译命令：<code>javap -v -p *.class &gt; 类.txt </code>（将进⾏输出到txt中）</p>
<p>synchronized在jvm中的实现原理：jvm基于进入和退出Monitor对象来实现方法同步和代码块同步，monitor是一个对象的监视器。</p>
<p><strong>同步代码块：</strong></p>
<p>同步代码块是通过monitorenter和monitorexit指令实现的。</p>
<p>monitorenter：在编译后插入到同步代码块的开始位置，会尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁。</p>
<p>monitorexit：代表执行完synchronized代码块之后，要从对象监视器中退出，也就是释放锁。</p>
<p><strong>同步普通⽅法：</strong></p>
<p>1.同步普通⽅法反编译后的结构：可以看到在synchronized修饰实例方法中，不会再有monitorenter和monitorexit指令，而是在这个方法上多了一个ACC_SYNCHRONIZED的flag。</p>
<p>2.调用普通方法的流程：当程序在运行时，调用method()方法时，会检查该方法是否有ACC_SYNCHRONIZED访问标识，如果有，则表明该方法是同步方法，这时候该线程会先尝试去获取该方法对应的监视器（monitor）对象，如果获取成功，则继续执行该method()方法。</p>
<p>3.在执行期间，任何其他线程都不能再获取该方法监视器的使用权，直到该方法正常退出或者抛出异常，才会释放，其他线程可以重新获得该监视器。</p>
<p><strong>同步静态方法：</strong></p>
<p>synchronized修饰静态方法和实例方法没有区别，都是增加一个ACC_SYNCHRONIZED的flag，静态方法只是比实例方法多一个ACC_STATIC标识代表这个方法是静态的。</p>
<p><strong>阿里开发手册说明：</strong></p>
<p>⾼并发时，同步调⽤应该去考量锁的性能损耗。<br>1.能⽤⽆锁数据结构，就不要⽤有锁；<br>2.能锁区块，就不要锁整个⽅法体；<br>3.能⽤对象锁，就不要⽤类锁；</p>
<p>参考：<br>synchronized三种加锁方式：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38963649/article/details/126139304">https://blog.csdn.net/weixin_38963649/article/details/126139304</a></p>
<h4 id="✅java对象头"><a href="#✅java对象头" class="headerlink" title="✅java对象头"></a>✅java对象头</h4><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>HotSpot虚拟机的对象头包括三部分信息：<br>1、mark word 2、元类指针 3、数组长度<br>普通对象头有两个区域（1，2）、数组对象头有三个区域（1,2,3）</p>
<p><strong>Mark Word</strong></p>
<p>这部分主要存储对象自身的运行数据，如Hashcode、gc分代年龄、对象锁，锁状态标志，偏向锁（线程）ID，偏向时间等等。mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位。</p>
<p>Java对象头一般占有2个机器码（64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</p>
<p><strong>指向类的指针</strong></p>
<p>该指针在32位JVM的长度是32Bit，64是64bit<br>它主要指向类的数据，也就是指向方法区中的位置。</p>
<p><strong>数组长度</strong></p>
<p>只有数组对象保存了这部分数据<br>该数据在32位和64位JVM都是32bit</p>
<p>参考：<br>java对象头以及打印对象头：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sumengnan/article/details/125035218">https://blog.csdn.net/sumengnan/article/details/125035218</a><br>java对象头以及锁升级过程：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Alei777/p/16308553.html">https://www.cnblogs.com/Alei777/p/16308553.html</a></p>
<h4 id="✅锁的升级与对比"><a href="#✅锁的升级与对比" class="headerlink" title="✅锁的升级与对比"></a>✅锁的升级与对比</h4><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。<br>在 Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状 态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。<br>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<p><strong>偏向锁</strong></p>
<p>背景：<br>大多数情况下，锁不仅不存在多线程竞争，而且总是由同 一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p>偏向锁原理：<br>当一个线程访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧</strong>中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p>偏向锁释放和升级：<br>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正 在执行的字节码）。<br>1、首先暂停拥有偏向锁的线程<br>2、然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；<br>3、如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁（升级为轻量级锁），最后唤醒暂停的线程。</p>
<p>关闭偏向锁<br>偏向锁在Java 6和Java 7里是默认启用，如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：<br><code>-XX:-UseBiasedLocking=false</code></p>
<p><strong>轻量级锁</strong></p>
<p>升级为轻量级锁后，线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>来获取锁。自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁。</p>
<p><strong>重量级锁</strong></p>
<p>轻量级锁 -&gt; 重量级锁 的方式有两种：</p>
<p>1 若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。</p>
<p>2 另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。</p>
<p>自旋会消耗CPU，一旦重量级锁，就不会恢复为轻量级锁。当锁处于这个状态下，其他线程试图获取锁时， 都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<p><strong>几种锁的对比</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">锁	优点	缺点	使用场景</span><br><span class="line">偏向锁	加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳秒级的差距	如果线程间存在锁竞争，会带来额外的撤销消耗	适用于只有一个线程访问同步块场景</span><br><span class="line">轻量级锁	竞争的线程不会阻塞，提高了程序的响应速度	如果始终得不到锁竞争的线程，会自旋消耗CPU	追求响应时间、同步块执行非常快</span><br><span class="line">重量级锁	线程不使用自旋，不会消耗CPU	线程阻塞，响应时间缓慢	追求吞吐量、同步块执行速度较快</span><br></pre></td></tr></table></figure>

<p>参考：<br>《书中内容》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Hello_mengkebao/article/details/119874999">https://blog.csdn.net/Hello_mengkebao/article/details/119874999</a></p>
<p><strong>总结：锁的升级过程</strong></p>
<p>JVM一般是这样使用锁和Mark Word的：</p>
<p>1，当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。</p>
<p>2，当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。</p>
<p>3，当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。</p>
<p>4，当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。</p>
<p>5，偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。</p>
<p>6，轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。</p>
<p>7，自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</p>
<h3 id="3-Atomic原子操作"><a href="#3-Atomic原子操作" class="headerlink" title="3.Atomic原子操作"></a>3.Atomic原子操作</h3><p>原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。</p>
<h4 id="✅处理器如何实现原子操作"><a href="#✅处理器如何实现原子操作" class="headerlink" title="✅处理器如何实现原子操作"></a>✅处理器如何实现原子操作</h4><p>首先处理器会自动保证<strong>基本的内存操作的原子性</strong>。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的。</p>
<p>但是<strong>复杂的内存操作处理器是不能自动保证其原子性的</strong>，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂内存操作的原子性。</p>
<p>首先我们要明确一点：a++是三步操作（取数，加一，赋值），而计算机和Java都只保证一步操作的原子性，多步操作是不保证原子性的。所以a++不是原子性的。想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p>
<p>⚠️volitale保证可见性为什么不能实现i++的线程安全？</p>
<blockquote>
<p>可见性是指瞬时可见性，是指那一时刻的可见性。放在这个例子里，就是指当线程1把（a=0，a++）的结果a=1刷回到主存中时，所有目前有a这个变量的缓存此时都应该变为a=1，而不是使用原来的值。所以，线程2也执行加一后，还没有写回到缓存中，保存在寄存器中，线程2缓存里面的a=0被置为无效，所以线程2又从主存中取得a=1替换掉了自己缓存中的a=0，然后线程2将a=1写入自己的缓存中，随后a=1又一次被立刻刷回到主存中。最后主存中的值还是a=1。</p>
</blockquote>
<p><strong>总线锁</strong></p>
<p>总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p>
<p><strong>缓存锁</strong></p>
<p>总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大。</p>
<p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。</p>
<p>“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong>，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
<p>不能使用缓存锁的情况：<br>1、第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行。<br>2、有些处理器不支持缓存锁定</p>
<h4 id="✅java如何实现原子操作"><a href="#✅java如何实现原子操作" class="headerlink" title="✅java如何实现原子操作"></a>✅java如何实现原子操作</h4><p><strong>循环CAS</strong></p>
<p>CAS 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制。CAS 操作包含三个操作数 – 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值相比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。（像改密码需要先验证旧密码一样）</p>
<p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</p>
<p>从Java 1.5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值）。这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p>
<p>CAS仍然存在<strong>三大问题</strong>。ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。</p>
<p>1、ABA问题<br>CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p>
<p>从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>2、循环时间长开销大<br>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<p>3、只能保证一个共享变量的原子操作<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证<strong>引用对象之间的原子性</strong>，就可以把多个变量放在一个对象里来进行CAS操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">count.incrementAndGet(); //原子自增</span><br><span class="line">int i = count.get();</span><br><span class="line">boolean suc = count.compareAndSet(i, ++i); //cas</span><br></pre></td></tr></table></figure>

<p><strong>使用锁实现原子操作</strong></p>
<p>使用锁机制实现原子操作锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p>
<p>参考：<br>书的笔记：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/412363896">https://zhuanlan.zhihu.com/p/412363896</a><br>jdk中的原子操作类：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a47285790467">https://www.jianshu.com/p/a47285790467</a><br>cas原理、synchronized悲观锁和cas乐观锁：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/huansky/p/15746624.html">https://www.cnblogs.com/huansky/p/15746624.html</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>几个java实现多线程安全的操作：<br>1、synchronized加锁<br>2、Volatile关键字<br>3、CAS</p>
<h2 id="第三章-Java内存模型"><a href="#第三章-Java内存模型" class="headerlink" title="第三章 Java内存模型"></a>第三章 Java内存模型</h2><h3 id="1-java内存模型的基础"><a href="#1-java内存模型的基础" class="headerlink" title="1.java内存模型的基础"></a>1.java内存模型的基础</h3><h4 id="✅并发编程的两个关键问题"><a href="#✅并发编程的两个关键问题" class="headerlink" title="✅并发编程的两个关键问题"></a>✅并发编程的两个关键问题</h4><p>1、线程之间如何通信：<br>通信是指线程之间以何种机制来交换信息<br>通信机制有两种：共享内存和消息传递</p>
<p>2、线程之间如何同步：<br>同步：指程序中用于控制不同线程间操作发生相对顺序的机制</p>
<p>java的并发采用的是共享内存模型，java线程之间的通信总是隐式进行，整个过程对程序员完全透明。</p>
<h4 id="✅java内存模型"><a href="#✅java内存模型" class="headerlink" title="✅java内存模型"></a>✅java内存模型</h4><p>堆内存：实例域、静态域、数组元素；在线程之间共享。<br>栈内存：局部变量、方法定义参数、异常处理器参数；不在线程之间共享，没有内存可见性问题。</p>
<p>Java线程之间的通信由Java内存模型(JMM)控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见</p>
<p>线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存(抽象概念)，本地内存中存储了该线程以读/写共享变量的副本。</p>
<p>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证<br>两个线程要通信，要经历下面2个步骤：<br>线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br>线程B到主内存中去读取线程A之前已更新过的共享变量</p>
<h4 id="✅从源代码到指令序列的重排序"><a href="#✅从源代码到指令序列的重排序" class="headerlink" title="✅从源代码到指令序列的重排序"></a>✅从源代码到指令序列的重排序</h4><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序</p>
<p>重排序分3种类型，第一种属于编译器重排，后两种属于处理器重排：<br>编译器优化的重排序<br>指令级并行的重排序<br>内存系统的重排序</p>
<p>JMM通过禁止特定类型的编译器重排序和处理器重排序（插入特定类型的内存屏障），提供内存可见性保证。</p>
<p>处理器利用写缓冲区来临时保存向内存写入的数据。但是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。例如a=1，先写在缓冲区，然后下一个语句用了a，然后缓冲区才将a=1写入主内存。这就算重排序了。</p>
<h4 id="✅happens-before"><a href="#✅happens-before" class="headerlink" title="✅happens-before"></a>✅happens-before</h4><p>JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系（一种阐述内存可见性的概念）。就是要求前一个操作的执行结果对后一个操作可见。并不意味着操作A就一定在操作B之前执行。</p>
<p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读</p>
<h3 id="2-重排序"><a href="#2-重排序" class="headerlink" title="2.重排序"></a>2.重排序</h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p>
<h4 id="✅数据依赖性"><a href="#✅数据依赖性" class="headerlink" title="✅数据依赖性"></a>✅数据依赖性</h4><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。<br>数据依赖可分为：读后写、写后读、写后写。</p>
<p>编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</p>
<h4 id="✅as-if-serial语义"><a href="#✅as-if-serial语义" class="headerlink" title="✅as-if-serial语义"></a>✅as-if-serial语义</h4><p>一个概念，意思是：不管怎么重排序，单线程的程序的执行结果不能被改变</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。</p>
<p>意思就是，编译器和处理器为了提高单线程的并行度，会对没有依赖关系的操作重排序，但是不影响结果和可见性。</p>
<h4 id="✅重排序对多线程的影响"><a href="#✅重排序对多线程的影响" class="headerlink" title="✅重排序对多线程的影响"></a>✅重排序对多线程的影响</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ReorderExample &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        a = 1; // 1</span><br><span class="line">        flag = true; // 2</span><br><span class="line">    &#125;</span><br><span class="line">    Public void reader() &#123;</span><br><span class="line">        if (flag) &#123; // 3</span><br><span class="line">        int i = a * a; // 4</span><br><span class="line">    ……</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法.</p>
<p>操作1和操作2没有数据依赖关系，且操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两对操作重排序.</p>
<p>对线程A的两个操作进行重排序：<br>1、线程A首先写标记变量flag<br>2、随后线程B读这个变量。由于条件判断为真，线程B将读取变量a<br>3、此时，变量a还没有被线程A写入，多线程程序的语义被重排序破坏</p>
<p>对线程B的两个操作进行重排序：<br>1、由于操作3和操作4存在控制依赖关系，执行线程B的处理器可提前读取并计算a*a<br>2、然后把计算结果临时保存到一个名为重排序缓冲(Reorder Buffer，ROB)的硬件缓存中<br>3、当操作3的条件判断为真时，就把该计算结果写入变量i中，多线程程序的语义被重排序破坏</p>
<h3 id="3-顺序一致性"><a href="#3-顺序一致性" class="headerlink" title="3.顺序一致性"></a>3.顺序一致性</h3><p>数据竞争的定义：在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读没有通过同步来排序</p>
<p>顺序一致性：如果程序是正确同步的，程序的执行将具有顺序一致性(即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同)【是一个理想化的概念】</p>
<h4 id="✅顺序一致性模型"><a href="#✅顺序一致性模型" class="headerlink" title="✅顺序一致性模型"></a>✅顺序一致性模型</h4><p>在顺序一致性模型（理论参考模型）中（不管有没有同步）：<br>任意时刻最多只有一个线程可以连接到内存。<br>一个线程的所有操作按程序的顺序串行执行。<br>每个操作必须立即对任意线程可见。<br>所有线程都只能看到一个一致的整体执行顺序。</p>
<blockquote>
<p>JMM中没有上述保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致</p>
</blockquote>
<h4 id="✅同步程序的执行效果"><a href="#✅同步程序的执行效果" class="headerlink" title="✅同步程序的执行效果"></a>✅同步程序的执行效果</h4><p>在JMM中，临界区（一个同步块儿）内的代码可以重排序(因为JMM目的是在不改变程序执行结果的前提下，尽可能优化编译器和处理器)。</p>
<p>结果是：重排序提高了执行效率，而且没有改变程序的执行结果。</p>
<h4 id="✅未同步程序的执行效果"><a href="#✅未同步程序的执行效果" class="headerlink" title="✅未同步程序的执行效果"></a>✅未同步程序的执行效果</h4><p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致（一致也没意义）。因为如果想要保证执行结果一致，JMM需要禁止大量的处理器和编译器的优化，这对程序的执行性能会产生很大的影响。</p>
<p>JMM不保证单线程内的操作会按程序顺序执行。所有线程看到的操作顺序可能不一致。执行顺序可能是：2-3-4-1，语义被破坏。可能是4的右边-1-2-3-4的左边，语义被破坏。</p>
<h4 id="✅处理器总线事务"><a href="#✅处理器总线事务" class="headerlink" title="✅处理器总线事务"></a>✅处理器总线事务</h4><p>总线事务包括读事务（内存-处理器）和写事务（处理器-内存），中间都要通过总线，总线会同步试图并发使用总线的事务，一次只有一个事务可以操作总线访问内存。</p>
<p>所以，一次最多只有一个处理器可以访问内存，这保证了单个总线事务之中的内存读写（读跟写，不是i++）具有原子性。</p>
<p>但是：32位的处理器上，对long型和double型这俩64位的数据的写操作拆分成了两个写事务，会分配在不同的总线事务中执行。所以不具有原子性。</p>
<h3 id="4-volatile的内存语义"><a href="#4-volatile的内存语义" class="headerlink" title="4.volatile的内存语义"></a>4.volatile的内存语义</h3><h4 id="✅volatile的特性："><a href="#✅volatile的特性：" class="headerlink" title="✅volatile的特性："></a>✅volatile的特性：</h4><p>1、可见性：对volatile变量的单个读写，相当于是用同一个锁对单个读写方法做了同步。对volatile变量的读，总能看到最后的写入。被volatile修饰的变量对所有线程总是立即可见的，对volatile变量的所有写操作总是能立刻反应到其他线程中。</p>
<p>2、原子性：对单个volatile变量的读写（64位的long和double类型也是）具有原子性，volatile++的复合操作不具有原子性。</p>
<h4 id="✅volatile变量读写实现线程之间通信"><a href="#✅volatile变量读写实现线程之间通信" class="headerlink" title="✅volatile变量读写实现线程之间通信"></a>✅volatile变量读写实现线程之间通信</h4><p>volatile变量的写、读，与锁的释放、获取有相同的内存效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">volatile boolean flag = false;</span><br><span class="line"></span><br><span class="line">public void writer() &#123;</span><br><span class="line">    a = 1;//1</span><br><span class="line">    flag = true;//2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void reader() &#123;</span><br><span class="line">    if (flag) &#123;  //3</span><br><span class="line">        int i = a; //4</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1 happens-before 2  (执行顺序可能在一个临界区内重排序)<br>3 happens-before 4<br>2 happens-before 3 （volatile带来的）<br>so: 1 happens-before 4</p>
<p>疑问：1.2没有数据依赖，可能被重排序。<br>指令重排使得执行顺序不会变成：2-3-4-1 吗？ 下面给答案。</p>
<h4 id="✅volatile写读的内存语义"><a href="#✅volatile写读的内存语义" class="headerlink" title="✅volatile写读的内存语义"></a>✅volatile写读的内存语义</h4><p>线程 - 本地内存 - 主内存</p>
<p>1、当写一个volatile变量时，JMM会把线程对应的本地内存中的共享变量（那个a）值刷新到主内存。（实质就是A向接下来要读这个volatile变量的某个线程发出了消息（我对共享变量做出的修改））</p>
<p>2、当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。（实质就是接受了之前某个线程发出的消息）</p>
<p>3、A写，B读，实质就是A通过主内存向B发送消息，实现线程之间通信</p>
<h4 id="✅volatile内存语义的实现-禁止指令重排。"><a href="#✅volatile内存语义的实现-禁止指令重排。" class="headerlink" title="✅volatile内存语义的实现-禁止指令重排。"></a>✅volatile内存语义的实现-禁止指令重排。</h4><p>背景：上面实现线程间通信那一小节，疑惑的是1.2是不是能重排序，3.4是不是能重排序。在这里给出答案，</p>
<p>为了实现volatile的内存语义，JMM会限制重排序类型。</p>
<p>1、当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到写之后。</p>
<p>2、当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到读之前。</p>
<p>3、当第一个操作是volatile写时，第二个操作是volatile读时，不能重排序。</p>
<p>那么，如何实现限制指令重排？<br>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>尽管内存屏障会降低效率，但是JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<h4 id="✅JSR-133增强volatile的内存语义"><a href="#✅JSR-133增强volatile的内存语义" class="headerlink" title="✅JSR-133增强volatile的内存语义"></a>✅JSR-133增强volatile的内存语义</h4><p>Java内存模型是一个雄心勃勃的计划，它是编程语言规范第一次尝试合并一个能够在各种处理器架构中为并发提供一致语义的内存模型。不过，定义一个既一致又直观的内存模型远比想象要更难。JSR133为Java语言定义了一个新的内存模型，它修复了早期内存模型中的缺陷。为了实现JSR133，final和volatile的语义需要重新定义。</p>
<p>旧的内存模型中，volatile的写读没有锁的释放和获取的内存语义，也就是实现线程之间通信那一小节里，会指令重排。</p>
<p>JSR-133，严格限制编译器和处理器对volatile变量与普通变量的重排序，确保了volatile的写读有锁的释放和获取的内存语义。</p>
<p>volatile与锁对比：<br>锁在功能上比volatile更强大，可以确保整个临界区代码具有原子性。volatile只能对单个volatile变量读写具有原子性。（所以不能单纯用volatile实现计数器）<br>在可伸缩性和执行性能上，volatile更具有优势。</p>
<h3 id="5-锁的内存语义"><a href="#5-锁的内存语义" class="headerlink" title="5.锁的内存语义"></a>5.锁的内存语义</h3><p>达到效果：线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立即变得对B线程可见。</p>
<h4 id="✅锁释放和获取的内存语义"><a href="#✅锁释放和获取的内存语义" class="headerlink" title="✅锁释放和获取的内存语义"></a>✅锁释放和获取的内存语义</h4><p>1、当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。（实质上是线程A向接下来要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。）</p>
<p>2、当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器锁保护的临界区代码必须从主内存中读取共享变量。（实质上是线程B接受了之前某个线程发出的（在释放这个锁对共享变量锁做的修改的）消息。）</p>
<p>3、线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</p>
<h4 id="✅锁内存语义的实现"><a href="#✅锁内存语义的实现" class="headerlink" title="✅锁内存语义的实现"></a>✅锁内存语义的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock();                 // 获取锁</span><br><span class="line">try &#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();          // 释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronized(AQS) 。AQS使用一个整型的volatile变量（state）来维护同步状态，这个volatile变量是ReentrantLock内存语义实现的关键。</p>
<p><strong>公平锁：</strong></p>
<p>加锁方法首先读取volatile变量state。<br>释放锁的最后写volatile变量state。</p>
<p>效果：释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取到同一个volatile变量后将立即变得对获取锁的线程可见。</p>
<p><strong>非公平锁：</strong></p>
<p>非公平锁的释放和公平锁的释放完全一致。</p>
<p>加锁：用了：<code>unsafe.compareAndSwapInt(this, stateOffset, expect, update);</code></p>
<p>该方法以原子操作的方式更新state变量，也就是compareAndSet() (CAS)操作。JDK文档对该方法说明如下：如果当前状态值等于预期值，则以原子方式同步状态设置为给定更新的值。此操作具有volatile读和写的内存语义。<br>（编译器不能对CAS与CAS前面和后面任意内存操作重排序。）</p>
<p>CAS具有volatile读写内存语义的实现方式：lock前缀<br>intel手册对lock前缀的说明：<br>对内存的读-改-写操作原子执行。（总线锁定/缓存锁定）<br>禁止该指令，与之前的读和写指令重排序<br>把写缓冲区的所有数据刷新到内存中<br>上面的2、3两点所具有的内存屏障的效果，足以同时实现volatile读和volatile写的内存语义。所以JDK文档说CAS 具有volatile读和volatile写的内存语义对于处理器也是符合的。</p>
<p><strong>总结：</strong><br>释放锁-获取锁的内存语义的实现方式总结 ：<br>利用volatile变量的写-读所具有的内存语义<br>利用CAS所附带的volatile读和volatile写的内存语义</p>
<h4 id="✅concurrent包的实现"><a href="#✅concurrent包的实现" class="headerlink" title="✅concurrent包的实现"></a>✅concurrent包的实现</h4><p>Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器实现同步的关键。同时volatile变量的读/写和CAS可以实现线程之间的通信。这些特性就是Java整个concurrent包的基石。</p>
<p>concurrent包的通用化实现模式：<br>1、声明共享变量volatile<br>2、使用CAS的原子条件更新来实现线程之间的同步<br>3、配合volatile的读/写和CAS具有的volatile读和写的内存语义来实现线程之间的通信。</p>
<p>AQS（java.util.concurrent.locks.AbstractQueuedSynchronizer）、非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中基础类都是使用这个模式来实现的，而concurrent包中的高层类又是依赖于这些基础类。</p>
<p>图示concurrent包的实现示意图：</p>
<p><img src="/images/concurrent%E5%8C%85.png"></p>
<h3 id="6-final域的内存语义"><a href="#6-final域的内存语义" class="headerlink" title="6.final域的内存语义"></a>6.final域的内存语义</h3><p>文中探讨的变量对线程可见，是保证线程安全的方式，如果不可见，那就要同步加锁，反言之，加锁也是为了变量对线程可见。</p>
<h4 id="✅final域的重排序规则"><a href="#✅final域的重排序规则" class="headerlink" title="✅final域的重排序规则"></a>✅final域的重排序规则</h4><p>对于final域，编译器和处理器要遵守两个重排序规则。</p>
<p>1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
<blockquote>
<p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。</p>
<p>写普通域的操作可能被编译器重排序到了构造函数之外，读线程B错误地读取了普通变量i初始化之前的值，很可能obj对象还没有构造完成，初始值1还没有写入普通域i。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确地读取了final变量初始化之后的值。</p>
</blockquote>
<blockquote>
<p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p>
</blockquote>
<p>2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p>
<blockquote>
<p>编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器的。</p>
</blockquote>
<blockquote>
<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class FinalExample &#123;</span><br><span class="line">    int i;  //普通变量</span><br><span class="line">    final int j;  //final变量</span><br><span class="line">    static FinalExample obj;</span><br><span class="line">    public FinalExample() &#123; //构造函数</span><br><span class="line">        i = 1; //写普通域</span><br><span class="line">        j = 2; //写final域</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123; //写线程A执行</span><br><span class="line">        obj = new FinalExample();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123; //读线程B执行</span><br><span class="line">        FinalExample object = obj; //读对象引用</span><br><span class="line">        int a = object.i; //读普通域</span><br><span class="line">        int b = object.j; //读final域</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅final域为引用类型"><a href="#✅final域为引用类型" class="headerlink" title="✅final域为引用类型"></a>✅final域为引用类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceExample &#123;</span><br><span class="line">    final int[] intArray; //final是引用类型</span><br><span class="line">    static FinalReferenceExample obj;</span><br><span class="line">    public FinalReferenceExample() &#123; //构造函数</span><br><span class="line">        intArray = new int[1]; //1</span><br><span class="line">        intArray[0] = 1; //2</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writerOne() &#123; //写线程A执行</span><br><span class="line">        obj = new FinalReferenceExample(); //3</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writerTwo() &#123; //写线程B执行</span><br><span class="line">        obj.intArray[0] = 2; //4</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123; //读线程C执行</span><br><span class="line">        if (obj != null) &#123; //5</span><br><span class="line">            int temp1 = obj.intArray[0]; //6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在<strong>构造函数内</strong>对一个final引用的对象的成员域的写入(2)，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量(3)，这两个操作之间不能重排序。</p>
<p>1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p>
<p>写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。</p>
<h4 id="✅为什么含final的对象引用不能从构造函数内“溢出”"><a href="#✅为什么含final的对象引用不能从构造函数内“溢出”" class="headerlink" title="✅为什么含final的对象引用不能从构造函数内“溢出”"></a>✅为什么含final的对象引用不能从构造函数内“溢出”</h4><p>写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实，要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceEscapeExample &#123;</span><br><span class="line">    final int                          i;</span><br><span class="line">    static FinalReferenceEscapeExample obj;</span><br><span class="line">    public FinalReferenceEscapeExample() &#123;</span><br><span class="line">        i = 1; //1写final域</span><br><span class="line">        obj = this; //2 this引用在此“逸出”</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123;</span><br><span class="line">        new FinalReferenceEscapeExample();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123;  //线程B</span><br><span class="line">        if (obj != null) &#123; //3</span><br><span class="line">            int temp = obj.i; //4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作2使得对象还未完成构造前就为线程B可见。这里的操作1和操作2之间可能被重排序。线程B看到了此时的final域可能还没有被初始化。</p>
<p>final不同于普通变量达到的效果是：在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p>
<h4 id="✅处理器中如何实现final语义"><a href="#✅处理器中如何实现final语义" class="headerlink" title="✅处理器中如何实现final语义"></a>✅处理器中如何实现final语义</h4><p>本来应该要插入内存屏障的。<br>X86处理器不会对写-写操作做重排序，X86处理器不会对存在间接依赖关系的操作做重排序，也就是说，在X86处理器中，final域的读/写不会插入任何内存屏障！（普通变量也有依赖关系吧，也有final语义？）</p>
<h4 id="✅JSR-133为什么要增强final的语义"><a href="#✅JSR-133为什么要增强final的语义" class="headerlink" title="✅JSR-133为什么要增强final的语义"></a>✅JSR-133为什么要增强final的语义</h4><p>在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为1（被某个线程初始化之后的值）。</p>
<p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p>
<h3 id="7-happens-before"><a href="#7-happens-before" class="headerlink" title="7.happens-before"></a>7.happens-before</h3><h4 id="✅设计初衷"><a href="#✅设计初衷" class="headerlink" title="✅设计初衷"></a>✅设计初衷</h4><p>设计内存模型JMM的初衷：让程序员易于理解，易于编程，提供内存可见性保证。对编译器和处理器的束缚越少越好，方便它们优化来提高性能。</p>
<p>JMM 对于这两种类型的重排序做了不同的处理：<br>对于有数据依赖的重排序，JMM 要求编译器和处理器禁止这种重排序<br>对于没有数据依赖的重排序，JMM 要求编译器和处理器不做处理</p>
<p>JMM 的 happens - before 向程序员提供了足够强的内存可见性保证，但是其中有些内存可见性保证其实不一定存在，【比如 int a=1; int b=2; 这个就只是可见，不保证执行顺序，但也是happens-before】。</p>
<p>JMM 对于编译器和处理器的优化已经尽可能少了。JMM 其实在遵循一个规则：单线程下或者已经同步的多线程下（synchronized，volatile等），只要不改变程序的执行结果，编译器和处理器想要怎么优化都可以。【比如 对于volatile 变量，如果编译器分析后认定这个变量只会被单线程访问，不存在多线程的可见性问题，那么编译器就会把 volatile 变量当作普通变量进行处理】。</p>
<h4 id="✅happens-before的定义"><a href="#✅happens-before的定义" class="headerlink" title="✅happens-before的定义"></a>✅happens-before的定义</h4><p>JSR - 133中提出，JSR - 133 使用 happens - before 关系来向程序员提供跨线程的内存可见性保证。</p>
<p>1、如果一个操作 happens - before 另一个操作，那么另一个操作的执行结果将对第二个操作可见。</p>
<p>2、两个操作之间存在 happens - before 关系，并不意味这 Java 平台必须要按照 happens - before 规定的顺序来执行。只要重排序之后的结果是不改变的，那么 JMM 是默认不对这种重排序处理的</p>
<p>核心原则是：只要不改变程序的执行结果（<strong>单线程和正确同步的多线程</strong>），编译器和处理器怎么优化都行。程序员对于这两个操作是否真的被重排序并不关心，程序员只需要关系的是程序执行时的语义不能被改变（就是执行结果不能被改变）。</p>
<p>happens - before 给编写正确同步的多线程程序的程序员一个幻觉：正确同步的多线程程序是按照 happens - before 指定的顺序来执行的。实际上不是，但是语义和按顺序执行是一样的。<br>（实际上是可见性，但也是一种假的顺序）</p>
<h4 id="✅happens-before规则"><a href="#✅happens-before规则" class="headerlink" title="✅happens-before规则"></a>✅happens-before规则</h4><p>1、程序顺序规则：一个线程中的每个操作，happens - before 于该程序的任意后续操作。</p>
<p>2、监视器规则：对一个锁的解锁，happens - before 于随后对这个锁的加锁。</p>
<p>3、volatile 变量规则：对一个 volatile 域的写，happens - before 于任意后续对这个 volatile 域的读。</p>
<p>4、传递性，如果 A happens - before B， B happens - before C，那么 A happens - before C</p>
<p>5、start() 规则：如果线程 A 执行操作 ThreadB.start()（启动线程B），那么线程 A 的 ThreadB.start() 操作 happens - before 线程 B 中的任意操作。</p>
<p>6、join() 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens- before 于线程 A 从 Thread.join() 操作成功返回。</p>
<p>⚠️像volitale变量一样，线程a写volatile变量前还写一个共享变量，线程b读那个volatile变量后还读那个共享变量，如何保证共享变量的安全性，因为线程a里的操作可能重排序，是由volitile的内存屏障插入策略和volatile的禁止编译器重排序规则来保证的，其他start方法和join方法也一样。因为重排序了的话，执行结果会不一样。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/laohuangaa/article/details/122773633">https://blog.csdn.net/laohuangaa/article/details/122773633</a></p>
<h3 id="8-双重检查锁定与延迟初始化"><a href="#8-双重检查锁定与延迟初始化" class="headerlink" title="8.双重检查锁定与延迟初始化"></a>8.双重检查锁定与延迟初始化</h3><p>在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。双重检查锁定是常见的延迟初始化技术，但它是一个错误的用法。</p>
<p>下面会讲述双重检查锁定为什么错误，以及两种线程安全的延迟初始化方案。</p>
<h4 id="✅双重检查锁定的由来"><a href="#✅双重检查锁定的由来" class="headerlink" title="✅双重检查锁定的由来"></a>✅双重检查锁定的由来</h4><p>在Java程序中，有时候可能需要推迟一些高开销的对象初始化操作，并且只有在使用这些对象时才进行初始化。此时，程序员可能会采用延迟初始化。</p>
<p>因为初始化可能在多线程环境下，它们共用一个对象，是需要一个线程创建就好了。非线程安全的延迟初始化对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class UnsafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null) //1：A线程执行</span><br><span class="line">            instance = new Instance(); //2：B线程执行</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A线程执行代码1的同时，B线程执行代码2。此时，线程A可能会看到instance引用的对象还没有完成初始化. 导致AB线程都初始化对象。</p>
<p>同步处理来实现线程安全的延迟初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line">    public synchronized static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">            instance = new Instance();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：synchronized将导致性能开销。如果getInstance()方法被多个线程频繁的调用，将会导致程序执行性能的下降。</p>
<p>因此，双重检查锁定来实现延迟初始化诞生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleCheckedLocking &#123; //1</span><br><span class="line">    private static Instance instance; //2</span><br><span class="line">    public static Instance getInstance() &#123; //3</span><br><span class="line">        if (instance == null) &#123; //4:第一次检查</span><br><span class="line">            synchronized (DoubleCheckedLocking.class) &#123; //5:加锁</span><br><span class="line">                if (instance == null) //6:第二次检查</span><br><span class="line">                    instance = new Instance(); //7:问题的根源出在这里</span><br><span class="line">            &#125; //8</span><br><span class="line">        &#125; //9</span><br><span class="line">        return instance; //10</span><br><span class="line">    &#125; //11</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心思想：不会每个线程都加锁，检查instance不为null，那么就不需要执行下面的加锁和初始化操作。获取锁之后，再检查一次是不是为null，因为在第一次判断是否为null时，可能另一个线程正在初始化。<br>（获取锁之前检查一次，获取锁之后检查一次）</p>
<p>但是是错误的：在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
<h4 id="✅双重检查锁定的问题"><a href="#✅双重检查锁定的问题" class="headerlink" title="✅双重检查锁定的问题"></a>✅双重检查锁定的问题</h4><p>第7行（instance=new Singleton();）创建了一个对象。这一行代码可以分解为如下的3行伪代码。</p>
<p>memory = allocate();　　// 1<strong>：分配对象的内存空间（引用变量）<br>ctorInstance(memory);　 // 2</strong>：初始化对象<br>instance = memory;　　 // 3**：设置instance指向刚分配的内存地址（赋值引用变量）（这个时候就不为null了）</p>
<p>上面3行伪代码中的2和3之间，可能会被重排序，因为这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。</p>
<p>如果发生重排序，另一个并发执行的线程B就有可能在第4行判断instance不为null。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化。<strong>线程B将会访问到一个还未初始化的对象</strong>。</p>
<p>如何解决，来实现线程安全的延迟初始化：<br>1） 不允许2和3重排序。<br>2）允许2和3重排序，但不允许其他线程“看到”这个重排序。</p>
<h4 id="✅基于volatile的解决方案"><a href="#✅基于volatile的解决方案" class="headerlink" title="✅基于volatile的解决方案"></a>✅基于volatile的解决方案</h4><p>把instance声明为volatile型，就可以实现线程安全的延迟初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SafeDoubleCheckedLocking &#123;</span><br><span class="line">    private volatile static Instance instance;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (SafeDoubleCheckedLocking.class) &#123;</span><br><span class="line">                if (instance == null)</span><br><span class="line">                    instance = new Instance();//instance为volatile，现在没问题了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要JDK 5或更高版本（因为从JDK 5开始使用新的JSR-133内存模型规范).</p>
<p>原理：使用了volatile修饰后，2、3将不会重排序。</p>
<h4 id="✅基于类初始化的解决方案"><a href="#✅基于类初始化的解决方案" class="headerlink" title="✅基于类初始化的解决方案"></a>✅基于类初始化的解决方案</h4><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceFactory &#123;</span><br><span class="line">    private static class InstanceHolder &#123;</span><br><span class="line">        public static Instance instance = new Instance();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        return InstanceHolder.instance; //这里将导致InstanceHolder类被初始化</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设两个线程并发执行getInstance()方法，但是只有一个线程能获取class对象的初始化锁，然后执行对象初始化。</p>
<p>💡初始化类的时机和原理：</p>
<p>初始化一个类，包括<strong>执行这个类的静态初始化和初始化在这个类中声明的静态字段</strong>。根据Java语言规范，在首次发生下列任意一种情况时，一个类或接口类型T将被立即初始化：<br>1）T是一个类，而且一个T类型的实例被创建。<br>2）T是一个类，且T中声明的一个静态方法被调用。<br>3）T中声明的一个静态字段被赋值。<br>4）T中声明的一个静态字段被使用，而且这个字段不是一个常量字段。<br>5）T是一个顶级类（Top Level Class），而且一个断言语句嵌套在T内部被执行。</p>
<p>在InstanceFactory示例代码中，首次执行getInstance()方法的线程将导致InstanceHolder类被初始化，是情况4.<br>（相当于是用一个工厂类来初始化另一个类？）</p>
<p>Java语言是多线程的，多个线程可能在同一时间尝试去初始化同一个类或接口（比如这里多个线程可能在同一时刻调用getInstance()方法来初始化InstanceHolder类）。因此，在Java中初始化一个类或者接口时，需要做细致的同步处理。</p>
<p>Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了。</p>
<p>（<strong>多个线程初始化类不是创建不同的对象吗？难道初始化类和创建对象不一样？</strong> 是的，先初始化类再创建对象）</p>
<p>对于类或接口的初始化，Java语言规范制定了精巧而复杂的类初始化处理过程。Java初始化一个类或接口的处理过程如下：</p>
<p>第1阶段：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化，获取锁之后，初始化维护一个状态，设置state=initialing，然后释放锁。获取不到的话，这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。</p>
<p>第2阶段：线程A执行类的初始化（上面的三步），同时线程B获取到初始化锁，发现状态是initialing，然后释放锁。后在初始化锁对应的condition上等待。</p>
<p>第3阶段：线程A获取初始化锁，设置state=initialized后，唤醒在condition中等待的所有线程，释放锁。</p>
<p>第4阶段：线程B获取锁，发现状态是initialed，释放锁，结束类的初始化处理。</p>
<p>所以，线程A执行类的初始化时的写入操作（执行类的静态初始化和初始化类中声明的静态字段），线程B一定能看到。</p>
<p>注意：这里的condition和state标记是本文虚构出来的。</p>
<p><strong>总结：</strong></p>
<p>基于类初始化的方案的实现代码更简洁，但只能对静态字段使用。但基于volatile的双重检查锁定的方案有一个额外的优势：除了可以对静态字段实现延迟初始化外，还可以对实例字段实现延迟初始化。</p>
<p>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://dandelioncloud.cn/article/details/1462953051467345921/">https://dandelioncloud.cn/article/details/1462953051467345921/</a></p>
<h3 id="9-java内存模型综述"><a href="#9-java内存模型综述" class="headerlink" title="9.java内存模型综述"></a>9.java内存模型综述</h3><h4 id="✅处理器的内存模型"><a href="#✅处理器的内存模型" class="headerlink" title="✅处理器的内存模型"></a>✅处理器的内存模型</h4><p>JMM：相当于是java编译器的内存模型</p>
<p>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为参照。在设计时，JMM和处理器内存模型会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。内存模型的束缚越少，处理器性能越好。</p>
<p>根据对不同类型的读/写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为如下几种类型：<br>1、放松程序中写-读操作的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）<br>2、在上面的基础上，继续放松程序中写-写操作的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。<br>3、在前面两条的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了Relaxed Memory Order内存模型（简称为RMO）和PowerPC内存模型。</p>
<p>这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，<strong>处理器不会对存在数据依赖性的两个内存操作做重排序</strong>）。</p>
<p>所有处理器内存模型都允许写-读重排序，原因是：使用了写缓存区。写缓存区可能导致写-读操作重排序。都允许更早读到当前处理器的写，原因同样是因为写缓存区。由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己写缓存区中的写。</p>
<p><strong>虚拟机对不同操作系统反映的一致性：</strong></p>
<p>由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。</p>
<h4 id="✅各种内存模型之间的关系"><a href="#✅各种内存模型之间的关系" class="headerlink" title="✅各种内存模型之间的关系"></a>✅各种内存模型之间的关系</h4><p>JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。</p>
<p>处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计得会越弱。</p>
<p>执行性能越好，易编程性越差。</p>
<h4 id="✅JMM的内存可见性保证"><a href="#✅JMM的内存可见性保证" class="headerlink" title="✅JMM的内存可见性保证"></a>✅JMM的内存可见性保证</h4><p>1、单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</p>
<p>2、正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p>
<p>3、未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。</p>
<p>最小安全性“发生”在对象被任意线程使用之前。64位数据的非原子性写“发生”在对象被多个线程使用的过程中（写共享变量）。如果是写了一半的，那就是线程B写了一半的，并不是null。<br>最小安全性保证线程读取到的值不会无中生有的冒出来，但并不保证线程读取到的值一定是正确的。</p>
<p>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h4 id="✅JSR-133对旧内存模型的修补"><a href="#✅JSR-133对旧内存模型的修补" class="headerlink" title="✅JSR-133对旧内存模型的修补"></a>✅JSR-133对旧内存模型的修补</h4><p>JSR-133对JDK 5之前的旧内存模型的修补主要有两个。</p>
<p>· 增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</p>
<p>· 增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，JSR-133为final增加了两个重排序规则。在保证final引用不会从构造函数内逸出的情况下，final具有了初始化安全性。</p>
<h2 id="第四章-java并发编程"><a href="#第四章-java并发编程" class="headerlink" title="第四章 java并发编程"></a>第四章 java并发编程</h2><p>Java从诞生开始就明智地选择了内置对多线程的支持，这使得Java语言相比同一时期的其他语言具有明显的优势。</p>
<p>线程作为操作系统调度的最小单元，多个线程能够同时执行（多核同时，单核并发），这将显著提升程序性能，在多核环境中表现得更加明显。但是，过多地创建线程和对线程的不当管理也容易造成问题。</p>
<h3 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1.线程简介"></a>1.线程简介</h3><h4 id="✅什么是线程"><a href="#✅什么是线程" class="headerlink" title="✅什么是线程"></a>✅什么是线程</h4><p>现代操作系统在运行一个程序时，会为其创建一个进程。操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<p>处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</p>
<p>Java程序天生就是多线程程序，使用JMX来查看一个普通的Java程序包含哪些线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MultiThread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 获取Java线程管理 MXBean</span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        // 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);</span><br><span class="line">        // 遍历线程信息，仅打印线程 ID 和 线程名称信息</span><br><span class="line">        for (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.println(&quot;[&quot; + threadInfo.getThreadId() + &quot;] &quot; + threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅为什么使用多线程"><a href="#✅为什么使用多线程" class="headerlink" title="✅为什么使用多线程"></a>✅为什么使用多线程</h4><p>1、更多的处理器核心<br>如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</p>
<p>2、更快的响应时间<br>使用多线程技术，将数据一致性不强的操作派发给不同线程处理（消息队列也可以做到），响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。</p>
<p>3、更好的编程模式<br>Java为多线程编程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决</p>
<h4 id="✅线程优先级"><a href="#✅线程优先级" class="headerlink" title="✅线程优先级"></a>✅线程优先级</h4><p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。</p>
<p>时间片就是分配给线程的处理器资源，在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。</p>
<p>设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。</p>
<p>一个计数线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static class Job implements Runnable &#123;</span><br><span class="line">            private int priority;</span><br><span class="line">            private long jobCount;</span><br><span class="line">            public Job(int priority) &#123;</span><br><span class="line">                    this.priority = priority;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (notStart) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">                while (notEnd) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                    jobCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看10s多个不同优先级的计数，操作系统可能会忽略对线程优先级的设定。</p>
<h4 id="✅线程的状态"><a href="#✅线程的状态" class="headerlink" title="✅线程的状态"></a>✅线程的状态</h4><p>线程创建之后，调用start()方法开始运行。当线程执行wait()方法之后，线程进入等待状态（释放锁）。</p>
<p>进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。</p>
<p>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。</p>
<p>等待和超时等待的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//该线程在waiting.class实例上等待</span><br><span class="line">static class Waiting implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (Waiting.class) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Waiting.class.wait();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该线程不断进行睡眠，超时等待</span><br><span class="line">static class TimeWaiting implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            SleepUtils.second(100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java将操作系统中的运行和就绪两个状态合并称为运行状态。<br>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</p>
</blockquote>
<h4 id="✅Daemon线程"><a href="#✅Daemon线程" class="headerlink" title="✅Daemon线程"></a>✅Daemon线程</h4><p>守护线程。</p>
<p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出，所有Daemon线程都需要立即终止。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。</p>
<p>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。因此，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p>
<h3 id="2-启动和终止线程"><a href="#2-启动和终止线程" class="headerlink" title="2.启动和终止线程"></a>2.启动和终止线程</h3><p>调用start方法进行启动线程，随着run方法的执行完毕，线程随之终止。</p>
<h4 id="✅构造线程"><a href="#✅构造线程" class="headerlink" title="✅构造线程"></a>✅构造线程</h4><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。</p>
<p>个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。</p>
<p>一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</p>
<h4 id="✅启动线程"><a href="#✅启动线程" class="headerlink" title="✅启动线程"></a>✅启动线程</h4><p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。</p>
<p>线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</p>
<h4 id="✅中断线程"><a href="#✅中断线程" class="headerlink" title="✅中断线程"></a>✅中断线程</h4><p>中断，效果是终止一个线程，可以理解为线程的一个标识位属性 （并不能直接终止一个线程），它表示一个运行中的线程是否被其他线程进行了中断操作。</p>
<p>中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的 interrupt() 方法对其进行中断操作。线程通过检查自身是否被中断来进行响应，线程通过方法 isInterrupted() 来进行判断是否被中断。</p>
<p>从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep （long millis）方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。</p>
<p>如下所示的例子中，首先创建了两个线程，SleepThread和BusyThread，前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Interrupted &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // sleepThread不停的尝试睡眠</span><br><span class="line">        Thread sleepThread = new Thread(new SleepRunner(), &quot;SleepThread&quot;);</span><br><span class="line">        sleepThread.setDaemon(true);</span><br><span class="line">        // busyThread不停的运行</span><br><span class="line">        Thread busyThread = new Thread(new BusyRunner(), &quot;BusyThread&quot;);</span><br><span class="line">        busyThread.setDaemon(true);</span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line">        // 休眠5秒，让sleepThread和busyThread充分运行</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line">        System.out.println(&quot;SleepThread interrupted is &quot; + sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(&quot;BusyThread interrupted is &quot; + busyThread.isInterrupted());</span><br><span class="line">        // 防止sleepThread和busyThread立刻退出</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125;</span><br><span class="line">    static class SleepRunner implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(10000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 对于Sleep，如果发生了中断，就会抛出中断异常。抛出后，interrupt的表示位会被重置。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class BusyRunner implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，抛出InterruptedException的线程SleepThread，其中断标识位被清除了，返回false。而一直忙碌运作的线程BusyThread，中断标识位没有被清除，返回true。</p>
<h4 id="✅过期的suspend-、resume-和stop"><a href="#✅过期的suspend-、resume-和stop" class="headerlink" title="✅过期的suspend()、resume()和stop()"></a>✅过期的suspend()、resume()和stop()</h4><p>suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。</p>
<p>不建议使用的原因主要是：</p>
<p>以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。<br>同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
<p>暂停和恢复操作可以用后面提到的等待/通知机制来替代。</p>
<h4 id="✅安全地终止线程"><a href="#✅安全地终止线程" class="headerlink" title="✅安全地终止线程"></a>✅安全地终止线程</h4><p>中断状态是线程的一个标识位，而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。</p>
<p>除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。</p>
<p>方法1：使用中断interrupt方法进行中断。按说是直接中断线程了，没加代码中的判断也应该中断的。❓<br>方法2：使用一个volatile的boolean类型变量来控制，实际上是中断while方法，然后执行完run方法，终止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Shutdown &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Runner one = new Runner();</span><br><span class="line">        Thread countThread = new Thread(one, &quot;CountThread&quot;);</span><br><span class="line">        countThread.start();</span><br><span class="line">        // 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line">        Runner two = new Runner();</span><br><span class="line">        countThread = new Thread(two, &quot;CountThread&quot;);</span><br><span class="line">        countThread.start();</span><br><span class="line">        // 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Runner implements Runnable &#123;</span><br><span class="line">        private long i;</span><br><span class="line">            private volatile boolean on = true;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            while (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;Count i = &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        public void cancel() &#123;</span><br><span class="line">            on = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例在执行过程中，main线程通过中断操作和cancel()方法均可使CountThread得以终止。</p>
<p>这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。</p>
<h3 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3.线程间通信"></a>3.线程间通信</h3><p>线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。多个线程配合工作，才更有价值。</p>
<h4 id="✅volatile和synchronized关键字"><a href="#✅volatile和synchronized关键字" class="headerlink" title="✅volatile和synchronized关键字"></a>✅volatile和synchronized关键字</h4><p>背景：<br>Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还可以拥有一份拷贝，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性）（就是线程的本地内存），所以程序在执行过程中，一个线程看到的变量并不一定是最新的。</p>
<p>volatile怎么解决：<br>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p>
<p>sychronized怎么解决：<br>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
<p>一点sychronized的实现原理：</p>
<p>看字节码文件，monitorenter和monitorexit指令，是对一个对象的监视器的获取，这个获取过程是排他的，一个时刻只有一个线程能够获取到由sychronized保护的对象的监视器。</p>
<p>任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处（进入同步队列），进入BLOCKED状态。当获锁线程释放了锁，该释放操作唤醒阻塞在同步队列中的线程，重新尝试对监视器的获取。</p>
<h4 id="✅等待-通知机制"><a href="#✅等待-通知机制" class="headerlink" title="✅等待/通知机制"></a>✅等待/通知机制</h4><p>背景：生产者线程修改某个变量的值，消费者线程能够感知到。简单的办法是让消费者线程不断地循环检查变量是否符合预期。但是开销大。</p>
<p>Java通过内置的等待/通知机制能够很好地解决这个矛盾并实现所需的功能。<br>等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类java.lang.Object上。（监视器方法）</p>
<p>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。<br>上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。（两个notify都是通知等待队列里的，不是阻塞状态的同步队列，notify通知一个，notifyAll通知所有）。</p>
<p>例子：创建了两个线程——WaitThread和NotifyThread，前者检查flag值是否为false，如果符合要求，进行后续操作，否则在lock上等待，后者在睡眠了一段时间后对lock进行通知。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotify &#123;</span><br><span class="line">    static boolean flag = true;</span><br><span class="line">    static Object lock = new Object();</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Thread waitThread = new Thread(new Wait(), &quot;WaitThread&quot;);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        Thread notifyThread = new Thread(new Notify(), &quot;NotifyThread&quot;);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    static class Wait implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 加锁，拥有lock的Monitor</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                // 当条件不满足时，继续wait，同时释放了lock的锁</span><br><span class="line">                while (flag) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + &quot; flag is true. wait@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 条件满足时，完成工作</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; flag is false. running@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Notify implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 加锁，拥有lock的Monitor</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                // 获取lock的锁，然后进行通知，通知时不会释放lock的锁，</span><br><span class="line">                // 直到当前线程释放了lock后，WaitThread才能从wait方法中返回</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; hold lock. notify @ &quot; +</span><br><span class="line">                        new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 再次加锁</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; hold lock again. sleep@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用wait()、notify()以及notifyAll()时需要注意的细节:</p>
<p>1、使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</p>
<p>2、调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列，并释放锁。</p>
<p>3、notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。</p>
<p>4、notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。</p>
<p>5、从wait()方法返回的前提是获得了调用对象的锁。<strong>等待/通知机制依托于同步机制</strong>，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改（也就是flag变量）。</p>
<p>梳理一下等待线程的状态变化：<br>1、wait线程首先获取锁，调用lock的wait方法，放弃了锁，进入等待队列，等待状态。（可以有很多个wait线程）<br>2、notify线程获取了锁，调用lock的notify方法，将wait线程从等待队列移动到了同步队列，是阻塞状态。（notify只能唤醒一个）<br>3、notify线程运行完了，释放锁，wait线程获取到锁，从wait方法返回并继续执行。</p>
<p>sleep不会释放锁<br>wait会释放锁</p>
<h4 id="✅等待-通知的经典范式"><a href="#✅等待-通知的经典范式" class="headerlink" title="✅等待/通知的经典范式"></a>✅等待/通知的经典范式</h4><p>范式分为两部分，分别针对等待方（消费者）和通知方（生产者）</p>
<p>等待方遵循如下原则：<br>1、获取对象的锁。<br>2、如果条件不满足（flag变量），那么调用对象的wait()方法，被通知后仍要检查条件。<br>3、条件满足则执行对应的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">	while(条件不满足) &#123;</span><br><span class="line">		对象.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知方遵循如下原则：<br>1、获得对象的锁。<br>2、改变条件。<br>3、通知所有等待在对象上的线程。（先改变条件还是先通知都行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">	改变条件(flag)</span><br><span class="line">	对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、flag的目的：相当于是一个线程修改了某个值，另一个线程能感知到，起到一个多线程通信达到什么条件做什么事的效果。<br>2、同步的目的：获取了锁才能wait和notify，同步的目的是把修改变量和notify包在一起，让wait出来的时候能感知到变量的变化。<br>3、其实这个模式已经是偏底层了。<br>4、flag和lock可以用一个，直接用flag来当锁（就像后面的手写线程池）</p>
<h4 id="✅管道输入-输出流"><a href="#✅管道输入-输出流" class="headerlink" title="✅管道输入/输出流"></a>✅管道输入/输出流</h4><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p>
<p>管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</p>
<p>例子：printThread线程接受main线程的输入，任何main线程的输入均通过PipedWriter写入，而printThread在另一端通过PipedReader将内容读出并打印。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Piped &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        PipedWriter out = new PipedWriter();</span><br><span class="line">        PipedReader in = new PipedReader();</span><br><span class="line">        // 将输出流和输入流进行连接，否则在使用时会抛出IOException</span><br><span class="line">        out.connect(in);</span><br><span class="line">        Thread printThread = new Thread(new Print(in), &quot;PrintThread&quot;);</span><br><span class="line">        printThread.start();</span><br><span class="line">        int receive = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while ((receive = System.in.read()) != -1) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Print implements Runnable &#123;</span><br><span class="line">        private PipedReader in;</span><br><span class="line"></span><br><span class="line">        public Print(PipedReader in) &#123;</span><br><span class="line">            this.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int receive = 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                while ((receive = in.read()) != -1) &#123;</span><br><span class="line">                    System.out.print((char) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️对于Piped类型的流，必须先要进行绑定，也就是调用connect()方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。</p>
<h4 id="✅Thread-join-的使用"><a href="#✅Thread-join-的使用" class="headerlink" title="✅Thread.join()的使用"></a>✅Thread.join()的使用</h4><p>如果一个线程A执行了thread.join()语句，其含义是：<br>当前线程A等待thread线程终止之后才从thread.join()返回，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。</p>
<p>例子：创建了10个线程，编号0~9，每个线程调用前一个线程的join()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Join &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Thread previous = Thread.currentThread();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span><br><span class="line">            Thread thread = new Thread(new Domino(previous), String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">            previous = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Domino implements Runnable &#123;</span><br><span class="line">        private Thread thread;</span><br><span class="line"></span><br><span class="line">        public Domino(Thread thread) &#123;</span><br><span class="line">            this.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）。加锁、循环和处理逻辑3个步骤。</p>
<p>1、线程a执行线程b的join方法，相当于用线程b对象做同步，内部本线程wait进入等待，并用一个变量flag进行条件判断。<br>2、线程b终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。</p>
<h4 id="✅ThreadLocal的使用"><a href="#✅ThreadLocal的使用" class="headerlink" title="✅ThreadLocal的使用"></a>✅ThreadLocal的使用</h4><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。它不是线程共有的，而是私有的。即修改不会影响其他线程。一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的值。set()方法设置，get()方法获取设置的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line">取出后，(T)value强转即可</span><br></pre></td></tr></table></figure>

<p>例子：一个Profile类，具有begin()和end()两个方法，而end()方法返回从begin()方法调用开始到end()方法被调用时的时间差，单位是毫秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Profiler &#123;</span><br><span class="line">    // 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次</span><br><span class="line">    private static final ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = new ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">        protected Long initialValue() &#123;</span><br><span class="line">            return System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static final void begin() &#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final long end() &#123;</span><br><span class="line">        return System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        System.out.println(&quot;Cost: &quot; + Profiler.end() + &quot; mills&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用途：Profiler可以被复用在方法调用耗时统计的功能上，在方法的入口前执行begin()方法，在方法调用后执行end()方法。好处是两个方法的调用不用在一个方法或者类中。</p>
<h3 id="4-线程应用案例"><a href="#4-线程应用案例" class="headerlink" title="4.线程应用案例"></a>4.线程应用案例</h3><h4 id="✅等待超时模式"><a href="#✅等待超时模式" class="headerlink" title="✅等待超时模式"></a>✅等待超时模式</h4><p>在前面等待/通知模式的基础上，如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。</p>
<p>范式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 对当前对象加锁</span><br><span class="line">public synchronized Object get(long mills) throws InterruptedException &#123;</span><br><span class="line">	long future = System.currentTimeMillis() + mills;</span><br><span class="line">	long remaining = mills;</span><br><span class="line">	// 当超时大于0并且result返回值不满足要求</span><br><span class="line">	while ((result == null) &amp;&amp; remaining &gt; 0) &#123;</span><br><span class="line">		wait(remaining);</span><br><span class="line">		remaining = future - System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等待超时模式就是在等待/通知范式基础上增加了超时控制，这使得该模式相比原有范式更具有灵活性，因为即使方法执行时间过长，也不会“永久”阻塞调用者，而是会按照调用者的要求“按时”返回。</p>
<p>并且，不是只wait固定的时间就完事，而是循环检查是不是wait够了，够了就直接返回不wait了。</p>
<h4 id="✅一个简单的数据库连接池示例"><a href="#✅一个简单的数据库连接池示例" class="headerlink" title="✅一个简单的数据库连接池示例"></a>✅一个简单的数据库连接池示例</h4><p>使用等待超时模式来构造一个简单的数据库连接池，在示例中模拟从连接池中获取、使用和释放连接的过程，而客户端获取连接的过程被设定为等待超时的模式，也就是在1000毫秒内如果无法获取到可用连接，将会返回给客户端一个null。</p>
<p>设定连接池的大小为10个，然后通过调节客户端的线程数来模拟无法获取连接的场景。</p>
<p>首先看一下连接池的定义。它通过构造函数初始化连接的最大上限，通过一个双向队列来维护连接，调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连接，当连接使用完成后，需要调用releaseConnection(Connection)方法将连接放回线程池，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionPool &#123;</span><br><span class="line">	//连接池</span><br><span class="line">    private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    //构造</span><br><span class="line">    public ConnectionPool(int initialSize) &#123;</span><br><span class="line">        if (initialSize &gt; 0) &#123;</span><br><span class="line">        	//创建数据库连接</span><br><span class="line">            for (int i = 0; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());//该类在后面实现，用于初始化线程池</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void releaseConnection(Connection connection) &#123;</span><br><span class="line">        if (connection != null) &#123;</span><br><span class="line">            synchronized (pool) &#123;</span><br><span class="line">                // 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                // 唤醒所有等待，让他们去竞争锁</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在mills内无法获取到连接，将会返回null</span><br><span class="line">    //获取连接</span><br><span class="line">    public Connection fetchConnection(long mills) throws InterruptedException &#123;</span><br><span class="line">        synchronized (pool) &#123;</span><br><span class="line">        	// 该部分代码逻辑为</span><br><span class="line">        	// 当完全超时时，必然会获得一个连接池对象,也即是无线等待时间。当传入mills &gt; 0时，不会走入该分支。因为else分支会处理其中超时情况</span><br><span class="line">        	// 非完全超时时，获得就返回一个连接池对象，不然就返回空</span><br><span class="line">        	</span><br><span class="line">            // 完全超时</span><br><span class="line">            if (mills &lt;= 0) &#123;</span><br><span class="line">            	// 连接池为空</span><br><span class="line">                while (pool.isEmpty()) &#123;</span><br><span class="line">                    //以连接池为通知对象，等待直到被唤醒，不在主动醒来</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                // 拿出连接池中第一个连接，并返回给当前请求者</span><br><span class="line">                return pool.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            //未超时 </span><br><span class="line">            else &#123;</span><br><span class="line">                long future = System.currentTimeMillis() + mills;</span><br><span class="line">                long remaining = mills;</span><br><span class="line">                //连接池为空且未超时</span><br><span class="line">                while (pool.isEmpty() &amp;&amp; remaining &gt; 0) &#123;</span><br><span class="line">                	//以连接池为通知对象，等待remaining毫秒,或者被唤醒</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    // 获取剩余时间，通过它来判断是主动醒来（超时），还是被动唤醒（notify）</span><br><span class="line">                    // 无论是被动还是主动醒来，都尝试获取连接池这个对象锁</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                    // 获得锁以后判断连接池是不是空的，空的的话再判断是否超时，超时就离开循环</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Connection result = null;</span><br><span class="line">                //抢到连接池这个对象锁后，若此时连接池不为空</span><br><span class="line">                if (!pool.isEmpty()) &#123;</span><br><span class="line">                	// 拿出连接池中第一个连接，并返回给当前请求者</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                // 否则此时为空</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于java.sql.Connection是一个接口，最终的实现是由数据库驱动提供方来实现的，考虑到只是个示例，我们通过<strong>动态代理</strong>构造了一个Connection，该Connection的代理实现仅仅是在commit()方法（提交sql）调用时休眠100毫秒，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionDriver &#123;</span><br><span class="line"></span><br><span class="line">    static class ConnectionHandler implements InvocationHandler &#123;</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123;</span><br><span class="line">         // 在方法执行之前</span><br><span class="line">        // 当方法是提交时，我们睡眠100毫秒</span><br><span class="line">        if (method.getName().equals(&quot;commit&quot;))&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 执行原本方法，此处就不执行了</span><br><span class="line">       	// Object invoke = method.invoke(vehical, args);</span><br><span class="line">       	</span><br><span class="line">		// 执行方法之后，此处也不处理，直接放回null</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个Connection的代理，在commit时休眠100毫秒</span><br><span class="line">    public static final Connection createConnection() &#123;</span><br><span class="line">    	// 创建一个代理实例</span><br><span class="line">    	// 类加载器(用哪个类加载器去加载代理对象) + 代理的类(接口，切入点) + 代理方法</span><br><span class="line">    	// 可以理解我们为Connection的&quot;commit&quot;方法，通过JDK的方式代理了一层(AOP)</span><br><span class="line">    	// 返回的就是我们Spring中学习的 代理额外增加的层 + 原本的类对象</span><br><span class="line">        return (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(),new Class &lt;?&gt;[]&#123;</span><br><span class="line">            Connection.class</span><br><span class="line">        &#125;,new ConnectionHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面通过一个示例来测试简易数据库连接池的工作情况，模拟客户端ConnectionRunner获取、使用、最后释放连接的过程，当它使用时连接将会增加获取到连接的数量，反之，将会增加未获取到连接的数量，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionPoolTest &#123;</span><br><span class="line">    static ConnectionPool pool = new ConnectionPool(10);</span><br><span class="line">    // 保证所有ConnectionRunner能够同时开始</span><br><span class="line">    static CountDownLatch start = new CountDownLatch(1);</span><br><span class="line">    // main线程将会等待所有ConnectionRunner结束后才能继续执行</span><br><span class="line">    static CountDownLatch end;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 线程数量，可以修改线程数量进行观察</span><br><span class="line">        int threadCount = 10;</span><br><span class="line">        end = new CountDownLatch(threadCount);</span><br><span class="line">        int count = 20;</span><br><span class="line">        // 用原子记录 获取到的与没有获取到的</span><br><span class="line">        AtomicInteger got = new AtomicInteger();</span><br><span class="line">        AtomicInteger notGot = new AtomicInteger();</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">        	// 运行线程</span><br><span class="line">            Thread thread = new Thread(new ConnetionRunner(count, got, notGot),</span><br><span class="line">                    &quot;ConnectionRunnerThread&quot;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        //运行到这里start值-1，此时为0，因此所有线程不再会被阻塞，开始执行</span><br><span class="line">        start.countDown();</span><br><span class="line">        //主线程阻塞在这里，等待end为0，即等待所有线程结束</span><br><span class="line">        end.await();   //等10个线程都执行完</span><br><span class="line">        System.out.println(&quot;total invoke: &quot; + (threadCount * count));</span><br><span class="line">        System.out.println(&quot;got connection: &quot; + got);</span><br><span class="line">        System.out.println(&quot;not got connection &quot; + notGot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ConnetionRunner implements Runnable &#123;</span><br><span class="line">        int count;</span><br><span class="line">        AtomicInteger got;</span><br><span class="line">        AtomicInteger notGot;</span><br><span class="line"></span><br><span class="line">		// got、noteGot因为是引用，所以本质还是原来的那个</span><br><span class="line">        public ConnetionRunner(int count, AtomicInteger got, AtomicInteger notGot) &#123;</span><br><span class="line">            this.count = count;</span><br><span class="line">            this.got = got;</span><br><span class="line">            this.notGot = notGot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            	// 阻塞在这里，等待start为0</span><br><span class="line">                start.await();  //等10个线程都创建好后一起执行</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当count &gt; 0 时，再次执行</span><br><span class="line">            while (count &gt; 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 从线程池中获取连接，如果1000ms内无法获取到，将会返回null</span><br><span class="line">                    // 分别统计连接获取的数量got和未获取到的数量notGot</span><br><span class="line">                    Connection connection = pool.fetchConnection(1000);</span><br><span class="line">                    // 如果获取到了</span><br><span class="line">                    if (connection != null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                        	// 创建SQL语句</span><br><span class="line">                            connection.createStatement();</span><br><span class="line">                            // 执行提交</span><br><span class="line">                            connection.commit();</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                        	// 释放</span><br><span class="line">                            pool.releaseConnection(connection);</span><br><span class="line">                            // 获取到got + 1</span><br><span class="line">                            got.incrementAndGet();</span><br><span class="line">                        &#125;</span><br><span class="line">                     // 没有获取到</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                    	// 没有获取到notGot + 1</span><br><span class="line">                        notGot.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                </span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 线程结束 end - 1</span><br><span class="line">            end.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中使用了CountDownLatch来确保ConnectionRunnerThread能够同时开始执行，并且在全部结束之后，才使main线程从等待状态中返回。</p>
<p>在资源一定的情况下（连接池中的10个连接），随着客户端线程的逐步增加，客户端出现超时无法获取连接的比率不断升高。</p>
<h4 id="✅线程池技术及其示例"><a href="#✅线程池技术及其示例" class="headerlink" title="✅线程池技术及其示例"></a>✅线程池技术及其示例</h4><p>如果服务端每次接受到一个任务，创建一个线程，然后进行执行，这会使操作系统频繁的进行线程上下文切换，无故增加系统的负载，而线程的创建和消亡都是需要耗费系统资源的，也无疑浪费了系统资源。</p>
<p>线程池技术能够很好地解决这个问题，它预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。</p>
<p>线程池的好处：<br>1、消除了频繁创建和消亡线程的系统资源开销<br>2、面对过量任务的提交能够平缓的劣化。</p>
<p>线程池接口定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface ThreadPool&lt;Job extends Runnable&gt; &#123;</span><br><span class="line">    // 执行一个Job，这个Job需要实现Runnable</span><br><span class="line">    void execute(Job job);</span><br><span class="line"></span><br><span class="line">    // 关闭线程池</span><br><span class="line">    void shutdown();</span><br><span class="line"></span><br><span class="line">    // 增加工作者线程</span><br><span class="line">    void addWorkers(int num);</span><br><span class="line"></span><br><span class="line">    // 减少工作者线程</span><br><span class="line">    void removeWorker(int num);</span><br><span class="line"></span><br><span class="line">    // 得到正在等待执行的任务数量</span><br><span class="line">    int getJobSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端可以通过execute(Job)方法将Job提交入线程池执行，而客户端自身不用等待Job的执行完成。<br>除了execute(Job)方法以外，线程池接口提供了增大/减少工作者线程以及关闭线程池的方法。<br>这里工作者线程代表着一个重复执行Job的线程，而每个由客户端提交的Job都将进入到一个工作队列中等待工作者线程的处理。</p>
<p>手写一个线程池，不用Executor创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123;</span><br><span class="line">    // 线程池最大限制数</span><br><span class="line">    private static final int MAX_WORKER_NUMBERS = 10;</span><br><span class="line">    // 线程池默认的数量</span><br><span class="line">    private static final int DEFAULT_WORKER_NUMBERS = 5;</span><br><span class="line">    // 线程池最小的数量</span><br><span class="line">    private static final int MIN_WORKER_NUMBERS = 1;</span><br><span class="line">    // 这是一个工作列表，将会向里面插入工作</span><br><span class="line">    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();</span><br><span class="line">    // 工作者列表</span><br><span class="line">    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;());</span><br><span class="line">    // 工作者线程的数量</span><br><span class="line">    private int workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    // 线程编号生成</span><br><span class="line">    private AtomicLong threadNum = new AtomicLong();</span><br><span class="line">	</span><br><span class="line">    //构造函数</span><br><span class="line">    public DefaultThreadPool() &#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DefaultThreadPool(int num) &#123;</span><br><span class="line">    	// num &gt; max ， 取 max，num &lt; min 取 min。其他取 num</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS:(num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num);</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute(Job job) &#123;</span><br><span class="line">        if (job != null) &#123;</span><br><span class="line">            // 添加一个工作，然后进行通知</span><br><span class="line">            synchronized (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();   //通知（这里jobs既是flag又是lock）</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        for (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addWorkers(int num) &#123;</span><br><span class="line">        synchronized (jobs) &#123;</span><br><span class="line">            // 限制新增的Worker数量不能超过最大值</span><br><span class="line">            if (num + this.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - this.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            this.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeWorker(int num) &#123;</span><br><span class="line">        synchronized (jobs) &#123;</span><br><span class="line">            if (num &gt;= this.workerNum) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;beyond workNum&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 按照给定的数量停止Worker</span><br><span class="line">            int count = 0;</span><br><span class="line">            while (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                if (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getJobSize() &#123;</span><br><span class="line">        return jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化线程工作者</span><br><span class="line">    private void initializeWokers(int num) &#123;</span><br><span class="line">        for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = new Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.inrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 工作者，负责消费任务</span><br><span class="line">    class Worker implements Runnable &#123;</span><br><span class="line">        // 是否工作</span><br><span class="line">        private volatile boolean running = true;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (running) &#123;</span><br><span class="line">                Job job = null;</span><br><span class="line">                synchronized (jobs) &#123;</span><br><span class="line">                    // 如果工作者列表是空的，那么就wait</span><br><span class="line">                    while (jobs.isEmpty()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            jobs.wait();  //等待</span><br><span class="line">                        &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                            // 感知到外部对WorkerThread的中断操作，返回</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 取出一个Job</span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                if (job != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; catch (Exception ex) &#123;</span><br><span class="line">                        // 忽略Job执行中的Exception</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void shutdown() &#123;</span><br><span class="line">            running = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Job是要放入线程池的线程，Worker是线程池内执行Job线程的工作线程。里面用了等待通知模式，放入一个job会通知一下，jobs为空了就会等待。</p>
<p>当客户端调用execute(Job)方法时，会不断地向任务列表jobs中添加Job，而每个工作者线程会不断地从jobs上取出一个Job进行执行，当jobs为空时，工作者线程进入等待状态。</p>
<p>添加一个Job后，对工作队列jobs调用了其notify()方法，而不是notifyAll()方法，因为能够确定有工作者线程被唤醒，这时使用notify()方法将会比notifyAll()方法获得更小的开销（避免将等待队列中的线程全部移动到阻塞队列中）。</p>
<p>可以看到，线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作队列上取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者线程，随着大量的任务被提交，更多的工作者线程会被唤醒。</p>
<h4 id="✅一个基于线程池技术的简单Web服务器"><a href="#✅一个基于线程池技术的简单Web服务器" class="headerlink" title="✅一个基于线程池技术的简单Web服务器"></a>✅一个基于线程池技术的简单Web服务器</h4><p>目前的浏览器都支持多线程访问，比如说在请求一个HTML页面的时候，页面中包含的图片资源、样式资源会被浏览器发起并发的获取。</p>
<p>大部分Web服务器也都是支持并发访问的。常用的Java Web服务器，如Tomcat、Jetty，在其处理请求的过程中都使用到了线程池技术。</p>
<p>使用前一节中的线程池来构造一个简单的Web服务器，这个Web服务器用来处理HTTP请求，目前只能处理简单的文本和JPG图片内容。这个Web服务器使用main线程不断地接受客户端Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleHttpServer &#123;</span><br><span class="line">    // 处理HttpRequest的线程池</span><br><span class="line">    static ThreadPool&lt;HttpRequestHandler&gt; threadPool = new DefaultThreadPool&lt;HttpRequestHandler&gt;(1);</span><br><span class="line">    // SimpleHttpServer的根路径</span><br><span class="line">    static String basePath;</span><br><span class="line">    static ServerSocket serverSocket;</span><br><span class="line">    // 服务监听端口</span><br><span class="line">    static int port = 8080;</span><br><span class="line"></span><br><span class="line">    public static void setPort(int port) &#123;</span><br><span class="line">        if (port &gt; 0) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setBasePath(String basePath) &#123;</span><br><span class="line">         if (basePath != null &amp;&amp; new File(basePath).exists() &amp;&amp; new File(basePath).isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启动SimpleHttpServer，一个客户端请求</span><br><span class="line">    public static void start() throws Exception &#123;</span><br><span class="line">        serverSocket = new ServerSocket(port);</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        //accept():3次握手结束，接受连接</span><br><span class="line">        while ((socket = serverSocket.accept()) != null) &#123;</span><br><span class="line">            // 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span><br><span class="line">            threadPool.execute(new HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class HttpRequestHandler implements Runnable &#123;</span><br><span class="line">        private Socket socket;</span><br><span class="line"></span><br><span class="line">        public HttpRequestHandler(Socket socket) &#123;</span><br><span class="line">            this.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            String line = null;</span><br><span class="line">            BufferedReader br = null;</span><br><span class="line">            BufferedReader reader = null;</span><br><span class="line">            PrintWriter out = null;</span><br><span class="line">            InputStream in = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">                // 由相对路径计算出绝对路径</span><br><span class="line">                String filePath = basePath + header.split(&quot; &quot;)[1];</span><br><span class="line">                out = new PrintWriter(socket.getOutputStream());</span><br><span class="line">                 // 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span><br><span class="line">                if (filePath.endsWith(&quot;jpg&quot;) || filePath.endsWith(&quot;ico&quot;)) &#123;</span><br><span class="line">                    in = new FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">                    int i = 0;</span><br><span class="line">                    while ((i = in.read()) != -1) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    byte[] array = baos.toByteArray();</span><br><span class="line">                    out.println(&quot;HTTP/1.1 200 OK&quot;);</span><br><span class="line">                    out.println(&quot;Server: yjx23332&quot;);</span><br><span class="line">                    out.println(&quot;Content-Type: image/jpeg&quot;);</span><br><span class="line">                    out.println(&quot;Content-Length: &quot; + array.length);</span><br><span class="line">                    out.println(&quot;&quot;);</span><br><span class="line">                    System.out.println(&quot;传回！&quot;);</span><br><span class="line">                    socket.getOutputStream().write(array, 0, array.length);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    br = new BufferedReader(new InputStreamReader(new</span><br><span class="line">                            FileInputStream(filePath)));</span><br><span class="line">                    out = new PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(&quot;HTTP/1.1 200 OK&quot;);</span><br><span class="line">                    out.println(&quot;Server: yjx23332&quot;);</span><br><span class="line">                    out.println(&quot;Content-Type: text/html; charset=UTF-8&quot;);</span><br><span class="line">                    out.println(&quot;&quot;);</span><br><span class="line">                    while ((line = br.readLine()) != null) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                out.println(&quot;HTTP/1.1 500&quot;);</span><br><span class="line">                out.println(&quot;&quot;);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 关闭流或者Socket</span><br><span class="line">    private static void close(Closeable... closeables) &#123;</span><br><span class="line">        if (closeables != null) &#123;</span><br><span class="line">            for (Closeable closeable : closeables) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleHttpServer提供设置端口和跟路径的方法，SimpleHttpServer在建立了与客户端的连接之后，并不会处理客户端的请求，而是将其包装成HttpRequestHandler并交由线程池处理。</p>
<p>在线程池中的Worker处理客户端请求的同时，SimpleHttpServer能够继续完成后续客户端连接的建立，不会阻塞后续客户端的请求。Worker处理请求资源生成响应内容后，异步输出内容到客户端。</p>
<p>html页面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;测试页面&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">&lt;body &gt;</span><br><span class="line">	&lt;h1&gt;第一张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;1.jpg&quot; /&gt;</span><br><span class="line">	&lt;h1&gt;第二张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;2.jpg&quot; /&gt;</span><br><span class="line">	&lt;h1&gt;第三张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;3.jpg&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>将SimpleHttpServer的根目录设定到该HTML页面所在目录，并启动SimpleHttpServer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    SimpleHttpServer.setBasePath(&quot;C:\Users\Administrator\Desktop\server&quot;);</span><br><span class="line">    SimpleHttpServer.setPort(8080);</span><br><span class="line">    SimpleHttpServer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️线程池中的线程不是越多越好：<br>线程池中线程数量并不是越多越好，具体的数量需要评估每个任务的处理时间，以及当前计算机的处理器能力和数量。使用的线程过少，无法发挥处理器的性能；使用的线程过多，将会增加系统的无故开销，起到相反的作用。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46949627/article/details/127009251">https://blog.csdn.net/weixin_46949627/article/details/127009251</a></p>
<h2 id="第五章-java中的锁"><a href="#第五章-java中的锁" class="headerlink" title="第五章 java中的锁"></a>第五章 java中的锁</h2><p>介绍java并发包中与锁相关的API和组件，以及这些API和组件的使用方式和实现细节。</p>
<h3 id="1-Lock接口"><a href="#1-Lock接口" class="headerlink" title="1.Lock接口"></a>1.Lock接口</h3><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。</p>
<h4 id="✅Lock接口和synchronized关键字的对比"><a href="#✅Lock接口和synchronized关键字的对比" class="headerlink" title="✅Lock接口和synchronized关键字的对比"></a>✅Lock接口和synchronized关键字的对比</h4><p>在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。</p>
<p>虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<p>使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。当然，这种方式简化了同步的管理，可是扩展性没有显示的锁获取和释放来的好。例如：先获得锁A，然后再获取锁B。</p>
<p>Lock的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。</p>
<p>Lock具备的sychronized关键字不具备的特点：<br>1、非阻塞地获取锁<br>2、能被中断地获取锁（获取到锁的线程能响应中断，中断异常被抛出，同时锁释放）<br>3、超时获取锁（截止时间无法获取锁，则返回）</p>
<h4 id="✅Lock接口中的API"><a href="#✅Lock接口中的API" class="headerlink" title="✅Lock接口中的API"></a>✅Lock接口中的API</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void lock()</span><br><span class="line">获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回</span><br><span class="line"></span><br><span class="line">void lockInterruptibly() throws InterruptedException	</span><br><span class="line">可中断地获取锁，和 lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程</span><br><span class="line"></span><br><span class="line">boolean tryLock()	</span><br><span class="line">尝试非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回true，否则返回false</span><br><span class="line"></span><br><span class="line">boolean tryLock(1ong time,TimeUnit unit) throws InterruptedException	</span><br><span class="line">超时的获取锁，当前线程在以下3种情况下会返回：①当前线程在超时时间内获得了锁 ②当前线程在超时时间内被中断 ③超时时间结束，返回false</span><br><span class="line"></span><br><span class="line">void unlock() </span><br><span class="line">释放锁</span><br><span class="line"></span><br><span class="line">Condition newCondition()	</span><br><span class="line">获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的 wait()方法，而调用后，当前线程将释放锁</span><br></pre></td></tr></table></figure>

<p>随后会详细介绍同步器AbstractQueuedSynchronizer以及常用Lock接口的实现ReentrantLock。Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。</p>
<h3 id="2-队列同步器"><a href="#2-队列同步器" class="headerlink" title="2.队列同步器"></a>2.队列同步器</h3><p>队列同步器 AbstractQueuedSynchronizer（AQS，以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<p>同步器提供的3个方法来对同步状态进行更改，它们能够保证状态的改变是安全的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getState()  获取当前同步状态。</span><br><span class="line">setState(int newState)  设置当前同步状态。</span><br><span class="line">compareAndSetState(int expect,int update)） 使用CAS设置当前状态，该方法能够保证状态</span><br></pre></td></tr></table></figure>

<p>子类通过继承同步器并实现它的抽象方法来管理同步状态，子类推荐被定义为自定义同步组件的静态内部类。同步器自身没有实现任何同步接口，它仅仅是定义了上面同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件：<br>ReentrantLock<br>ReentrantReadWriteLock<br>CountDownLatch</p>
<p>队列同步器与锁的关系：</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</p>
<p>1、锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节<br>2、同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<h4 id="✅队列同步器的接口与示例"><a href="#✅队列同步器的接口与示例" class="headerlink" title="✅队列同步器的接口与示例"></a>✅队列同步器的接口与示例</h4><p>同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器作为静态内部类组合在自定义同步组件的实现中，并调用同步器提供的模板方法。</p>
<p><strong>同步器可重写的方法</strong>，包含两种，一种是获取独占锁，一种是获取共享锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态，实现该方法需要查询当前状态，并判断同步状态是否符合预期，然后通过CAS设置同步状态（非阻塞的？）</span><br><span class="line"> */</span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式释放同步状态，此时等待获取同步状态的线程将有机会获取同步状态</span><br><span class="line"> */</span><br><span class="line">protected boolean tryRelease(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态，返回结果大于等于0，表示获取成功，否则获取失败</span><br><span class="line"> */</span><br><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式释放同步状态</span><br><span class="line"> */</span><br><span class="line">protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否被当前线程所独占</span><br><span class="line"> */</span><br><span class="line">protected boolean isHeldExclusively() &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自定义的同步器组件时，将会调用<strong>同步器提供的模板方法</strong>，同步器提供的模板方法分为三类：一是独占式获取与释放同步状态、二是共享式获取与释放同步状态、三是查询同步队列中等待线程的情况。自定义的同步器将使用这些提供的模板方法来实现自己的同步语义。同步器提供的模板方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 如果当前线程获取同步状态成功，则该方法执行完毕，否则，当前线程将会进入</span><br><span class="line"> * 同步队列等待，该方法将会调用重写的tryAcquire方法（区别：一个有返回，一个没有，输入没什么用？）</span><br><span class="line"> */</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 与acquire 相同，但是该方法响应中断，当前线程未获取到同步状态则进入同步队列；如果当前线程被中断，则该方法会抛出异常并返回</span><br><span class="line"> */</span><br><span class="line">public final void acquireInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 该方法在 acquireInterruptibly(int arg) 基础上增加了超时限制，如果当前线程在超时时间内没有获取同步状态，那么将返回false，否则返回true</span><br><span class="line"> */</span><br><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式释放同步状态</span><br><span class="line"> * 该方法会在释放同步状态后，将同步队列中第一个节点中的线程唤醒</span><br><span class="line"> */</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 与独占式的区别在于，同一时刻可以有多个线程获得同步状态</span><br><span class="line"> */</span><br><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 与方法acquireShared(int arg) 一样，只是该方法响应中断</span><br><span class="line"> */</span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 在方法 acquireSharedInterruptibly(int arg) 基础上，增加了超时限制</span><br><span class="line"> */</span><br><span class="line">public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquireShared(arg) &gt;= 0 ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式释放同步状态</span><br><span class="line"> */</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取在同步队列上等待的线程的集合</span><br><span class="line"> */</span><br><span class="line">public final Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">    ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();</span><br><span class="line">    for (Node p = tail; p != null; p = p.prev) &#123;</span><br><span class="line">        Thread t = p.thread;</span><br><span class="line">        if (t != null)</span><br><span class="line">            list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，独占锁是在同一时刻只能有一个线程获得锁，而其他获取锁的线程只能在同步队列中等待，只有持有锁的线程释放了，其他线程才能获得锁。<strong>独占锁的示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class Mutex implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态内部类自定义同步器</span><br><span class="line">     */</span><br><span class="line">    private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 是否处于独占状态</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean isHeldExclusively() &#123;</span><br><span class="line">            return getState() == 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 独占式获取锁，状态为0时获取锁</span><br><span class="line">         * 如果经过CAS设置成功（同步状态设置为1）</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            if (compareAndSetState(0, 1)) &#123;  //0是期望，1是更新</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 独占式释放锁，只是将状态置为0</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryRelease(int releases) &#123;</span><br><span class="line">            if (getState() == 0) &#123;</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 实例化一个 Condition，每个 Condition 都包含一个队列</span><br><span class="line">         */</span><br><span class="line">        Condition newCondition() &#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Sync sync = new Sync();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isLocked() &#123;</span><br><span class="line">        return sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasQueuedThreads() &#123;</span><br><span class="line">        return sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：<br>1、自定义定义独占锁实现Lock，所以需要实现Lock接口中的API<br>2、自定义同步器作为静态内部类继承自同步器，重写同步器方法，实现独占式获取和释放同步状态<br>3、Lock的API中使用同步器的重写方法/模版方法</p>
<p>在使用自定义同步器Mutex 时，不会直接与内部同步器交互，而是通过Mutex 提供的方法。</p>
<p>lock和tryLock的区别：<br>lock是非阻塞的，会一直尝试或锁，用acquire方法（内部用tryAcquire方法）线程调用该方法获取同步状态失败后会被加入到同步队列中等待；tryLock是阻塞的，获取一次，所以直接用tryAcquire方法。</p>
<p>Condition是什么？<br>ConditionObject 是AQS的内部类，用来维护等待队列<br>AQS内部实际上有两个队列<br>同步队列：公平/非公平，共享/非共享<br>等待队列：条件等待队列，也就是Condition<br>等待队列中就是用await方法时任务进入的队列（类似之前使用的wait，该队列中的任务只有唤醒才会尝试获取锁，以此减少CPU频繁的获取锁），通过signal唤醒。</p>
<h4 id="✅队列同步器的实现分析"><a href="#✅队列同步器的实现分析" class="headerlink" title="✅队列同步器的实现分析"></a>✅队列同步器的实现分析</h4><p>接下来将从实现角度分析同步器是如何完成线程同步的。<br>主要包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模板方法。</p>
<h5 id="一、同步队列"><a href="#一、同步队列" class="headerlink" title="一、同步队列"></a>一、同步队列</h5><p>同步器依赖内部的同步队列（一个FIFO双向队列,FIFO先进先出）来完成同步状态的管理。</p>
<p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node，它也是AQS的内部类）并将其加入同步队列的尾部，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</p>
<p>当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：<code>compareAndSetTail(Node expect,Node update)</code>，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p>
<p>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。（只有一个线程获取到同步状态，所以设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。）</p>
<h5 id="二、独占式同步状态获取和释放"><a href="#二、独占式同步状态获取和释放" class="headerlink" title="二、独占式同步状态获取和释放"></a>二、独占式同步状态获取和释放</h5><p>同步器的 <code>acquire(int arg)</code> 方法可以获取同步状态（阻塞型的，相当于是获锁），该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，<strong>线程不会从同步队列中移出</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">	if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作。首先tryAcquire非阻塞型地获取，如果获取到直接返回了，获取不到，就构造节点加入同步队列，在同步队列中会一直自旋尝试获取同步状态。</p>
<p>步骤：<br>1、调用自定义同步器实现的 tryAcquire(int arg) 方法，该方法保证线程安全的获取同步状态</p>
<p>2、如果同步状态获取失败，则构造同步节点（独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过 addWaiter(Node node) 方法将该节点加入到同步队列的尾部。</p>
<blockquote>
<p>enq(final Node node) 方法中，同步器通过 “死循环” 来保证节点的正确添加，在 “死循环” 中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线程不断地尝试设置。<br>可以看出，enq(final Node node) 方法将并发添加节点的请求通过CAS变得 “串行化” 了。</p>
</blockquote>
<p>3、节点进入同步队列之后，就进入了一个自旋的过程（acquireQueued(Node node,int arg) 方法），每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，代表获取了锁，否则依旧留在这个自旋过程中（并会阻塞节点的线程，阻塞线程也就是进入等待，自旋不停？）</p>
<blockquote>
<p>虽然同步队列中每个线程都会自旋，但是只有前驱节点是头节点才能够尝试获取同步状态：<br>头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。<br>维护同步队列的FIFO原则。</p>
</blockquote>
<p>4、如果获取不到则阻塞节点中的线程，而<strong>被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现</strong>。</p>
<blockquote>
<p>节点自旋，发现前驱不是头节点，就进入等待状态，只有线程被中断或前驱节点被释放才会再判断是不是前驱是头节点。前驱是头节点后，获取同步状态，如果获取失败，则进入等待状态。（几个等待状态应该不一样？）</p>
</blockquote>
<p>独占式同步状态获取流程，见P128</p>
<p>5、线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。调用同步器的 release(int arg) 模版方法（内部用tryRelease重写方法）可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // 尝试释放锁</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        //头节点不为空或者状态不是0</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            // 唤醒后继节点</span><br><span class="line">            unparkSuccessor(h);  //用来唤醒处于等待状态的线程</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>独占式同步状态获取和释放过程总结：<br>1、在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被自旋地加入到队列中并在队列中进行自旋<br>2、移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。<br>3、如果线程被中断，只是会唤醒被阻塞线程，是不会立刻被移出队列的，而是FIFO到该节点才移出。<br>4、不管是获取还是释放，都是模版方法里调用了重写的try方法。acquire是阻塞的，tryAcquire是非阻塞的，试一次，会返回是否成功。</p>
<p>疑问❓：<br>同步队列中节点的自旋和线程被阻塞的关系是什么？自旋发现前驱节点不是头节点或者获取不到同步状态的话，会阻塞线程，阻塞后是依靠前驱节点释放同步状态后唤醒或是中断唤醒还是一直自旋？</p>
<h5 id="三、共享式同步状态获取与释放"><a href="#三、共享式同步状态获取与释放" class="headerlink" title="三、共享式同步状态获取与释放"></a>三、共享式同步状态获取与释放</h5><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，读可以是共享锁，可以同时读，写是独占锁，一个在写，其他既不能读也不能写。</p>
<p>在 acquireShared(int arg) 方法中，同步器调用 tryAcquireShared(int arg) 方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    // 小于零获取锁失败</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    // 共享模式加入同步队列</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 如果前一个线程为头结点</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                // 尝试获取锁</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                // 成功</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    // 将自己设置为头节点同时，传播状态，r就是之前返回的值</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null;</span><br><span class="line">                    // 如果过被当前线程状态为true，就设置当前线程的中断状态</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 逻辑同前</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 逻辑同前</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用releaseShared(int arg)方法可以释放同步状态:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 尝试释放锁</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 成功就修改自己节点状态</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。因为可能多个线程获取锁，所以，它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p>
<h5 id="四、独占式超时获取同步状态"><a href="#四、独占式超时获取同步状态" class="headerlink" title="四、独占式超时获取同步状态"></a>四、独占式超时获取同步状态</h5><p>通过调用同步器的 doAcquireNanos(int arg,long nanosTimeout) 【模版方法】方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。</p>
<p>在Java 5之前，当一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧会阻塞在synchronized上，等待着获取锁。</p>
<p>在Java 5中，同步器提供了acquireInterruptibly(int arg)方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出InterruptedException。</p>
<p>超时获取同步状态过程可以被视作响应中断获取同步状态过程的“增强版”，doAcquireNanos(int arg,long nanosTimeout)方法在支持响应中断的基础上，增加了超时获取的特性。</p>
<p>该方法在自旋过程中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。</p>
<p>如果当前线程获取同步状态失败，则判断是否超时（nanosTimeout小于等于0表示已经超时），如果没有超时，重新计算超时间隔nanosTimeout，然后使当前线程等待 nanosTimeout 纳秒（当已到设置的超时时间，该线程会从LockSupport.parkNanos(Object<br>blocker,long nanos)方法返回）。</p>
<p><strong>总结：</strong><br>独占式超时获取同步状态doAcquireNanos(int arg,long nanosTimeout)和独占式获取同步状态acquire(int args)在流程上非常相似，其主要区别在于未获取到同步状态时的处理逻辑：<br>1、acquire(int args)在未获取到同步状态时，将会使当前线程一直处于等待状态<br>2、doAcquireNanos(int arg,long nanosTimeout)会使当前线程等待nanosTimeout纳秒，如果当前线程在nanosTimeout纳秒内没有获取到同步状态，将会从等待逻辑中自动返回。</p>
<h5 id="五、自定义同步组件——TwinsLock"><a href="#五、自定义同步组件——TwinsLock" class="headerlink" title="五、自定义同步组件——TwinsLock"></a>五、自定义同步组件——TwinsLock</h5><p>设计一个同步工具：该工具在同一时刻，只允许至多两个线程同时访问，超过两个线程的访问将被阻塞。</p>
<p>TwinsLock在同一时刻允许至多两个线程的同时访问，表明同步资源数为2，这样可以设置初始状态status为2，当一个线程进行获取，status减1，该线程释放，则status加1，状态的合法范围为0、1和2，其中0表示当前已经有两个线程获取了同步资源，此时再有其他线程对同步状态进行获取，该线程只能被阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class TwinsLock implements Lock &#123;</span><br><span class="line">    private final Sync sync = new Sync(2);</span><br><span class="line"></span><br><span class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            if (count &lt;= 0) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;count must large than zero.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 在本方法中，用状态去代指资源数目</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int tryAcquireShared(int reduceCount) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                int newCount = current - reduceCount;</span><br><span class="line">                if (newCount &lt; 0 || compareAndSetState(current,newCount)) &#123;</span><br><span class="line">                	// 返回当前剩余资源</span><br><span class="line">                    return newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean tryReleaseShared(int returnCount) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                // 当前数目 + 释放数目</span><br><span class="line">                int newCount = current + returnCount;</span><br><span class="line">                if (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">    	// 获取共享锁，state + 1</span><br><span class="line">    	// 使用的是node节点的方法</span><br><span class="line">        sync.acquireShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 释放共享锁 -1</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 其他接口方法略</span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, @NotNull TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    @NotNull</span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：<br>1、TwinsLock实现Lock接口，提供面向使用者的接口，使用者调用lock()<br>方法获取锁，随后调用unlock()方法释放锁，而同一时刻只能有两个线程同时获取到锁。<br>2、自定义同步器Sync作为静态内部类，该同步器面向线程访问和同步状态控制。共享式获取同步状态。<br>3、重写tryAcquireShared(int reduceCount)等方法，内部用过CAS确保状态的正确设置。acquireShared方法里是判断tryAcquireShared方法返回值大于等于0时，当前线程才获取同步状态。</p>
<p>总结：<br>1、acquireShared方法里输入的int，都是1呢。啥意思？<br>2、同步器作为一个桥梁，连接线程访问以及同步状态控制等底层技术与不同并发组件（比如Lock、CountDownLatch等）的接口语义。</p>
<p>测试类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line">public class TwinsLockTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        final Lock lock = new TwinsLock();</span><br><span class="line">        class Worker extends Thread &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName());</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        throw new RuntimeException(e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 启动10个线程</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Worker w = new Worker();</span><br><span class="line">            w.setDaemon(true);</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">        // 每隔1秒换行</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程名称成对输出，在同一时刻只有两个线程能够获取到锁。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46949627/article/details/127078972">https://blog.csdn.net/weixin_46949627/article/details/127078972</a><br><a target="_blank" rel="noopener" href="http://t.zoukankan.com/liukaifeng-p-10052596.html">http://t.zoukankan.com/liukaifeng-p-10052596.html</a><br>Lock和sychronized区别：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41010294/article/details/123528508">https://blog.csdn.net/weixin_41010294/article/details/123528508</a></p>
<h3 id="3-重入锁"><a href="#3-重入锁" class="headerlink" title="3.重入锁"></a>3.重入锁</h3><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</p>
<p>上一节的独占锁示例中，调用Mutex的lock()方法获取锁之后，如果再次调用lock()方法，则该线程将会被自己所阻塞，原因是Mutex在实现tryAcquire(int acquires)方法时没有考虑占有锁的线程再次获取锁的场景，而在调用tryAcquire(int acquires)方法时返回了false，导致该线程被阻塞。</p>
<p>所以说，Mutex是一个不支持重进入的锁。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，而不像Mutex由于获取了锁，而在下一次获取锁时出现阻塞自己的情况。</p>
<p>重入锁：在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p>
<p>公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。</p>
<h4 id="✅实现重进入"><a href="#✅实现重进入" class="headerlink" title="✅实现重进入"></a>✅实现重进入</h4><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。</p>
<p>1、线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</p>
<p>2、锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</p>
<p>非公平锁获取的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 非公平锁获取</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    // 当前线程</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    // 获取锁状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 0 代表无锁</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        // 设置状态</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            // 设置独享锁的拥有者</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    // 如果当前线程是独有线程的线程ID</span><br><span class="line">    &#125; else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        // 是则增加次数</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        //设置</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。成功获取锁的线程再次获取锁，只是增加了同步状态值.</p>
<p>非公平锁释放的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    // 减去释放的值</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    // 如果当前线程不是拥有者</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 是否完全释放</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 如果是 0 则完全释放</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        // 抹去拥有者</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p>
<h4 id="✅公平与非公平获取锁的区别"><a href="#✅公平与非公平获取锁的区别" class="headerlink" title="✅公平与非公平获取锁的区别"></a>✅公平与非公平获取锁的区别</h4><p>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。</p>
<p>对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同。判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。<br>【因此，上面的独占锁和共享锁也都是公平的】</p>
<p>测试公平和非公平锁在获取锁时的区别，五个线程循环获取锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class FairAndUnfairTest &#123;</span><br><span class="line">    private static Lock fairLock = new ReentrantLock2(true);</span><br><span class="line">    private static Lock unfairLock = new ReentrantLock2(false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void fair() &#123;</span><br><span class="line">        testLock(fairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void unfair() &#123;</span><br><span class="line">        testLock(unfairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void testLock(Lock lock)&#123;</span><br><span class="line">        // 启动5个Job</span><br><span class="line">        for(int i = 0; i &lt; 5;i++)&#123;</span><br><span class="line">            new Job(lock).start();</span><br><span class="line">        &#125;</span><br><span class="line">        while (true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Job extends Thread &#123;</span><br><span class="line">        private Lock lock;</span><br><span class="line"></span><br><span class="line">        public Job(Lock lock) &#123;</span><br><span class="line">            this.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 连续2次打印当前的Thread和等待队列中的Thread</span><br><span class="line">                lock.lock();</span><br><span class="line">                ReentrantLock2 reentrantLock2 = (ReentrantLock2) lock;</span><br><span class="line">                System.out.println(&quot;Fair:&quot; + reentrantLock2.isFair() + &quot;,Lock By 【&quot; + Thread.currentThread().getName() + &quot;】，waitting by  &quot; + reentrantLock2.getQueuedThreads().toString());</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ReentrantLock2 extends ReentrantLock &#123;</span><br><span class="line">        public ReentrantLock2(boolean fair) &#123;</span><br><span class="line">            super(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">            List&lt;Thread&gt; arrayList = new ArrayList&lt;Thread&gt;(super.getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);</span><br><span class="line">            return arrayList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、公平性锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁出现了一个线程连续获取锁的情况。（刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待。）</p>
<p>2、公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平锁虽然可能造成线程饥饿，但是极少的线程切换，保证了其更大的吞吐量。</p>
<h3 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4.读写锁"></a>4.读写锁</h3><p>之前提到锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升，提供写操作对读操作的可见性以及并发性的提升。</p>
<p>适用场景：在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。</p>
<p>在没有读写锁支持的（Java 5之前）时候，如果需要完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。</p>
<h4 id="✅读写锁的接口和示例"><a href="#✅读写锁的接口和示例" class="headerlink" title="✅读写锁的接口和示例"></a>✅读写锁的接口和示例</h4><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方法，而其实现——ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Cache &#123;</span><br><span class="line">    static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    static Lock r = rwl.readLock();</span><br><span class="line">    static Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    // 获取一个key对应的value</span><br><span class="line">    public static final Object get(String key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置key对应的value，并返回旧的value</span><br><span class="line">    public static final Object put(String key, Object value) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清空所有的内容</span><br><span class="line">    public static final void clear() &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个非线程安全的HashMap作为缓存,使用读写锁的读锁和写锁来保证Cache是线程安全的.Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性，同时简化了编程方式。</p>
<h4 id="✅读写锁的实现分析"><a href="#✅读写锁的实现分析" class="headerlink" title="✅读写锁的实现分析"></a>✅读写锁的实现分析</h4><h5 id="一、读写状态的设计"><a href="#一、读写状态的设计" class="headerlink" title="一、读写状态的设计"></a>一、读写状态的设计</h5><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。</p>
<p>回想ReentrantLock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，如果在一个整型变量上维护多种状态，就一定需要 “按位切割使用” 这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。</p>
<p>通过位运算可以迅速确定读和写各自的状态，假设当前同步状态值为 S ，写状态等于 S&amp;0x0000FFFF （将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。</p>
<h5 id="二、写锁的获取与释放"><a href="#二、写锁的获取与释放" class="headerlink" title="二、写锁的获取与释放"></a>二、写锁的获取与释放</h5><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    // 锁状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 通过状态计算写锁数量</span><br><span class="line">    int w = exclusiveCount(c);</span><br><span class="line">    // 锁不为0，说明有读或者写</span><br><span class="line">    if (c != 0) &#123;</span><br><span class="line">        // 写锁不存在（说明现在是读锁）或者当前获取线程不是已经获取写锁的线程</span><br><span class="line">        if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">            return false;</span><br><span class="line">        // 如果重入次数大于最大冲入数目</span><br><span class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 尝试获取写锁</span><br><span class="line">    // writerShouldBlock：公平锁会调用 hasQueuedPredecessors判断轮得到自己吗，非公平直接返回false去竞争锁</span><br><span class="line">    //  compareAndSetState 失败就会返回false</span><br><span class="line">    if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置当前线程拥有锁</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。</p>
<p>如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>
<p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p>
<h5 id="三、读锁的获取与释放"><a href="#三、读锁的获取与释放" class="headerlink" title="三、读锁的获取与释放"></a>三、读锁的获取与释放</h5><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在 没有其他写线程访问（或者写状态为0） 时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。</p>
<p>获取读锁的实现从Java 5到Java 6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount() 方法，作用是返回当前线程获取读锁的次数。由于读状态是 所有线程获取读锁次数的总和 ，所以每个线程 各自获取读锁的次数只能选择保存在ThreadLocal中 ，由线程自身维护，于是使获取读锁的实现变得复杂。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        // 获取锁状态</span><br><span class="line">        int c = getState();</span><br><span class="line">        // 读数目+1</span><br><span class="line">        int nextc = c + (1 &lt;&lt; 16);</span><br><span class="line">        // 溢出</span><br><span class="line">        if (nextc &lt; c)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        // 现在是写状态 且 拥有者不是自己</span><br><span class="line">        if (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">            return -1;</span><br><span class="line">        // 修改状态</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</p>
<p>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1&lt;&lt;16）。</p>
<h5 id="四、锁降级"><a href="#四、锁降级" class="headerlink" title="四、锁降级"></a>四、锁降级</h5><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void processData() &#123;</span><br><span class="line">		//锁住读锁</span><br><span class="line">        readLock.lock();</span><br><span class="line">        // 数据在更新吗</span><br><span class="line">        if (!update) &#123;</span><br><span class="line">			// 必须先释放读锁</span><br><span class="line">            readLock.unlock();</span><br><span class="line">			// 锁降级从写锁获取到开始</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!update) &#123;</span><br><span class="line">					// 准备数据的流程（略）</span><br><span class="line">                    update = true;</span><br><span class="line">                &#125;</span><br><span class="line">                //开始降级</span><br><span class="line">                readLock.lock();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">            	// 锁降级完成，写锁降级为读锁</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">			// 使用数据的流程（略）</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>锁降级：先获取写锁，变更数据，再获取读锁，再释放写锁。此时还有读锁，还可以读数据，其他线程也可以获取读锁读数据。<br>这样变更完数据之后，可以多个读线程一起读取数据。</p>
<p>不支持锁升级：有线程获取读锁的时候，不能获取写锁，数据更新对其他线程的可见性。</p>
<h3 id="5-LockSupport工具"><a href="#5-LockSupport工具" class="headerlink" title="5.LockSupport工具"></a>5.LockSupport工具</h3><p>队列同步器中，当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作。LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。</p>
<p>在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。</p>
<p>比如说，线程dump结果结果中，有阻塞对象的parkNanos方法能够传递给开发人员阻塞对象的信息。</p>
<p>为什么要加阻塞对象信息？<br>由于在Java 5之前，当线程阻塞（使用synchronized关键字）在一个对象上时，通过线程dump能够查看到该线程的阻塞对象，方便问题定位，而Java 5推出的Lock等并发工具时却遗漏了这一点，致使在线程dump时无法提供阻塞对象的信息。因此，在Java 6中，LockSupport新增了上述3个含有阻塞对象的park方法，用以替代原有的park方法。</p>
<h3 id="6-Condition接口"><a href="#6-Condition接口" class="headerlink" title="6.Condition接口"></a>6.Condition接口</h3><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。</p>
<p>Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的：<br>1、前置条件不但要获取锁，还要调用<code>Lock.newCondition()</code>获取Condition对象<br>2、等待队列支持多个<br>3、支持超时等待状态<br>4、支持在等待状态中不响应中断（可以对中断不敏感）</p>
<p>总结一下：<br>synchronized + Object监视器方法 - 实现等待通知 - 案例线程池<br>Lock(队列同步器) + Condition接口 - 实现等待通知 - 案例有界队列<br>可以直接使用synchronized实现同步<br>可以直接使用Lock实现锁，只不过只有同步队列，里面线程是阻塞状态，没有等待队列</p>
<h4 id="✅Condition接口与示例"><a href="#✅Condition接口与示例" class="headerlink" title="✅Condition接口与示例"></a>✅Condition接口与示例</h4><p>Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。</p>
<p>Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。</p>
<p>等待通知模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">public void conditionWait() throws InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void conditionSignal() throws InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Condition对象作为成员变量。通过Lock的newCondition()方法</p>
<p>当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
<p>Condition接口方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">await() ：造成当前线程在接到信号或被中断之前一直处于等待状态，对中断敏感。</span><br><span class="line">await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span><br><span class="line">awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。</span><br><span class="line">awaitUninterruptibly() ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。</span><br><span class="line">awaitUntil(Date deadline) ：造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返回false。</span><br><span class="line">signal() ：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。</span><br><span class="line">signalAll() ：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。</span><br></pre></td></tr></table></figure>

<p>有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程（进入等待队列），直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”。有点像线程池。</p>
<p>线程池：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class BoundedQueue&lt;T&gt; &#123;</span><br><span class="line">    private Object[] items;</span><br><span class="line">    // 添加的下标，删除的下标和数组当前数量</span><br><span class="line">    private int addIndex, removeIndex, count;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    private Condition notEmpty = lock.newCondition();</span><br><span class="line">    private Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public BoundedQueue(int size) &#123;</span><br><span class="line">        items = new Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加一个元素，如果数组满，则添加线程进入等待状态，直到有&quot;空位&quot;</span><br><span class="line">    public void add(T t) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[addIndex] = t;</span><br><span class="line">            if (++addIndex == items.length)</span><br><span class="line">                addIndex = 0;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public T remove() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[removeIndex];</span><br><span class="line">            if (++removeIndex == items.length)</span><br><span class="line">                removeIndex = 0;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return (T) x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以添加方法为例：首先需要获得锁，目的是确保数组修改的可见性和排他性。当数组数量等于数组长度时，表示数组已满，则调用notFull.await()，当前线程随之释放锁并进入等待状态。如果数组数量不等于数组长度，表示数组未满，则添加元素到数组中，同时通知等待在notEmpty上的线程，数组中已经有新元素可以获取。</p>
<p>在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。回想之前提到的等待/通知的经典范式，二者是非常类似的。</p>
<p>⚠️线程的阻塞、等待的区别：<br>在java中，线程阻塞状态是线程本身不可计划的，而线程等待状态是线程本身计划之内的。<br>相同点：<br>（1）都会暂停线程的执行。<br>区别点：<br>（1）线程进入阻塞状态是被动的, 而线程进入等待状态是主动的。<br>阻塞状态的被动：线程在同步代码外，获取对象锁失败时，线程进入阻塞状态；何时获取对象锁失败不可知，即线程阻塞状态是线程本身不可计划的。<br>等待状态的主动：线程在同步代码内await，等待其他线程唤醒时，线程接入等待状态；何时等待其他线程操作可知，即线程等待状态是线程本身计划之内的。</p>
<h4 id="✅Condition的实现分析"><a href="#✅Condition的实现分析" class="headerlink" title="✅Condition的实现分析"></a>✅Condition的实现分析</h4><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。</p>
<p>每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。</p>
<h5 id="一、等待队列"><a href="#一、等待队列" class="headerlink" title="一、等待队列"></a>一、等待队列</h5><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</p>
<p>等待队列：当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p>
<p>在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列（每个Condition对象一个）。</p>
<h5 id="二、等待"><a href="#二、等待" class="headerlink" title="二、等待"></a>二、等待</h5><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p>
<p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</p>
<p>ConditionObject的await方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 当前线程加入等待队列</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    // 释放同步状态，也就是释放锁</span><br><span class="line">    int savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    // 节点是否在同步队列中</span><br><span class="line">    // Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.</span><br><span class="line">    // 如果节点在同步队列中，现在等待重新去获取锁，返回true</span><br><span class="line">    // 一般总是在条件队列</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        // 暂停自己，等待被唤醒或者被中断</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        // 是否被中断了</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取锁成功且异常模式不为THROW_IE，就修改interruptMode</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    // 该方法是内部类Condition中的，设置下一个在首位的等待者</span><br><span class="line">    if (node.nextWaiter != null)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    // 如果interruptMode 不是0，唤醒后报告中断</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。（同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。）</p>
<p>（2）当等待队列中的节点被唤醒，则唤醒节点的线程进入同步队列，开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p>
<h5 id="三、通知"><a href="#三、通知" class="headerlink" title="三、通知"></a>三、通知</h5><p>调用Condition的signal()方法的前置条件是当前线程必须获取了锁，将在等待队列中等待时间最长的节点（首节点），线程安全地移动到同步队列，并使用LockSupport唤醒节点中的线程，然后就竞争锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    // 锁是否处于占用状态</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 获取第一个线程</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        // 唤醒</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。</p>
<p>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。如果未获取到锁，将在同步队列中阻塞。</p>
<p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>
<h2 id="第六章-java并发容器和框架"><a href="#第六章-java并发容器和框架" class="headerlink" title="第六章 java并发容器和框架"></a>第六章 java并发容器和框架</h2><h3 id="1-ConcurrentHashMap的实现原理与使用"><a href="#1-ConcurrentHashMap的实现原理与使用" class="headerlink" title="1.ConcurrentHashMap的实现原理与使用"></a>1.ConcurrentHashMap的实现原理与使用</h3><p>ConcurrentHashMap是线程安全且高效的HashMap。</p>
<h4 id="✅为什么使用ConcurrentHashMap"><a href="#✅为什么使用ConcurrentHashMap" class="headerlink" title="✅为什么使用ConcurrentHashMap"></a>✅为什么使用ConcurrentHashMap</h4><p>（1）<strong>HashMap线程不安全会死循环</strong></p>
<p>HashMap 在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(2); // 容量为2的Map</span><br><span class="line">Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i=0;i&lt;10000;i++)&#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    map.put(UUID.randomUUID().toString(),&quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;ftf&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&quot;ftf&quot;);</span><br><span class="line">thread.start();</span><br><span class="line">thread.join();</span><br></pre></td></tr></table></figure>

<p>HashMap的实现原理：<br>HashMap的主干是一个Entry数组（Entry是以链表的形式存储的）。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。(其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合)。</p>
<p>Entry结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next; // 存储指向下一个Entry的引用，单链表结构。</span><br><span class="line"> </span><br><span class="line">    int hash;	   // 对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以：HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p>HashMap在put的时候，插入的元素超过了容量(由负载因子决定)的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在其他的元素也在put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</p>
<p>HashMap的线程不安全主要体现在会造成死循环，数据丢失，数据覆盖这些问题。其中死循环和数据丢失是在JDK1.7中出现的问题，在Jdk1.8中已经得到解决，然而JDK1.8仍会有数据覆盖这样的问题。</p>
<p>（2）<strong>效率低下的HashTable</strong></p>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其它线程也访问HashTable的同步方法时，会进入阻塞或轮询状态，所以竞争越激烈效率越低。</p>
<p>（3）ConcurrentHashMap的锁分段技术可有效提升并发访问率。</p>
<p>HashTable的线程都必须竞争同一把锁，假如容器里有多把锁每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其它段的数据也能被其他线程访问。</p>
<h4 id="✅ConcurrentHashMap的结构"><a href="#✅ConcurrentHashMap的结构" class="headerlink" title="✅ConcurrentHashMap的结构"></a>✅ConcurrentHashMap的结构</h4><p>类图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁(ReentrantLock),在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。<strong>一个Segment里包含一个HashEntry数组</strong>，<strong>每个HashEntry是一个链表结构的元素（一个包含数据的链表）</strong>，每个Segment里守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p>
<h4 id="✅ConcurrentHashMap的初始化与定位"><a href="#✅ConcurrentHashMap的初始化与定位" class="headerlink" title="✅ConcurrentHashMap的初始化与定位"></a>✅ConcurrentHashMap的初始化与定位</h4><p>ConcurrentHashMap初始化方法是通过initialCapacity, loadFactor和concurrencyLevel等几个参数来初始化segment数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组来实现。</p>
<p>ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到Segment。而且，会使用再散裂算法对元素的hashCode进行一次再散列。</p>
<p>再散列的目的：减少散列冲突，使元素均匀地分布在不同的segmrnt上，提高容器的存取效率。</p>
<h4 id="✅ConcurrentHashMap的操作"><a href="#✅ConcurrentHashMap的操作" class="headerlink" title="✅ConcurrentHashMap的操作"></a>✅ConcurrentHashMap的操作</h4><p>（1）get(key)</p>
<p>经过一次再散列，先定位到segment，然后再通过散列运算定位到元素。<br>不需要加锁，除非读到的值是空的才会加锁重读。原因是：将共享变量（segment大小、HashEntry里的value）定义为volatile。利用volatile在多线程中的可见性，可以被多线程读，保证不会读到过期的值。</p>
<p>（2）put(key, value)</p>
<p>先定位到segment，然后在segment里进行插入操作。分两步：<br>1.是否需要扩容？<br>先判断HashEntry数组是否超过阈值，如果超过了就扩容，扩容之后再插入数据。而HashMap是先插入再扩容，这样不好，因为下次可能就没有数据进来了，那就白扩容了。<br>2.如何扩容？<br>先创建一个容量是原来2倍的数组，然后通过对原数组元素进行再散列后插入到新数组。扩容只会对某个segment进行。</p>
<p>（3）size()</p>
<p>Segment中有一个全局变量count是一个volatile变量，可以累加各个segment的count来计算大小。但是可能累加前count发生了变化，统计结果不准。但是锁住所有的segment再计算也不合适。</p>
<p>在每个segment中有一个volatile修饰的count属性，表示这个segment中的元素个数，先通过2次不加锁的方法统计所有count的总和，如果两次结果不相等，或者容器被修改过了，就将Segment加锁，再进行第三次统计。</p>
<p>ConcurrentHashMap中有一个modCount变量，每次put\remove\clean操作，都会对这个值加一，通过比较这个值，就知道是否容器是否被修改了。</p>
<h3 id="2-ConcurrentLinkedQueue"><a href="#2-ConcurrentLinkedQueue" class="headerlink" title="2.ConcurrentLinkedQueue"></a>2.ConcurrentLinkedQueue</h3><p>无界线程安全队列。</p>
<p>在并发编程中，有时候需要使用线程安全的对列。如果要实现一个线程安全的对列有2种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的对列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。【锁也是基于CAS和volatile来实现的吧】</p>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全对列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到对列的尾部；当我们获取一个元素时，它会返回对列头部的元素。它采用了”wait-free”算法(即CAS算法)来实现。</p>
<h4 id="✅ConcurrentLinkedQueue的结构"><a href="#✅ConcurrentLinkedQueue的结构" class="headerlink" title="✅ConcurrentLinkedQueue的结构"></a>✅ConcurrentLinkedQueue的结构</h4><p>ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素(item)和指向下一个节点(next)的引用组成，节点和节点之间就是通过这个next关联起来，从而组成一张链表结构的对列。默认情况下head节点存储的元素为空，tail节点等于head节点。</p>
<p>继承了AbstractQueue，不是阻塞队列。</p>
<p>ConcurrentLinkedQueue由head节点和tail节点组成。head、tail、next、item均使用volatile修饰，保证其内存可见性。</p>
<h4 id="✅入队列-offer-E-e"><a href="#✅入队列-offer-E-e" class="headerlink" title="✅入队列:offer(E e)"></a>✅入队列:offer(E e)</h4><p>入队列就是将入队节点添加到对列的尾部。入队主要做两件事情：<br>第一：是将入队节点设置成当前队列尾节点的下一个节点；<br>第二：是更新tail节点，如果tail节点的next不为空，则将入队节点设置为tial节点，成为队尾节点的next节点，如果tail节点的next为空，则将入队节点的设置为tail的next节点。所以tail节点不总是尾节点。【效果是两格两格得跳】</p>
<p>1.定位尾节点<br>tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能是tail节点，也可能是tail节点的next节点。</p>
<p>2.设置入队节点为尾节点<br>p.casNext(null,n)方法用于将入队节点设置为当前对尾节点的next节点，如果p是null，表示p是当前节点的尾节点，如果不为null，表示有其它线程更新了尾节点，则需要重新获取当前对列的尾节点。</p>
<p>⚠️不是每次入队都更新tail节点：<br>如果将tail节点永远作为尾节点，这样每次都需要循环CAS更新tail节点，而设置一个到尾节点的距离，当tail到尾节点的距离大于某个值（通常为1）的时候再更新tail，这样可以减少更新的次数，提高入队的效率。定位尾节点时就需要增加对volatile变量读操作，但是对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p>
<p><strong>入队方法永远返回true，所以不要通过返回值判断入队是否成功。</strong></p>
<h4 id="✅出队列：poll"><a href="#✅出队列：poll" class="headerlink" title="✅出队列：poll()"></a>✅出队列：poll()</h4><p>不是每次出队都更新head节点，当head中有元素，就直接弹出head的元素，如果没有元素，就弹出head的next，然后更新head节点，head节点变为弹出节点的next节点。【一次走两格】<br>也是通过控制距离的方式，减少CAS更新节点的消耗。</p>
<h3 id="3-阻塞队列"><a href="#3-阻塞队列" class="headerlink" title="3.阻塞队列"></a>3.阻塞队列</h3><p>阻塞对列(BlockingQueue)是一个支持两个附加操作的对列。这两个附加操作支持阻塞的插入和移除方法。</p>
<p>1）支持阻塞的插入方法：意思是当对列满时，对列会阻塞插入元素的线程，直到对列不满。<br>2）支持阻塞的移除方法：意思是当对列为空时，获取元素的线程会等待对列不为空。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向对列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--------------------插入和移除操作的4种处理方式--------------</span><br><span class="line"></span><br><span class="line">方法/处理方式    抛出异常    返回特殊值    一直阻塞    超时退出</span><br><span class="line">插入方法        add(e)     offer(e)     put(e)      offer(e,time,unit)</span><br><span class="line">移除方法       remove()    poll()       take()     poll(time,unit)</span><br><span class="line">检查方法      element()    peek()       不可用      不可用</span><br><span class="line"></span><br><span class="line">1）抛出异常：当队列满时，如果再往对列里插入元素，会抛出IllegalStateException(&quot;Queue full&quot;)异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</span><br><span class="line">2）返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有返回null。</span><br><span class="line">3）一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到对列可用或者响应中断退出。当队列为空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</span><br><span class="line">4）超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</span><br></pre></td></tr></table></figure>

<p>如果是无界阻塞队列，队列不可能出现满的情况，岁月使用put和offer永远不会被阻塞，而且使用offer方法时，总返回true。</p>
<h4 id="✅java提供的几种阻塞队列"><a href="#✅java提供的几种阻塞队列" class="headerlink" title="✅java提供的几种阻塞队列"></a>✅java提供的几种阻塞队列</h4><p>ArrayBlockingQueue:    一个由数组结构组成的有界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue是一个用数组实现的有界阻塞队列。</span><br><span class="line">此队列按照先进先出(FIFO)的原则对元素进行排序。</span><br><span class="line">默认情况下不保证线程公平的访问队，即不保证先阻塞线程先访问队列。</span><br><span class="line"></span><br><span class="line">如果想保证公平性，可以用可重入锁来实现</span><br><span class="line">ArrayBlockingQueue fairQueue = new ArrayBlockingQueue&lt;&gt;(1000, true);</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">    if (capacity &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.items = new Object[capacity];</span><br><span class="line">    lock = new ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedBlockingQueue:    一个由链表结构组成的有界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue是一个用链表实现的有界阻塞队列。</span><br><span class="line">此队列的默认和最大长度为Inter.MAX_VALUE。</span><br><span class="line">此队列按照先进先出的原则对元素进行排序。</span><br></pre></td></tr></table></figure>

<p>PriorityBlockingQueue:    一个支持优先级排序的无界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PriorityBlockingQueue是一个支持优先级的无界阻塞队列。</span><br><span class="line">默认情况下元素采取自然顺序升序排列。</span><br><span class="line">也可以自定义实现compareTo()方法来指定元素排序规则，</span><br><span class="line">或者初始化PriorityBlockingQueue时，指定构造参数(Comparator)来对元素进行排序。</span><br><span class="line">需要注意的是不能保证同优先级元素的排序。</span><br></pre></td></tr></table></figure>

<p>DelayQueue:    一个使用优先级队列实现的无界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">DelayQueue是一个支持延时获取元素的无界阻塞队列.</span><br><span class="line">队列使用PriorityQueue来实现。</span><br><span class="line">队列中的元素必须实现Delayed接口，在创建元素时可以指定多久（元素存在了多久）才能从队列中获取当前元素。</span><br><span class="line">只有在延迟期满时才能从队列里提取元素。</span><br><span class="line"></span><br><span class="line">应用场景：</span><br><span class="line">1）缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue获取元素时，表示缓存有效期到了。</span><br><span class="line">2）定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimeQueue就是使用DelayQueue实现的。</span><br><span class="line"></span><br><span class="line">a.如何实现Delayed接口</span><br><span class="line">DelayQueue队列的元素必须实现Delayed接口。我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类的实现，一共有三步。</span><br><span class="line"></span><br><span class="line">第一步：在对象创建的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可以使用，使用sequenceNumber来标识元素在队列中的先后顺序。</span><br><span class="line"></span><br><span class="line">private static final AtomicLong sequencer = new AtomicLong(0);</span><br><span class="line">private class ScheduledFutureTask&lt;V&gt; extends FutureTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt; &#123;</span><br><span class="line">ScheduledFutureTask(Runnable r, V result, long ns) &#123;</span><br><span class="line">    super(r, result);</span><br><span class="line">    this.time = ns;</span><br><span class="line">    this.period = 0;</span><br><span class="line">    this.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒</span><br><span class="line"></span><br><span class="line">public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">    return unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第三步：实现compareTo()方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。</span><br><span class="line"></span><br><span class="line">public int compareTo(Delayed other) &#123;</span><br><span class="line">    if (other == this) // compare zero ONLY if same object</span><br><span class="line">        return 0;</span><br><span class="line">    if (other instanceof ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        long diff = time - x.time;</span><br><span class="line">        if (diff &lt; 0)</span><br><span class="line">            return -1;</span><br><span class="line">        else if (diff &gt; 0)</span><br><span class="line">            return 1;</span><br><span class="line">        else if (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            return -1;</span><br><span class="line">        else</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    long d = (getDelay(TimeUnit.NANOSECONDS) -</span><br><span class="line">            other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">    return (d == 0) ? 0 : ((d &lt; 0) ? -1 : 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b. 如何实现延时阻塞队列</span><br><span class="line">延时阻塞队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</span><br><span class="line"></span><br><span class="line">public RunnableScheduledFuture take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            RunnableScheduledFuture first = queue[0];</span><br><span class="line">            if (first == null)</span><br><span class="line">                available.await();</span><br><span class="line">            else &#123;</span><br><span class="line">                long delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                if (delay &lt;= 0)</span><br><span class="line">                    return finishPoll(first);</span><br><span class="line">                else if (leader != null)</span><br><span class="line">                    available.await();</span><br><span class="line">                else &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (leader == thisThread)</span><br><span class="line">                            leader = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (leader == null &amp;&amp; queue[0] != null)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码中的变量leader是一个等待获取队列头部元素的线程。</span><br><span class="line">如果leader不等于空，表示已经有线程在等待获取队列的头元素。</span><br><span class="line">所以，使用await()方法让当前线程等待信号。</span><br><span class="line">如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</span><br></pre></td></tr></table></figure>

<p>SynchronousQueue:    一个不存储元素的阻塞队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。</span><br><span class="line">它支持公平访问队列.</span><br><span class="line">默认情况下线程采用非公平性策略访问队列。创建公平性访问的SynchronousQueue，如果设置true，则等待的线程会采用先进先出的顺序访问队列。</span><br><span class="line">负责把生产者线程处理的数据直接传递给消费者线程。</span><br><span class="line">队列本身并不存储任何元素，非常适合传递性场景。</span><br><span class="line">SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</span><br><span class="line">有点像go的channel</span><br></pre></td></tr></table></figure>

<p>LinkedTransferQueue:    一个由链表结构组成的无界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。</span><br><span class="line">相对于其它阻塞队列，linkedTransferQueue多了tryTransfer和transfer方法。</span><br><span class="line"></span><br><span class="line">（1）transfer方法</span><br><span class="line">如果当前有消费者正在等待接收元素(消费者使用take()方法或带有时间限制的poll()方法时)，</span><br><span class="line">transfer方法可以把生产者传入的元素立刻transfer(传输)给消费者。</span><br><span class="line">如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</span><br><span class="line">会让CPU自旋等待消费者消费元素。</span><br><span class="line">因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其它线程。</span><br><span class="line"></span><br><span class="line">（2）tryTransfer方法</span><br><span class="line">tryTransfer方法是用来试探生产者传入的元素是否能直接传递给消费者。</span><br><span class="line">如果没有消费者等待接收元素，则返回false。</span><br><span class="line">和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，</span><br><span class="line">而transfer方法是必须等到消费者消费了才返回。</span><br><span class="line"></span><br><span class="line">对于带有时间限制的tryTransfer(E e,long timeout,TimeUnit unit)方法，</span><br><span class="line">试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回。</span><br><span class="line">如果超时还没有消费元素，则返回false，如果在超时时间内消费了元素，则返回true.</span><br></pre></td></tr></table></figure>

<p>LinkedBlockingDeque:    一个由链表结构组成的双向阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。</span><br><span class="line">所谓双向队列指的是可以从队列的两端插入和移出元素。</span><br><span class="line">双向队列因为多了个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</span><br><span class="line">相比其它的阻塞队列，LinkedBlockingDeque多了addFirst,addLast,offerFirst,offerLast,peekFirst和peekLast等方法，</span><br><span class="line">以First单词结尾的方法，表示插入，获取(peek)或移除双端队列的第一个元素。</span><br><span class="line">以Last单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。</span><br><span class="line">另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst.</span><br><span class="line"></span><br><span class="line">在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外双向阻塞队列可以运用在&quot;工作窃取&quot;模式中。</span><br></pre></td></tr></table></figure>

<h4 id="✅阻塞队列的实现原理"><a href="#✅阻塞队列的实现原理" class="headerlink" title="✅阻塞队列的实现原理"></a>✅阻塞队列的实现原理</h4><p>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源代码发现ArrayBlockingQueue使用了Condition来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notEmpty = lock.newCondition();</span><br><span class="line">notFull = lock.newChonditon();</span><br></pre></td></tr></table></figure>

<ul>
<li>如果队列满：添加元素的时候，通过调用notFull.await()阻塞当前线程；移除元素额时候，用notFull.signal()唤醒在notFull上等待的线程。</li>
<li>如果队列空：读取元素的时候，通过notEmpty.await()阻塞当前线程；当添加元素时，调用notEmpty.signal()唤醒在notEmpty上等待的线程。</li>
</ul>
<p>阻塞生产者await()主要通过LockSupport.park(this)来实现。其中，首先调用setBlocker先保存一下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。</p>
<h3 id="4-Fork-Join框架"><a href="#4-Fork-Join框架" class="headerlink" title="4.Fork/Join框架"></a>4.Fork/Join框架</h3><p>Fork/Join框架是Java 7 提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<h4 id="✅工作窃取-work-stealing-算法"><a href="#✅工作窃取-work-stealing-算法" class="headerlink" title="✅工作窃取(work-stealing)算法"></a>✅工作窃取(work-stealing)算法</h4><p>工作窃取(work-stealing)算法是指某个线程从其他队列里窃取任务来执行。</p>
<p>做一个比较大的任务，可以把这个任务分割成若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。<br>比如A线程负责处理A队列里的任务。但是，有的线程会把自己队列里的任务干完，而其它线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常使用双端队列，被窃取任务线程永远从双端队列头部拿任务执行，而窃取任务的线程永远从双队列的尾部拿任务执行。</p>
<p>工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</p>
<p>工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<h4 id="✅Fork-Join框架的设计"><a href="#✅Fork-Join框架的设计" class="headerlink" title="✅Fork/Join框架的设计"></a>✅Fork/Join框架的设计</h4><p>步骤1：分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。</p>
<p>步骤2：执行任务并合并结果。分割的子任务分别放在双端队列，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p>
<p>Fork/Join使用两个类来完成以上两个事情：</p>
<p>1)ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。<br>通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。<br>a.RecursiveAction: 用于没有返回结果的任务。<br>b.RecursiveTask:用于有返回结果的任务。</p>
<p>2）ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。</p>
<p>任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程队列的尾部获取一个任务。</p>
<h4 id="✅使用Fork-Join的例子"><a href="#✅使用Fork-Join的例子" class="headerlink" title="✅使用Fork/Join的例子"></a>✅使用Fork/Join的例子</h4><p>计算1+2+3+4的结果：</p>
<p>1.如何fork：设置分割的阈值是2，由于是4个数字相加，所以Fork/Join框架会把这个任务fork成两个子任务</p>
<p>2.如何join：join两个子任务的结果。因为是有结果的任务，因此必须继承RecursiveTask</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class CountTask extends RecursiveTask&lt;Integer&gt;&#123;</span><br><span class="line"> </span><br><span class="line">    private static final int THRESHOLD = 2;//阈值</span><br><span class="line"> </span><br><span class="line">    private int start;</span><br><span class="line"> </span><br><span class="line">    private int end;</span><br><span class="line"> </span><br><span class="line">    public CountTask(int start,int end)&#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        // 如果任务足够小就计算任务</span><br><span class="line">        boolean canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        if (canCompute)&#123;</span><br><span class="line">            for (int i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 如果任务大于阈值，就分裂成两个子任务计算</span><br><span class="line">            int middle = (start + end)/2;</span><br><span class="line">            CountTask leftTask = new CountTask(start,middle);</span><br><span class="line">            CountTask rightTask = new CountTask(middle+1,end);</span><br><span class="line"> </span><br><span class="line">            // 执行子任务</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"> </span><br><span class="line">            // 等待子任务执行完，并得到结果</span><br><span class="line">            int leftResult = leftTask.join();</span><br><span class="line">            int rightResult = rightTask.join();</span><br><span class="line"> </span><br><span class="line">            // 合并子任务</span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">        // 生成一个计算任务，负责计算 1+2+3+4</span><br><span class="line">        CountTask task = new CountTask(1,4);</span><br><span class="line">        // 执行一个任务</span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;魔法革的日志信息：----&gt;&quot;+ result.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fork方法是执行，join方法是等待执行完获取运行结果。需要实现computer方法，在这个方法里看怎么拆分任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完成并得到结果。</p>
<h4 id="✅Fork-Join框架的异常处理"><a href="#✅Fork-Join框架的异常处理" class="headerlink" title="✅Fork/Join框架的异常处理"></a>✅Fork/Join框架的异常处理</h4><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (task.isCompletedAbnormally())&#123;</span><br><span class="line">    System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回 null。</p>
<h4 id="✅Fork-Join框架的实现原理"><a href="#✅Fork-Join框架的实现原理" class="headerlink" title="✅Fork/Join框架的实现原理"></a>✅Fork/Join框架的实现原理</h4><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成的，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p>
<p>（1）fork方法实现原理：</p>
<p>调用ForkJoinTask的fork()方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步地执行这个任务，然后立即返回结果。</p>
<p>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。</p>
<p>（2）join方法实现原理</p>
<p>Join方法的主要作用是阻塞当前线程并等待获取结果。</p>
<p>它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：<br>已完成(NORMAL)，被取消(CANCELLED)，信号(SIGNAL)和出现异常(EXCEPTION)。</p>
<p>a. 如果任务状态已完成，则直接返回任务结果。<br>b. 如果任务状态是被取消，则直接抛出CancellationException。<br>c. 如果任务状态是抛出异常，则直接抛出对应的异常。</p>
<p>在doJoin()方法里，首先通过任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。<br>如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p>
<h2 id="第七章-java中的13个原子操作类"><a href="#第七章-java中的13个原子操作类" class="headerlink" title="第七章 java中的13个原子操作类"></a>第七章 java中的13个原子操作类</h2><p>多线程同时更新一个变量，通常我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。</p>
<p>Java从JDK 1.5开始提供了java.util.concurrent.atomic包（以下简称Atomic包），这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p>
<p>Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。Atomic包里的类基本都是使用Unsafe实现的包装类。</p>
<blockquote>
<p>Unsafe类位于sun.misc包下，它是java实现高并发的基础，通过它可以执行一些不安全的操作，如像C语言一样直接操作内存资源，<br>它提供的这些方法增强了java对底层资源的操作能力，但同时也增加了程序出错的风险.<br>Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障相关、数组相关等。</p>
</blockquote>
<blockquote>
<p>CAS(compareAndSwap)即比较并替换，是实现并发算法时常用到的一种技术。CAS底层为一条原子指令cmpxchg，可以保证原子性，Unsafe提供的CAS方法如compareAndSwapInt底层就是CPU指令cmpxchg。<br>CAS在java并发包中的原子类如AtomicInteger，AQS(AbstractQueuedSynchronizer)，ConcurrentHashMap等实现中都有广泛的使用。<br>因此，不管是Atomic还是什么锁里的CAS都依托于Unsafe包里的方法。</p>
</blockquote>
<p>Unsafe类：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/strongmore/p/15468423.html">https://www.cnblogs.com/strongmore/p/15468423.html</a></p>
<h3 id="1-原子更新基本类型类"><a href="#1-原子更新基本类型类" class="headerlink" title="1.原子更新基本类型类"></a>1.原子更新基本类型类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">三个类：</span><br><span class="line">· AtomicBoolean：原子更新布尔类型。</span><br><span class="line">· AtomicInteger：原子更新整型。</span><br><span class="line">· AtomicLong：原子更新长整型。</span><br><span class="line"></span><br><span class="line">AtomicInteger为例：</span><br><span class="line">· int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</span><br><span class="line"></span><br><span class="line">· boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</span><br><span class="line"></span><br><span class="line">· int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。</span><br><span class="line"></span><br><span class="line">· void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br><span class="line"></span><br><span class="line">·int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。</span><br></pre></td></tr></table></figure>

<p>源码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">    int current = get(); </span><br><span class="line">    int next = current + 1;</span><br><span class="line">    if (compareAndSet(current, next)) </span><br><span class="line">        return current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Atomic包里的类基本都是使用Unsafe实现的.<br>Unsafe只提供了3种CAS方法：compareAndSwapObject、compare- AndSwapInt和compareAndSwapLong.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapObject(Object o,  long offset, Object expected, Object x);  </span><br><span class="line">  </span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,  int expected, int x);  </span><br><span class="line">  </span><br><span class="line">public final native boolean compareAndSwapLong(Object o, long offset,  long expected, long x);  </span><br></pre></td></tr></table></figure>

<h3 id="2-原子更新数组"><a href="#2-原子更新数组" class="headerlink" title="2.原子更新数组"></a>2.原子更新数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">三个类：</span><br><span class="line">· AtomicIntegerArray：原子更新整型数组里的元素。</span><br><span class="line">· AtomicLongArray：原子更新长整型数组里的元素。</span><br><span class="line">· AtomicReferenceArray：原子更新引用类型数组里的元素。</span><br><span class="line"></span><br><span class="line">AtomicIntegerArray为例：</span><br><span class="line">· int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。</span><br><span class="line"></span><br><span class="line">· boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</span><br><span class="line"></span><br><span class="line">static int[] value = new int[] &#123; 1， 2 &#125;;  </span><br><span class="line">static AtomicIntegerArray ai = new AtomicIntegerArray(value); </span><br><span class="line">ai.getAndSet(0， 3);</span><br><span class="line">System.out.println(ai.get(0)); //3</span><br><span class="line">System.out.println(value[0]);  //1</span><br></pre></td></tr></table></figure>

<p>需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p>
<h3 id="3-原子更新引用类型"><a href="#3-原子更新引用类型" class="headerlink" title="3.原子更新引用类型"></a>3.原子更新引用类型</h3><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">· AtomicReference：原子更新引用类型。</span><br><span class="line">· AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</span><br><span class="line">· AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。</span><br><span class="line"></span><br><span class="line">AtomicReference为例：</span><br><span class="line"></span><br><span class="line">public class AtomicReferenceTest &#123;</span><br><span class="line"></span><br><span class="line">    public static AtomicReference&lt;user&gt; atomicUserRef = new AtomicReference&lt;user&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user = new User(&quot;conan&quot;， 15); atomicUserRef.set(user);</span><br><span class="line">        User updateUser = new User(&quot;Shinichi&quot;， 17); atomicUserRef.compareAndSet(user， updateUser);</span><br><span class="line">        System.out.println(atomicUserRef.get().getName());</span><br><span class="line">        System.out.println(atomicUserRef.get().getOld());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-原子更新字段类"><a href="#4-原子更新字段类" class="headerlink" title="4.原子更新字段类"></a>4.原子更新字段类</h3><p>更新静态类里的成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</span><br><span class="line">· AtomicLongFieldUpdater：原子更新长整型字段的更新器。</span><br><span class="line">· AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。</span><br></pre></td></tr></table></figure>

<p>要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</p>
<p>AstomicIntegerFieldUpdater例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicIntegerFieldUpdaterTest &#123;</span><br><span class="line"></span><br><span class="line">   // 创建原子更新器，并设置需要更新的对象类和对象的属性</span><br><span class="line">    private static AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class， &quot;old&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User conan = new User(&quot;conan&quot;， 10);</span><br><span class="line">        System.out.println(a.getAndIncrement(conan)); //10</span><br><span class="line">        System.out.println(a.get(conan));  //11</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class User &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        public volatile int old;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">静态变量和成员变量：</span><br><span class="line">由static修饰的变量称为静态变量，其实质上就是一个全局变量。</span><br><span class="line">如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰；</span><br><span class="line">没有被静态修饰的内容，其实是属于对象的特殊描述。</span><br><span class="line"></span><br><span class="line">成员变量和静态变量的区别：</span><br><span class="line">1.生命周期不同</span><br><span class="line">成员变量随着对象的创建而存在，随着对象被回收而释放。</span><br><span class="line">静态变量随着类的加载而存在，随着类的消失而消失。</span><br><span class="line">2.调用方式不同</span><br><span class="line">成员变量只能被对象调用。</span><br><span class="line">静态变量可以被对象调用，还可以被类名调用。</span><br><span class="line">3.别名不同</span><br><span class="line">成员变量也称为实例变量。</span><br><span class="line">静态变量也称为类变量。</span><br><span class="line">4.数据存储位置不同</span><br><span class="line">成员变量存储在堆内存的对象中，所以也叫对象的特有数据。</span><br><span class="line">静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">静态方法和非静态方法：</span><br><span class="line">静态方法:是使用static关键字修饰的方法，又叫类方法.属于类的，</span><br><span class="line">不属于对象， 在实例化对象之前就可以通过类名.方法名调用静态方法。</span><br><span class="line">非静态方法：又称为实例方法，成员方法。属于对象的，不属于类的。</span><br><span class="line"></span><br><span class="line">静态方法和非静态方法的区别：</span><br><span class="line">1.调用方法</span><br><span class="line">静态方法中，可以调用静态方法，不能调用非静态方法。在静态方法中，不能使用super和this关键字。不能引用成员变量。</span><br><span class="line">普通方法中，可以调用普通方法，也可以调用静态方法。</span><br><span class="line">2.使用方法</span><br><span class="line">静态方法可以直接调用，类名调用和对象调用。</span><br><span class="line">但是非静态方法只能通过对象调用。（对象名.方法名）</span><br><span class="line">3.生命周期不同</span><br><span class="line">静态方法的生命周期跟相应的类一样长，静态方法和静态变量会随着类的定义而被分配和装载入内存中。一直到线程结束，静态属性和方法才会被销毁。</span><br><span class="line">非静态方法的生命周期和类的实例化对象一样长，只有当类实例化了一个对象，非静态方法才会被创建，而当这个对象被销毁时，非静态方法也马上被销毁。</span><br><span class="line"></span><br><span class="line">静态方法优点：常住在内存中，调用快捷方便，全剧唯一，用类调用就行。</span><br><span class="line">应用场景：</span><br><span class="line">1. 静态方法最适合工具类中方法的定义；比如文件操作，日期处理方法等.</span><br><span class="line">2. 静态方法适合入口方法的定义；如单例模式，因为从外部拿不到构造函数，所有定义一个静态的方法获取对象非常有必要.</span><br><span class="line">3. 静态变量适合全局变量的定义.（如布尔型静态成员变量做控制符）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">静态类：</span><br><span class="line">java允许我们在一个类里面定义静态类。比如内部类（nested class）。</span><br><span class="line">把nested class封闭起来的类叫外部类。</span><br><span class="line">在java中，我们不能用static修饰顶级类（top level class）。只有内部类可以为static。</span><br><span class="line">（一般工具类也不是static的，方法是static的）</span><br><span class="line">（一般在一个类里再定义一个类用于包装数据，用public static class）</span><br><span class="line"></span><br><span class="line">静态内部类和非静态内部类的区别：</span><br><span class="line">1.内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。（此话怎样，意思是非静态内部类需要对象.类名，静态内部类需要外部类名.类名）</span><br><span class="line">2.非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。</span><br><span class="line">3.一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。</span><br><span class="line"></span><br><span class="line">class OuterClass&#123;</span><br><span class="line">  private static String msg = &quot;GeeksForGeeks&quot;;</span><br><span class="line">  // 静态内部类</span><br><span class="line">  public static class NestedStaticClass&#123;</span><br><span class="line">    // 静态内部类只能访问外部类的静态成员</span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">     // 试着将msg改成非静态的，这将导致编译错误 </span><br><span class="line">     System.out.println(&quot;Message from nested static class: &quot; + msg); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 非静态内部类</span><br><span class="line">  public class InnerClass&#123;</span><br><span class="line">    // 不管是静态方法还是非静态方法都可以在非静态内部类中访问</span><br><span class="line">    public void display()&#123;</span><br><span class="line">     System.out.println(&quot;Message from non-static nested class: &quot;+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">class Main</span><br><span class="line">&#123;</span><br><span class="line">  // 怎么创建静态内部类和非静态内部类的实例</span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">    // 创建静态内部类的实例</span><br><span class="line">    OuterClass.NestedStaticClass printer = new OuterClass.NestedStaticClass();</span><br><span class="line">    // 创建静态内部类的非静态方法</span><br><span class="line">    printer.printMessage();  </span><br><span class="line">    // 为了创建非静态内部类，我们需要外部类的实例</span><br><span class="line">    OuterClass outer = new OuterClass();    </span><br><span class="line">    OuterClass.InnerClass inner = outer.new InnerClass();</span><br><span class="line">    // 调用非静态内部类的非静态方法</span><br><span class="line">    inner.display();</span><br><span class="line">    // 我们也可以结合以上步骤，一步创建的内部类实例</span><br><span class="line">    OuterClass.InnerClass innerObject = new OuterClass().new InnerClass();</span><br><span class="line">    // 同样我们现在可以调用内部类方法</span><br><span class="line">    innerObject.display();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Inner class &#x27;Person&#x27; may be &#x27;static&#x27; </span><br><span class="line">ide提示内部类最好是静态的. 不然不能在所在外部类里直接new一个对象。</span><br><span class="line"></span><br><span class="line">一个类包在另一个外部类里面，叫做内部类，可以和其他内部类重名。</span><br><span class="line">但是和一个类并列在一个类文件里，不是内部类，不能重名。不同于内部类，是可以直接使用的，相当于一个单独的文件，不建议这么做。</span><br></pre></td></tr></table></figure>

<p>静态内部类和非静态内部类：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/74838.htm">https://www.jb51.net/article/74838.htm</a></p>
<h2 id="第八章-java中的并发工具类"><a href="#第八章-java中的并发工具类" class="headerlink" title="第八章 java中的并发工具类"></a>第八章 java中的并发工具类</h2><p>JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类提供了在线程间交换数据的一种方法。</p>
<h3 id="1-等待多线程完成的CountDownLatch"><a href="#1-等待多线程完成的CountDownLatch" class="headerlink" title="1.等待多线程完成的CountDownLatch"></a>1.等待多线程完成的CountDownLatch</h3><p>应用场景：等待其他多个线程执行完了，再执行当前线程。</p>
<p>在JDK1.5之后的并发包中提供的CountDownLatch可以实现join的功能，一个countDownLatch的await()方法相当于多个线程的join方法。join线程终止后，其实是调用了<code>this.notifyAll()方法</code>，在JVM里实现的，在JDK里看不到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(1);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(2);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用CountDownLatch的countDown方法时，CountDownLatch的await方法会阻塞当前线程，直到N变为0。可以是N个线程，也可以是1个线程的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p>
<p>超时机制：<code>await(long time, TimeUnit unit)</code>，这个方法等待特定时间后，就会不再阻挡当前线程。</p>
<p>⚠️CountDownLatch不可能重新初始化或者修改其内部计数器的值。</p>
<h3 id="2-同步屏障CyclicBarrier"><a href="#2-同步屏障CyclicBarrier" class="headerlink" title="2.同步屏障CyclicBarrier"></a>2.同步屏障CyclicBarrier</h3><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<p>应用场景：一辆车装10个人，上够10个人才开车。</p>
<p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier = new CyclicBarrier(2);</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    try &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程和子线程的调度是有CPU决定的，两个线程都有可能先执行。可能是1，2，也可能是2，1.</p>
<p>CyclicBarrier还提供了一个高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在所有线程都到达屏障时，优先执行barrierAction。注意，这个barrierAction不一定是要用cyclicBarrier.await()的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 22:50</span><br><span class="line"> **/</span><br><span class="line">public class CyclicTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier c = new CyclicBarrier(2, new A());</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(2);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class A implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出3-1-2 或者3-2-1.</p>
<h4 id="✅线程的阻塞状态和中断状态"><a href="#✅线程的阻塞状态和中断状态" class="headerlink" title="✅线程的阻塞状态和中断状态"></a>✅线程的阻塞状态和中断状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">线程的阻塞状态和中断状态</span><br><span class="line"></span><br><span class="line">已知：</span><br><span class="line">wait和notify：</span><br><span class="line">执行了监视器的wait()方法后，放弃锁进入等待状态。</span><br><span class="line">执行了监视器的notify()方法后，让一个线程从等待队列到同步队列，进入阻塞状态。</span><br><span class="line">wait()和notify()方法使用的前提是要获取对象的锁的，也就是在synchronized(obj)&#123;&#125;内。</span><br><span class="line">sleep方法进入定时等待状态，不会释放锁(如果写在synchronized内)。</span><br><span class="line"></span><br><span class="line">sleep和wait区别：</span><br><span class="line">1.sleep是Thread类的方法，是「静态方法」。wait是Object类的方法，调用需要具体的对象。</span><br><span class="line">2.sleep是不释放锁的，解除方法要么是timeout，或者interrupt一下让它抛出InterruptedException。wait是释放锁的，可以被notify/notifyAll恢复，同样也可以timeout或者interrupt。</span><br><span class="line">3.sleep在哪里都可以调用，wait必须在同步方法或同步块里调用，并且同步的对象要跟wait的对象一样。</span><br><span class="line">4.sleep作用只是线程的操作，用于短时间暂停线程，wait/notify可以用作线程间通信，达到资源调度的功能。</span><br><span class="line"></span><br><span class="line">Thread.yield():</span><br><span class="line">yield方法也是Thread类的静态方法，重新分配。</span><br><span class="line">会把当前线程从可运行状态变成就绪状态。</span><br><span class="line">之后会cpu会从众多就绪状态的线程中选择一个来执行。</span><br><span class="line"></span><br><span class="line">thread.join():</span><br><span class="line">join是Thread类方法，非静态，表示等待该线程结束，当前线程才继续执行</span><br><span class="line">join进入等待状态。</span><br><span class="line"></span><br><span class="line">线程中断：</span><br><span class="line">suspend()暂停和resume()继续容易造成死锁，stop()具有固有的不安全性。已废弃。</span><br><span class="line">终止线程的几种方式：</span><br><span class="line">1.设计标记位法：volatile的boolean类型变量来控制</span><br><span class="line">缺点：如果代码并没有这种循环语句，或者线程被其他语句阻塞了，线程可能一直不会去检查标记位。</span><br><span class="line">2.thread.interrupt()方法中断</span><br><span class="line">线程里有一个boolean类型的中断状态，是一个标记位，是存在Native层的。</span><br><span class="line">当使用Thread的interrupt()方法时，线程的中断状态会被设置为true。</span><br><span class="line">一些阻塞方法就会抛出一个异常InterruptedException。如果没有这种阻塞方法，那就什么都不会做。</span><br><span class="line">interrupt()方法是实例方法</span><br><span class="line">还有两个方法：isInterrupted() 和 interrupted() </span><br><span class="line">相同点是这两个都是返回一个boolean值，true表示中断，false表示未被中断。</span><br><span class="line">不同点是interrupted()是静态方法，只能在当前线程调用，判断是true后会清除标记，也就是重置为false。isInterrupted()是实例方法，不会清除标记，所以可以多次判断。</span><br><span class="line"></span><br><span class="line">*在Thread.sleep这些方法，抛出InterruptedException异常后会清除标记位状态。</span><br><span class="line">一个关于中断的例子见下面代码</span><br><span class="line"></span><br><span class="line">*所谓的interrupt线程中断，只是修改了一个标记位，需要我们判断标记位做后续的处理。</span><br><span class="line">如果catch代码块什么都不处理，会继续跑完剩下的代码。所以应该理解为『并不是中断，而是通知你应该自行中断了』</span><br><span class="line">线程不应该交给别的线程中断，应该由自己中断自己，过程中保证资源和变量已合理的处理了（该关的关，该释放的释放）。</span><br><span class="line"></span><br><span class="line">线程阻塞：</span><br><span class="line">阻塞和非阻塞是形容多个线程之间的相互影响的，一个线程占用了临界区资源，那么其他线程必须在临界区外等待。</span><br><span class="line">如果一个线程一直占用不释放资源，那么其他需要该临界区资源的线程都必须一直等待。</span><br><span class="line">非阻塞就是运行多个线程同时进入临界区，只要保证不把数据修改坏就行。</span><br><span class="line"></span><br><span class="line">线程阻塞的场景：</span><br><span class="line">运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</span><br><span class="line">发出I/O请求时，JVM会把该线程置为阻塞状态，I/O处理完毕时，线程重新转入就绪状态。</span><br><span class="line"></span><br><span class="line">线程阻塞和等待的区别：</span><br><span class="line">在java中，线程阻塞状态是线程本身不可计划的，而线程等待状态是线程本身计划之内的。</span><br><span class="line">相同点：</span><br><span class="line">（1）都会暂停线程的执行。</span><br><span class="line">区别点：</span><br><span class="line">（1）线程进入阻塞状态是被动的, 而线程进入等待状态是主动的。</span><br><span class="line">阻塞状态的被动：线程在同步代码外，获取对象锁失败时，线程进入阻塞状态；何时获取对象锁失败不可知，即线程阻塞状态是线程本身不可计划的。</span><br><span class="line">等待状态的主动：线程在同步代码内，等待其他线程操作时，线程接入等待状态；何时等待其他线程操作可知，即线程等待状态是线程本身计划之内的。</span><br><span class="line"></span><br><span class="line">countDownLatch/cyclicBarrier的await方法进入阻塞状态，会不会释放锁？</span><br><span class="line">经测试，测试代码如下，不会释放锁。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">wait进入等待状态，释放锁。</span><br><span class="line">sleep进入定时等待状态，不释放锁。</span><br><span class="line">await进入阻塞状态，不释放锁。</span><br></pre></td></tr></table></figure>

<p>线程中断的讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/alcoholdi/article/details/79475029">https://blog.csdn.net/alcoholdi/article/details/79475029</a></p>
<p>关于线程中断的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"> </span><br><span class="line">    // 中断目标线程</span><br><span class="line">    public void interrupt() &#123;</span><br><span class="line">        if (this != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"> </span><br><span class="line">        synchronized (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            if (b != null) &#123;</span><br><span class="line">                interrupt0();           // Just to set the interrupt flag</span><br><span class="line">                b.interrupt(this);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 返回目标线程的中断状态	static在这里理解为：只供当前线程使用这个方法</span><br><span class="line">    public static boolean interrupted() &#123;</span><br><span class="line">        return currentThread().isInterrupted(true);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 判断目标线程是否中断</span><br><span class="line">    public boolean isInterrupted() &#123;</span><br><span class="line">        return isInterrupted(false);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private native boolean isInterrupted(boolean ClearInterrupted);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个关于中断的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 09:06</span><br><span class="line"> **/</span><br><span class="line">public class InterruptDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss:SSS&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        InterruptThread t = new InterruptThread();</span><br><span class="line">        Interrupt2Thread t = new Interrupt2Thread();</span><br><span class="line">//        Interrupt3Thread t = new Interrupt3Thread();</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class InterruptThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 抛出InterruptedException后中断标志被清除</span><br><span class="line">                    // 在catch中直接return结束线程</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; catch &quot; + isInterrupted() + &quot; &quot; + interrupted()); //false false</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //false false</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //不输出</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Interrupt2Thread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!isInterrupted()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 抛出InterruptedException后中断标志被清除</span><br><span class="line">                    // 可以再次调用interrupt恢复中断</span><br><span class="line">                    // catch中再次调用interrupt恢复中断状态，while中下次判断isInterrupted()中结束线程</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; catch &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //false false</span><br><span class="line">                    //interrupt();</span><br><span class="line">                    //如果不在catch里再中断，会一直执行</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot;);</span><br><span class="line">//                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted());</span><br><span class="line">                //如果用了上面的那个，中断标识为会输出true后被重置为false，继续循环，不会停</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Interrupt3Thread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @SneakyThrows</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!isInterrupted()) &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                // 抛出InterruptedException后中断标志被清除</span><br><span class="line">                // 可以再次调用interrupt恢复中断</span><br><span class="line">                // catch中再次调用interrupt恢复中断状态，while中下次判断isInterrupted()中结束线程</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; catch &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //false false</span><br><span class="line">                interrupt();</span><br><span class="line">                //System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot;);</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted());</span><br><span class="line">                //如果用了上面的那个，中断标识为会输出true后被重置为false，继续循环，直到在主线程内中断，抛出InterruptedException</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试await方法会不会释放锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 22:33</span><br><span class="line"> **/</span><br><span class="line">public class AwaitTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object lock = 1;</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">        Thread thread1 = new Thread()&#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    System.out.println(&quot;thread1 get lock&quot;);</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread2 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(&quot;thread2 get lock&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier的使用场景：多用于多线程计算数据，最后合并计算结果的场景。<br>一个合并计算结果的例子，用了barrierAction参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 23:02</span><br><span class="line"> **/</span><br><span class="line">public class CyclicDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss:SSS&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BankWaterService bankWaterService = new BankWaterService();</span><br><span class="line">        bankWaterService.count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class BankWaterService implements Runnable &#123;</span><br><span class="line">        private final CyclicBarrier c = new CyclicBarrier(4, this);  //这里屏障解除后执行本线程。</span><br><span class="line">        private final ExecutorService executor = Executors.newFixedThreadPool(4);</span><br><span class="line">        private final ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        private void count() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                executor.execute(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        sheetBankWaterCount.put(Thread.currentThread().getName(), 3);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            c.await();</span><br><span class="line">                            System.out.println(sdf.format(new Date()) + &quot; &quot; + Thread.currentThread().getName());</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int result = 0;</span><br><span class="line">            for (Map.Entry&lt;String, Integer&gt; sheet : sheetBankWaterCount.entrySet()) &#123;</span><br><span class="line">                result += sheet.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sdf.format(new Date()) + &quot; &quot; + &quot;result:&quot; + result);</span><br><span class="line">            executor.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-CyclicBarrier和CountDownLatch的区别"><a href="#3-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="3.CyclicBarrier和CountDownLatch的区别"></a>3.CyclicBarrier和CountDownLatch的区别</h3><p>1、使用的场景不一样，CyclicBarrier阻塞每个线程（每个线程都等待最后一个线程到达屏障），像分布式问题，屏障清除了，每个线程可以继续做自己的事情；CountDownLatch阻塞等待线程（等待线程等待其他线程完成）向集中式的，最后由等待线程统一处理。</p>
<p>2、CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重弄下执行一次。</p>
<p>3、CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</p>
<p>cyclicBarrier线程中断示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-19 18:37</span><br><span class="line"> **/</span><br><span class="line">public class CyclicInterruptTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier c = new CyclicBarrier(3);</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                //e.printStackTrace();</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(2);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        try &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(c.isBroken());</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">2</span><br><span class="line">true</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>说明：尽管屏障数是3，但是其中一个中断了的话，其他的await也会跑出异常。被中断的抛出InterruptedException，其他的抛出BrokenBarrierException。</p>
<h3 id="4-控制并发线程数的Semaphore"><a href="#4-控制并发线程数的Semaphore" class="headerlink" title="4.控制并发线程数的Semaphore"></a>4.控制并发线程数的Semaphore</h3><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p>
<p>应用场景：Semaphore可以做流量控制，特别是公用资源有限的应用场景，比如数据库连接。<br>假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库连接数只有10个，这是我们必须控制只有10个线程同时获取数据库连接保持数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static final int THREAD_COUNT = 30;</span><br><span class="line">private static final ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">private static final Semaphore s = new Semaphore(10);</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                System.out.println(&quot;save data&quot;);</span><br><span class="line">                s.release();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然有30个线程在执行，但是只允许10个线程并发执行。<br>为什么不开始创建10个线程的线程池呢？因为前面需要30个，只是在代码某部分限制10个。<br>构造方法Semaphore(int permits)接收一个整型的数组，表示可用的许可证数量。<br>Semaphore的acquire()方法获取一个许可证，获取不到就阻塞，使用完之后调用release()方法归还许可证。还可以使用tryAcquire()方法尝试获取许可证。</p>
<p>其他方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">intavailablePermits():返回信号量中当前可用的许可证数目。</span><br><span class="line">ingetQueueLength():返回正在等待获取许可证的线程数。</span><br><span class="line">booleanhasQueueThreads():是否有线程正在等待获取许可证</span><br><span class="line">void reducePermits(int reduction):减少reduction个许可证，是个protected方法。</span><br><span class="line">Collection getQueuedThreads():返回所有等待获取许可证的线程集合，是个protected方法。</span><br></pre></td></tr></table></figure>

<h3 id="5-线程间交互数据的Exchanger"><a href="#5-线程间交互数据的Exchanger" class="headerlink" title="5.线程间交互数据的Exchanger"></a>5.线程间交互数据的Exchanger</h3><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exhange()方法交换数据，如果第一个线程先执行exhange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都达到同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p>
<p>应用场景：可用于遗传算法，将两个人作为交配对象，交换两个人的数据。还可以用于校对工作，比如我们需要将纸质银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入之后比对。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Exchanger;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-19 19:23</span><br><span class="line"> **/</span><br><span class="line">public class ExchangerTest &#123;</span><br><span class="line">    private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;&gt;();</span><br><span class="line">    private static final ExecutorService threadPool = Executors.newFixedThreadPool(2);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            String a = &quot;银行流水A&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange = exgr.exchange(a);</span><br><span class="line">                System.out.println(&quot;B 录入的是:&quot; + exchange + &quot; A录入的是：&quot; + a);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            String b = &quot;银行流水B&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange = exgr.exchange(b);</span><br><span class="line">                System.out.println(&quot;A 录入的是:&quot; + exchange + &quot; B录入的是：&quot; + b);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个线程一个没有执行exchange()方法，则会一直等待，如果单向特殊情况发生，避免一直等待，可以使用<code>exchange(V x, long timeout, TimeUnit unit)</code>设置最大等待时间。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/tianzhonghaoqing/article/details/123976376">https://blog.csdn.net/tianzhonghaoqing/article/details/123976376</a></p>
<h2 id="第九章-java中的线程池"><a href="#第九章-java中的线程池" class="headerlink" title="第九章 java中的线程池"></a>第九章 java中的线程池</h2><p>合理地使用线程池能够带来3个好处：<br>降低资源消耗(通过重复利用已创建的线程降低线程创建和销毁造成的消耗)<br>提高响应速度(当任务到达时，任务可以不需要等到线程创建就能立即执行)<br>提高线程的可管理性(线程池可以进行统一分配、调优和监控线程)</p>
<h3 id="1-线程池的实现原理"><a href="#1-线程池的实现原理" class="headerlink" title="1.线程池的实现原理"></a>1.线程池的实现原理</h3><p>ThreadPoolExecutor执行execute方法分下面4种情况：</p>
<p>1、如果当前运行的线程少于corePoolSize，则创建新线程来执行任务，不管已有线程是不是空闲(需要获取全局锁)</p>
<p>2、如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</p>
<p>3、如果BlockingQueue队列已满，则创建新的线程(非核心线程)来处理任务(需要获取全局锁）</p>
<p>4、如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法</p>
<p>工作线程：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。</p>
<h3 id="2-线程池的创建"><a href="#2-线程池的创建" class="headerlink" title="2.线程池的创建"></a>2.线程池的创建</h3><p><code>new ThreadPoolExecutor(xxx)</code>，其中参数具体含义如下：</p>
<p>1、corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，线程池会创建一个线程来执行任务(即使其他空闲的基本线程能够执行新任务也会创建，满了不再创建。）如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p>
<p>2、runnableTaskQueue(任务队列)：用于保存等待执行的任务的阻塞队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue:基于数组结构的有界阻塞队列，按FIFO原则对元素排序。</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue:基于链表结构的有界阻塞队列，FIFO原则，吞吐量高于ArrayBlockingQueue，</span><br><span class="line">静态工厂方法Executors.newFixedThreadPool()使用该队列。</span><br><span class="line"></span><br><span class="line">SynchronousQueue:一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直阻塞。吞吐量高于LinkedBlockingQueue。</span><br><span class="line">静态工厂方法Executors.newCachedThreadPool使用该队列。</span><br><span class="line"></span><br><span class="line">PriorityBlockingQueue:一个具有优先级的无限阻塞队列。</span><br></pre></td></tr></table></figure>

<p>3、maximumPoolSize(线程池最大数量)：线程池允许创建的最大线程数，如果队列满了且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用的是无界队列，改参数没效果。</p>
<p>4、ThreadFactory：设置创建线程的工厂，可以给线程命名。</p>
<p>5、RejectedExecutionHandler(饱和策略)：当队列和线程池都满了，则采取一种策略处理提交的新任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbortPolicy(默认)：直接抛出异常。</span><br><span class="line">CallerRunsPolicy：用调用者所在线程来运行任务。</span><br><span class="line">DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</span><br><span class="line">DiscardPolicy：不处理，丢弃掉且不抛出异常</span><br></pre></td></tr></table></figure>

<p>6、keepAliveTime(线程活动保持时间)：线程池的工作线程空闲后保持存活的时间(超过该时长，非核心线程就会被回收)</p>
<p>7、TimeUnit(线程活动保持时间的单位)</p>
<h3 id="3-向线程池提交任务"><a href="#3-向线程池提交任务" class="headerlink" title="3.向线程池提交任务"></a>3.向线程池提交任务</h3><ul>
<li>execute()：用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>submit()：用于提交需要返回值的任务(返回future类型的对象，该对象可以判断任务是否执行成功且可以通过对象的get()来获取返回值).<br>get()方法会阻塞当前线程直到任务完成。<code>get(long timeout, TimeUnit unit)</code>可阻塞一段时间后立即返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line">    try &#123;</span><br><span class="line">    	Object s = future.get();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    	// 处理中断异常</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">    	// 处理无法执行任务异常</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	// 关闭线程池</span><br><span class="line">    	executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-关闭线程池"><a href="#4-关闭线程池" class="headerlink" title="4.关闭线程池"></a>4.关闭线程池</h3><p>线程池的shutdown或shutdownNow方法关闭线程池，原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程。</p>
<p>无法响应中断的线程可能永远无法终止。</p>
<p>shutdown =&gt; 平缓关闭，等待所有已添加到线程池中的任务执行完再关闭<br>shutdownNow =&gt; 立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">shutdown和shutdownNow：</span><br><span class="line">1、shutdown()</span><br><span class="line">阻止新来的任务提交，对已经提交了的任务不会产生任何影响。</span><br><span class="line">当已经提交的任务执行完后，它会将那些闲置的线程（idleWorks）进行中断，这个过程是异步的。</span><br><span class="line">将线程池的状态改成SHUTDOWN，当再将执行execute提交任务时，如果测试到状态不为RUNNING，则抛出rejectedExecution，从而达到阻止新任务提交的目的。</span><br><span class="line"></span><br><span class="line">2、shutdownNow()</span><br><span class="line">阻止新来的任务提交，同时会中断当前正在运行的线程，即workers中的线程。</span><br><span class="line">它还将workQueue中的任务给移除，并将这些任务添加到列表中进行返回。</span><br><span class="line">通过将线程池的状态改成STOP，当再将执行execute提交任务时，如果测试到状态不为RUNNING，则抛出rejectedExecution，从而达到阻止新任务提交的目的.</span><br><span class="line">一个特例：</span><br><span class="line">一个线程正在sleep状态中，此时执行shutdownNow()，</span><br><span class="line">它向该线程发起interrupt()请求，而sleep()方法遇到有interrupt()请求时，会抛出InterruptedException，并清除中断标志</span><br><span class="line">如果catch了，并没有在catch中再interrupt()，会继续往下执行。</span><br><span class="line">如果向外抛出异常，会中断</span><br></pre></td></tr></table></figure>

<h3 id="5-合理配置线程池"><a href="#5-合理配置线程池" class="headerlink" title="5.合理配置线程池"></a>5.合理配置线程池</h3><p>1、任务的性质：</p>
<p>CPU密集型任务：配置尽可能小的线程(Ncpu+1)，因为CPU密集型任务使得CPU使用率很高，若开过多的线程数能增加上下文切换的次数，带来额外的开销。</p>
<p>IO密集型任务：配置尽可能多的线程(2*Ncpu)，因为CPU使用率并不高，可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。</p>
<p>混合型任务：可将任务分成IO密集型和CPU密集型任务(两个任务执行时间相差不大时)，然后分别用不同的线程池去处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU密集型和IO密集型：</span><br><span class="line">CPU密集型：需非常多CPU计算资源，让每个CPU核心都参与计算，CPU性能充分利用，应避免过多线程上下文切换。</span><br><span class="line">IO密集型：网络、磁盘 IO （与DB、缓存），一旦IO，线程就等待，结束才执行。多设线程数，等待时去做其它事，提高效率。</span><br></pre></td></tr></table></figure>

<p>2、任务的优先级：优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理</p>
<p>3、任务的执行时间：可以交给不同规模的线程池来处理，或者优先级队列。执行时间短的先执行</p>
<p>4、任务的依赖性：比如依赖数据库连接池的任务，线程提交SQL后需要等待数据库返回结果，等待的时间越长，CPU空闲时间就越长(相当于IO密集型任务，应设置较大线程数)</p>
<p>5、建议使用有界队列，可以增加系统稳定性和预警能力，再抛弃任务的时候加监控，无界队列会撑满内存，导致整个系统不能用。</p>
<h3 id="6-线程池的监控"><a href="#6-线程池的监控" class="headerlink" title="6.线程池的监控"></a>6.线程池的监控</h3><p>如果在系统中大量使用线程池，则需要对线程池进行监控，在出现问题时，可根据线程池的使用状况快速定位问题。可使用以下属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">taskCount：线程池需要执行的任务数量</span><br><span class="line">completedTaskCount：线程池在运行过程中已完成的任务数量</span><br><span class="line">largestPoolSize：线程池里曾经创建过的最大线程数量</span><br><span class="line">getPoolSize：线程池的线程数量(线线程池不销毁的话，线程池里的线程不会自动销毁)</span><br><span class="line">getActiveCount：获取活动的线程数</span><br></pre></td></tr></table></figure>

<p>可以继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法进行监控。在执行前、执行后、线程池关闭前监控，比如：任务平均执行时间，最大执行时间，最小执行时间。</p>
<h3 id="7-Executors的线程池："><a href="#7-Executors的线程池：" class="headerlink" title="7.Executors的线程池："></a>7.Executors的线程池：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">定长线程池(FixedThreadPool)：用于控制线程最大并发数</span><br><span class="line">只有核心线程</span><br><span class="line">线程数量固定</span><br><span class="line">执行完立即回收</span><br><span class="line">任务队列为链表结构的有界队列(消耗内存)</span><br><span class="line"></span><br><span class="line">定时线程池(ScheduledThreadPool)：用于执行定时或周期性的任务</span><br><span class="line">核心线程数量固定</span><br><span class="line">非核心线程数量无限(线程过多导致内存溢出)</span><br><span class="line">执行完闲置10ms后回收</span><br><span class="line">任务队列为延时阻塞队列</span><br><span class="line"></span><br><span class="line">可缓存线程池(CachedThreadPool)：执行大量且耗时少的任务</span><br><span class="line">无核心线程</span><br><span class="line">非核心线程数量无限(线程过多导致内存溢出)</span><br><span class="line">执行完闲置60s后回收</span><br><span class="line">任务队列为不存储元素的阻塞队列</span><br><span class="line"></span><br><span class="line">单线程化线程池(SingleThreadExecutor)：应用于不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作</span><br><span class="line">只有1个核心线程</span><br><span class="line">无非核心线程</span><br><span class="line">执行完立即回收</span><br><span class="line">任务队列为链表结构的有界队列(消耗内存)</span><br></pre></td></tr></table></figure>

<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41398418/article/details/126279652">https://blog.csdn.net/qq_41398418/article/details/126279652</a></p>
<h2 id="第十章-Executor框架"><a href="#第十章-Executor框架" class="headerlink" title="第十章 Executor框架"></a>第十章 Executor框架</h2><p>在Java中，使用线程来异步执行任务。Java线程的创建与销毁需要一定的开销，如果我们为每一个任务创建一个新线程来执行，这些线程的创建与销毁将消耗大量的计算资源。同时， 为每一个任务创建一个新线程来执行，这种策略可能会使处于高负荷状态的应用最终崩溃。</p>
<p>Java的线程既是工作单元，也是执行机制。从JDK 5开始，把工作单元与执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p>
<h3 id="1-Executor框架"><a href="#1-Executor框架" class="headerlink" title="1.Executor框架"></a>1.Executor框架</h3><h4 id="✅Executor框架的两级调度模型"><a href="#✅Executor框架的两级调度模型" class="headerlink" title="✅Executor框架的两级调度模型"></a>✅Executor框架的两级调度模型</h4><p>在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。操作系统会调度所有线程并将它们分配给可用的CPU。</p>
<p><strong>两级调度模型</strong>：<br>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。<br><em>应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</em></p>
<h4 id="✅Executor框架的结构"><a href="#✅Executor框架的结构" class="headerlink" title="✅Executor框架的结构"></a>✅Executor框架的结构</h4><p>Executor框架主要由3大部分组成：</p>
<p>1、任务。包括被执行任务需要实现的接口：Runnable接口或Callable接口。</p>
<p>2、任务的执行。包括任务执行机制的核心接口Executor，以及实现自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor和<br>ScheduledThreadPoolExecutor）。</p>
<p>3、异步计算的结果。包括接口Future和实现Future接口的FutureTask类。</p>
<hr>
<p>Executor框架的类与接口：</p>
<p>1、Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。</p>
<p>2、ExecutorService接口，实现自Executor接口。</p>
<p>3、ThreadPoolExecutor类是线程池的核心实现类，用来执行被提交的任务。</p>
<p>4、ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。<br>ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。</p>
<p>5、Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</p>
<p>6、Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled- ThreadPoolExecutor执行。</p>
<hr>
<p>使用步骤：</p>
<p>1.创建任务对象：主线程创建实现Runnable或者Callable接口的任务对象。<code>工具类Executors可以把一个Runnable对象封装为一个Callable对象（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule））</code></p>
<p>2.任务提交给线程池执行：把Runnable对象直接交给ExecutorService执行<code>（ExecutorService.execute（Runnable command））</code>；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行<code>（ExecutorService.submit（Runnable task）或ExecutorService.submit（Callabletask））</code><br>如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象（到目前为止的JDK中，返回的是FutureTask对象）。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。</p>
<p>3.submit的获取结果：主线程可以执行<code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行<code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</p>
<h4 id="✅-Executor框架的成员"><a href="#✅-Executor框架的成员" class="headerlink" title="✅ Executor框架的成员"></a>✅ Executor框架的成员</h4><p>Executor框架的主要成员：ThreadPoolExecutor、<br>ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</p>
<hr>
<p>（1） ThreadPoolExecutor</p>
<p>ThreadPoolExecutor可以使用工厂类Executors来创建。Executors可以创建3种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool和CachedThreadPool。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">固定线程数的FixedThreadPool的 API。</span><br><span class="line">适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">        0L, TimeUnit.MILLISECONDS,</span><br><span class="line">        new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">单个线程的SingleThreadExecutor的API.</span><br><span class="line">适用于需要保证顺序地执行各个任务；只要一个线程的应用场景。</span><br><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,</span><br><span class="line">        0L, TimeUnit.MILLISECONDS,</span><br><span class="line">        new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">        threadFactory));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CachedThreadPool是大小无界的线程池，</span><br><span class="line">适用于执行很多的短期异步任务的小程序，或者 是负载较轻的服务器。</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">        60L, TimeUnit.SECONDS,</span><br><span class="line">        new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>（2） ScheduledThreadPoolExecutor<br>ScheduledThreadPoolExecutor可以使用工厂类Executors来创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor。</span><br><span class="line">包含若干个线程的ScheduledThreadPoolExecutor。</span><br><span class="line">适用于需要多个后台线程执行周期任务</span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SingleThreadScheduledExecutor。</span><br><span class="line">只包含一个线程的ScheduledThreadPoolExecutor。</span><br><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123;</span><br><span class="line">    return new DelegatedScheduledExecutorService</span><br><span class="line">        (new ScheduledThreadPoolExecutor(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>（3） Future接口</p>
<p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当我们把Runnable 接口或Callable接口的实现类提交（submit）给ThreadPoolExecutor或<br>ScheduledThreadPoolExecutor时，会向我们返回一个FutureTask对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">api:</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>到目前最新的JDK 8为止，Java通过上述API返回的是一个FutureTask对象。但从API可以看到，Java仅仅保证返回的是一个实现了Future接口的对象。</p>
<hr>
<p>（4） Runnable接口和Callable接口</p>
<p>Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled- ThreadPoolExecutor执行。它们之间的区别是Runnable不会返回结果，而Callable可以返回结果。</p>
<p>工厂类Executors可以把一个Runnable包装成一个Callable。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Callable&lt;Object&gt; callable(Runnable task) //结果是null</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)  //结果是result</span><br></pre></td></tr></table></figure>

<h3 id="2-ThreadPoolExecutor详解"><a href="#2-ThreadPoolExecutor详解" class="headerlink" title="2.ThreadPoolExecutor详解"></a>2.ThreadPoolExecutor详解</h3><p>介绍一下Executors创建的三种用的是什么参数</p>
<p>1.FixThreadPool内部使用无界队列LinkedBlockingQueue作为任务队列，队列的容量为Integer.MAX_VALUE，由于是无界队列，所以不会拒绝任务，maximumPool没有意义，可能会造成任务无限堆积，从而导致系统资源耗尽的情况。</p>
<p>2.SingleThreadExecutor：与FixThreadPool类似，只是SingleThreadExecutor的线程数固定为1</p>
<p>3.CachedThreadPool的corePool为空，maximumPoolSize为Integer.MAX_VALUE，keepAliveTime为60L，这意味着线程空闲超过60秒则会进行回收。CachedThreadPool内部使用不存储元素的阻塞队列SynchronousQueue作为任务队列，每个插入操作必须等待另一个线程的移除操作。这意味着如果任务的提交速度高于线程的处理速度，那么CachedThreadPool则会不断的创建新的线程，在极端的情况下，会耗尽CPU和内存资源。</p>
<h3 id="3-ScheduledThreadPoolExecutor"><a href="#3-ScheduledThreadPoolExecutor" class="headerlink" title="3.ScheduledThreadPoolExecutor"></a>3.ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor主要用来执行需要延迟或者定时执行的任务，功能与Timer类似，不同的是Timer只能单线程允许，ScheduledThreadPoolExecutor可以指定多个线程。</p>
<p>ScheduledThreadPoolExecutor执行<code>scheduleAtFixedRate()方法或者scheduleWithFixedDelay()</code>方法时，会把要执行的任务放在一个无界队列DelayQueue中，<code>ScheduledThreadPoolExecutor会把Runable对象封装成ScheduledFutureTask（实现了RunnableScheduledFuture接口）</code>。线程池中的线程从DelayQueue中获取ScheduledFutureTask。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private class ScheduledFutureTask&lt;V&gt;</span><br><span class="line">    extends FutureTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>ScheduledFutureTask内部包含三个成员变量。<br>time：任务要被执行的具体时间<br>sequenceNumber：任务排序编号，如果两个任务的time相同，那么则sequenceNumber较小的会先执行<br>period：任务执行的周期</p>
<hr>
<p>ScheduledThreadPoolExecutor执行任务的流程大体是：<br>1.从DelayQueue中获取ScheduledFutureTask（time大于当前时间的任务）<br>2.执行ScheduledFutureTask<br>3.修改ScheduledFutureTask的time为下次要执行的时间<br>4.将ScheduledFutureTask再次放入DelayQueue中</p>
<h3 id="3-FutureTask"><a href="#3-FutureTask" class="headerlink" title="3.FutureTask"></a>3.FutureTask</h3><p>Future接口和FutureTask实现类代表线程异步执行的结果，可以通过FutureTask.get()方法获取异步返回的结果。</p>
<p>FutureTask类还实现了Runnable接口，因此可以交给Executor执行，也可以直接在当前线程中执行：<code>FutureTask.run()</code>。</p>
<hr>
<p>根据FutureTask.run被执行的时机，FutureTask可处于下面3种状态：<br>未启动：方法还没有被执行之前，FutureTask处于未启动状态<br>已启动：方法被执行的过程中，FutureTask处于已启动状态<br>已完成：方法执行完后正常结束或、取消(即执行FutureTask.cancel)或抛异常，FutureTask处于已完成状态</p>
<hr>
<p>FutureTask状态决定get和cancel方法执行结果：</p>
<p>1.gei方法：如果未启动或已启动状态，get方法将导致调用线程阻塞，如果已完成状态，get方法将导致调用线程立即返回结果或抛出异常。</p>
<p>2.cancel方法：当处于未启动状态，该任务将不会执行，当处于已启动状态，<code>Future.cancel(true)</code>将中断此任务线程来停止任务，<code>Future.cancel(false)</code>将不会对正在执行此任务的线程产生影响，当处于已完成状态时，cancel方法将返回false。</p>
<p>当一个线程需要等待另一个线程把某个任务执行完后并获取结果它才能继续执行，可使用FutureTask。</p>
<hr>
<p>FutureTask的实现：</p>
<p>FutureTask的实现基于AbstractQueuedSynchronizer(AQS是同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列)。java.util.concurrent里的很多阻塞类：ReetrantLock、Semaphore、ReetrantReadWriteLock、CountDownLatch都是基于AQS实现。</p>
<hr>
<p>AQS遗忘的知识：<br>AQS实现的同步器都会包含两种类型的操作：<br>1.acquuire操作，获取同步状态，用来阻塞调用线程。FutureTask中为get方法。<br>2.release操作，释放同步状态，用来解除阻塞线程的阻塞，FutureTask中为run方法和cancel方法。</p>
<hr>
<p>基于复合优先于基础原则，FutureTask的内部私有类Sync继承自AQS。实现了AQS的<code>tryAcquireShared(int) 和 tryReleaseShared(int)</code>.</p>
<p>🤔因为FutureTask涉及到线程的阻塞唤醒也就是同步，所以用AQS。</p>
<h2 id="第十一章-java并发编程实践"><a href="#第十一章-java并发编程实践" class="headerlink" title="第十一章 java并发编程实践"></a>第十一章 java并发编程实践</h2><h3 id="1-生产者和消费者模式"><a href="#1-生产者和消费者模式" class="headerlink" title="1.生产者和消费者模式"></a>1.生产者和消费者模式</h3><p>什么是生产者和消费者模式？</p>
<p>生产者和消费者模式是<strong>通过一个容器来解决生产者和消费者的强耦合问题</strong>。生产者和消费者彼此之间不直接通信，而是<strong>通过阻塞队列来进行通信</strong>，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，<strong>阻塞队列就相当于一个缓冲区</strong>，平衡了生产者和消费者的处理能力。</p>
<p>这个阻塞队列就是用来给生产者和消费者解耦的。纵观大多数设计模式，都会<strong>找一个第三者出来进行解耦</strong>，如工厂模式的第三者是工厂类，模板模式的第三者是模板类。在学习一些设计模式的过程中，先找到这个模式的第三者，能帮助我们快速熟悉一个设计模式。</p>
<p>获取机器有多少个CPU，来决定线程池大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int corePoolSize = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>


<h3 id="2-多生产者和多消费者场景"><a href="#2-多生产者和多消费者场景" class="headerlink" title="2.多生产者和多消费者场景"></a>2.多生产者和多消费者场景</h3><p>在多核时代，多线程并发处理速度比单线程处理速度更快，所以可以使用多个线程来生产数据，同样可以使用多个消费线程来消费数据。而更复杂的情况是，消费者消费的数据，有可能需要继续处理，于是消费者处理完数据之后，它又要作为生产者把数据放在新的队列里，交给其他消费者继续处理.</p>
<h3 id="3-线程池就是生产者消费者模式"><a href="#3-线程池就是生产者消费者模式" class="headerlink" title="3.线程池就是生产者消费者模式"></a>3.线程池就是生产者消费者模式</h3><p>Java 中的线程池类其实就是一种生产者和消费者模式的实现方式，但是更加高明。生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要运行的任务数大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实现生产者和消费者模式显然要高明很多，因为消费者能够处理直接就处理掉了（不用中转队列），这样速度更快，而生产者先存，消费者再取这种方式显然慢一些。</p>
<p>生产者消费者例子：</p>
<p>调用一个远程接口查询数据，如果远程服务接口查询时需要几十秒的时间，那么它可以提供一个申请查询的接口，这个接口把要申请查询任务放数据库中，然后该接口立刻返回。然后服务器端用线程轮询并获取申请任务进行处理，处理完之后发消息给调用方，让调用方再来调用另外一个接口取数据。</p>
<p>再比如：</p>
<p>1.有一些任务，这些任务放在db里，表示完成进程，同时将表的id放入redis队列中。</p>
<p>2.任务处理端，从redis队列中取出id，再用id从数据库读出一个任务进行处理，并更新db中任务完成的进程。</p>
<p>3.因为redis缓存稳定性考虑，定时任务搂db中长时间未完成的任务，将id放入redis队列中。</p>
<h3 id="4-线上问题定位"><a href="#4-线上问题定位" class="headerlink" title="4.线上问题定位"></a>4.线上问题定位</h3><p>看日志、系统状态和 dump 线程。</p>
<p>在 Java 进程这一行里可以看到 CPU 利用率是 300%，不用担心，这个是当前机器所有核加在一起的 CPU 利用率。</p>
<p>jstack命令可以把线程 dump 下来，看看究竟是哪个线程、执行什么代码造成的 CPU 利用率高。</p>
<p>dump 出来的线程 ID（nid）是十六进制的，而我们用 TOP 命令看到的线程 ID 是十进制的，所以要用 printf 命令转换一下进制。然后用十六进制的 ID 去 dump 里找到对应的线程。</p>
<p>十进制转十六进制：<br><code>printf &quot;%x\n&quot; 31558</code></p>
<p><code>netstat -nat | grep 8080 -c</code> 多少台机器连接到本机8080端口</p>
<p><code>ps -eLf|grep java -c</code> 看java线程数</p>
<h3 id="5-异步任务池"><a href="#5-异步任务池" class="headerlink" title="5.异步任务池"></a>5.异步任务池</h3><p>如果一个任务仍进线程池之后，运行线程池的程序重启了，那么线程池里的任务就会丢失。另外，线程池只能处理本机的任务，在集群环境下不能有效地调度所有机器的任务。所以，结合线程池开发一个异步任务处理池。</p>
<p>任务池的主要处理流程是，每台机器会启动一个任务池，每个任务池里有多个线程池，当某台机器将一个任务交给任务池后，任务池会先将这个任务保存到数据中，然后某台机器上的任务池会从数据库中获取待执行的任务，再执行这个任务。</p>
<p>每个任务有几种状态，分别是创建（NEW）、执行中（EXECUTING）、RETRY（重试）、挂起（SUSPEND）、中止（TEMINER）和执行完成（FINISH）。</p>
<p>创建：提交给任务池之后的状态。<br>执行中：任务池从数据库中拿到任务执行时的状态。<br>重试：当执行任务时出现错误，程序显式地告诉任务池这个任务需要重试，并设置下一次执行时间。<br>挂起：当一个任务的执行依赖于其他任务完成时，可以将这个任务挂起，当收到消息后，再开始执行。<br>中止：任务执行失败，让任务池停止执行这个任务，并设置错误消息告诉调用端。<br>执行完成：任务执行结束。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/22/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/idea%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/22/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/idea%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Idea日常使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-22 21:43:06" itemprop="dateCreated datePublished" datetime="2022-07-22T21:43:06+08:00">2022-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 17:33:36" itemprop="dateModified" datetime="2022-11-20T17:33:36+08:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="替换文字"><a href="#替换文字" class="headerlink" title="替换文字"></a>替换文字</h2><p>command + R ：当前文件替换<br>command + shift + R ：全局文件替换</p>
<h2 id="字符编码问题"><a href="#字符编码问题" class="headerlink" title="字符编码问题"></a>字符编码问题</h2><p>换行符：LF<br>编码：UTF-8<br>提交代码之后中文乱码：设置里 File Encodings 里的都选UTF-8，Transparent native-to-ascii conversion（透明转换为ascii）不勾选。</p>
<h2 id="变量高亮"><a href="#变量高亮" class="headerlink" title="变量高亮"></a>变量高亮</h2><p>变量写操作颜色设置：Settings-&gt; Editor -&gt; Color Scheme -&gt; General -&gt; Code -&gt; identifier under caret(write) -&gt; 设置底色</p>
<p>变量读操作颜色设置：Settings-&gt; Editor -&gt; Color Scheme -&gt; General -&gt; Code -&gt; identifier under caret -&gt; 设置底色</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/03/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/03/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/python/" class="post-title-link" itemprop="url">python语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-03 16:22:40" itemprop="dateCreated datePublished" datetime="2022-07-03T16:22:40+08:00">2022-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 15:56:58" itemprop="dateModified" datetime="2023-08-20T15:56:58+08:00">2023-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>✅计算机组成：<br>硬件：中央处理器CPU（处理指令、运算数据的）、存储器（内存（存临时数据读写速度快）、外存（硬盘、U盘））、输入设备、输出设备<br>软件：应用软件、系统软件（操作系统）</p>
<p>✅编译型语言和解释型语言：</p>
<ul>
<li><p>编译型语言：在执行之前要先经过编译过程，编译成为一个可执行的机器语言的文件，比如exe。因为翻译只做一遍，以后都不需要翻译，所以执行效率高。<br>  代表：C、C++<br>  优缺点：执行速度快、跨平台差（操作一步，与操作系统联系紧密）、不便调试。</p>
</li>
<li><p>解释型语言：解释性语言编写的程序不进行预先编译，以文本方式存储程序代码。执行时才翻译执行。程序每执行一次就要翻译一遍。解释一句，执行一句，直至结束。<br>  代表：Java、C#、Python、JavaScript<br>  优缺点：速度较慢、跨平台好（操作两步，跨平台有优势，可在windows上运行，也可在linux上运行）、易于调试</p>
</li>
</ul>
<p>怎么选：<br>编译型语言由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object Pascal（Delphi）等都是编译语言。</p>
<p>而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如Java、JavaScript、VBScript、Perl、Python、Ruby、MATLAB等等。</p>
<p>一个比较好的例子：编译型语言就像炒菜吃饭，只有将全部的菜炒好了才能吃饭，解释型语言就像吃火锅，边放菜边吃，不需要将菜全部放在火锅里面。</p>
<p>✅java是解释型语言，javac编译成.class字节码文件是？<br>java的编译器（javac.exe）先将java文件编译为class文件，也就是字节码；然后将字节码交由jvm(java虚拟机)解释执行；<br>所以很多地方都说“java是一种半编译、半解释执行”的语言；</p>
<p>java是解释型的语言，因为虽然java也需要编译，编译成.class文件，<br>但是并不是机器可以识别的语言，而是字节码，最终还是需要 jvm的解释（逐行解释为特定平台机器码），才能在各个平台执行，这同时也是java跨平台的原因。<br>所以可以说java即是编译型的，也是解释型，但是假如非要归类的话，从概念上的定义，恐怕java应该归到解释型的语言中。</p>
<p>✅编译器和解释器之间的主要区别<br>1、编译器将一个程序作为一个整体进行翻译，而解释器则一条一条地翻译一个程序<br>2、在编译器的情况下生成中间代码或目标代码。而解释器不创建中间代码<br>3、编译器比解释器要快得多，因为编译器一次完成整个程序，而解释器则是依次编译每一行代码<br>4、由于要生成目标代码，编译器比解释器需要更多的内存<br>5、编译器同时显示所有错误，很难检测错误，而解释器则逐个显示每条语句的错误，更容易检测错误<br>6、在编译器中，当程序中出现错误时，它会停止翻译，并在删除错误后重新翻译整个程序。相反，当解释器中发生错误时，它会阻止其翻译，在删除错误后，翻译将继续<br>7、在编译器中，这个过程需要两个步骤，首先将源代码翻译成目标程序，然后执行。而在解释器中，这是一个一次性的过程，源代码在编译的同时执行<br>8、编译器用于编程语言，如C、c++、c#、Scala等。解释器用于PHP、Ruby、Python等语言。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CodeHouse/article/details/121846119">https://blog.csdn.net/CodeHouse/article/details/121846119</a></p>
<p>✅脚本语言（动态语言）和静态语言</p>
<p>脚本语言:又被称为扩建的语言，或者动态语言，用来控制软件应用程序，脚本通常以文本保存，只 在被调用时进行解释或编译。脚本语言有:PHP、Python、JavaScript、Lua、Scala、VBScript， ActionScript，MAXScript，ASP，JSP，SQL，Perl，Shell，Ruby，JavaFX，AutoIt等 脚本语言是一种解释性的语言，它不象c/c++等可以编译成二进制代码，以可执行文件的形式存在，脚本 语言不需要编译，可以直接用，由解释器来负责解释。在运行时才确定数据类型的语言。</p>
<p>静态语言:要求在使用变量之前必须声明数据类型。 例如:C、C++、Golang、Java、C#等。 </p>
<p>so：脚本语言一定是解释型语言，解释型语言不一定是脚本语言。</p>
<p>✅Python解释器：<br>CPU不能直接处理 Python 语言，只能直接处理机器指令语言，那是一种由0和1数字组成的语言。.py结尾的文件需要解释器去运行执行。解释器就是能够执行用其他计算机语言编写的程序的系统软件，它是一种翻译程序。它的执行方式是一边翻译一边执行，因此其执行效率一般偏低，但是解释器的实现较为简单，而且编写源程序的高级语言可以使用更加灵活和富于表现力的语法。</p>
<p>常见的Python解释器：</p>
<p>　　1、CPython：这个解释器是用C语言开发的，所以叫CPython。在命令行下运行Python就是启动CPython解释器。CPython是使用最广的Python解释器。</p>
<p>2、IPython：IPython是基于CPython之上的一个交互解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。</p>
<p>　　3、PyPy：PyPy是另一个解释器，它的目标是执行速度。采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。</p>
<p>　　4.Jython：Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p>
<h3 id="mac安装python环境"><a href="#mac安装python环境" class="headerlink" title="mac安装python环境"></a>mac安装python环境</h3><p>终端输入python，跳出的是2.7版本<br>终端输入python3，跳出的是3.9版本<br>就没安装了，要找解析器去官网下载安装</p>
<p>终端执行.py文件：<br>1、写文件，前面要加个注释<br><code>#!/usr/bin/env python3</code><br><code>print(&quot;hello!&quot;)</code><br>2、给文件以执行权限<br><code>chmod a+x hi.py</code><br>3、运行文件<br><code>./hi.py</code></p>
<p>✅安装pycharm<br>官网下载：<a target="_blank" rel="noopener" href="https://www.jetbrains.com.cn/en-us/pycharm/download">https://www.jetbrains.com.cn/en-us/pycharm/download</a><br>下载的社区版本。破解太费劲。<br>新建工程，选择解析器，不选虚拟的那个，选previously configured nterpret.<br>警告：PEP 8: W292 no newline at end of file，因为没有换行，换个行就好了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jade liu"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Jade liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jadeliuliu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jadeliuliu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jadeliu1998@163.com" title="E-Mail → mailto:jadeliu1998@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jadeliu1998" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;jadeliu1998" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5823044646" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5823044646" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jade liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
