<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="int数组的排序int[]数组的排序单纯从小到大排序，直接 Arrays.sort(nums);但是想要倒叙排列或者自定义排序，就需要先转换为Integer[]数组。 123456789101112131415161718192021222324&#x2F;&#x2F; 首先将int[]转换为Integer[]，因为Comparator不适用于原始数据类型数组Integer[] numbersObj &#x3D; Arrays">
<meta property="og:type" content="article">
<meta property="og:title" content="javaのleecode">
<meta property="og:url" content="http://example.com/2022/10/22/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/leeco%E9%A2%98%E7%9B%AE/index.html">
<meta property="og:site_name" content="Jadeliu&#39;s blog">
<meta property="og:description" content="int数组的排序int[]数组的排序单纯从小到大排序，直接 Arrays.sort(nums);但是想要倒叙排列或者自定义排序，就需要先转换为Integer[]数组。 123456789101112131415161718192021222324&#x2F;&#x2F; 首先将int[]转换为Integer[]，因为Comparator不适用于原始数据类型数组Integer[] numbersObj &#x3D; Arrays">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-10-22T01:27:14.666Z">
<meta property="article:modified_time" content="2023-12-29T12:58:34.321Z">
<meta property="article:author" content="Jade liu">
<meta property="article:tag" content="java">
<meta property="article:tag" content="leecode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/10/22/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/leeco%E9%A2%98%E7%9B%AE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>javaのleecode | Jadeliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jadeliu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/22/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/leeco%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          javaのleecode
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-22 09:27:14" itemprop="dateCreated datePublished" datetime="2022-10-22T09:27:14+08:00">2022-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-29 20:58:34" itemprop="dateModified" datetime="2023-12-29T20:58:34+08:00">2023-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leecode%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">leecode刷题</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="int数组的排序"><a href="#int数组的排序" class="headerlink" title="int数组的排序"></a>int数组的排序</h2><p>int[]数组的排序<br>单纯从小到大排序，直接 <code>Arrays.sort(nums);</code><br>但是想要倒叙排列或者自定义排序，就需要先转换为Integer[]数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 首先将int[]转换为Integer[]，因为Comparator不适用于原始数据类型数组</span><br><span class="line">Integer[] numbersObj = Arrays.stream(numbers).boxed().toArray(Integer[]::new);</span><br><span class="line">变为Integer[]之后，就可以</span><br><span class="line">Arrays.sort(numbers, Collections.reverseOrder());</span><br><span class="line">或者：</span><br><span class="line">Arrays.sort(strings, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public int compare(String s1, String s2) &#123;</span><br><span class="line">		return s2.compareTo(s1); // 逆序</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 使用自定义Comparator按绝对值从大到小排序</span><br><span class="line">Arrays.sort(numbersObj, (a, b) -&gt; &#123;</span><br><span class="line">	// 比较绝对值，实现逆序排序</span><br><span class="line">	return Integer.compare(Math.abs(b), Math.abs(a));</span><br><span class="line">&#125;);</span><br><span class="line">或者转变为List&lt;Integer&gt;，使用 Collections.sort(list);   Collections.reverse(list);</span><br><span class="line">以及自定义排序：</span><br><span class="line">Collections.sort(list, new Comparator&lt;A&gt;()&#123;</span><br><span class="line">  @Oerride</span><br><span class="line">  public int compare(A a1, A a2)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="int-和List转换"><a href="#int-和List转换" class="headerlink" title="int[]和List转换"></a>int[]和List转换</h2><p>List转变为int[]：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在Java中，将List&lt;Integer&gt;转换为基本类型数组int[]需进行拆箱操作，</span><br><span class="line">因为List可以存储对象（例如Integer类型），而基本类型数组（如int[]）存储的是基本类型的值。</span><br><span class="line">除了遍历add，也可以用stream。</span><br><span class="line"></span><br><span class="line">// 将List&lt;Integer&gt;转换为int[]</span><br><span class="line">int[] array = list.stream()  // 将List转换为Stream</span><br><span class="line">		 .mapToInt(Integer::intValue)  // 将每个Integer拆箱成int</span><br><span class="line">		 .toArray();  // 从Stream创建数组</span><br></pre></td></tr></table></figure>

<p>int[]转变为List：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在Java中，将一个基本类型的数组 int[] 转换为 List&lt;Integer&gt; 相对来说更为直接，</span><br><span class="line">因为需要进行装箱操作。除了遍历add，也可以用stream。</span><br><span class="line"></span><br><span class="line">// 使用Stream API将int[]转换为List&lt;Integer&gt;</span><br><span class="line">List&lt;Integer&gt; list = IntStream.of(array) // 创建一个IntStream</span><br><span class="line">			.boxed()   // 将每个int装箱成Integer</span><br><span class="line">			.collect(Collectors.toList()); // 收集为List</span><br></pre></td></tr></table></figure>

<p>不是普通数据类型的转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[][] nums = list.toArray(new int[list.size()][]);  // toArray需要一个参数，即数组的类型和期望的大小</span><br><span class="line"> List&lt;int[]&gt; list = Arrays.stream(nums).collect(Collectors.toList());</span><br><span class="line">打印：list.forEach(m -&gt; System.out.println(Arrays.toString(m)));</span><br></pre></td></tr></table></figure>

<p>java中String和char[]的相互转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">要将一个 String 对象转换为 char[] 数组，可以使用 String 类提供的 toCharArray() 方法：</span><br><span class="line">String str = &quot;Hello World&quot;;</span><br><span class="line">char[] charArray = str.toCharArray();</span><br><span class="line"></span><br><span class="line">要将一个 char[] 数组转换为 String 对象，可以使用 String 类的构造函数之一：</span><br><span class="line">char[] charArray = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;;</span><br><span class="line">String str = new String(charArray);</span><br></pre></td></tr></table></figure>

<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>创建栈：</p>
<p>在Java中，创建栈可以通过使用 java.util.Stack 类，它是 Java 集合框架的一部分。但自从 Java 1.6 开始，通常建议使用 Deque 接口来实现栈的功能，因为它提供了更为一致和完整的栈操作。ArrayDeque 是 Deque 接口的一个常用实现，它比 Stack 类更快，因此通常是实现栈的首选。 Stack 类是基于 Vector 实现的，而 Vector 是一个同步的集合类，它的操作比 ArrayDeque 更慢且通常不是必需的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>✅ArrayDeque 和 LinkedList：</p>
<p>ArrayDeque 和 LinkedList 都是 Deque 接口的实现，都可以用来创建一个双端队列（deque）。尽管它们都提供了相似的操作，但是在内部数据结构和性能上有所不同。</p>
<p>ArrayDeque<br>•内部数据结构：ArrayDeque 是基于一个循环数组实现的，这意味着它的操作可以非常快速，并且具有较好的内存局部性。扩容时，涉及到数组复制，可能比 LinkedList 慢。</p>
<p>LinkedList<br>•内部数据结构：LinkedList 是基于双向链表实现的，为每个元素都分配了一个节点（包含数据和前后指针）。在列表中搜索特定元素的操作，它的时间复杂度是线性的（O(n)）。添加新元素不需要复制整个数据结构，也不需要预先分配内存。LinkedList 对于每个元素都有额外的内存开销，因为每个节点都需要额外存储两个指针（前一个和后一个节点的引用）。</p>
<p>在大多数情况下，ArrayDeque 是实现栈或队列的更好选择，因为它提供了更高的性能和更低的内存开销。然而，如果你需要一个可以包含 null 元素的双端队列，或者你确切知道你的应用场景中 LinkedList 的某些特性更有优势，那么选择 LinkedList 也是合理的。</p>
<p>✅Stack、Deque、Queue、ArrayDeque、LinkedList的关系：</p>
<p>1、Stack:<br>Stack 是一个类，它表示后进先出（LIFO）的栈数据结构。<br>它继承自 Vector 类，并提供了标准的栈操作，比如 push、pop、和 peek。<br>Stack 类是传统的栈实现，但自Java 1.6起不推荐使用，因为它是同步的（线程安全的），这在单线程环境下导致不必要的性能损耗。</p>
<p>2、Deque:<br>Deque 是一个接口，代表双端队列，它支持在两端插入和移除元素。<br>Deque 接口扩展了 Queue 接口，因此它有 Queue 的所有功能，加上额外的在队列头部和尾部进行操作的能力。<br>Deque 接口可以作为栈或队列使用。</p>
<p>3、Queue:<br>Queue 是一个接口，它表示先进先出（FIFO）的队列数据结构。<br>它定义了基本的队列操作，如 offer、poll、和 peek。</p>
<p>4、ArrayDeque:<br>ArrayDeque 是 Deque 接口的一个具体实现，它使用循环数组来支持双端队列的操作。<br>ArrayDeque 可以用作栈或队列，通常比 Stack 更高效，并且不允许插入 null 元素。<br>作为一个 Deque 实现，它提供了所有 Deque 接口的方法，也包括 Queue 接口的方法。</p>
<p>5、LinkedList:<br>LinkedList 是 List 和 Deque 接口的一个具体实现，它使用链表数据结构。<br>LinkedList 可以用作列表、栈或队列，并允许插入 null 元素。<br>作为 Deque 的实现，它提供了在双端队列的两端进行操作的方法，同时也支持 Queue 接口的所有操作。</p>
<p>总的来说，Stack、ArrayDeque、和 LinkedList 都可以用来实现栈的功能，而 ArrayDeque 和 LinkedList 也可以用来实现队列。Deque 是一个更通用的接口，涵盖了栈和队列的操作，而 Queue 是专注于队列操作的接口。在实际使用中，ArrayDeque 是推荐用来实现栈和队列的类，因为它通常比 Stack 和 LinkedList 提供更好的性能。</p>
<p>✅Queue、Deque、和Stack在Java中的常见方法的简单介绍：</p>
<p>1、Queue<br>Queue是一个先进先出（FIFO）的集合。它是一个接口，定义了以下基本操作：<br>offer(E e): 将指定元素添加到队列的尾部，如果成功返回true，如果由于容量限制无法添加则返回false。<br>poll(): 移除并返回队列的头部元素，如果队列为空，则返回null。<br>peek(): 返回队列的头部元素，但不移除，如果队列为空，则返回null。<br>add(E e): 将指定元素添加到队列的尾部，如果成功返回true，如果无法添加则抛出IllegalStateException。<br>remove(): 移除并返回队列的头部元素，如果队列为空，则抛出NoSuchElementException。<br>element(): 返回队列的头部元素，但不移除，如果队列为空，则抛出NoSuchElementException。</p>
<p>2、Deque<br>Deque是双端队列接口，继承自Queue接口，包括Queue的所有方法，以及支持从两端插入和删除元素的方法：<br>addFirst(E e)和offerFirst(E e): 在队列的头部插入一个元素。<br>addLast(E e)和offerLast(E e): 在队列的尾部插入一个元素。<br>removeFirst()和pollFirst(): 移除并返回队列的第一个元素。<br>removeLast()和pollLast(): 移除并返回队列的最后一个元素。<br>getFirst()和peekFirst(): 返回队列的第一个元素，但不移除。<br>getLast()和peekLast(): 返回队列的最后一个元素，但不移除。<br>push(E e): 将元素推入栈顶（等同于addFirst）。<br>pop(): 移除并返回栈顶元素（等同于removeFirst）。</p>
<p>3、Stack<br>Stack是一个类，实现了传统的后进先出（LIFO）的栈数据结构。它继承自Vector类，并提供了以下方法：<br>push(E item): 将项目压入栈顶。<br>pop(): 移除并返回栈顶元素，如果栈为空，则抛出EmptyStackException。<br>peek(): 返回栈顶元素但不移除，如果栈为空，则抛出EmptyStackException。<br>empty(): 测试堆栈是否为空，为空则返回true，否则返回false。<br>search(Object o): 返回对象在堆栈中的位置，以1为栈底的偏移量开始计数。如果对象不在堆栈中，返回-1。</p>
<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>题目：给个数组和目标值，给出数组中两个数之和等于目标值的数的索引。<br>思想：哈希映射，利用map的快速查找key特性（<code>map.containsKey(key)</code>）来实现遍历一次就够了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 两数之和</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-20 23:39</span><br><span class="line"> **/</span><br><span class="line">public class TwoNumSum &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = new int[]&#123;2,7,11,15&#125;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        int[] res = solution.twoSum(nums, 9);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">            HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">                if (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                    return new int[]&#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new IllegalArgumentException(&quot;no result&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        d = dict()  #字典，相当于map</span><br><span class="line">        for i, num in enumerate(nums):  #遍历获取索引和内容</span><br><span class="line">            if target - num in d:</span><br><span class="line">                return [i, d[target - num]]</span><br><span class="line">            else:</span><br><span class="line">                d[num] = i</span><br><span class="line">        return []</span><br></pre></td></tr></table></figure>

<h2 id="两链表表示的数相加"><a href="#两链表表示的数相加" class="headerlink" title="两链表表示的数相加"></a>两链表表示的数相加</h2><p>题目：两个链表表示的数，1-&gt;2-&gt;3 表示 123，相加得到和的链表。<br>思想：相加遍历进位即可，carry表示进位，要在while循环外定义，要先算和再算进位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计算两个琏表表示的数的和</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-22 10:18</span><br><span class="line"> **/</span><br><span class="line">public class TwoLinkNumSum &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 构造链表</span><br><span class="line">        ListNode listNode1 = ListNode.inputList(1, 2, 3);</span><br><span class="line">        ListNode.printList(listNode1);</span><br><span class="line">        ListNode.printList(ListNode.reverseList(listNode1));</span><br><span class="line">        ListNode l1 = ListNode.inputList(2, 4, 3);</span><br><span class="line">        ListNode l2 = ListNode.inputList(5, 6, 4);</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        ListNode sum = s.addTwoNumbers(l1, l2);</span><br><span class="line">        ListNode.printList(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">            // 定义pre节点，保证头节点也参与循环</span><br><span class="line">            ListNode pre = new ListNode(0);</span><br><span class="line">            ListNode cur = pre;</span><br><span class="line">            int carry = 0;</span><br><span class="line">            while (l1 != null || l2 != null) &#123;</span><br><span class="line">                int x = l1 == null ? 0 : l1.val;</span><br><span class="line">                int y = l2 == null ? 0 : l2.val;</span><br><span class="line">                int sum = (x y carry) % 10;</span><br><span class="line">                carry = (x y carry) / 10;</span><br><span class="line">                cur.next = new ListNode(sum);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                if (l1 != null) &#123;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if (l2 != null) &#123;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (carry != 0) &#123;</span><br><span class="line">                cur.next = new ListNode(carry);</span><br><span class="line">            &#125;</span><br><span class="line">            return pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ListNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;;</span><br><span class="line">        ListNode(int val) &#123;this.val = val;&#125;</span><br><span class="line">        ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"></span><br><span class="line">        /** 向队尾添加节点 */</span><br><span class="line">        private void addNode(ListNode newNode) &#123;</span><br><span class="line">            if (this.next == null) &#123;</span><br><span class="line">                this.next = newNode;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.next.addNode(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /** 使用方法可变参数把一串数字变成链表 */</span><br><span class="line">        public static ListNode inputList(int ...data) &#123;</span><br><span class="line">            ListNode listHead = null;</span><br><span class="line">            for (int temp : data) &#123;</span><br><span class="line">                ListNode newNode = new ListNode(temp);</span><br><span class="line">                if (listHead == null) &#123;</span><br><span class="line">                    listHead = newNode;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    listHead.addNode(newNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return listHead;</span><br><span class="line">        &#125;</span><br><span class="line">        /** 打印链表 */</span><br><span class="line">        public static void printList(ListNode head) &#123;</span><br><span class="line">            while (head != null) &#123;</span><br><span class="line">                System.out.print(head.val &quot;-&gt;&quot;);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        /** 翻转链表 */</span><br><span class="line">        public static ListNode reverseList(ListNode head) &#123;</span><br><span class="line">            ListNode pre = null;</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            while (cur != null) &#123;</span><br><span class="line">                ListNode next = cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            return pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串的最长无重复字符子串"><a href="#字符串的最长无重复字符子串" class="headerlink" title="字符串的最长无重复字符子串"></a>字符串的最长无重复字符子串</h2><p>题目：一个字符串，给出字符串的连续子串中其中无重复字符的子串的最大长度。<br>思想：滑动窗口，或者叫做双指针，两个指针的差+1表示窗口的长度，用一个map记录某字符最晚出现的位置的下一个位置。如果在start指针后面出现过就需要移动start到map该字符的value的位置了。如果要子串本身，还得记录开始位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 无重复字符的最长子串</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-22 12:29</span><br><span class="line"> **/</span><br><span class="line">public class MaxNoRepeatString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;abcabc&quot;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        System.out.println(solution.lengthOfLongestSubstring(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">            // 用map表示字符对应的下一个位置</span><br><span class="line">            Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            int res = 0;</span><br><span class="line">            String sub = null;</span><br><span class="line">            for (int start = 0, end = 0; end &lt; s.length(); end ++) &#123;</span><br><span class="line">                char c = s.charAt(end);</span><br><span class="line">                if (map.containsKey(c)) &#123;</span><br><span class="line">                    start = Math.max(start, map.get(c));</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果存在key，会更新</span><br><span class="line">                map.put(c, end 1);</span><br><span class="line">                //res = Math.max(res, end - start 1);</span><br><span class="line">                if (end - start 1 &gt; res) &#123;</span><br><span class="line">                    res = end - start 1;</span><br><span class="line">                    sub = s.substring(start, end 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;sub字符串：&quot; sub);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap();</span><br><span class="line">        int maxSize = 0;</span><br><span class="line">        int l = 0;</span><br><span class="line">        String res = null;</span><br><span class="line">        for (int r = 0; r &lt; s.length(); r ++) &#123;  //String是.length() 数组是.length</span><br><span class="line">            char c = s.charAt(r);  //不是.get，是.charAt</span><br><span class="line">            if (map.containsKey(c)) &#123;</span><br><span class="line">                l = Math.max(map.get(c) 1, l);  //需要取大的，不然会回退</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, r);</span><br><span class="line">            if (r - l 1 &gt; maxSize) &#123;</span><br><span class="line">                maxSize = r - l 1;</span><br><span class="line">                res = s.substring(l, r 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;res:&quot; res);</span><br><span class="line">        return maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s: str) -&gt; int:</span><br><span class="line">        dic, res, i = &#123;&#125;, 0, 0</span><br><span class="line">        for j in range(len(s)):</span><br><span class="line">            if s[j] in dic:</span><br><span class="line">                i = max(i, dic[s[j]] + 1)</span><br><span class="line">            dic[s[j]] = j</span><br><span class="line">            res = max(res, j - i + 1)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><p>题目：给两个正序排列的数组，返回这两个数组合起来的数组的中位数。<br>思路1：遍历，在两个数组间横跳，遍历(m+n)/2+1次就好了。时间复杂度是O(m+n)<br>思路2：遍历是挨个排除不可能的值，那么如果用二分法就可以一半一半地排除不可能的值。其实是找第K小的数，要比两个数组的K/2位置的数，小的那个数组K/2及前面的数就可以排除掉，这样递归查找。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 寻找两个正序数组的中位数</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-23 10:10</span><br><span class="line"> **/</span><br><span class="line">public class MedianOfTwoArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array1 = new int[]&#123;1, 2&#125;;</span><br><span class="line">        int[] array2 = new int[]&#123;3, 4&#125;;</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        System.out.println(s.findMedianSortedArrays(array1, array2));</span><br><span class="line">        System.out.println(s.findMedianSortedArrays2(array1, array2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        // 方法一：在两个数组间遍历，移动(m+n)/2+1步</span><br><span class="line">        public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">            int index1 = 0, index2 = 0, left = 0, right = 0;</span><br><span class="line">            int size = nums1.length nums2.length;</span><br><span class="line">            for (int i = 0; i &lt;= size / 2; i++) &#123;</span><br><span class="line">                // left慢一步</span><br><span class="line">                left = right;</span><br><span class="line">                if (index1 &lt; nums1.length &amp;&amp; (index2 == nums2.length || nums1[index1] &lt;= nums2[index2])) &#123;</span><br><span class="line">                    right = nums1[index1++];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right = nums2[index2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (size % 2 == 0) &#123;</span><br><span class="line">                return (left right) / 2.0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 方法二：二分法</span><br><span class="line">        public double findMedianSortedArrays2(int[] nums1, int[] nums2) &#123;</span><br><span class="line">            int n = nums1.length;</span><br><span class="line">            int m = nums2.length;</span><br><span class="line">            int left = (n m 1) / 2;</span><br><span class="line">            int right = (n m 2) / 2;</span><br><span class="line">            return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取两正序数组的第k大的值</span><br><span class="line">        private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) &#123;</span><br><span class="line">            // 要进行比较的数组的长度</span><br><span class="line">            int len1 = end1 - start1 1;</span><br><span class="line">            int len2 = end2 - start2 1;</span><br><span class="line">            if (len1 len2 &lt; k) &#123;throw new IllegalArgumentException(&quot;no result&quot;);&#125;</span><br><span class="line">            // 出递归条件</span><br><span class="line">            if (len1 == 0) return nums2[start2 k - 1];</span><br><span class="line">            if (len2 == 0) return nums1[start1 k - 1];</span><br><span class="line">            if (k == 1) return Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">            // 要比较的两个数组的索引</span><br><span class="line">            int i = start1 Math.min(len1, k / 2) - 1;</span><br><span class="line">            int j = start2 Math.min(len2, k / 2) - 1;</span><br><span class="line">            if (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 1));</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int size = nums1.length nums2.length;</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        int left = 0, right = 0;</span><br><span class="line">        for (int m = 0; m &lt;= size/2; m ++) &#123;</span><br><span class="line">            left = right;</span><br><span class="line">            if (i &lt; nums1.length &amp;&amp; (j == nums2.length || nums1[i] &lt;= nums2[j])) &#123;  //注意越界</span><br><span class="line">                right = nums1[i ++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right = nums2[j ++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (size % 2 == 0) &#123;</span><br><span class="line">            return (left right) / 2.0; //注意除以2.0</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 二分法的思想：在有序数组中查找，每次缩小一半的查找范围</span><br><span class="line">    // 就要看怎么淘汰：扩展一下，找第k大数，两个数组k/2位置，小的那个数组之前的就能淘汰</span><br><span class="line">    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int len = nums1.length nums2.length;</span><br><span class="line">        if (len % 2 == 0) &#123;</span><br><span class="line">            return (getK(nums1, 0, nums1.length - 1, nums2, 0, nums2.length - 1, len/2) getK(nums1, 0, nums1.length - 1, nums2, 0, nums2.length - 1, len/2 1)) / 2.0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return getK(nums1, 0, nums1.length - 1, nums2, 0, nums2.length - 1, len/2 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Integer getK(int[] nums1, int s1, int e1, int[] nums2, int s2, int e2, int k) &#123;</span><br><span class="line">        System.out.println(s1+&quot;.&quot;+e1+&quot;.&quot;+s2+&quot;.&quot;+e2+&quot;.&quot;+k);</span><br><span class="line">        // 递归第一步：出递归条件</span><br><span class="line">        if (s1 &gt; e1) return nums2[s2 k - 1]; // 注意这里得加s2</span><br><span class="line">        if (s2 &gt; e2) return nums1[s1 k - 1]; // 注意k是第k个，索引又是从0开始的</span><br><span class="line">        if (k == 1) return nums1[s1] &lt; nums2[s2] ? nums1[s1]:nums2[s2];</span><br><span class="line">        // 递归第二步：缩小范围</span><br><span class="line">        // 需要注意数组可能没k/2那么大了，没那么大只能选边界</span><br><span class="line">        int i = Math.min(s1 k/2 - 1, e1); // 注意-1</span><br><span class="line">        int j = Math.min(s2 k/2 - 1, e2);</span><br><span class="line">        if (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            // 应该找第几个了</span><br><span class="line">            int find = k - (i - s1 1);</span><br><span class="line">            return getK(nums1, i + 1, e1, nums2, s2, e2, find);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int find = k - (j - s2 1);</span><br><span class="line">            return getK(nums1, s1, e1, nums2, j + 1, e2, find);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>题目：给一个字符串，返回该字符串的最长回文子串，例如：aba，abba。<br>思想1：可以挨个遍历每个字符，从字符开始向左右散发，如果不相等了就停止，并且分两种散发：一个中心字符，两个一样的作为中心字符。记录开始位置和结束位置。<br>思想2：回文子串也是该字符串与它倒过来的字符串的最长公共子串，可以用动态规划维护一个二维数组来做。动态规划就是为了减少重复计算的问题。动态规划听起来很高大上。其实说白了就是空间换时间，将计算结果暂存起来，避免重复计算。作用和工程中用 redis 做缓存有异曲同工之妙。<br>求出最长公共子串后，并不一定是回文串，我们还需要判断该字符串倒置前的下标和当前的字符串下标是不是匹配</p>
<blockquote>
<p>整体思想就是，申请一个二维的数组初始化为 0，然后判断对应的字符是否相等，相等的话<br>arr [ i ][ j ] = arr [ i - 1 ][ j - 1] + 1 。<br>当 i = 0 或者 j = 0 的时候单独分析，字符相等的话 arr [ i ][ j ] 就赋为 1 。<br>arr [ i ][ j ] 保存的就是公共子串的长度，表示以i为结尾和以j为结尾的前arr[i][j]个字符是公共子串。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最长回文子串</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-29 20:43</span><br><span class="line"> **/</span><br><span class="line">public class HuiWenString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;aacabdkacaa&quot;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        System.out.println(solution.longestPalindrome(s));</span><br><span class="line">        System.out.println(solution.longestPalindrome1(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public String longestPalindrome(String s) &#123;</span><br><span class="line">            if (null == s || s.length() &lt; 2) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">            int max = 0;</span><br><span class="line">            String res = null;</span><br><span class="line">            for (int i = 0; i &lt; s.length() - 1; i ++) &#123;</span><br><span class="line">                int l = i, r = i;</span><br><span class="line">                while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                    l --;</span><br><span class="line">                    r ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (r - l 1 &gt; max) &#123;</span><br><span class="line">                    max = r - l 1;</span><br><span class="line">                    res = s.substring(l 1, r);</span><br><span class="line">                &#125;</span><br><span class="line">                l = i;</span><br><span class="line">                r = i + 1;</span><br><span class="line">                while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                    l --;</span><br><span class="line">                    r ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (r - l 1 &gt; max) &#123;</span><br><span class="line">                    max = r - l 1;</span><br><span class="line">                    res = s.substring(l 1, r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String longestPalindrome1(String s) &#123;</span><br><span class="line">            if (null == s || s.length() &lt; 2) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">            String res = null;</span><br><span class="line">            int max = 0;</span><br><span class="line">            int length = s.length();</span><br><span class="line">            int[][] arr = new int[length][length];</span><br><span class="line">            String rev = new StringBuffer(s).reverse().toString(); //字符串翻转</span><br><span class="line">            for (int i = 0; i &lt; length; i ++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; length; j ++) &#123;</span><br><span class="line">                    //如果不想等可以不赋值为0，表示以这个字符为公共最后字符没有公共字符，动态规划也用不上</span><br><span class="line">                    if (s.charAt(i) == rev.charAt(j)) &#123;</span><br><span class="line">                        //为0的边界</span><br><span class="line">                        if (i == 0 || j == 0) &#123;</span><br><span class="line">                            arr[i][j] = 1;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            arr[i][j] = arr[i - 1][j - 1] + 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (arr[i][j] &gt; max) &#123;</span><br><span class="line">                        int beforeRev = length - 1 - j; //倒置前的坐标</span><br><span class="line">                        if (beforeRev arr[i][j] - 1 == i) &#123; //判断下标是否对应</span><br><span class="line">                            max = arr[i][j];</span><br><span class="line">                            res = s.substring(i - arr[i][j] + 1, i + 1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        //遍历每个元素，用双指针前后拓展，直到不一样就停止</span><br><span class="line">        int maxSize = 0;</span><br><span class="line">        String res = &quot;&quot;;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            // 1.一个点为中心</span><br><span class="line">            int jump = 0;</span><br><span class="line">            while (i - jump &gt;= 0 &amp;&amp; i jump &lt; s.length() &amp;&amp; s.charAt(i - jump) == s.charAt(i jump)) &#123;</span><br><span class="line">                if (jump*2+1 &gt; maxSize) &#123;</span><br><span class="line">                    maxSize = jump*2+1;</span><br><span class="line">                    res = s.substring(i - jump, i jump +1);</span><br><span class="line">                &#125;</span><br><span class="line">                jump ++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 2.以两个点为中心</span><br><span class="line">            jump= 0; // 注意从0开始</span><br><span class="line">            while (i - jump &gt;= 0 &amp;&amp; i + 1 jump &lt; s.length() &amp;&amp; s.charAt(i - jump) == s.charAt(i + 1 jump)) &#123;</span><br><span class="line">                if (jump*2+2 &gt; maxSize) &#123;</span><br><span class="line">                    maxSize = jump*2+2;</span><br><span class="line">                    res = s.substring(i - jump, i jump +2);  //注意是substring</span><br><span class="line">                &#125;</span><br><span class="line">                jump ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        //动态规划的思想：以空间换时间，保存计算结果，避免重复计算</span><br><span class="line">        //需要明确[i][j]表示的含义，以及怎么传递下去，以及最开始怎么算</span><br><span class="line">        // 1.初始化动态规划矩阵</span><br><span class="line">        int length = s.length();</span><br><span class="line">        int[][] nums = new int[length][length]; //矩阵初始化方法</span><br><span class="line">        String res = &quot;&quot;;</span><br><span class="line">        int max = 0;</span><br><span class="line">        // 2.遍历方向要依据传递条件</span><br><span class="line">        for (int i = length - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">            int maxj = i;</span><br><span class="line">            for (int j = i; j &lt; length; j++) &#123;</span><br><span class="line">                if (i == j) &#123;</span><br><span class="line">                    // 3.代表的含义应该是：是否回文</span><br><span class="line">                    nums[i][j] = 1;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    if (j == i + 1) &#123;</span><br><span class="line">                        nums[i][j] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 4.上面是初始条件，下面是传递条件</span><br><span class="line">                        nums[i][j] = nums[i + 1][j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxj = nums[i][j] == 1 &amp;&amp; j &gt; maxj ? j: maxj;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    nums[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (maxj - i + 1 &gt; max) &#123;</span><br><span class="line">                max = maxj - i + 1;</span><br><span class="line">                res = s.substring(i, maxj + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Z字形变换"><a href="#Z字形变换" class="headerlink" title="Z字形变换"></a>Z字形变换</h2><p>题目：将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>思路：根据行数可以得出多少个循环一次半Z，然后第一行就是除以几余几的，看有咩用方法可以获取一个字符串中位置是/n余i的字符组成的字符串。String的split方法尽管可以按照正则表达式来分割，但是貌似无法实现隔位分割。<br>所以只能是新建一个<code>List&lt;StringBuilder&gt;</code>，然后遍历字符串来append进去。比取余更好的做法是用一个index标注，往下是+1，遇到拐角就-1.</p>
<p>遍历字符串中的字符：<code>char c : s.toCharArray()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package leeco.string;</span><br><span class="line"></span><br><span class="line">import com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-12 12:08</span><br><span class="line"> **/</span><br><span class="line">public class ZTransform &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;PAYPALISHIRING&quot;;</span><br><span class="line">        Solution so = new Solution();</span><br><span class="line">        String res = so.convert(s, 3);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public String convert(String s, int numRows) &#123;</span><br><span class="line">            if (numRows &lt; 2) return s;</span><br><span class="line">            List&lt;StringBuilder&gt; rows = Lists.newArrayList();</span><br><span class="line">            //List&lt;StringBuilder&gt; rows = new ArrayList&lt;StringBuilder&gt;();</span><br><span class="line">            //需要写入numRows个StringBuilder到List</span><br><span class="line">            for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                rows.add(sb);</span><br><span class="line">            &#125;</span><br><span class="line">            int index = 0;</span><br><span class="line">            int step = -1;</span><br><span class="line">            for (char c : s.toCharArray()) &#123;</span><br><span class="line">                rows.get(index).append(c);</span><br><span class="line">                //遇到拐点，方向就反</span><br><span class="line">                if (index == 0 || index == numRows - 1) &#123;</span><br><span class="line">                    step = -step;</span><br><span class="line">                &#125;</span><br><span class="line">                index += step;</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder res = new StringBuilder();</span><br><span class="line">            for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class="line">                res.append(rows.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            return res.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String convert(String s, int numRows) &#123;</span><br><span class="line">        //很简单，规律性的东西，两个方向：往上走和往下走</span><br><span class="line">        if (numRows == 1) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;StringBuilder&gt; sbList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i&lt; numRows; i++) &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            sbList.add(sb);</span><br><span class="line">        &#125;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i ++) &#123;</span><br><span class="line">            sbList.get(index).append(s.charAt(i));</span><br><span class="line">            if (i % (2 * numRows - 2) &lt; numRows - 1) &#123;</span><br><span class="line">                index ++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                index --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i&lt;numRows; i++) &#123;</span><br><span class="line">            sbList.get(0).append(sbList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return sbList.get(0).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h2><p>题目：给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。-123 变 -321<br>Integer整数区间：[−2^31,  2^31 − 1]<br>思路1：变成一个字符串，然后反转，然后加符号。<br>思路2：对int一步一步/10，然后拿到结果一步一步*10<br>思路3：用栈stack，也得先变字符串，本质上也是字符串反转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-12 22:38</span><br><span class="line"> **/</span><br><span class="line">public class IntegerReverse &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Integer.MAX_VALUE);</span><br><span class="line">        System.out.println(Math.pow(2, 31) - 1);</span><br><span class="line">        int i = -33;</span><br><span class="line">        System.out.println(~(i-1));  //和-i一样</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        System.out.println(s.reverse(-123));</span><br><span class="line">        System.out.println(s.reverse2(-123));</span><br><span class="line">        System.out.println(s.reverse2(-123));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int reverse(int x) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                if (x &lt; 0) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x = -x;</span><br><span class="line">                &#125;</span><br><span class="line">                String old = String.valueOf(x);</span><br><span class="line">                String newS = new StringBuilder(old).reverse().toString();</span><br><span class="line">                int res = Integer.parseInt(newS);</span><br><span class="line">                if (flag) res = -res;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int reverse2(int x) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                if (x &lt; 0) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x = -x;</span><br><span class="line">                &#125;</span><br><span class="line">                int res = 0;</span><br><span class="line">                while (x &gt; 0) &#123;</span><br><span class="line">                    res = res * 10 x % 10;</span><br><span class="line">                    x = x / 10;</span><br><span class="line">                &#125;</span><br><span class="line">                if (flag) res = - res;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int reverse3(int x) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                if (x &lt; 0) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x = -x;</span><br><span class="line">                &#125;</span><br><span class="line">                String old = String.valueOf(x);</span><br><span class="line">                Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">                for (char c : old.toCharArray()) stack.push(c);</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                while (!stack.empty()) sb.append(stack.pop());</span><br><span class="line">                int res = Integer.parseInt(sb.toString());</span><br><span class="line">                if (flag) res = -res;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int reverse(int x) &#123;</span><br><span class="line">        // 用String进行反转，java的幂运算用Math.pow(2,2)</span><br><span class="line">        boolean isFu = false;</span><br><span class="line">        if(x &lt; 0) &#123;</span><br><span class="line">            isFu = true;</span><br><span class="line">            // 如果是-2^31，负的接不住。</span><br><span class="line">            if (x == Integer.MIN_VALUE) return 0;</span><br><span class="line">            x = -x;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = new StringBuilder(String.valueOf(x)).reverse().toString();</span><br><span class="line">        long l = Long.valueOf(s);</span><br><span class="line">        // 原来正的，反过来正的，不能大于2^ 31-1</span><br><span class="line">        if ((isFu &amp;&amp; l &gt; Math.pow(2, 31)) || !isFu &amp;&amp; l &gt; Math.pow(2, 31)-1)</span><br><span class="line">            return 0;</span><br><span class="line">        return isFu? -Integer.valueOf(String.valueOf(l)) : Integer.valueOf(String.valueOf(l));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ErFen &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;输入有序数组，逗号分隔：&quot;);</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        str = str.replace(&quot; &quot;, &quot;&quot;);</span><br><span class="line">        String[] strArray = str.split(&quot;,&quot;);</span><br><span class="line">        int[] array = new int[strArray.length];</span><br><span class="line">        for(int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = Integer.parseInt(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;输入目标值：&quot;);</span><br><span class="line">        int target = sc.nextInt();</span><br><span class="line">        System.out.println(&quot;array:&quot; Arrays.toString(array));</span><br><span class="line">        int min = 0;</span><br><span class="line">        int max = array.length - 1;</span><br><span class="line">        int middle = min (max - min) / 2; //防止越界</span><br><span class="line">        while(min &lt;= max) &#123;</span><br><span class="line">            if (array[middle] == target) &#123;</span><br><span class="line">                System.out.println(middle);</span><br><span class="line">                return;</span><br><span class="line">            &#125; else if (array[middle] &lt; target) &#123;</span><br><span class="line">                min = middle 1;</span><br><span class="line">                middle = min (max - min) / 2;</span><br><span class="line">            &#125; else if (array[middle] &gt; target) &#123;</span><br><span class="line">                max = middle - 1;</span><br><span class="line">                middle = min (max - min) / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="字符串转换为整数"><a href="#字符串转换为整数" class="headerlink" title="字符串转换为整数"></a>字符串转换为整数</h2><p>“   -42” 变为-42.<br>“4193 with words” 变为4193。<br>遇到非数字的字符串就停止，如果超过int表示范围了就返回正负的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int myAtoi(String s) &#123;</span><br><span class="line">        // 去掉头尾空白符，中间的不去</span><br><span class="line">        char[] c = s.trim().toCharArray();</span><br><span class="line">        if (c.length == 0) return 0;</span><br><span class="line">        int res = 0, bndry = Integer.MAX_VALUE / 10; //最大是2147483647</span><br><span class="line">        int i = 1, sign = 1;</span><br><span class="line">        if (c[0] == &#x27;-&#x27;) sign = -1;</span><br><span class="line">        else if (c[0] != &#x27;+&#x27;) i = 0; //从0开始</span><br><span class="line">        for (int j = i; j &lt; c.length; j++) &#123;</span><br><span class="line">            if (c[j] &lt; &#x27;0&#x27; || c[j] &gt; &#x27;9&#x27;) break;</span><br><span class="line">            if (res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; &#x27;7&#x27;) &#123;</span><br><span class="line">                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * 10 (c[j] - &#x27;0&#x27;); //字符变数字</span><br><span class="line">        &#125;</span><br><span class="line">        return sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="到最近的人的最大距离"><a href="#到最近的人的最大距离" class="headerlink" title="到最近的人的最大距离"></a>到最近的人的最大距离</h2><p>给你一个数组 seats 表示一排座位，其中 seats[i] = 1 代表有人坐在第 i 个座位上，seats[i] = 0 代表座位 i 上是空的（下标从 0 开始）。</p>
<p>找一个距离两边人最近的一个位置，找坑位。返回他到离他最近的人的最大距离。</p>
<p>双指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistToClosest(int[] seats) &#123;</span><br><span class="line">        //双指针：左右指针为相邻的有人座位，则最大距离是r-l/2</span><br><span class="line">        //但是要考虑两边没座位的情况</span><br><span class="line">        int res = 0;</span><br><span class="line">        int l = 0;</span><br><span class="line">        while(seats[l] == 0) &#123;</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, l);</span><br><span class="line">        while(l &lt; seats.length - 1) &#123;</span><br><span class="line">            int r = l 1;</span><br><span class="line">            while(r &lt; seats.length &amp;&amp; seats[r] == 0) &#123;</span><br><span class="line">                r ++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (r == seats.length) &#123;</span><br><span class="line">                res = Math.max(res, r - l - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res = Math.max(res, (r - l)/2);</span><br><span class="line">            &#125;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><p>1.变成String之后反转比较是否跟之前的数相等，但是要注意Integer溢出。<br>2.变成String之后，双指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPalindrome(int x) &#123;</span><br><span class="line">        if (x &lt; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        long y = Long.valueOf(new StringBuilder(new Long(x).toString()).reverse().toString());</span><br><span class="line">        return x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        // 双指针：一个最前一个最后，谁小就移动谁</span><br><span class="line">        int l = 0, r = height.length-1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        while(l &lt; r) &#123;</span><br><span class="line">            // 选择小的移动</span><br><span class="line">            if (height[l] &lt; height[r]) &#123;</span><br><span class="line">                max = Math.max(max, (r - l) * height[l]);</span><br><span class="line">                l ++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                max = Math.max(max, (r - l) * height[r]);</span><br><span class="line">                r --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>1.5.10.50…有特定的符号，但是4.9.40.90…也比较特殊，所以把它们也作为特定的符号。从大到小遍历。不会出现80变为两个40的情况，因为之前一定会先拆出一个50.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int[] values = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">    String[] symbols = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    public String intToRoman(int num) &#123;</span><br><span class="line">        StringBuffer roman = new StringBuffer();</span><br><span class="line">        for (int i = 0; i &lt; values.length; ++i) &#123;</span><br><span class="line">            int value = values[i];</span><br><span class="line">            String symbol = symbols[i];</span><br><span class="line">            while (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman.append(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            if (num == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p>给两个递增的数组，其中nums1后面的nums2的长度是有的，填充的0.将nums2填充到nums1中，并且是排好序的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        //用双指针进行替换，如果是第二个队列的元素大，就替换</span><br><span class="line">        //替换出来的第一个队列的元素放在哪，放哪都不行，所以从后往前移动</span><br><span class="line">        // 方法一：先合并，直接Arrays.sort(nums1)</span><br><span class="line">        // 方法二：开一个新数组，从前往后双指针</span><br><span class="line">        // 方法三：不用重开，直接从后往前双指针</span><br><span class="line">        int tail = m n - 1;</span><br><span class="line">        int p1 = m - 1;</span><br><span class="line">        int p2 = n - 1;</span><br><span class="line">        while(p1 &gt;= 0 || p2 &gt;= 0) &#123;</span><br><span class="line">            if (p1 &lt; 0) &#123;</span><br><span class="line">                nums1[tail] = nums2[p2--];</span><br><span class="line">            &#125; else if (p2 &lt; 0) &#123;</span><br><span class="line">                nums1[tail] = nums1[p1--];</span><br><span class="line">            &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                nums1[tail] = nums1[p1--];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums1[tail] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不能使用额外的空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        //双指针，一前一后，前面的不是val，就往后走，如果是就替换，并前后都移动，其实不用替换</span><br><span class="line">        int l = 0;</span><br><span class="line">        int r = nums.length - 1;</span><br><span class="line">        while(l &lt;= r) &#123;</span><br><span class="line">            if (l == r) &#123;</span><br><span class="line">                if (nums[l] != val) l ++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[l] == val &amp;&amp; nums[r] != val) &#123;</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">                l ++;</span><br><span class="line">                r --;</span><br><span class="line">            &#125; else if (nums[l] == val &amp;&amp; nums[r] == val) &#123;</span><br><span class="line">                r --;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                l ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h2><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。nums 的其余元素与 nums 的大小不重要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        //双指针，移除重复的元素其实就是把不重复的元素移到最前面</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = 1;</span><br><span class="line">        while(j &lt; nums.length) &#123;</span><br><span class="line">            if (nums[i] == nums[j]) &#123;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除有序数组中的重复项-II"><a href="#删除有序数组中的重复项-II" class="headerlink" title="删除有序数组中的重复项 II"></a>删除有序数组中的重复项 II</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p>
<p>和上面的相比，多了保留两个重复的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        // 同样是相当于将元素向前移动，无非是加个标识位表示第一个</span><br><span class="line">        int i = 0, j = 1;</span><br><span class="line">        boolean isFirst = true;</span><br><span class="line">        while (j &lt; nums.length) &#123;</span><br><span class="line">            if (nums[i] == nums[j]) &#123;</span><br><span class="line">                if (isFirst) &#123;</span><br><span class="line">                    i ++;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    isFirst = false;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                j ++;</span><br><span class="line">                isFirst = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h2><p>摩尔投票法：<br>候选人(cand_num)初始化为 nums[0]，票数 count 初始化为 1。<br>当遇到与 cand_num 相同的数，则票数 count = count 1，否则票数 count = count - 1。当票数 count 为 0 时，更换候选人，并将票数 count 重置为 1。遍历完数组后，cand_num 即为最终答案。</p>
<p>投票法是遇到相同的则 票数 1，遇到不同的则 票数 - 1。<br>且“多数元素”的个数 &gt; ⌊ n/2 ⌋，其余元素的个数总和 &lt;= ⌊ n/2 ⌋。<br>因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 &gt;= 1。<br>这就相当于每个 “多数元素” 和其他元素 两两相互抵消，抵消到最后肯定还剩余 至少1个 “多数元素”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int majorityElement(int[] nums) &#123;</span><br><span class="line">        // 排序之后的nums.length/2元素一定是多数元素</span><br><span class="line">        // 摩尔投票法：先选一个，往后遍历，如果不一样就减一，直到0就换</span><br><span class="line">        int res = nums[0];</span><br><span class="line">        int score = 1;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            if (num == res) score ++;</span><br><span class="line">            else if (--score == 0) &#123;</span><br><span class="line">                res = num;</span><br><span class="line">                score = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h2><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。<br>使用空间复杂度为 O(1) 的 原地 算法解决这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[] nums, int k) &#123;</span><br><span class="line">        // 使用额外的数组很简单，问题是怎么用O1的空间</span><br><span class="line">        // 被替换的元素保存在变量temp中，从而避免了额外数组的开销</span><br><span class="line">        // 怎么遍历？跳跃式替换，回到原点时应该从下一个元素开始跳跃</span><br><span class="line">        // 什么时候结束？用一个元素记录遍历了多少次</span><br><span class="line">        if (k == 0 || nums.length &lt; 2) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = 0;</span><br><span class="line">        int index = 0;</span><br><span class="line">        int temp = nums[index];</span><br><span class="line">        int pre;</span><br><span class="line">        int start = 0;</span><br><span class="line">        while (count &lt; nums.length) &#123;</span><br><span class="line">            index = (index k) % nums.length;</span><br><span class="line">            pre = nums[index];</span><br><span class="line">            nums[index] = temp;</span><br><span class="line">            temp = pre;</span><br><span class="line">            count ++;</span><br><span class="line">            if (count &lt; nums.length &amp;&amp; index == start) &#123;</span><br><span class="line">                index = start 1;</span><br><span class="line">                start = index;</span><br><span class="line">                temp = nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        // 一次遍历便可得到，每次遍历得到之前最小的数，以及目前为止最大利润</span><br><span class="line">        int cost = Integer.MAX_VALUE, profile = 0;</span><br><span class="line">        for (int price : prices) &#123;</span><br><span class="line">            profile = Math.max(price - cost, profile);</span><br><span class="line">            cost = Math.min(cost, price);</span><br><span class="line">        &#125;</span><br><span class="line">        return profile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用动态规划：</p>
<p>状态定义：dp[i][j]：下标为 i 这一天结束的时候，手上持股状态为 j 时，我们持有的现金数。换种说法：dp[i][j] 表示天数 [0, i] 区间里，下标 i 这一天状态为 j 的时候能够获得的最大利润。</p>
<p>推导状态转移方程：<br>dp[i][0]：规定了今天不持股，有以下两种情况：<br>昨天不持股，今天什么都不做；<br>昨天持股，今天卖出股票（现金数增加）</p>
<p>dp[i][1]：规定了今天持股，有以下两种情况：<br>昨天持股，今天什么都不做（现金数与昨天一样）；<br>昨天不持股，今天买入股票（注意：只允许交易一次，因此手上的现金数就是当天的股价的相反数）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        // 特殊判断</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] dp = new int[len][2];</span><br><span class="line"></span><br><span class="line">        // dp[i][0] 下标为 i 这天结束的时候，不持股，手上拥有的现金数</span><br><span class="line">        // dp[i][1] 下标为 i 这天结束的时候，持股，手上拥有的现金数</span><br><span class="line"></span><br><span class="line">        // 初始化：不持股显然为 0，持股就需要减去第 1 天（下标为 0）的股价</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line">        dp[0][1] = -prices[0];</span><br><span class="line"></span><br><span class="line">        // 从第 2 天开始遍历</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] prices[i]);</span><br><span class="line">            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len - 1][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机2"><a href="#买卖股票的最佳时机2" class="headerlink" title="买卖股票的最佳时机2"></a>买卖股票的最佳时机2</h2><p>与第一题只能进行一次交易不同，这里可以进行多次交易。</p>
<p>方法一：在每一天都有操作/不操作（买入还是卖出）的选择。所以用树形结构进行回溯搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private int res;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        this.res = 0;</span><br><span class="line">        dfs(prices, 0, len, 0, res);</span><br><span class="line">        return this.res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param prices 股价数组</span><br><span class="line">     * @param index  当前是第几天，从 0 开始</span><br><span class="line">     * @param status 0 表示不持有股票，1表示持有股票，</span><br><span class="line">     * @param profit 当前收益</span><br><span class="line">     */</span><br><span class="line">    private void dfs(int[] prices, int index, int len, int status, int profit) &#123;</span><br><span class="line"></span><br><span class="line">        if (index == len) &#123;</span><br><span class="line">            this.res = Math.max(this.res, profit);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(prices, index 1, len, status, profit);</span><br><span class="line"></span><br><span class="line">        if (status == 0) &#123;</span><br><span class="line">            // 可以尝试转向 1</span><br><span class="line">            dfs(prices, index 1, len, 1, profit - prices[index]);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 此时 status == 1，可以尝试转向 0</span><br><span class="line">            dfs(prices, index 1, len, 0, profit prices[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：动态规划，与上一题在状态转移的时候会有所不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        // 特殊判断</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] dp = new int[len][2];</span><br><span class="line"></span><br><span class="line">        // dp[i][0] 下标为 i 这天结束的时候，不持股，手上拥有的现金数</span><br><span class="line">        // dp[i][1] 下标为 i 这天结束的时候，持股，手上拥有的现金数</span><br><span class="line"></span><br><span class="line">        // 初始化：不持股显然为 0，持股就需要减去第 1 天（下标为 0）的股价</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line">        dp[0][1] = -prices[0];</span><br><span class="line"></span><br><span class="line">        // 从第 2 天开始遍历</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] prices[i]);</span><br><span class="line">            // 这里持股，并不是这天持股的收益，与只买卖一次就这里的差别</span><br><span class="line">            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len - 1][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于当前行只参考上一行，每一行就 2 个值，因此可以考虑使用「滚动变量」</p>
<p>方法三：贪心算法</p>
<p>求解最优化问题的算法通常需要经过一系列的步骤，在每个步骤都面临生种选择。对于许多最优化问题，使用动态规划算法来求最优解有些杀鸡用牛力了，可以使用更简单、更高效的算法。贪心算法(greedy algorithm)就是这样的算法，它在每一步都做出当时看起来最佳的选择。也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。</p>
<p>贪心算法和动态规划相比，它既不看前面（也就是说它不需要从前面的状态转移过来），也不看后面（无后效性，后面的选择不会对前面的选择有影响），因此贪心算法时间复杂度一般是线性的，空间复杂度是常数级别的。</p>
<p>这道题 「贪心」 的地方在于，对于 「今天的股价 - 昨天的股价」，得到的结果有 3 种可能：① 正数，② 0，③负数。贪心算法的决策是： 只加正数 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            res += Math.max(prices[i] - prices[i - 1], 0);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机3"><a href="#买卖股票的最佳时机3" class="headerlink" title="买卖股票的最佳时机3"></a>买卖股票的最佳时机3</h2><p>与上面不同，这里只允许最多完成两笔交易，并且必须在再次购买前出售掉之前的股票。</p>
<p>结合上面两道题，第一题是交易一次就不交易，第二题是还可以交易。这里设定三维数组，增加一维表示交易次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        if (len &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第 2 维的 0 没有意义，1 表示交易进行了 1 次，2 表示交易进行了 2 次</span><br><span class="line">        // 为了使得第 2 维的数值 1 和 2 有意义，这里将第 2 维的长度设置为 3</span><br><span class="line">        int[][][] dp = new int[len][3][2];</span><br><span class="line"></span><br><span class="line">        // 理解如下初始化</span><br><span class="line">        // 第 3 维规定了必须持股，因此是 -prices[0]</span><br><span class="line">        dp[0][1][1] = -prices[0];</span><br><span class="line">        // 还没发生的交易，持股的时候应该初始化为负无穷</span><br><span class="line">        dp[0][2][1] = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            // 转移顺序先持股，再卖出</span><br><span class="line">            dp[i][1][1] = Math.max(dp[i - 1][1][1], -prices[i]) ;</span><br><span class="line">            dp[i][1][0] = Math.max(dp[i - 1][1][0], dp[i - 1][1][1] prices[i]);</span><br><span class="line">            dp[i][2][1] = Math.max(dp[i - 1][2][1], dp[i - 1][1][0] - prices[i]);</span><br><span class="line">            dp[i][2][0] = Math.max(dp[i - 1][2][0], dp[i - 1][2][1] prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[len - 1][1][0], dp[len - 1][2][0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机4"><a href="#买卖股票的最佳时机4" class="headerlink" title="买卖股票的最佳时机4"></a>买卖股票的最佳时机4</h2><p>最多可以完成 k 笔交易。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">         int len = prices.length;</span><br><span class="line">        if (k &gt;= len / 2) &#123;</span><br><span class="line">            int res = 0;</span><br><span class="line">            for (int i = 1; i &lt; len; i ++) &#123;</span><br><span class="line">                res += Math.max(0, prices[i] - prices[i - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dpHold = new int[k 1];</span><br><span class="line">        int[] dpNoHold = new int[k 1];</span><br><span class="line">        for (int i = 0; i &lt;= k; i++) &#123;</span><br><span class="line">            dpHold[i] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int price : prices) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= k; j++) &#123;</span><br><span class="line">                // 持有 = max(前一天持有，前一天不持有今天持有)</span><br><span class="line">                // 持有表示交易次数+1，需要考虑交易次数-1的情况</span><br><span class="line">                dpHold[j] = Math.max(dpHold[j], dpNoHold[j - 1] - price);</span><br><span class="line">                // 不持有 = max(前一天不持有， 今天卖掉)</span><br><span class="line">                // 不持有，卖掉，交易次数还是原来的</span><br><span class="line">                dpNoHold[j] = Math.max(dpNoHold[j], dpHold[j] price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dpNoHold[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="买卖股票含冷冻期"><a href="#买卖股票含冷冻期" class="headerlink" title="买卖股票含冷冻期"></a>买卖股票含冷冻期</h2><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        // 一维表示天，二维表示 不持有、持有、冷冻</span><br><span class="line">        int[][] dp = new int[len 1][3];</span><br><span class="line">        for (int i = 0; i &lt;= len; i++) &#123;</span><br><span class="line">            dp[i][1] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= len; i++) &#123;</span><br><span class="line">            // 不持有：前一天不持有/前一天持有今天卖掉</span><br><span class="line">            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] prices[i-1]);</span><br><span class="line">            // 持有：前一天持有/前一天冷冻今天持有</span><br><span class="line">            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][2] - prices[i-1]);</span><br><span class="line">            // 冷冻：前一天不持有/前一天冷冻</span><br><span class="line">            dp[i][2] = Math.max(dp[i-1][2], dp[i-1][0]);</span><br><span class="line">            System.out.println(dp[i][0] &quot;==&quot; dp[i][1] &quot;==&quot; dp[i][2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[len][0], dp[len][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票含手续费"><a href="#买卖股票含手续费" class="headerlink" title="买卖股票含手续费"></a>买卖股票含手续费</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices, int fee) &#123;</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        int[][] dp = new int[len+1][2];</span><br><span class="line">        for (int i = 0; i&lt;=len; i++) &#123;</span><br><span class="line">            dp[i][1] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= len; i++) &#123;</span><br><span class="line">            // 不持有</span><br><span class="line">            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] prices[i-1]);</span><br><span class="line">            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i-1] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p>
<p>解法：从前往后遍历，在当前点时，可以知道当前点最远可以到达哪里，在遍历下一个的时候，对比能不能达到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canJump(int[] nums) &#123;</span><br><span class="line">        int reach = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (i &gt; reach) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            reach = Math.max(reach, i nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏2"><a href="#跳跃游戏2" class="headerlink" title="跳跃游戏2"></a>跳跃游戏2</h2><p>给一个数组，表示在该位置上的最大跳跃长度。现在要给出最少跳跃步数。</p>
<p>标签：贪心、动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 方法1：动态规划，正向遍历到达每一个位置需要的最少步数，时间复杂度On2</span><br><span class="line">    public static int jump(int[] nums) &#123;</span><br><span class="line">        int[] res = new int[nums.length];</span><br><span class="line">        for (int i = 1; i&lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt;= i nums[i] &amp;&amp; j &lt; nums.length; j++) &#123;</span><br><span class="line">                res[j] = Math.min(res[i] + 1, res[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[res.length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 方法2：贪心，反向查找出发位置，具体哪个位置跳最好需要从前往后遍历</span><br><span class="line">    // ps：因为不是固定步数跳，所以可行</span><br><span class="line">    public static int jump(int[] nums) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int pos = len - 1;</span><br><span class="line">        int step = 0;</span><br><span class="line">        while (pos &gt; 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                if (i nums[i] &gt;= pos) &#123;</span><br><span class="line">                    step += 1;</span><br><span class="line">                    pos = i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 方法3：贪心地正向查找，每次可到达的最远位置</span><br><span class="line">    public static int jump(int[] nums) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int end = 0; //边界</span><br><span class="line">        int maxPos = 0; //能到达的最远位置</span><br><span class="line">        int step = 0;</span><br><span class="line">        // 注意：遍历到最后元素的前一个就好</span><br><span class="line">        for (int i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            maxPos = Math.max(maxPos, nums[i] i);</span><br><span class="line">            // 到达边界了就需要走一步了，并且更新边界</span><br><span class="line">            if (i == end) &#123;</span><br><span class="line">                end = maxPos;</span><br><span class="line">                step ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="跳跃游戏3"><a href="#跳跃游戏3" class="headerlink" title="跳跃游戏3"></a>跳跃游戏3</h2><p>这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i arr[i] 或者 i - arr[i]。判断自己是否能够跳到对应元素值为 0 的 任一 下标处。</p>
<p>标签：深度优先搜索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 跳跃游戏3：可以左右跳跃，只能跳跃固定值，从给定开始位置，能不能跳到元素值为0的地方</span><br><span class="line">    // 深度优先搜索：DFS，可以用递归实现，也可以用栈实现</span><br><span class="line">    // 比如二叉树，向下遍历直到叶子节点，然后向上回溯，再向下遍历。用栈就是出栈和入栈。</span><br><span class="line">    public static boolean canReach(int[] nums, int start) &#123;</span><br><span class="line">        // 用一个数组表示是否访问过</span><br><span class="line">        boolean[] visit = new boolean[nums.length];</span><br><span class="line">        return dfs(nums, start, visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean dfs(int[] nums, int start, boolean[] visit) &#123;</span><br><span class="line">        if (start &lt; 0 || start &gt;= nums.length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果之前访问过，一定到不了</span><br><span class="line">        if (visit[start]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 出递归条件</span><br><span class="line">        if (nums[start] == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[start] = true;</span><br><span class="line">        return dfs(nums, start - nums[start], visit) || dfs(nums, start nums[start], visit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>这个题目要求打印出来。</p>
<p>标签：深度优先搜索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = new ArrayList();</span><br><span class="line">        int[] place = new int[n];</span><br><span class="line">        List&lt;int[]&gt; resList = new ArrayList();</span><br><span class="line">        int resNum = queueDfs(0, place, n, res);</span><br><span class="line">        for (int[] resPlace : resList) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(resPlace));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; print(int[] place) &#123;</span><br><span class="line">        List&lt;String&gt; ss = new ArrayList();</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int j = 0; j &lt; place.length; j++) &#123;</span><br><span class="line">            sb.append(&#x27;.&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int column : place) &#123;</span><br><span class="line">            // 这里也得新建一个</span><br><span class="line">            StringBuilder pre = new StringBuilder(sb);</span><br><span class="line">            pre.setCharAt(column, &#x27;Q&#x27;);</span><br><span class="line">            ss.add(pre.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // row代表第row行皇后的放置</span><br><span class="line">    private int queueDfs(int row, int[] place, int n, List&lt;List&lt;String&gt;&gt; resList) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if (row == n) &#123;</span><br><span class="line">            // 注意这里加入的是数组的引用，之后会变</span><br><span class="line">            resList.add(print(place));</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第row行可以放到第0到n-1列</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            if (isValid(row, place, i)) &#123;</span><br><span class="line">                place[row] = i;</span><br><span class="line">                res += queueDfs(row 1, place, n, resList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查第row行皇后放在column列有没有问题</span><br><span class="line">    private static boolean isValid(int row, int[] place, int column) &#123;</span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            if (place[i] == column || row - i == Math.abs(column - place[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(row &quot;:&quot; column &quot;:&quot; Arrays.toString(place));</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还有一种构建”…Q”字符串的方法，更优雅，用char数组创建String：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char[] row = new char[n];</span><br><span class="line">Arrays.fill(row, &#x27;.&#x27;);</span><br><span class="line">row[queens[i]] = &#x27;Q&#x27;;</span><br><span class="line">board.add(new String(row));</span><br></pre></td></tr></table></figure>

<h2 id="N皇后2"><a href="#N皇后2" class="headerlink" title="N皇后2"></a>N皇后2</h2><p>这个N皇后之需要给出有几种解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public static int totalNQueens(int n) &#123;</span><br><span class="line">        // 皇后问题，在于DFS，表现形式：int[] 表示每列上皇后的位置</span><br><span class="line">        int[] place = new int[n];</span><br><span class="line">        return queueDfs(0, place, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // column代表第row列的放置</span><br><span class="line">    private static int queueDfs(int column, int[] place, int n) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if (column == n) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第row列可以放到第0到n-1行</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            if (isValid(column, place, i)) &#123;</span><br><span class="line">                place[column] = i;</span><br><span class="line">                res += queueDfs(column 1, place, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查第column列皇后放在row行有没有问题</span><br><span class="line">    private static boolean isValid(int column, int[] place, int row) &#123;</span><br><span class="line">        for (int i = 0; i &lt; column; i++) &#123;</span><br><span class="line">            if (place[i] == row || column - i == Math.abs(row - place[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
<p>标签：DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class BracketAlgo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(generateBracket(3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 给出一个n，返回可能的括号组合</span><br><span class="line">    public static List&lt;String&gt; generateBracket(int n) &#123;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList();</span><br><span class="line">        String s = &quot;&quot;;</span><br><span class="line">        dfs(n, n, s, res);</span><br><span class="line">        return  res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 入参：剩余左括号数、剩余右括号数、当前String、结果</span><br><span class="line">    private static void dfs(int left, int right, String curStr, List&lt;String&gt; res) &#123;</span><br><span class="line">        // 出递归条件</span><br><span class="line">        if (left == 0 &amp;&amp; right == 0) &#123;</span><br><span class="line">            res.add(curStr);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 左括号还有就可以继续放左括号，剩余右括号大于剩余左括号，就可以放右括号</span><br><span class="line">        // 这里没有感觉有回溯呢，就感觉不需要回溯</span><br><span class="line">        if (left &gt; 0) &#123;</span><br><span class="line">            dfs(left - 1, right, curStr &quot;(&quot;, res);</span><br><span class="line">        &#125;</span><br><span class="line">        if (right &gt; left) &#123;</span><br><span class="line">            dfs(left, right - 1, curStr &quot;)&quot;, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
<p>标签：DFS、并查集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan.lee;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class IslandAlgo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char[][] lands = new char[][]&#123;&#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;&#125;;</span><br><span class="line">        System.out.println(islandNum(lands));</span><br><span class="line">        lands = new char[][]&#123;&#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;&#125;;</span><br><span class="line">        System.out.println(islandNum2(lands));</span><br><span class="line">        lands = new char[][]&#123;&#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;&#125;;</span><br><span class="line">        System.out.println(islandNum3(lands));</span><br><span class="line">        lands = new char[][]&#123;&#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&#125;&#125;;</span><br><span class="line">        System.out.println(maxIsland(lands));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1表示陆地，0表示水，四周也是水，斜线相接的不是一座岛屿，返回总共有几个岛屿</span><br><span class="line">    // 方法一：DFS解法：</span><br><span class="line">    //遍历整个二维网格，当遇到一个岛屿（值为1）时，计数器加1，然后调用DFS函数，将相邻的岛屿都标记为已遍历（可以将其值置为0）。</span><br><span class="line">    //在DFS函数中，首先判断当前位置是否越界或者已经遍历过，如果是，直接返回。</span><br><span class="line">    //如果当前位置是岛屿，则将其值置为0，并递归调用DFS函数，分别向上、向下、向左、向右四个方向进行搜索。</span><br><span class="line">    //最后，返回计数器的值即为岛屿的数量。</span><br><span class="line">    public static int islandNum(char[][] lands) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; lands.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; lands[0].length; j++) &#123;</span><br><span class="line">                // 有一块陆地就表示一定是一个岛屿，只需要把周围的都变成水</span><br><span class="line">                // 递归的目的是将周围的陆地变为水，并且是在遍历下一块儿地之前</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    dfs(i, j, lands);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void dfs(int i, int j, char[][] lands) &#123;</span><br><span class="line">        // 越界则出递归</span><br><span class="line">        if (i &lt; 0 || i &gt;= lands.length || j &lt; 0 || j &gt;= lands[0].length) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 是水则出递归</span><br><span class="line">        if (lands[i][j] == &#x27;0&#x27;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 这里将陆地变为水，所以下面即使递归回到该位置也直接return了</span><br><span class="line">        lands[i][j] = &#x27;0&#x27;;</span><br><span class="line">        dfs(i - 1, j, lands);</span><br><span class="line">        dfs(i + 1, j, lands);</span><br><span class="line">        dfs(i, j - 1, lands);</span><br><span class="line">        dfs(i, j + 1, lands);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并查集，有点问题：不一定都是往左上角靠拢的，比如工字型，所以使用完整的并查集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public static int numIslands(char[][] lands) &#123;</span><br><span class="line">        // 1.首先初始化，用一个数组表示每个节点的根结点</span><br><span class="line">        int n = lands.length;</span><br><span class="line">        int m = lands[0].length;</span><br><span class="line">        int[] roots = new int[n * m];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    roots[i * m j] = i * m j;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.合并，往四个方向走，如果也是1的话就合并节点（将当前节点的根结点变为相邻节点的根结点），在合并的过程中就完成计数</span><br><span class="line">        int[][] directs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j ++) &#123;</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    for (int[] direct : directs) &#123;</span><br><span class="line">                        // 如果相邻也是1，且根结点不相同则进行合并：将相邻节点的根节点变为当前节点的根结点，这样向下向右遍历的时候，就不会再变原来的根结点了</span><br><span class="line">                        // 正常合并需要考虑节点深度，如果两个集合的深度不同，为了保持并查集的平衡性，应该将深度较小的集合合并到深度较大的集合上</span><br><span class="line">                        // 但是这里由于遍历的有序性，所以先遍历的深度大</span><br><span class="line">                        int newRow = i direct[0];</span><br><span class="line">                        int newColumn = j direct[1];</span><br><span class="line">                        if (newRow &lt; 0 || newRow &gt;= n || newColumn &lt; 0 || newColumn &gt;= m) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 这里还是由于遍历的有序性，找root，根结点一定是左上角的1</span><br><span class="line">                        if (lands[newRow][newColumn] == &#x27;1&#x27; &amp;&amp; roots[i * m j] != roots[newRow * m newColumn]) &#123;</span><br><span class="line">                            roots[newRow * m newColumn] = roots[i * m j];</span><br><span class="line">                            res --;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 并查集-规范完整版</span><br><span class="line">    public static int numIslands(char[][] lands) &#123;</span><br><span class="line">        // 1.首先初始化，用一个数组表示每个节点的根结点</span><br><span class="line">        int n = lands.length;</span><br><span class="line">        int m = lands[0].length;</span><br><span class="line">        // 记录节点的父节点</span><br><span class="line">        int[] parents = new int[n * m];</span><br><span class="line">        // 记录节点深度</span><br><span class="line">        int[] ranks = new int[n * m];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    parents[i * m j] = i * m j;</span><br><span class="line">                    ranks[i * m j] = 0;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.合并，往四个方向走，如果也是1的话就合并节点（将当前节点的根结点变为相邻节点的根结点），在合并的过程中就完成计数</span><br><span class="line">        int[][] directs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j ++) &#123;</span><br><span class="line">                if (lands[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    int curRoot = find(parents, i * m j);</span><br><span class="line">                    for (int[] direct : directs) &#123;</span><br><span class="line">                        int newRow = i direct[0];</span><br><span class="line">                        int newColumn = j direct[1];</span><br><span class="line">                        if (newRow &lt; 0 || newRow &gt;= n || newColumn &lt; 0 || newColumn &gt;= m || lands[newRow][newColumn] == &#x27;0&#x27;) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        int newRoot = find(parents, newRow * m newColumn);</span><br><span class="line">                        if (curRoot != newRoot) &#123;</span><br><span class="line">                            System.out.println(&quot;cur:&quot; i &quot;-&quot; j &quot;:&quot; curRoot &quot;===&quot; &quot;new:&quot; newRow &quot;-&quot; newColumn &quot;:&quot; newRoot);</span><br><span class="line">//                            System.out.println(&quot;curRanks:&quot; ranks[i * m j] &quot;===&quot; &quot;newRanks:&quot; ranks[newRow * m newColumn]);</span><br><span class="line">                            // 深度小的往深度大的合并，提高查找根结点的效率</span><br><span class="line">                            // 将rank较小的根节点指向rank较大的根节点，以保持树的平衡。如果两个根节点的rank相同，则可以将其中一个根节点作为另一个根节点的子节点，并将rank增加1。</span><br><span class="line">                            if (ranks[i * m j] &lt; ranks[newRow * m newColumn]) &#123;</span><br><span class="line">                                // 当前节点深度小：将深度较小的根节点合并到深度较大的根节点上</span><br><span class="line">                                parents[curRoot] = newRoot;</span><br><span class="line">                            &#125; else if (ranks[i * m j] &gt; ranks[newRow * m newColumn])&#123;</span><br><span class="line">                                parents[newRoot] = curRoot;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                parents[newRoot] = curRoot;</span><br><span class="line">                                ranks[i * m j] ++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            res --;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int find(int[] parents, int k) &#123;</span><br><span class="line">        // 根结点的父节点是自己</span><br><span class="line">        if (parents[k] == k) &#123;</span><br><span class="line">            return k;</span><br><span class="line">        &#125;</span><br><span class="line">        return find(parents, parents[k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 岛屿的最大面积</span><br><span class="line">    // ps：将area作为参数传递时，int不行、Integer也不行、返回出去需要在连续四个dfs上加上返回再传入下一个</span><br><span class="line">    // 用一个全局变量表示area比较好</span><br><span class="line">    public static int maxAreaOfIsland(int[][] lands) &#123;</span><br><span class="line">        // 和获取数量一样，递归，但是同时记录岛屿最大面积</span><br><span class="line">        int maxArea = 0;</span><br><span class="line">        for (int i = 0; i &lt; lands.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; lands[0].length; j++) &#123;</span><br><span class="line">                if (lands[i][j] == 1) &#123;</span><br><span class="line">                    int area = dfs(lands, i , j, 0);</span><br><span class="line">                    maxArea = Math.max(area, maxArea);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int dfs(int[][] lands, int i, int j, int area) &#123;</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;= lands.length || j &gt;= lands[0].length) &#123;</span><br><span class="line">            return area;</span><br><span class="line">        &#125;</span><br><span class="line">        if (lands[i][j] == 0) &#123;</span><br><span class="line">            return area;</span><br><span class="line">        &#125;</span><br><span class="line">        lands[i][j] = 0;</span><br><span class="line">        area += 1;</span><br><span class="line">        area = dfs(lands, i - 1, j, area);</span><br><span class="line">        area = dfs(lands, i + 1, j, area);</span><br><span class="line">        area = dfs(lands, i, j - 1, area);</span><br><span class="line">        area = dfs(lands, i, j + 1, area);</span><br><span class="line">        return area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h2><p>有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p>
<p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p>输入：nums = [1,5]<br>输出：10</p>
<p>标签：深度优先搜索、动态规划</p>
<p>超出时间限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 戳气球：一组数代表气球的值，戳一个气球收益是左气球*自己*右气球，戳破后左右两个变为相邻的，求最大收益</span><br><span class="line">    // 方法一：深度优先搜索，到最后一个气球时记录收益记录下来，最后对比最大值</span><br><span class="line">    public static int maxCoins(int[] nums) &#123;</span><br><span class="line">        // 注意：List是一个对象类型的集合，需要用Integer</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return dfs(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int dfs(List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (list.size() == 0) return 0;</span><br><span class="line">        // 在哪里取最大值：在这里取，因为这里就是最终的最大值</span><br><span class="line">        int max = 0;</span><br><span class="line">        int left, cur, right;</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            left = i == 0 ? 1 : list.get(i - 1);</span><br><span class="line">            right = i == list.size() - 1 ? 1 : list.get(i + 1);</span><br><span class="line">            cur = list.get(i);</span><br><span class="line">            // 这里会报warning：再循环中修改List，可以使用一个临时List，每次传入临时List</span><br><span class="line">            list.remove(i);</span><br><span class="line">            max = Math.max(left * cur * right dfs(list), max);</span><br><span class="line">            list.add(i, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个不对的DFS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 方法二：另一个深度优先搜索，上一个是先戳破再递归计算剩下的，这里可以先拆开计算左右的再加起来</span><br><span class="line">    // 这样的好处是：List没有被破坏，只需给个边界</span><br><span class="line">    // !!! 这个方法不对，忽略了气球戳破后两边气球就变成相邻气球的事实</span><br><span class="line">    private static int maxProfit2(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return dfs2(list, 0, nums.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int dfs2(List&lt;Integer&gt; list, int left, int right) &#123;</span><br><span class="line">        if (left == right) return 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        int l, r, cur;</span><br><span class="line">        for (int i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            l = i == 0 ? 1 : list.get(i - 1);</span><br><span class="line">            r = i == list.size() - 1 ? 1 : list.get(i + 1);</span><br><span class="line">            cur = list.get(i);</span><br><span class="line">            int profit = l * cur * r dfs2(list, left, i - 1) dfs2(list, i + 1, right);</span><br><span class="line">            max = Math.max(max, profit);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正确的动态规划：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 方法三：动态规划</span><br><span class="line">    // 1.定义数据 2.初始化 3.状态转移</span><br><span class="line">    // 两边各加一个辅助气球，是1，用k表示最后戳破的气球</span><br><span class="line">    // dp[i][j]表示戳破i-j区间内气球获得的收益，两边是包含辅助气球的，辅助气球不戳破</span><br><span class="line">    // 因此：状态转移：dp[i][j] = Math.max(dp[i][j], dp[i][k] dp[k][j] list[k] * list[i] * [j])</span><br><span class="line">    // 注意：k是最后戳破的，所以乘以最两边的辅助气球</span><br><span class="line">    // 辅助气球不戳破，所以这样拆分之后k是辅助气球，为两边算收益用，但本身不被戳破</span><br><span class="line">    // Max的过程是在选最后戳破哪个气球的过程中选择的</span><br><span class="line">    // 因为该状态方程，所以长度短的应该先算好，所以最外层循环为长度</span><br><span class="line">    public static int maxCoins(int[] nums) &#123;</span><br><span class="line">        // 定义数据</span><br><span class="line">        int len =nums.length 2;</span><br><span class="line">        int[][] dp = new int[len][len];</span><br><span class="line">        int[] arr = new int[len];</span><br><span class="line">        arr[0] = 1;</span><br><span class="line">        arr[len - 1] = 1;</span><br><span class="line">        System.arraycopy(nums, 0, arr, 1, len - 2);</span><br><span class="line">        // 初始化，因为在状态转移过程中会取值，所以为0就好</span><br><span class="line">        // 一层循环为长度，最小长度为3，两边是辅助气球</span><br><span class="line">        for (int l = 3; l &lt;= len; l ++) &#123;</span><br><span class="line">            // 二层循环为开始位置</span><br><span class="line">            for (int i = 0; i &lt;= len - l; i ++) &#123;</span><br><span class="line">                // 结束位置</span><br><span class="line">                int j = i l - 1;</span><br><span class="line">                // 最后戳破气球的位置k</span><br><span class="line">                for (int k = i + 1; k &lt; j; k ++) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], arr[i] * arr[k] * arr[j] dp[i][k] dp[k][j]);</span><br><span class="line">                    // 为什么不能正向先戳破k？</span><br><span class="line">                    // 因为戳破之后k就不存在了，所以不能在算两边时加k而是加k左右两边的，是一个k断开的状态</span><br><span class="line">                    // 最后戳破k就可以用k算两边，因为算完两边最后才戳破k</span><br><span class="line">//                    dp[i][j] = Math.max(dp[i][j], arr[k] * arr[k - 1] * arr[k 1] dp[i][k] dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][len - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a>省份数量</h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>
<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<p>标签：并查集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private static int num;</span><br><span class="line">    </span><br><span class="line">    // 省份数量</span><br><span class="line">    // 输入n*n，nums[i][j]表示i和j相连</span><br><span class="line">    // 返回有多少不相连的城市群</span><br><span class="line">    public static int findCircleNum(int[][] nums) &#123;</span><br><span class="line">        // 1.初始化</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int[] parents = new int[len];</span><br><span class="line">        int[] ranks = new int[len];</span><br><span class="line">        num = len;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">            ranks[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.合并</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">                if (nums[i][j] == 0) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                union(parents, ranks, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void union(int[] parents, int[] ranks, int i, int j) &#123;</span><br><span class="line">        int iRoot = find(parents, i);</span><br><span class="line">        int jRoot = find(parents, j);</span><br><span class="line">        if (iRoot == jRoot) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ranks[i] &gt; ranks[j]) &#123;</span><br><span class="line">            parents[jRoot] = iRoot;</span><br><span class="line">        &#125; else if (ranks[i] &lt; ranks[j]) &#123;</span><br><span class="line">            parents[iRoot] = jRoot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parents[iRoot] = jRoot;</span><br><span class="line">            ranks[j] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        num --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int find(int[] parents, int k) &#123;</span><br><span class="line">        if (parents[k] == k) &#123;</span><br><span class="line">            return k;</span><br><span class="line">        &#125;</span><br><span class="line">        return find(parents, parents[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统计无向图中无法互相到达点数量"><a href="#统计无向图中无法互相到达点数量" class="headerlink" title="统计无向图中无法互相到达点数量"></a>统计无向图中无法互相到达点数量</h2><p>给你一个整数 n ，表示一张 无向图 中有 n 个节点，编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。</p>
<p>请你返回 无法互相到达 的不同 点对数目 。</p>
<p>标签：并查集、DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 统计无向图中无法互相到达的点对数</span><br><span class="line">    // 输入：总共多少个点、点与点间无向边</span><br><span class="line">    // 输出：总共多少不连接的点组合</span><br><span class="line">    // 超出时间限制：因为获取结果双层循环，可以简化</span><br><span class="line">    public static long countPairs(int n, int[][] edges) &#123;</span><br><span class="line">        // 1.初始化</span><br><span class="line">        int[] parents = new int[n];</span><br><span class="line">        // 这里不用ranks表示深度，而是用sizes表示以x为根结点所在树的顶点数</span><br><span class="line">        int[] sizes = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">            sizes[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.合并</span><br><span class="line">        for (int[] edge : edges) &#123;</span><br><span class="line">            union(parents, sizes, edge[0], edge[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 3.获取结果</span><br><span class="line">        long res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            res += n - sizes[find(parents, i)];</span><br><span class="line">        &#125;</span><br><span class="line">        // 注意：上面是每个节点与几个节点不相连，算两遍了</span><br><span class="line">        return res / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void union(int[] parents, int[] sizes, int i, int j) &#123;</span><br><span class="line">        int iRoot = find(parents, i);</span><br><span class="line">        int jRoot = find(parents, j);</span><br><span class="line">        if (iRoot == jRoot) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sizes[i] &gt; sizes[j]) &#123;</span><br><span class="line">            // j应该往i合并，j的节点数给到i</span><br><span class="line">            parents[jRoot] = iRoot;</span><br><span class="line">            sizes[iRoot] += sizes[jRoot];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // i应该往j合并，i的节点数给到j</span><br><span class="line">            parents[iRoot] = jRoot;</span><br><span class="line">            sizes[jRoot] += sizes[iRoot];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int find(int[] parents, int k) &#123;</span><br><span class="line">        if (parents[k] == k) &#123;</span><br><span class="line">            return k;</span><br><span class="line">        &#125;</span><br><span class="line">        return find(parents, parents[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DFS:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public static int countPairs(int n, int[][] edges) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            graph.add(new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        // 构建图的邻接表，存储直接连接的节点</span><br><span class="line">        for (int[] edge : edges) &#123;</span><br><span class="line">            graph.get(edge[0]).add(edge[1]);</span><br><span class="line">            graph.get(edge[1]).add(edge[0]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean[] visited = new boolean[n];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (!visited[i]) &#123;</span><br><span class="line">                int count = dfs(graph, i, visited);</span><br><span class="line">                // 结果要不连通的节点对数，对于该簇，count个点相互联通，这样算会算两次</span><br><span class="line">                res += count * (n - count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 通过DFS得到该节点联通的节点数（一个簇的节点数）</span><br><span class="line">    private static int dfs(List&lt;List&lt;Integer&gt;&gt; graph, int node, boolean[] visited) &#123;</span><br><span class="line">        visited[node] = true;</span><br><span class="line">        int count = 1;</span><br><span class="line">        for (int neighbor : graph.get(node)) &#123;</span><br><span class="line">            if (!visited[neighbor]) &#123;</span><br><span class="line">                count += dfs(graph, neighbor, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿的周长"><a href="#岛屿的周长" class="headerlink" title="岛屿的周长"></a>岛屿的周长</h2><p>标签：DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 岛屿的周长：只有一个岛屿，并且岛屿内部没有湖</span><br><span class="line">    // 使用DFS的方法，for循环遍历到第一个陆地，然后开始DFS，将lands元素置为2表示遍历过了</span><br><span class="line">    public static int islandPerimeter(int[][] lands) &#123;</span><br><span class="line">        for (int i = 0; i &lt; lands.length; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; lands[0].length; j ++) &#123;</span><br><span class="line">                if (lands[i][j] == 1) &#123;</span><br><span class="line">                    return lengthDfs(lands, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int lengthDfs(int[][] lands, int i, int j) &#123;</span><br><span class="line">        // 边界或遇到水周长+1</span><br><span class="line">        if (i &lt; 0 || i &gt;= lands.length || j &lt; 0 || j &gt;= lands[0].length || lands[i][j] == 0) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (lands[i][j] == 2) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        lands[i][j] = 2;</span><br><span class="line">        return lengthDfs(lands, i-1, j) lengthDfs(lands, i+1, j) lengthDfs(lands, i, j-1) lengthDfs(lands, i, j+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="衣橱整理-机器人的运动范围"><a href="#衣橱整理-机器人的运动范围" class="headerlink" title="衣橱整理/机器人的运动范围"></a>衣橱整理/机器人的运动范围</h2><p>家居整理师将待整理衣橱划分为 m x n 的二维矩阵 grid，其中 grid[i][j] 代表一个需要整理的格子。整理师自 grid[0][0] 开始 逐行逐列 地整理每个格子。</p>
<p>整理规则为：在整理过程中，可以选择 向右移动一格 或 向下移动一格，但不能移动到衣柜之外。同时，不需要整理 digit(i) digit(j) &gt; cnt 的格子，其中 digit(x) 表示数字 x 的各数位之和。</p>
<p>请返回整理师 总共需要整理多少个格子。</p>
<p>输入：m = 4, n = 7, cnt = 5<br>输出：18</p>
<p>标签：DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 机器人的运动范围</span><br><span class="line">    // 输入：m行、n列的格子，机器人从[0][0]开始移动，每次只能移动一格，但是不能到格子数位之和为k的格子。</span><br><span class="line">    // 返回：能到几个格子</span><br><span class="line">    public static int wardrobeFinishing(int m, int n, int k) &#123;</span><br><span class="line">        int[][] lands = new int[m][n];</span><br><span class="line">        dfs(lands, 0 , 0, k);</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (lands[i][j] == 1) res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不能直接返回？因为初次到达的应该返回1，但是还得往下遍历不能return</span><br><span class="line">    private static void dfs(int[][] lands, int i, int j, int k) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= lands.length || j &lt; 0 || j &gt;= lands[0].length || lands[i][j] == 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!checkValid(i, j, k)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 可以到达置为1</span><br><span class="line">        lands[i][j] = 1;</span><br><span class="line">        dfs(lands, i+1, j, k);</span><br><span class="line">        dfs(lands, i-1, j, k);</span><br><span class="line">        dfs(lands, i, j-1, k);</span><br><span class="line">        dfs(lands, i, j+1, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean checkValid(int i, int j, int k) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while (i &gt; 0) &#123;</span><br><span class="line">            sum += i % 10;</span><br><span class="line">            i = i / 10;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &gt; 0) &#123;</span><br><span class="line">            sum += j % 10;</span><br><span class="line">            j = j / 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>标签：DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 单词搜索</span><br><span class="line">    // 输入：一个字符矩阵，一个单词</span><br><span class="line">    // 输出：水平两连和垂直相连，可以拐弯，能否找到这个单词</span><br><span class="line">    // 解法：DFS，dfs起点：每个点；dfs需要携带的：匹配上的字符长度；dfs出口：字符不一样/字符长度达到</span><br><span class="line">    // 已经用过的字母不能再用：向下一个递归之前变为其他字符，递归完之后再变回来</span><br><span class="line">    public static boolean exist(char[][] words, String s) &#123;</span><br><span class="line">        for (int i = 0; i &lt; words.length; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; words[0].length; j ++) &#123;</span><br><span class="line">                if (dfs(words, i, j, 0, s)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean dfs(char[][] words, int i, int j, int k, String s) &#123;</span><br><span class="line">        if (s.length() == k) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;= words.length || j &lt; 0 || j &gt;= words[0].length || words[i][j] != s.charAt(k)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        k ++;</span><br><span class="line">        char pre = words[i][j];</span><br><span class="line">        words[i][j] = &#x27; &#x27;;</span><br><span class="line">        boolean one = dfs(words, i + 1, j, k, s);</span><br><span class="line">        boolean two = dfs(words, i - 1, j, k, s);</span><br><span class="line">        boolean three = dfs(words, i, j + 1, k, s);</span><br><span class="line">        boolean four = dfs(words, i, j - 1, k, s);</span><br><span class="line">        words[i][j] = pre;</span><br><span class="line">        return one || two || three || four;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h2><p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：</p>
<p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。</p>
<p>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p>
<p>标签：BFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 腐烂的橘子</span><br><span class="line">    // 输入：0空 1新鲜 2腐烂，每一分钟腐烂橘子向四周扩散</span><br><span class="line">    // 输出：几分钟可以全部腐烂</span><br><span class="line">    // 广度优先搜索：使用一个队列Queue或者双向队列Deque，先将第一层节点放到队列里，然后while循环中poll出来，每poll一个就把它的下一层节点offer进去</span><br><span class="line">    public static int orangesRotting(int[][] oranges) &#123;</span><br><span class="line">        // 1.将第一层烂橘子加入队列，统计好橘子个数</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        int freshNum = 0;</span><br><span class="line">        for (int i = 0; i &lt; oranges.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; oranges[0].length; j++) &#123;</span><br><span class="line">                if (oranges[i][j] == 2) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                &#125; else if (oranges[i][j] == 1) &#123;</span><br><span class="line">                    freshNum ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] directs = new int[][]&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">        int res = 0;</span><br><span class="line">        // 2.一层一层BFS</span><br><span class="line">        // 需要增加freshNum &gt; 0，不然最后一层之后还会遍历一下</span><br><span class="line">        while (!queue.isEmpty() &amp;&amp; freshNum &gt; 0) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">                int[] cur = queue.poll();</span><br><span class="line">                int row = cur[0];</span><br><span class="line">                int column = cur[1];</span><br><span class="line">                for (int[] direct : directs) &#123;</span><br><span class="line">                    int newRow = row direct[0];</span><br><span class="line">                    int newColumn = column direct[1];</span><br><span class="line">                    if (newRow &gt;= 0 &amp;&amp; newRow &lt; oranges.length &amp;&amp; newColumn &gt;= 0 &amp;&amp; newColumn &lt; oranges[0].length &amp;&amp; oranges[newRow][newColumn] == 1) &#123;</span><br><span class="line">                        queue.offer(new int[]&#123;newRow, newColumn&#125;);</span><br><span class="line">                        freshNum --;</span><br><span class="line">                        oranges[newRow][newColumn] = 2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return freshNum == 0 ? res : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小基因变化"><a href="#最小基因变化" class="headerlink" title="最小基因变化"></a>最小基因变化</h2><p>基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 ‘A’、’C’、’G’ 和 ‘T’ 之一。</p>
<p>假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p>
<p>另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 bank 中）</p>
<p>给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。</p>
<p>注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。</p>
<p>标签：BFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 最小基因变化</span><br><span class="line">    // 八个字符的字符串，并且字符只能是ACGT，每次基因变化只能改变一个字符，并且必须得是基因库里的</span><br><span class="line">    // 问最少需要几次基因变化，有的字符不能直接变过去，需要bank里的中转一下 123-145，123-163-165-145</span><br><span class="line">    // 最少需要几次这种问题，就是几层，自然是广度优先遍历</span><br><span class="line">    // 深度优先遍历行不行？我认为也行，类似与单词搜索，但是需要遍历完所有符合要求的end，然后求最少次数，时间复杂度高了</span><br><span class="line">    public int minMutation(String startGene, String endGene, String[] bank) &#123;</span><br><span class="line">        // 1.将第一个放入队列</span><br><span class="line">        char[] chars = new char[]&#123;&#x27;A&#x27;, &#x27;C&#x27;, &#x27;G&#x27;, &#x27;T&#x27;&#125;;</span><br><span class="line">        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(startGene);</span><br><span class="line">        int res = 0;</span><br><span class="line">        // 如果将char数组（char[]）作为HashSet或HashMap的键（key），那么只有当两个char数组是相同的对象引用时，才会被视为相同的键。两个具有相同元素的char数组，即使它们的元素内容相同，但是不是同一个对象引用，仍然被视为不同的键。</span><br><span class="line">        // 这里注意，需要使用String</span><br><span class="line">        Set&lt;String&gt; bankSet = new HashSet&lt;&gt;(Arrays.asList(bank));</span><br><span class="line">        // 以及遍历过的不能再遍历，Set记录</span><br><span class="line">        Set&lt;String&gt; visitedSet = new HashSet&lt;&gt;();</span><br><span class="line">        visitedSet.add(startGene);</span><br><span class="line">        // 2.开始while广度遍历</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">                String gene = queue.poll();</span><br><span class="line">                if (gene.equals(endGene)) &#123;</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;</span><br><span class="line">                // 遍历下层节点</span><br><span class="line">                char[] geneChars = gene.toCharArray();</span><br><span class="line">                for (int index = 0; index &lt; geneChars.length; index ++) &#123;</span><br><span class="line">                    char originChar = geneChars[index];</span><br><span class="line">                    for (char c : chars) &#123;</span><br><span class="line">                        if (c == originChar) &#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        geneChars[index] = c;</span><br><span class="line">                        String pre = new String(geneChars);</span><br><span class="line">                        //拷贝char[] : System.arraycopy(gene, 0, pre, 0, gene.length);</span><br><span class="line">                        if (bankSet.contains(pre) &amp;&amp; !visitedSet.contains(pre)) &#123;</span><br><span class="line">                            queue.offer(pre);</span><br><span class="line">                            visitedSet.add(pre);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    geneChars[index] = originChar;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙</h2><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk：</p>
<p>每一对相邻的单词只差一个字母。<br> 对于 1 &lt;= i &lt;= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。<br>sk == endWord<br>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。</p>
<p>标签：BFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 单词接龙</span><br><span class="line">    // wordList是从startWord到endWord的转换序列，每次只能变一个字母，endWord需要在转换序列里</span><br><span class="line">    // 返回：最短转换序列中的单词数目</span><br><span class="line">    // 怎么从wordList中获取可以变的word？</span><br><span class="line">    public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        if (!wordList.contains(endWord)) return 0;</span><br><span class="line">        // 1.定义队列，放入第一个</span><br><span class="line">        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line">        int res = 1;</span><br><span class="line">        // 2.遍历队列</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">                String word = queue.poll();</span><br><span class="line">                if (word.equals(endWord)) return res;</span><br><span class="line">                for (String other : wordList) &#123;</span><br><span class="line">                    if (!visited.contains(other) &amp;&amp; checkWord(word, other)) &#123;</span><br><span class="line">                        queue.offer(other);</span><br><span class="line">                        visited.add(other);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean checkWord(String s1, String s2) &#123;</span><br><span class="line">        if (s1.length() != s2. length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int diffNum = 0;</span><br><span class="line">        for (int i = 0; i &lt; s1.length(); i ++) &#123;</span><br><span class="line">            if (s1.charAt(i) != s2.charAt(i)) diffNum ++;</span><br><span class="line">            if (diffNum &gt; 1) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏4"><a href="#跳跃游戏4" class="headerlink" title="跳跃游戏4"></a>跳跃游戏4</h2><p>给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。</p>
<p>每一步，你可以从下标 i 跳到下标 i + 1 、i - 1 或者 j ：</p>
<p>i + 1 需满足：i + 1 &lt; arr.length<br>i - 1 需满足：i - 1 &gt;= 0<br>j 需满足：arr[i] == arr[j] 且 i != j<br>请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。</p>
<p>注意：任何时候你都不能跳到数组外面。</p>
<p>标签：BFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 跳跃游戏4</span><br><span class="line">    // 从index=0开始，每次能前后跳一步，或者跳到arr[i] == arr[j]的位置</span><br><span class="line">    // 返回到达数组最后一个元素的下标处所需的最少操作次数</span><br><span class="line">    public int minJumps(int[] arr) &#123;</span><br><span class="line">        // 1.初始化，第一个点加入队列</span><br><span class="line">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(0);</span><br><span class="line">        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();</span><br><span class="line">        visited.add(0);</span><br><span class="line">        int res = 0;</span><br><span class="line">        // 2.while循环</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">                Integer index = queue.poll();</span><br><span class="line">                if (index == arr.length - 1) return res;</span><br><span class="line">                for (int j = 0; j &lt; arr.length; j ++) &#123;</span><br><span class="line">                    if (visited.contains(j)) continue;</span><br><span class="line">                    if (arr[j] == arr[index] || j == index - 1 || j == index 1) &#123;</span><br><span class="line">                        queue.offer(j);</span><br><span class="line">                        visited.add(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合总和1（元素无重复可重选）"><a href="#组合总和1（元素无重复可重选）" class="headerlink" title="组合总和1（元素无重复可重选）"></a>组合总和1（元素无重复可重选）</h2><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>标签：DFS回溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    </span><br><span class="line">    // 组合总和</span><br><span class="line">    // 输入：无重复元素的整数数组、目标整数</span><br><span class="line">    // 输出：所有组合，数组中的数可重复使用</span><br><span class="line">    // 常规DFS回溯</span><br><span class="line">    // 注意：1.每次add nums时，需要add副本；2.需要传start索引，因为找到后面的就不需要再往前找了。</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        // 1.初始化，排个序（实际上这个例子中不需要排序）</span><br><span class="line">        // Arrays.sort(candidates);</span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(candidates, target, 0, new ArrayList&lt;&gt;(), 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[] candidates, int target, int sum, List&lt;Integer&gt; nums, int start) &#123;</span><br><span class="line">        if (sum &gt; target) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(nums)); // 需要添加nums的副本</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            nums.add(candidates[i]);</span><br><span class="line">            dfs(candidates, target, sum candidates[i], nums, i); // 传递当前索引i作为下一次递归的start</span><br><span class="line">            nums.remove(nums.size() - 1); // 回溯移除最后一个元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合总和2（元素重复不可重选）"><a href="#组合总和2（元素重复不可重选）" class="headerlink" title="组合总和2（元素重复不可重选）"></a>组合总和2（元素重复不可重选）</h2><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用 一次 。</p>
<p>注意：解集不能包含重复的组合。 </p>
<p>标签：DFS回溯 剪枝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res2;</span><br><span class="line">    // 组合总和2</span><br><span class="line">    // 输入：可重复元素的整数数组、目标整数</span><br><span class="line">    // 输出：所有组合，数组中的数不可重复使用</span><br><span class="line">    // 常规DFS回溯</span><br><span class="line">    // 注意：1.每次add nums时，需要add副本；2.需要传start索引，因为找到后面的就不需要再往前找了。</span><br><span class="line">    // 返回的结果里不能包含重复的组合，元素值重复，但是元素不能重复使用，一样值的不同元素可以用</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">        // 1.初始化，排序也行，不排序也行。排序可以在横向循环遍历时发现大了就break，而不往下DFS，上面那个例子也是</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        System.out.println(Arrays.toString(candidates));</span><br><span class="line">        res2 = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs2(candidates, target, 0, 0, new ArrayList&lt;&gt;());</span><br><span class="line">        return res2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs2(int[] candidates, int target, int sum, int start, List&lt;Integer&gt; nums) &#123;</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            res2.add(new ArrayList&lt;&gt;(nums));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            if (sum candidates[i] &gt; target) break; //剪枝</span><br><span class="line">            // 关键：后面元素一样的话，就continue，这是横向的，因为比如111，target为2，用前面两个11就行，后面就不用遍历了</span><br><span class="line">            if (i &gt; start &amp;&amp; candidates[i] == candidates[i- 1]) &#123;</span><br><span class="line">                System.out.println(candidates[i]);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            nums.add(candidates[i]);</span><br><span class="line">            dfs2(candidates, target, sum candidates[i], i + 1, nums);</span><br><span class="line">            nums.remove(nums.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合总和3（k个数和为n）"><a href="#组合总和3（k个数和为n）" class="headerlink" title="组合总和3（k个数和为n）"></a>组合总和3（k个数和为n）</h2><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>
<p>标签：DFS回溯 只传leftNum</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 组合总和3</span><br><span class="line">    // 找出所有相加之和为n的k个数的组合，数字1-9，每个数字最多只用一次</span><br><span class="line">    // 技巧：迭代中只传剩下的n、剩下的k就好了。</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; res3;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        res3 = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs3(n, k, 1, new ArrayList&lt;&gt;());</span><br><span class="line">        return res3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs3(int leftNum, int leftK, int start, List&lt;Integer&gt; nums) &#123;</span><br><span class="line">        if (leftNum &lt; 0 || leftK &lt; 0) return;</span><br><span class="line">        if (leftNum == 0 &amp;&amp; leftK == 0) &#123;</span><br><span class="line">            res3.add(new ArrayList&lt;&gt;(nums));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt;= 9; i ++) &#123;</span><br><span class="line">            nums.add(i);</span><br><span class="line">            dfs3(leftNum - i, leftK - 1, i + 1, nums);</span><br><span class="line">            nums.remove(nums.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>标签：DFS+回溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 手机号码的组合</span><br><span class="line">    // 手机九宫格键盘 2-9分别对应几个字符，返回一串数字的所有字母组合</span><br><span class="line">    private List&lt;String&gt; res4;</span><br><span class="line">    private String[] letters = new String[]&#123;&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    // 手机号码的组合</span><br><span class="line">    // 手机九宫格键盘 2-9分别对应几个字符，返回一串数字的所有字母组合</span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        res4 = new ArrayList&lt;&gt;();</span><br><span class="line">        if (digits.equals(&quot;&quot;)) return res4;</span><br><span class="line">        dfs4(0, digits, new ArrayList&lt;&gt;());</span><br><span class="line">        return res4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs4(int index, String digits, List&lt;Character&gt; chars) &#123;</span><br><span class="line">        if (index == digits.length()) &#123;</span><br><span class="line">            String s = chars.stream().map(String :: valueOf).collect(Collectors.joining());</span><br><span class="line">            res4.add(s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String letter = letters[digits.charAt(index) - &#x27;2&#x27;];</span><br><span class="line">        for (int i = 0; i &lt; letter.length(); i ++) &#123;</span><br><span class="line">            chars.add(letter.charAt(i));</span><br><span class="line">            dfs4(index 1, digits, chars);</span><br><span class="line">            chars.remove(chars.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p>
<p>输入：s = “aab”<br>输出：[[“a”,”a”,”b”],[“aa”,”b”]]</p>
<p>标签：分割问题 DFS+回溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    // 分割回文串</span><br><span class="line">    // 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案</span><br><span class="line">    // 解法：DFS+回溯，要传start记录切割位置，for横向遍历，dfs纵向遍历</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(s, 0, new ArrayList&lt;&gt;());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(String s, int start, List&lt;String&gt; track) &#123;</span><br><span class="line">        if (start == s.length()) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt; s. length(); i ++) &#123;</span><br><span class="line">            if (isHuiWen(s, start, i)) &#123;</span><br><span class="line">                track.add(s.substring(start, i + 1));</span><br><span class="line">                dfs(s, i + 1, track);</span><br><span class="line">                track.remove(track.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isHuiWen(String s, int start, int end) &#123;</span><br><span class="line">        while(start &lt; end) &#123;</span><br><span class="line">            if (s.charAt(start) != s.charAt(end)) return false;</span><br><span class="line">            start ++;</span><br><span class="line">            end --;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复原-IP-地址"><a href="#复原-IP-地址" class="headerlink" title="复原 IP 地址"></a>复原 IP 地址</h2><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#x39;&#50;&#46;&#49;&#x36;&#56;&#64;&#x31;&#46;&#x31;">&#x31;&#x39;&#50;&#46;&#49;&#x36;&#56;&#64;&#x31;&#46;&#x31;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>
<p>标签：切割问题 DFS+回溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 复原IP地址</span><br><span class="line">    // 输入一串数字，返回可能的IP地址，如0.1.255.23</span><br><span class="line">    private List&lt;String&gt; ipList;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        ipList = new ArrayList&lt;&gt;();</span><br><span class="line">        if (s.length() &gt; 12) return ipList;</span><br><span class="line">        dfs2(s, 0, new ArrayList&lt;&gt;());</span><br><span class="line">        return ipList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs2(String s, int start, List&lt;String&gt; track) &#123;</span><br><span class="line">        if (track.size() == 4 &amp;&amp; start == s. length()) &#123;</span><br><span class="line">            String ip = String.join(&quot;.&quot;, track);</span><br><span class="line">            ipList.add(ip);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (track.size() == 4) return;</span><br><span class="line">        for (int i = start; i &lt; s. length(); i ++) &#123;</span><br><span class="line">            String ss = s.substring(start, i + 1);</span><br><span class="line">            if (isRightIp(ss)) &#123;</span><br><span class="line">                track.add(ss);</span><br><span class="line">                dfs2(s, i + 1, track);</span><br><span class="line">                track.remove(track.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isRightIp(String s) &#123;</span><br><span class="line">        if (s.length() == 1) return true;</span><br><span class="line">        if (s.charAt(0) == &#x27;0&#x27;) return false;</span><br><span class="line">        long num = Long.parseLong(s);</span><br><span class="line">        return num &lt; 256;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p>输入：nums = [1,2,3]<br>输出：<code>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></p>
<p>标签：DFS+回溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 子集</span><br><span class="line">    // 给定一个int[]，返回它的子集，包括[]，不能重复.</span><br><span class="line">    // 给定的数组中，就没重复的，没重复的就不用排序</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">        //Arrays.sort(nums);</span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums, 0, new ArrayList&lt;&gt;());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int[] nums, int start, List&lt;Integer&gt; track) &#123;</span><br><span class="line">        res.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">        for (int i = start; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            dfs(nums, i + 1, track);</span><br><span class="line">            track.remove(track.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子集2"><a href="#子集2" class="headerlink" title="子集2"></a>子集2</h2><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p>
<p>输入：nums = [1,2,2]<br>输出：<code>[[],[1],[1,2],[1,2,2],[2],[2,2]]</code></p>
<p>标签：DFS+回溯+剪枝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 子集2：输入可能包含重复元素了</span><br><span class="line">    // 只需要增加一个横向的去重</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; res2;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        res2 = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs2(nums, 0, new ArrayList&lt;&gt;());</span><br><span class="line">        return res2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs2(int[] nums, int start, List&lt;Integer&gt; track) &#123;</span><br><span class="line">        res2.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">        for (int i = start; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            dfs2(nums, i + 1, track);</span><br><span class="line">            track.remove(track.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<p>输入：nums = [4,6,7,7]<br>输出：<code>[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</code></p>
<p>标签：DFS+回溯+剪枝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 递增子序列</span><br><span class="line">    // 输入一个整数数组，返回所有的递增子序列，相同也算递增，子序列不需要连续元素，可以间隔取用</span><br><span class="line">    // 注意：序列本身并不一定是递增的，子序列不能不是原序列的顺序，所以不能排序</span><br><span class="line">    // 注意：序列不是递增的，剪枝就不能前后对比剪枝了</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; sequenceList;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;</span><br><span class="line">        sequenceList = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs3(nums, 0, new ArrayList&lt;&gt;());</span><br><span class="line">        return sequenceList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs3(int[] nums, int start, List&lt;Integer&gt; track) &#123;</span><br><span class="line">        // 判断是否递增</span><br><span class="line">        if (track.size() &gt;= 2 &amp;&amp; track.get(track.size() - 1) &lt; track.get(track.size() - 2)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 长度至少是2</span><br><span class="line">        if (track.size() &gt;= 2) &#123;</span><br><span class="line">            // 这里不应该return</span><br><span class="line">            sequenceList.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; jianzhiSet = new HashSet&lt;&gt;();</span><br><span class="line">        for (int i = start; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            // 横向去重，剪枝</span><br><span class="line">//            if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; //这样不行</span><br><span class="line">            if(jianzhiSet.contains(nums[i])) continue;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            jianzhiSet.add(nums[i]);</span><br><span class="line">            dfs3(nums, i + 1, track);</span><br><span class="line">            track.remove(track.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全排列（元素无重，不可重选）"><a href="#全排列（元素无重，不可重选）" class="headerlink" title="全排列（元素无重，不可重选）"></a>全排列（元素无重，不可重选）</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p>输入：nums = [1,2,3]<br>输出：<code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></p>
<p>标签：DFS+回溯+记录数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 全排列(元素无重，不可重选)</span><br><span class="line">    // [1,2] 输出: [1,2][2,1]</span><br><span class="line">    // 元素无重复，一个位置的元素不能重选</span><br><span class="line">    // 实现：不需要start来记录遍历到哪，但是需要记录哪些位置遍历过了（前提是元素无重复，要是有重复的话，不同位置但是值一样就会重选）</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        if (nums.length == 0) return res;</span><br><span class="line">        dfs(nums, new ArrayList&lt;&gt;(), new HashSet&lt;&gt;());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int[] nums, List&lt;Integer&gt; track, Set&lt;Integer&gt; usedIndex) &#123;</span><br><span class="line">        if (track.size() == nums.length) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (usedIndex.contains(i)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            usedIndex.add(i);</span><br><span class="line">            dfs(nums, track, usedIndex);</span><br><span class="line">            track.remove(track.size() - 1);</span><br><span class="line">            usedIndex.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全排列2（元素可重，不可重选）"><a href="#全排列2（元素可重，不可重选）" class="headerlink" title="全排列2（元素可重，不可重选）"></a>全排列2（元素可重，不可重选）</h2><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<p>输入：nums = [1,1,2]<br>输出：<code>[[1,1,2], [1,2,1], [2,1,1]]</code></p>
<p>标签：DFS+回溯+记录数组+剪枝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 全排列(元素重复，不可重选)</span><br><span class="line">    // 输入：[1,1,2] 输出：[1,1,2][1,2,1][2,1,1]</span><br><span class="line">    // 不光要记录深度方向哪些索引已经用过，还要横向剪枝，但是这里剪枝比较特殊，需要是横向之前确定用过的，用临时数记录</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; res2;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">        res2 = new ArrayList&lt;&gt;();</span><br><span class="line">        if (nums.length == 0) return res2;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs2(nums, new ArrayList&lt;&gt;(), new HashSet&lt;&gt;());</span><br><span class="line">        return res2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs2(int[] nums, List&lt;Integer&gt; track, Set&lt;Integer&gt; usedIndex) &#123;</span><br><span class="line">        System.out.println(track);</span><br><span class="line">        if (track.size() == nums.length) &#123;</span><br><span class="line">            res2.add(new ArrayList&lt;&gt;(track));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int used = -11;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (usedIndex.contains(i)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == used) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            used = nums[i];</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            usedIndex.add(i);</span><br><span class="line">            dfs2(nums, track, usedIndex);</span><br><span class="line">            track.remove(track.size() - 1);</span><br><span class="line">            usedIndex.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p>标签：DFS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 解数独</span><br><span class="line">    // 输入9*9的矩阵，未知数用.表示，每行每列每个左中右3*3，都是1-9不能重复</span><br><span class="line">    // 输出填好的数独</span><br><span class="line">    // 解法：和n皇后问题类似，n皇后是只填一个，数独要1-9。n皇后用一个int[]表示皇后的位置。</span><br><span class="line">    // 遍历还有没有没填的数，如果没有了就return了。得返回boolean记录一下。</span><br><span class="line">    // 思想其实都是尝试，n皇后尝试在每行的哪个位置放置皇后，然后校验。填数独在没填的位置尝试，然后校验。</span><br><span class="line">    // n皇后要返回几种答案，所以dfs返回几种。</span><br><span class="line">    public void solveSudoku(char[][] board) &#123;</span><br><span class="line">        dfs(board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean dfs(char[][] board) &#123;</span><br><span class="line">        for (int i = 0; i &lt; board.length; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; board[0].length; j ++) &#123;</span><br><span class="line">                if (board[i][j] != &#x27;.&#x27;) continue;</span><br><span class="line">                for (int tryNum = 1; tryNum &lt;= 9; tryNum ++) &#123;</span><br><span class="line">                    char tryChar = (char) (&#x27;0&#x27; tryNum);</span><br><span class="line">                    if (isValid(board, i, j, tryChar)) &#123;</span><br><span class="line">                        board[i][j] = tryChar;</span><br><span class="line">                        if (dfs(board)) return true;</span><br><span class="line">                        else board[i][j] = &#x27;.&#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 注意：所有数都不行，证明前面填错了，因此需要回溯。不然还会遍历下一个位置</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isValid(char[][] board, int row, int column, char num) &#123;</span><br><span class="line">        // 同行是否已有</span><br><span class="line">        for (int i = 0; i &lt; board[0].length; i++) &#123;</span><br><span class="line">            if (board[row][i] == num)  return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同列是否已有</span><br><span class="line">        for (int i = 0; i &lt; board.length; i++) &#123;</span><br><span class="line">            if (board[i][column] == num)  return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同方块儿是否已有</span><br><span class="line">        int startRow = (row / 3) * 3;</span><br><span class="line">        int startColumn = (column / 3) * 3;</span><br><span class="line">        for (int i = startRow; i &lt; startRow 3; i ++) &#123;</span><br><span class="line">            for (int j = startColumn; j &lt; startColumn 3; j ++) &#123;</span><br><span class="line">                if (board[i][j] == num)  return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同构字符串"><a href="#同构字符串" class="headerlink" title="同构字符串"></a>同构字符串</h2><p>给定两个字符串 s 和 t ，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。</p>
<p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<p>输入：s = “egg”, t = “add”<br>输出：true</p>
<p>标签：Map indexOf charAt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 同构字符串</span><br><span class="line">    // 输入两个字符串，判断是否是同构字符串，如：aabc、oody，映射只能是一对一的</span><br><span class="line">    // 思路：</span><br><span class="line">    // 1.可以用String的indexOf()方法：找到元素的第一个索引下标</span><br><span class="line">    // 2.可以用map记录字符映射</span><br><span class="line">    public boolean isIsomorphic(String s1, String s2) &#123;</span><br><span class="line">        if (s1.length() != s2.length()) return false;</span><br><span class="line">        for (int i = 0; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            if (s1.indexOf(s1.charAt(i)) != s2.indexOf(s2.charAt(i))) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isIsomorphic2(String s1, String s2) &#123;</span><br><span class="line">        if (s1.length() != s2.length()) return false;</span><br><span class="line">        Map&lt;Character, Character&gt; map = new HashMap();</span><br><span class="line">        for (int i = 0; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            if (map.containsKey(s1.charAt(i)) &amp;&amp; s2.charAt(i) != map.get(s1.charAt(i))) return false;</span><br><span class="line">            map.put(s1.charAt(i), s2.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="贪心专栏"><a href="#贪心专栏" class="headerlink" title="贪心专栏"></a>贪心专栏</h2><p>贪心专栏：贪心算法就是找当下的最优解，每一个状态都找到最优解，从而希望结果是全局最优的。<br>解题思路一般是：<br>    •    问题分解为若干子问题<br>    •    找出适合的贪心策略<br>    •    求解每个子问题的最优解<br>    •    将局部最优解堆叠成全局最优</p>
<h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>标签：贪心算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 分发饼干</span><br><span class="line">    // 输入：g数组表示孩子的胃口值，数组大小表示有多少个孩子，s数组表示饼干的尺寸，数组大小表示有多少个饼干</span><br><span class="line">    // 输出：最多能满足多少个孩子</span><br><span class="line">    // 贪心思想：从局部最优到全局最优，大的饼干尽可能满足胃口大的孩子</span><br><span class="line">    public int findContentChildren(int[] g, int[] s) &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        int i = g.length - 1, j = s.length - 1;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123;</span><br><span class="line">            // 胃口大了</span><br><span class="line">            if (g[i] &gt; s[j]) &#123;</span><br><span class="line">                i --;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">            i --;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h2><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p>
<p>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。<br>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p>
<p>以这种方式修改数组后，返回数组 可能的最大和 。</p>
<p>标签：贪心算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // k次取反后最大化的数组和</span><br><span class="line">    // 输入：一个整数数组nums、一个整数k，每次选择一个元素取反，重复k次，可以重复选择同一元素</span><br><span class="line">    // 输出：操作后最大的数组和</span><br><span class="line">    // 贪心思想：局部最优是每次取反的数字是最小的</span><br><span class="line">    // 方法一：每次都重排序，取最小的反转。时间复杂度高</span><br><span class="line">    public int largestSumAfterKNegations1(int[] nums, int k) &#123;</span><br><span class="line">        for (int i = 0; i &lt; k; i ++) &#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            nums[0] = -nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            res += num;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法二：优化一下，首先将数组按照绝对值从大到小排列，然后从前往后遍历遇到负数就反转，最后如果k没用完就将放最后的数组来回反转。</span><br><span class="line">    // 优点：只需要排序一次，需要自定义排序</span><br><span class="line">    public int largestSumAfterKNegations(int[] nums, int k) &#123;</span><br><span class="line">        // 首先将int[]转换为Integer[]，因为Comparator不适用于原始数据类型数组</span><br><span class="line">        Integer[] numbersObj = Arrays.stream(nums).boxed().toArray(Integer[]::new);</span><br><span class="line">        Arrays.sort(numbersObj, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">                // 比较绝对值，实现逆序排序</span><br><span class="line">                return Integer.compare(Math.abs(o2), Math.abs(o1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (k &gt; 0 &amp;&amp; i &lt; numbersObj.length) &#123;</span><br><span class="line">            if (numbersObj[i] &lt; 0) &#123;</span><br><span class="line">                numbersObj[i] *= -1;</span><br><span class="line">                k --;</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (k -- &gt; 0) &#123;</span><br><span class="line">            numbersObj[numbersObj.length - 1] *= -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int num : numbersObj) &#123;</span><br><span class="line">            res += num;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
<p>标签：贪心算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 柠檬水找零</span><br><span class="line">    // 一个柠檬5块，输入一个整数数组，表示顾客付的钱(5、10、20)，需要考虑顺序</span><br><span class="line">    // 返回是否成功找零</span><br><span class="line">    // 贪心思想：顺序遍历有多少5块10块，找20优先使用10+5</span><br><span class="line">    public boolean lemonadeChange(int[] bills) &#123;</span><br><span class="line">        int fiveNum = 0;</span><br><span class="line">        int tenNum = 0;</span><br><span class="line">        for (int bill : bills) &#123;</span><br><span class="line">            if (bill == 5) fiveNum ++;</span><br><span class="line">            else if (bill == 10) &#123;</span><br><span class="line">                fiveNum --;</span><br><span class="line">                tenNum ++;</span><br><span class="line">            &#125; else if (bill == 20) &#123;</span><br><span class="line">                if (tenNum &gt; 0) &#123;</span><br><span class="line">                    tenNum --;</span><br><span class="line">                    fiveNum --;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    fiveNum -= 3;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (fiveNum &lt; 0 || tenNum &lt; 0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。</p>
<p>返回 你可以获得的最大乘积 。</p>
<p>标签：贪心算法、动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 整数拆分</span><br><span class="line">    // 给一个正整数n，求将其拆分后的最大积</span><br><span class="line">    // 方法1：贪心，发现除了最后的4，将其拆分为尽可能多的3，最后积最大</span><br><span class="line">    public int integerBreak2(int n) &#123;</span><br><span class="line">        if (n &lt;= 2) return 1;</span><br><span class="line">        if (n == 3) return 2;</span><br><span class="line">        int res = 1;</span><br><span class="line">        while (n &gt; 4) &#123;</span><br><span class="line">            res *= 3;</span><br><span class="line">            n -= 3;</span><br><span class="line">        &#125;</span><br><span class="line">        return res * n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法2：动态规划，后一个状态与前一个状态有关，建立状态转移方程</span><br><span class="line">    public int integerBreak(int n) &#123;</span><br><span class="line">        if (n &lt;= 2) return 1;</span><br><span class="line">        // 1.定义dp</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        // 2.初始化，本来想每个都初始化自己n，但是只有1，2是需要赋予初值的</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        dp[2] = 1;</span><br><span class="line">        // 3.状态转移</span><br><span class="line">        for (int i = 3; i &lt;= n; i ++) &#123;</span><br><span class="line">            // 遍历拆到一半的数</span><br><span class="line">            for (int j = 1; j &lt;= i/2; j ++) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], j * Math.max(dp[i - j], i - j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 5 1</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 零钱兑换</span><br><span class="line">     * 输入：一个数组表示有哪些种零钱，每种的数量无限，给你一个整数表示总金额，返回所需最少的零钱个数</span><br><span class="line">     * 如果组合不成，就返回-1</span><br><span class="line">     */</span><br><span class="line">    // 思路：用动态规划</span><br><span class="line">    public static int coinChange(int[] changes, int total) &#123;</span><br><span class="line">        if (total == 0) return 0;</span><br><span class="line">        Arrays.sort(changes);</span><br><span class="line">        int[] dp = new int[total 1];</span><br><span class="line">        for (int num : changes) &#123;</span><br><span class="line">            if (num &lt;= total)  dp[num] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= total; i ++) &#123;</span><br><span class="line">            for (int num : changes) &#123;</span><br><span class="line">                if (i - num &lt; 1) break;</span><br><span class="line">                if (dp[i - num] == 0) continue;</span><br><span class="line">                dp[i] = dp[i] == 0 ? dp[i - num] + 1 : Math.min(dp[i], dp[i - num] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[total] == 0 ? -1 : dp[total];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
<p>输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</p>
<p>标签：贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">     /**</span><br><span class="line">     * 摆动序列</span><br><span class="line">     * 什么是摆动序列：序列相邻元素的差值是正数负数摆动的，仅含有一个/两个元素的序列也是摆动序列</span><br><span class="line">     * 输入一个序列，返回这个序列的最长摆动子序列（只能删除元素）</span><br><span class="line">     * 思考：不管怎么样，最优答案一定是可以从最开头开始遍历的，就算是：1 2 3 2 3..，也可以 1 3 2 3</span><br><span class="line">     * 所以从头开始遍历，贪心地往后走就好</span><br><span class="line">     */</span><br><span class="line">    public static int wiggleMaxLength(int[] nums) &#123;</span><br><span class="line">        if (nums.length == 1) return 1;</span><br><span class="line">        if (nums.length == 2) return nums[0] == nums[1]? 1:2;</span><br><span class="line">        int res = nums[0] == nums[1] ? 1 : 2;</span><br><span class="line">        int preDiff = nums[1] - nums[0];</span><br><span class="line">        for (int i = 2; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            int curDiff = nums[i] - nums[i - 1];</span><br><span class="line">            if ((preDiff &gt;= 0  &amp;&amp; curDiff &lt; 0) || (preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0)) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">                preDiff = curDiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="峰与谷"><a href="#峰与谷" class="headerlink" title="峰与谷"></a>峰与谷</h2><p>在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。</p>
<p>输入: [5, 3, 1, 2, 3]<br>输出: [5, 1, 3, 2, 3]</p>
<p>标签：贪心，注意贪心算法，从局部最优到全局最优的前提是：局部最优不影响全局最优。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   </span><br><span class="line">    /**</span><br><span class="line">     * 峰与谷</span><br><span class="line">     * 输入：一个整数数组，峰是大于等于两边数的，谷是小于等于两边数的。在最边只有一个相邻元素也算</span><br><span class="line">     * 输出：将该数组按照峰与谷的顺序交替顺序排序</span><br><span class="line">     * [5,3,1,2,3] 输出：[5,1,3,2,3]  应该输出不止有一种可能</span><br><span class="line">     * 贪心的思想：挨个遍历，挨个满足要求。重点是峰与谷交替，所以每个位置是峰还是谷是确定的，每次遍历保证和上一个位置的关系。</span><br><span class="line">     * 从第二个数开始遍历，保证和前一个数的关系，不满足就交换。可是交换了影响前面的怎么办？不会，后面交换只会换来更小或更大的</span><br><span class="line">     * 比如，在应该峰的位置，比前面小，换来前面的大值，在下一个应该谷的位置，发现比前一个大，所以换来前面的小值，那么最开始峰的位置变得更大了，不影响</span><br><span class="line">     */</span><br><span class="line">    public static int[] wiggleSort(int[] nums) &#123;</span><br><span class="line">        if(nums.length == 1) &#123;</span><br><span class="line">            return nums;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            if (i % 2 == 0) &#123;</span><br><span class="line">                //峰，应该比上一个大</span><br><span class="line">                if (nums[i] &lt; nums[i - 1]) &#123;</span><br><span class="line">                    swap(nums, i, i - 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //谷，应该比上一个小</span><br><span class="line">                if (nums[i] &gt; nums[i - 1]) &#123;</span><br><span class="line">                    swap(nums, i, i - 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] nums, int index1, int index2) &#123;</span><br><span class="line">        int pre = nums[index2];</span><br><span class="line">        nums[index2] = nums[index1];</span><br><span class="line">        nums[index1] = pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。</p>
<p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</p>
<p>标签：贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  </span><br><span class="line">    /**</span><br><span class="line">     * 单调递增的数字</span><br><span class="line">     * 单调数字是各位数字都是单调递增的，比如：123、122。121就不是  213 199; 9213 8999；192 189</span><br><span class="line">     * 输入n，返回小于等于n的最大单调数字</span><br><span class="line">     * 思路：从前往后遍历，如果前&gt;后，前-1，后面就都变9</span><br><span class="line">     * 错误：332，应该是299。这种情况怎么处理。在发现前数大于后数时，需要先向前遍历，-1是否会比前一位小（这样麻烦）</span><br><span class="line">     * 修正：从后（个位）往前遍历，如果前面比后面大，前面位-1，并记录flag，决定从哪位开始后面都变为9</span><br><span class="line">     */</span><br><span class="line">    public static int monotoneIncreasingDigits(int n) &#123;</span><br><span class="line">        // 存数的各个位，前面是个位</span><br><span class="line">        List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();</span><br><span class="line">        while(n &gt; 0) &#123;</span><br><span class="line">            nums.add(n % 10);</span><br><span class="line">            n /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        int flag = -1;</span><br><span class="line">        for (int i = 0; i &lt; nums.size() - 1; i++) &#123;</span><br><span class="line">            if (nums.get(i) &lt; nums.get(i + 1)) &#123;</span><br><span class="line">                nums.set(i + 1, nums.get(i + 1) - 1);</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt;= flag; i ++) &#123;</span><br><span class="line">            nums.set(i, 9);</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = nums.size() - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">            res = res * 10 nums.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p>
<p>标签：动态规划，动态规划和贪心的关系：都是局部到全局，贪心不需要状态转移，也就是不需要dp。动态规划需要状态转移dp。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  </span><br><span class="line">    // 最大子数组和</span><br><span class="line">    // 给你一个数组，返回一个最大连续子数组和</span><br><span class="line">    //动态规划，dp表示的应该是连续的到某位置的最大值</span><br><span class="line">    public static int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        int res = dp[0];</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - 1] nums[i], nums[i]);</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><p>标签：动态规划</p>
<p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p>
<p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 最长连续递增子序列</span><br><span class="line">    // 输入一个未经排序的整数数组，返回最长连续递增子序列的长度，等于不算递增</span><br><span class="line">    public static int findLengthOfLCIS(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        int res = 1;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            if (nums[i] &gt; nums[i - 1]) dp[i] = dp[i - 1] + 1;</span><br><span class="line">            else dp[i] = 1;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p>
<p>标签：贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 分发糖果</span><br><span class="line">    // 输入一个数组，表示n个孩子站成一排的评分</span><br><span class="line">    // 分发糖果规则：每个孩子都需要分到至少一个，相邻孩子评分高的需要分到更多糖果，如果相等则无所谓，可以少</span><br><span class="line">    // 输出：需要的最少糖果数</span><br><span class="line">    // 贪心，从头遍历分糖果，第一个给1，往后遍历如果出现了需要分0的情况，往前遍历，连续变大的+1，例如5-4-3-2-1</span><br><span class="line">    // 出错，注意：往前遍历不能无脑加1，需要是后面值的加一，而且需要比较一下取大的</span><br><span class="line">    public static int candy(int[] nums) &#123;</span><br><span class="line">        int[] candies = new int[nums.length];</span><br><span class="line">        candies[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            if (nums[i] &gt; nums[i - 1]) &#123;</span><br><span class="line">                candies[i] = candies[i - 1] + 1;</span><br><span class="line">            &#125; else if (nums[i] == nums[i - 1]) &#123;</span><br><span class="line">                candies[i] = 1; //相等就给最少的</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (candies[i - 1] == 1) &#123;</span><br><span class="line">                    candies[i] = 1;</span><br><span class="line">                    int j = i - 1;</span><br><span class="line">                    while(j &gt;= 0 &amp;&amp; nums[j] &gt; nums[j + 1]) &#123;</span><br><span class="line">                        candies[j] = Math.max(candies[j + 1] + 1, candies[j]);</span><br><span class="line">                        j --;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    candies[i] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int num : candies) &#123;</span><br><span class="line">            res += num;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(candies));</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
<p>标签：贪心，难点在于怎么总结出规律</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 根据身高重建队列</span><br><span class="line">    // 给定一个数组的数组[[5,1],[6,2],[7,3]]表示一些人，[5,1]中5表示身高，1表示前面有一个大于等于身高5的人</span><br><span class="line">    // 输入的数组是乱序的，输出排好序的数组</span><br><span class="line">    // 思路：关键在于先按照身高从高到低排序，如果身高相同，则按照前面的人数值从小到大排序。然后，使用一个列表（或数组）来依次放置每个人。对于每个人，我们根据前面人数值将其插入到结果列表中的正确位置。</span><br><span class="line">    // 输入：&#123;&#123;7, 0&#125;, &#123;4, 4&#125;, &#123;7, 1&#125;, &#123;5, 0&#125;, &#123;6, 1&#125;, &#123;5, 2&#125;&#125;</span><br><span class="line">    // 排序后：[[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]</span><br><span class="line">    // 一个一个插入：[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]</span><br><span class="line">    public int[][] reconstructQueue(int[][] people) &#123;</span><br><span class="line">        // 按照身高降序排列，身高相同的则按照前面人数升序排列</span><br><span class="line">        // 这里排的是int[]，不是int，所以可以。</span><br><span class="line">        // Comparator排序，a-b表示正序，b-a表示倒叙</span><br><span class="line">        Arrays.sort(people, (a, b) -&gt; &#123;</span><br><span class="line">            if (a[0] == b[0]) &#123;</span><br><span class="line">                return a[1] - b[1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return b[0] - a[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;int[]&gt; peopleList = new ArrayList&lt;&gt;();</span><br><span class="line">        // 遍历排序后的数组，根据前面人数插入到队列中的适当位置</span><br><span class="line">        for (int[] person : people) &#123;</span><br><span class="line">            peopleList.add(person[1], person);</span><br><span class="line">        &#125;</span><br><span class="line">        return peopleList.toArray(new int[peopleList.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p>标签：贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 合并区间</span><br><span class="line">    // 输入：int[][]，每个int[]表示一个区间，这些区间有重叠</span><br><span class="line">    // 返回：重叠区间合并后的不重叠的区间数组，边界相同也可合并</span><br><span class="line">    // 例如：输入：[1,3],[2,6],[8,10]  输出：[1,6],[8,10]</span><br><span class="line">    // 注意：排序之后，前一个的右边界可能比后一个右边界大</span><br><span class="line">    public int[][] merge(int[][] nums) &#123;</span><br><span class="line">        // 首先根据第一个数正序排序，如果相同根据第二个数正序排序</span><br><span class="line">        Arrays.sort(nums, (a, b) -&gt; &#123;</span><br><span class="line">            if (a[0] == b[0]) &#123;</span><br><span class="line">                return a[1] - b[1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return a[0] - b[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        int[] lastSec = nums[0];</span><br><span class="line">        List&lt;int[]&gt; secList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            // 不合并条件</span><br><span class="line">            if (lastSec[1] &lt; nums[i][0]) &#123;</span><br><span class="line">                secList.add(lastSec);</span><br><span class="line">                lastSec = nums[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 合并</span><br><span class="line">                lastSec[1] = Math.max(lastSec[1], nums[i][1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        secList.add(lastSec);</span><br><span class="line">        int[][] res = secList.toArray(new int[secList.size()][]);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p>
<p>输入：points = [[10,16],[2,8],[1,6],[7,12]]<br>输出：2</p>
<p>标签：贪心 区间问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 用最少数量的箭引爆气球</span><br><span class="line">    // 气球在平面上，一个气球有x轴的坐标，箭从x轴某个位置射出。求最少需要射多少箭</span><br><span class="line">    // 输入：int[][]表示气球的坐标</span><br><span class="line">    // 思路：其实和合并区间是一个问题，最后合并完变成几个区间，就是几个箭 ? 并不是，应该是有几个相交区域，就是几个箭。</span><br><span class="line">    public static int findMinArrowShots(int[][] nums) &#123;</span><br><span class="line">        // 1.首先排序</span><br><span class="line">        Arrays.sort(nums, (a, b) -&gt; &#123;</span><br><span class="line">            // 下面这样会越界</span><br><span class="line">            // if (a[0] == b[0]) return a[1] - b[1];</span><br><span class="line">            // else return a[0] - b[0];</span><br><span class="line">            // 只根据end排序就行</span><br><span class="line">            if (a[1] &gt; b[1]) &#123;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125; else if (a[1] &lt; b[1]) &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 2.遍历寻找合并契机</span><br><span class="line">        // 上一个重合区间，可以合并的条件变严格，只有和这个重合区间重合，才能同一根箭射爆</span><br><span class="line">        int[] lastSec = nums[0];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            if (lastSec[1] &gt;= nums[i][0]) &#123;</span><br><span class="line">                // 可以合并</span><br><span class="line">                lastSec[0] = Math.max(lastSec[0], nums[i][0]);</span><br><span class="line">                lastSec[1] = Math.min(lastSec[1], nums[i][1]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 不能合并</span><br><span class="line">                res ++;</span><br><span class="line">                lastSec = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p>
<p>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<p>标签：贪心、区间问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 无重叠区间</span><br><span class="line">    // 输入一组区间，返回最少需要移除几个区间才能使剩余区间互不重叠，区间边界相同也不算重叠</span><br><span class="line">    // 思路：其实没那么复杂，就是射箭问题的反面，思考几个case就能明白，但你需要注意气球是边界相同可以射破，这里不行。</span><br><span class="line">    public static int eraseOverlapIntervals(int[][] nums) &#123;</span><br><span class="line">        // 1.首先排序</span><br><span class="line">        Arrays.sort(nums, (a, b) -&gt; &#123;</span><br><span class="line">            if (a[0] == b[0]) return a[1] - b[1];</span><br><span class="line">            else return a[0] - b[0];</span><br><span class="line">        &#125;);</span><br><span class="line">        // 2.遍历寻找合并契机</span><br><span class="line">        // 上一个重合区间，可以合并的条件变严格，只有和这个重合区间重合，才能同一根箭射爆</span><br><span class="line">        int[] lastSec = nums[0];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            if (lastSec[1] &gt; nums[i][0]) &#123;</span><br><span class="line">                // 可以合并</span><br><span class="line">                lastSec[0] = Math.max(lastSec[0], nums[i][0]);</span><br><span class="line">                lastSec[1] = Math.min(lastSec[1], nums[i][1]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 不能合并</span><br><span class="line">                res ++;</span><br><span class="line">                lastSec = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums.length - res - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<p>输入：s = “ababcbacadefegdehijhklij”<br>输出：[9,7,8]<br>解释：<br>划分结果为 “ababcbaca”、”defegde”、”hijhklij” 。</p>
<p>标签：贪心、区间问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 划分字母区间</span><br><span class="line">    // 输入一个字符串，表示单词。要将这个单词划分为尽可能多的片段，同一个字母最多出现在一个片段中。</span><br><span class="line">    // 并且，所有片段按顺序连接之后，还是这个单词</span><br><span class="line">    // 返回表示每个字符串片段长度的列表</span><br><span class="line">    // 思路：indexOf只能获取字符的第一个位置索引。还是遍历用map记录一下字符的最大索引。然后遍历，并更新边界，如果和边界相等则成一个片段。</span><br><span class="line">    public static List&lt;Integer&gt; partitionLabels(String s) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            map.put(s.charAt(i), i);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; resList = new ArrayList&lt;&gt;();</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i ++) &#123;</span><br><span class="line">            end = Math.max(map.get(s.charAt(i)), end);</span><br><span class="line">            // 等于边界，表示可以分割</span><br><span class="line">            if (i == end) &#123;</span><br><span class="line">                resList.add(end - start 1);</span><br><span class="line">                start = end 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模拟行走机器人"><a href="#模拟行走机器人" class="headerlink" title="模拟行走机器人"></a>模拟行走机器人</h2><p>机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：</p>
<p>-2 ：向左转 90 度<br>-1 ：向右转 90 度<br>1 &lt;= x &lt;= 9 ：向前移动 x 个单位长度<br>在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点  obstacles[i] = (xi, yi) 。</p>
<p>机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，并继续执行下一个命令。</p>
<p>返回机器人距离原点的 最大欧式距离 的 平方 。（即，如果距离为 5 ，则返回 25 ）</p>
<p>标签：贪心模拟</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 模拟行走机器人</span><br><span class="line">    // 机器人在无限大平面行走，初始位置在(0,0)，初始朝向是向北，接收指令：-2向左转90度 -1向右转90度 1-9表示走多少步。</span><br><span class="line">    // 有障碍物，机器人走不上去，需要原地踏步直到转向，求达到点点最大欧式距离(x平方+y平方)</span><br><span class="line">    // obstacles表示障碍物位置</span><br><span class="line">    // 思路：其实不难，就是遍历指令，只是需要控制好方向</span><br><span class="line">    public int robotSim(int[] commands, int[][] obstacles) &#123;</span><br><span class="line">        // 定义转向 东南西北</span><br><span class="line">        int[][] directs = new int[][]&#123;&#123;1, 0&#125;,&#123;0, -1&#125;,&#123;-1, 0&#125;,&#123;0, 1&#125;&#125;;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int curX = 0;</span><br><span class="line">        int curY = 0;</span><br><span class="line">        int dir = 3; //初始朝向北</span><br><span class="line">        // 定义障碍物位置set</span><br><span class="line">        Set&lt;String&gt; obstacleSet = new HashSet&lt;&gt;();</span><br><span class="line">        for (int[] obs : obstacles) &#123;</span><br><span class="line">            obstacleSet.add(obs[0] &quot;:&quot; obs[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int command : commands) &#123;</span><br><span class="line">            if (command == -2) &#123;</span><br><span class="line">                dir = dir - 1 == -1? 3 : dir - 1;</span><br><span class="line">            &#125; else if (command == -1) &#123;</span><br><span class="line">                dir = dir 1 == 4? 0 : dir 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while (command -- &gt; 0) &#123;</span><br><span class="line">                    int nextX = curX directs[dir][0];</span><br><span class="line">                    int nextY = curY directs[dir][1];</span><br><span class="line">                    String nextPos = nextX &quot;:&quot; nextY;</span><br><span class="line">                    if (obstacleSet.contains(nextPos)) break;</span><br><span class="line">                    curX = nextX;</span><br><span class="line">                    curY = nextY;</span><br><span class="line">                    res = (int)Math.max(res, Math.pow(curX, 2) Math.pow(curY, 2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p>
<p>输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]<br>输出: 3</p>
<p>标签：贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 加油站</span><br><span class="line">    // 输入：cost数组表示第i个加油站到i+1个加油站需要的汽油，gas表示第i个加油站的汽油</span><br><span class="line">    // 加油站是个环，油箱无限，开始时邮箱为空，返回从哪个加油站出发能绕一圈，答案唯一，不能返回-1</span><br><span class="line">    // 输入：1,2,3,4,5 和 3,4,5,1,2，返回3</span><br><span class="line">    // 思路：remain数组表示只用这个加油站的油到下一个可以剩下多少，找到负的，向前遍历，到哪可以满足</span><br><span class="line">    // 应该先找到一个应该开始遍历的负点：这个点是从0点开始累计油量最少的地方。画个累计油量曲线就好了，从0开始和从其他地方开始曲线形状都是一样的，无非是上下平移</span><br><span class="line">    // 因为有解也只有一个解，所以一定是累计邮箱最少的点的下一个点开始才行。无解情况：cost总共比gas还多，从结余曲线来看就是固定出发点纵坐标为出发点结余量是，曲线还在x轴下</span><br><span class="line">    // [2,0,0,0] [0,1,0,0]  开始点是0则哪都去不了，违背上面的规律。</span><br><span class="line">    // 还是得用这种。累计油量新低不代表行不通。</span><br><span class="line">    public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        // 为了适配[0,2,0,0,0] [0,0,1,0,0]情况，将res设定为gas最多的点。不行，去掉</span><br><span class="line">        int res = 0;</span><br><span class="line">        int maxGas = Integer.MIN_VALUE;</span><br><span class="line">        // for (int i = 0; i &lt; gas.length; i ++) &#123;</span><br><span class="line">        //     if (gas[i] &gt; maxGas) &#123;</span><br><span class="line">        //         res = i;</span><br><span class="line">        //         maxGas= gas[i];</span><br><span class="line">        //     &#125;</span><br><span class="line">        // &#125;</span><br><span class="line">        int totalSum = 0;</span><br><span class="line">        int currentSum = 0;</span><br><span class="line">        for (int i = 0; i &lt; gas.length; i++) &#123;</span><br><span class="line">            int netGas = gas[i] - cost[i];</span><br><span class="line">            totalSum += netGas;</span><br><span class="line">            currentSum += netGas;</span><br><span class="line">            // 如果当前累计的净油量小于0，那么不能从之前的起点出发，需要将起点设置为下一个站点</span><br><span class="line">            if (currentSum &lt; 0) &#123;</span><br><span class="line">                res = i + 1;</span><br><span class="line">                currentSum = 0; // 重置当前累计油量</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果总油量小于总成本，无法绕环行驶</span><br><span class="line">        if (totalSum &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 由于加油站是环形的，如果可以绕行整个环路，返回计算出的起点</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p>给定一个二叉树，我们在树的节点上安装摄像头。<br>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>计算监控树的所有节点所需的最小摄像头数量。</p>
<p>标签：贪心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 监控二叉树</span><br><span class="line">    // 给定一个二叉树，要在二叉树上装摄像头，每个摄像头可以监控当前节点、父节点、直接子对象，返回最少需要几个摄像头</span><br><span class="line">    // 思路：局部最优到全局最优，就是摄像头尽量往头节点而不是叶子节点放，所以是后序遍历</span><br><span class="line">    // 为什么不是层序遍历：这里涉及到状态转移，父节点的状态依赖于叶子结点的状态，并且层序是从上到下，不合适。</span><br><span class="line">    // 状态转移：三种状态：有摄像头、无摄像头有覆盖、无摄像头无覆盖。空节点应该是无摄像头有覆盖</span><br><span class="line">    public int minCameraCover(TreeNode root) &#123;</span><br><span class="line">        // 注意：如果根节点是3，根节点需要装一个</span><br><span class="line">        if (dfs(root) == 3)  minCameraRes ++;</span><br><span class="line">        return minCameraRes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int minCameraRes;</span><br><span class="line"></span><br><span class="line">    // 返回：1.有摄像头 2.无摄像头有覆盖 3.无摄像头无覆盖</span><br><span class="line">    private int dfs(TreeNode node) &#123;</span><br><span class="line">        if (null == node) return 2;</span><br><span class="line">        int left = dfs(node.left);</span><br><span class="line">        int right = dfs(node.right);</span><br><span class="line">        if (left == 3 || right == 3) &#123;minCameraRes ++; return 1;&#125;</span><br><span class="line">        if (left == 1 || right == 1) return 2;</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p>
<p>标签：单调栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 每日温度</span><br><span class="line">    // 输入temperatures数组表示每天的温度</span><br><span class="line">    // 输出数组表示改天之后的下一个更高温天出现在几天后，如果没有用0代替</span><br><span class="line">    // 思路：单调栈，因为要找更高温，所以用单调不递增的单调栈</span><br><span class="line">    // 单调栈：</span><br><span class="line">    // 如果要加入的数大于栈顶元素，则应该弹出栈，直到栈顶元素&gt;=加入的数。表示弹出的数的右边第一高就是要加入的数</span><br><span class="line">    // 如果要加入的数小于等于栈顶元素，则加入</span><br><span class="line">    // peek返回栈顶元素不移除  pop移除栈顶元素  push向栈加入一个元素</span><br><span class="line">    // 输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">    // 输出: [1,1,4,2,1,1,0,0]</span><br><span class="line">    public int[] dailyTemperatures(int[] temperatures) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">        int[] res = new int[temperatures.length];</span><br><span class="line">        // 遍历入栈出栈</span><br><span class="line">        for (int i = 0; i &lt; temperatures.length; i ++) &#123;</span><br><span class="line">            // 如果栈顶元素小，就弹出</span><br><span class="line">            while (!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt; temperatures[i]) &#123;</span><br><span class="line">                int index = stack.pop();</span><br><span class="line">                res[index] = i - index;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        // 还在栈里的元素右边就没有比它更大的了</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            res[stack.pop()] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="移掉k位数字"><a href="#移掉k位数字" class="headerlink" title="移掉k位数字"></a>移掉k位数字</h2><p>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
<p>输入：num = “1432219”, k = 3<br>输出：”1219”<br>解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 移除k位数字</span><br><span class="line">    // 输入：一个字符串表示的非负整数num，和一个整数k，表示需要从num中移除k位</span><br><span class="line">    // 输出：移除k位后的最小数</span><br><span class="line">    // 例如：10200 和 1  输出200。1432219 和 3 输出1219</span><br><span class="line">    // 思路：从前往后遍历，如果前&gt;后，就移除。不行，会漏掉前面的大数。除非每次只删除一个数。</span><br><span class="line">    // 单调栈：每日温度是要获取后面大的数的位置，弹出前面小的位置，用单调递减的。这里要弹出前面大的，所以用单调递增</span><br><span class="line">    // 总结：要弹出小的，单调递减。要弹出大的，单调递增。(从栈底到栈顶)</span><br><span class="line">    public String removeKdigits(String num, int k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">        for (char ch : num.toCharArray()) &#123;</span><br><span class="line">            int n = ch - &#x27;0&#x27;;</span><br><span class="line">            // 如果栈顶元素更大，就弹出</span><br><span class="line">            while (!stack.isEmpty() &amp;&amp; k &gt; 0 &amp;&amp; stack.peek() &gt; n) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                k --;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(n);</span><br><span class="line">        &#125;</span><br><span class="line">        // 没删完，就删后面大的，也就是出栈</span><br><span class="line">        while (k -- &gt; 0) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        // 开始计算，栈顶是个位。用int记录结果会导致数据溢出，所以用StringBuilder</span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            // 从栈底加数据</span><br><span class="line">            builder.append(stack.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        // 移除前导零</span><br><span class="line">        while (builder.length() &gt; 1 &amp;&amp; builder.charAt(0) == &#x27;0&#x27;) &#123;</span><br><span class="line">            builder.deleteCharAt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果移除所有数字，返回 &quot;0&quot;</span><br><span class="line">        if (builder.length() == 0) &#123;</span><br><span class="line">            return &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下一个更大元素"><a href="#下一个更大元素" class="headerlink" title="下一个更大元素"></a>下一个更大元素</h2><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</p>
<p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。</p>
<p>对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</p>
<p>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。</p>
<p>输入：nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出：[-1,3,-1]</p>
<p>标签：单调栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 下一个更大元素1</span><br><span class="line">    // 输入两个数组，两个数组都没重复，数组1是数组2的子集</span><br><span class="line">    // 返回数组1的数字在数组2中位置右边第一个比它大的数，没有就返回-1</span><br><span class="line">    // 例子：[4,1,2] [1,3,4,2] 返回[-1,3,-1]</span><br><span class="line">    // 思路：和每日温度类似，只不过每日温度就一个当前数组。这个问题就需要遍历过程记录数字对应的右边第一个大的数</span><br><span class="line">    // 使用单调不递增的单调栈，弹出小的</span><br><span class="line">    public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">        // map记录nums1的 数-index 映射</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums1.length; i ++) &#123;</span><br><span class="line">            map.put(nums1[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res = new int[nums1.length];</span><br><span class="line">        Arrays.fill(res, -1);</span><br><span class="line">        for (int value : nums2) &#123;</span><br><span class="line">            // 栈顶小的话就弹出</span><br><span class="line">            while (!stack.isEmpty() &amp;&amp; stack.peek() &lt; value) &#123;</span><br><span class="line">                int num2 = stack.pop();</span><br><span class="line">                if (map.containsKey(num2)) &#123;</span><br><span class="line">                    res[map.get(num2)] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下一个更大元素-II"><a href="#下一个更大元素-II" class="headerlink" title="下一个更大元素 II"></a>下一个更大元素 II</h2><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。</p>
<p>数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。</p>
<p>输入: nums = [1,2,1]<br>输出: [2,-1,2]</p>
<p>标签：单调栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    // 下一个更大元素2</span><br><span class="line">    // 输入一个数组，把它当作循环数组。返回数组元素下一个更大元素，如果不存在则输出-1</span><br><span class="line">    // 思路：直接把数组copy一份放后面就ok。但是倒也不用真的复制一份，遍历2size就行</span><br><span class="line">    // 使用单调不递增单调栈，弹出小的</span><br><span class="line">    public int[] nextGreaterElements(int[] nums) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">        int[] res = new int[nums.length];</span><br><span class="line">        Arrays.fill(res, -1);</span><br><span class="line">        for (int i = 0; i &lt; nums.length * 2; i ++) &#123;</span><br><span class="line">            int index = i % nums.length;</span><br><span class="line">            while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[index]) &#123;</span><br><span class="line">                int topIndex = stack.pop();</span><br><span class="line">                res[topIndex] = nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(index);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 01背包问题</span><br><span class="line">// 输入：重量数组、价值数组、背包最大容量。每个物品仅能用一次。</span><br><span class="line">// 输出：背包能容纳的最大价值</span><br><span class="line">// 动态规划步骤：</span><br><span class="line">// 1.确定dp数组以及下标的含义</span><br><span class="line">// 2.确定递推公式</span><br><span class="line">// 3.dp数组如何初始化</span><br><span class="line">// 4.确定遍历顺序</span><br><span class="line">// 5.举例推导dp数组</span><br><span class="line">public static int maxPackage(int[] weight, int[] value, int size) &#123;</span><br><span class="line">    // 1.确定dp数组：二维dp[i][j]，i表示购买到第i个物品，j表示用了j背包容量</span><br><span class="line">    int[][] dp = new int[weight.length][size + 1];</span><br><span class="line">    // 2.确定递推公式：要i和不要i: dp[i][j] = Math.max(dp[i-1][j-weight[i]] + value[i], dp[i-1][j]);</span><br><span class="line">    // 遍历顺序：先物品再size</span><br><span class="line">    // 3.初始化:i=0时，只有j大于等于了weight[0]才可以有value[0]的价值</span><br><span class="line">    for (int j = weight[0]; j &lt;= size; j ++) &#123;</span><br><span class="line">        dp[0][j] = value[0];</span><br><span class="line">    &#125;</span><br><span class="line">    // 4.开始遍历 外层是物品 内层是大小size</span><br><span class="line">    for (int i = 1; i &lt; weight.length; i ++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= size; j ++) &#123;</span><br><span class="line">            // 放不下当前物品</span><br><span class="line">            if (j &lt; weight[i]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - 1][j - weight[i]] + value[i], dp[i-1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[weight.length - 1][size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 01背包问题使用一维数组，表示容量为j时的最大价值</span><br><span class="line">// 其实也可以不用对i=0初始化，一维的不用加判断，但是二维的就得加了</span><br><span class="line">public static int maxPackage1(int[] weight, int[] value, int size) &#123;</span><br><span class="line">    int[] dp = new int[size + 1];</span><br><span class="line">//        for (int i = weight[0]; i &lt;= size; i ++) &#123;</span><br><span class="line">//            dp[i] = value[0];</span><br><span class="line">//        &#125;</span><br><span class="line">    for (int i = 0; i &lt; weight.length; i ++) &#123;</span><br><span class="line">        // 注意：遍历顺序应该从右往左了，确保取数相当于还是从上一层取</span><br><span class="line">        // 如果还是从左到右，后面的元素就可能因为前边元素的变化而变化，不是由上一层的元素推出来的了</span><br><span class="line">        // 现实意义表示一个物品用了多次</span><br><span class="line">        for (int j = size; j &gt; 0; j --) &#123;</span><br><span class="line">            if (j &gt;= weight[i])  dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 完全背包问题</span><br><span class="line">// 输入：重量数组、价值数组、背包最大容量。每个物品能用无限次</span><br><span class="line">// 输出：背包能容纳的最大价值</span><br><span class="line">// 一维数组遍历顺序从左到右</span><br><span class="line">// weight和value内元素的顺序不会有影响：因为遍历到物件，都会从容量1开始遍历</span><br><span class="line">public static int maxPackageTotal(int[] weight, int[] value, int size) &#123;</span><br><span class="line">    int[] dp = new int[size + 1];</span><br><span class="line">    for (int i = 0; i &lt; weight.length; i ++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= size; j ++) &#123;</span><br><span class="line">            if (j &gt;= weight[i])  dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p>标签：背包问题 动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 完全平方数</span><br><span class="line">    // 输入：一个整数n，返回这个整数n最少可以是几个完全平方数的和，可重复用</span><br><span class="line">    // 完全背包问题，一维数组从前往后遍历</span><br><span class="line">    public static int numSquares(int num) &#123;</span><br><span class="line">        // 1比较独特</span><br><span class="line">        if (num == 1) return 1;</span><br><span class="line">        int[] dp = new int[num + 1];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE - 1);</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        // 物品表示1-num/2</span><br><span class="line">        for (int i = 0; i &lt;= num / 2; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= num; j ++) &#123;</span><br><span class="line">                int square = (int) Math.pow(i, 2);</span><br><span class="line">                if (j &gt;= square) &#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j - square] + 1, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true</p>
<p>标签：背包问题(有顺序) 动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 单词拆分</span><br><span class="line">    // 输入一个字符串word，和一个String数组表示可以使用的单词，单词不一定全部使用，单词可以重复使用</span><br><span class="line">    // 完全背包问题，一维数组从前往后遍历</span><br><span class="line">    // 这个不同于上面的背包问题，上面的对于物品没有顺序要求，但是这里需要，如果按照上面的步骤，就会导致aba的情况无法遍历到</span><br><span class="line">    // 解决办法：先遍历size，再遍历物品。遍历顺序要先遍历背包，不能先遍历物品，因为物品得是有序的</span><br><span class="line">    public static boolean wordBreak(String word, List&lt;String&gt; words) &#123;</span><br><span class="line">        // 得初始化 word.length() + 1，因为需要dp[0]</span><br><span class="line">        boolean[] dp = new boolean[word.length() + 1];</span><br><span class="line">        // 初始化：dp[0]就行</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        // 因为需要有序，遍历先遍历背包再遍历物品</span><br><span class="line">        for (int j = 1; j &lt;= word.length(); j ++) &#123;</span><br><span class="line">            for (int i = 0; i &lt; words.size(); i ++) &#123;</span><br><span class="line">                if (j &lt; words.get(i).length())  continue;</span><br><span class="line">                // 判断该单词能否与字符尾部匹配</span><br><span class="line">                String sub = word.substring(j - words.get(i).length(), j);</span><br><span class="line">                if (sub.equals(words.get(i))) &#123;</span><br><span class="line">                    dp[j] = dp[j] || dp[j - words.get(i).length()];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">        return dp[word.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子序列（不连续）"><a href="#最长公共子序列（不连续）" class="headerlink" title="最长公共子序列（不连续）"></a>最长公共子序列（不连续）</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   </span><br><span class="line">    // 最长公共子序列</span><br><span class="line">    // 输入：两个字符串，求最长公共子序列，可以不连续，但是顺序得正确</span><br><span class="line">    // 思想：动态规划</span><br><span class="line">    public static int longestCommonSubsequence(String s1, String s2) &#123;</span><br><span class="line">        int len1 = s1.length();</span><br><span class="line">        int len2 = s2.length();</span><br><span class="line">        // 定义dp[i][j]表示s1前i个字符和s2前j个字符的最长公共子序列长度</span><br><span class="line">        int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">        // 初始化看状态转移方程依赖于哪些状态，这里是上和左</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">                if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子串（连续）"><a href="#最长公共子串（连续）" class="headerlink" title="最长公共子串（连续）"></a>最长公共子串（连续）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 最长公共子串</span><br><span class="line">// 输入：两个字符串，求最长公共子串，要求连续</span><br><span class="line">// 思想：动态规划</span><br><span class="line">public static String maxCommonString(String s1, String s2) &#123;</span><br><span class="line">    int len1  = s1.length();</span><br><span class="line">    int len2 = s2.length();</span><br><span class="line">    int maxSize = 0;</span><br><span class="line">    // 用于记录子串String</span><br><span class="line">    int endIndex = 0;</span><br><span class="line">    // dp[i][j]表示以s1[i-1]结尾的s1和以s2[j-1]结尾的s2，并且公共子串需要包括这两个结尾字符的最长公共子串长度</span><br><span class="line">    int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">    // 需要的初始化是0，所以忽略初始化</span><br><span class="line">    for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">            if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                dp[i][j] = dp[i -1][j -1] + 1;</span><br><span class="line">                // 记录结果</span><br><span class="line">                if (dp[i][j] &gt; maxSize) &#123;</span><br><span class="line">                    maxSize = dp[i][j];</span><br><span class="line">                    endIndex = i - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxSize &gt; 0 ? s1.substring(endIndex - maxSize + 1, endIndex + 1) : &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="最长回文子串-1"><a href="#最长回文子串-1" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<p>标签：动态规划</p>
<p>方法一：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  </span><br><span class="line">    // 最长回文子串</span><br><span class="line">    // 给定一个字符串，返回它的最长回文子串，这个子串需要是连续的子串</span><br><span class="line">    // 思路：和本字符串反转的用最长公共子串，就是回文子串。需要增加一个判断条件：索引位置是否镜像。</span><br><span class="line">    // 如果不判断，abaxab和baxaba就会把ab、ba当作回文串</span><br><span class="line">    public static String longestPalindrome(String s) &#123;</span><br><span class="line">        String s2 = new StringBuilder(s).reverse().toString();</span><br><span class="line">        int len = s.length();</span><br><span class="line">        int maxSize = 0;</span><br><span class="line">        // 用于记录子串String</span><br><span class="line">        int endIndex = 0;</span><br><span class="line">        // dp[i][j]表示以s1[i-1]结尾的s1和以s2[j-1]结尾的s2，并且公共子串需要包括这两个结尾字符的最长公共子串长度</span><br><span class="line">        int[][] dp = new int[len + 1][len + 1];</span><br><span class="line">        // 需要的初始化是0，所以忽略初始化</span><br><span class="line">        for (int i = 1; i &lt;= len; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len; j ++) &#123;</span><br><span class="line">                if (s.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i -1][j -1] + 1;</span><br><span class="line">                    // 记录结果，并检查子串的索引是否镜像，以确保它是回文. 1213 3121 i=3 dp=3 len=4 j=4</span><br><span class="line">                    if (dp[i][j] &gt; maxSize &amp;&amp; i - dp[i][j] == len - j) &#123;</span><br><span class="line">                        maxSize = dp[i][j];</span><br><span class="line">                        endIndex = i - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(endIndex - maxSize + 1, endIndex + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：另一个dp含义的动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  </span><br><span class="line">    public static String longestPalindrome(String s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        // dp[i][j]表示下标i-j的字符串是否是回文字符串，j&gt;=i</span><br><span class="line">        boolean[][] dp = new boolean[len][len];</span><br><span class="line">        int maxLen = 0;</span><br><span class="line">        String res = &quot;&quot;;</span><br><span class="line">        // 遍历顺序：左下到右上，因为用到[i+1][j-1]</span><br><span class="line">        for (int i = len - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">            for (int j = i; j &lt; len; j ++) &#123;</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    // 相差&lt;=1肯定回文，不是就要看中间是不是</span><br><span class="line">                    if (j -i &lt;= 1 || dp[i + 1][j - 1]) &#123;</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                        if (j - i + 1 &gt; maxLen) &#123;</span><br><span class="line">                            maxLen = j - i + 1;</span><br><span class="line">                            res = s.substring(i, j + 1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p>
<p>回文字符串 是正着读和倒过来读一样的字符串。</p>
<p>子字符串 是字符串中的由连续字符组成的一个序列。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>输入：s = “aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 回文子串</span><br><span class="line">    // 输入一个字符串返回有多少个回文子串。子串：连续的字符组成的。字符串相等，但是位置不同也算不同的子串</span><br><span class="line">    // 思路：动态规划，不用反转字符串，直接动态规划</span><br><span class="line">    //01 dp[i][j]的定义 是在 i-j这个区间内的 是不是回文</span><br><span class="line">    //02 更新方法: 这里是如果 ij的char相等 且 gap &lt;= 1那一定就是回文；要是gap &gt; 1那就要看 dp[i+1][j-1]是不是回文；</span><br><span class="line">    //03 更新顺序， 是从左下到右上，因为需要i+1 和 j-1 所以是从左下开始</span><br><span class="line">    // 注：最长回文子串也可以使用该方法</span><br><span class="line">    public static int countSubstrings(String s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        // dp[i][j]表示下标i-j的字符串是否是回文字符串，j&gt;=i</span><br><span class="line">        boolean[][] dp = new boolean[len][len];</span><br><span class="line">        int res = 0;</span><br><span class="line">        // 遍历顺序：左下到右上，因为用到[i+1][j-1]</span><br><span class="line">        for (int i = len - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">            for (int j = i; j &lt; len; j ++) &#123;</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    // 相差&lt;=1肯定回文，不是就要看中间是不是</span><br><span class="line">                    if (j -i &lt;= 1 || dp[i + 1][j - 1]) &#123;</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                        res ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p>输入：s = “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” 。</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    // 最长回文子序列</span><br><span class="line">    //01 dp[i][j] 表示 i-j区间内的最长回文子序列的长度；</span><br><span class="line">    //02 更新方法是 如果 s[i] = s[j] 那就在 s[i-1][j-1]的基础上+2；要是不相等的话，那就取 [i+1,j] 和 [i, j-1]区间内比较大的那个回文子串数目，也就是max(dp[i+1][j], dp[i][j-1])；</span><br><span class="line">    //03 遍历顺序 还是从左下到右上；</span><br><span class="line">    //04 初始化对角线</span><br><span class="line">    public static int longestPalindromeSubseq(String s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        // dp表示字符串i-j的最长回文子序列长度</span><br><span class="line">        int[][] dp = new int[len][len];</span><br><span class="line">        // 初始化对角线</span><br><span class="line">        for (int i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">            dp[i][i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从左下开始遍历</span><br><span class="line">        for (int i = len - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; len; j ++) &#123;</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + 1][j -1] + 2;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][len - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>输入：s = “abc”, t = “ahbgdc”<br>输出：true</p>
<p>标签：双指针、动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 判断子序列</span><br><span class="line">    // 输入字符串s和字符串t，判断s是否是t的子序列  abc是ajisbshc的子序列，出现顺序得一样</span><br><span class="line">    // 思路：1.双指针</span><br><span class="line">    public static boolean isSubsequence(String s, String t) &#123;</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        while (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;</span><br><span class="line">            if (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return i == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 思路2：动态规划</span><br><span class="line">    // 1.可以用最长公共子序列，得到的结果为s的长度，就是子序列。dp表示公共子序列长度</span><br><span class="line">    // 2.dp也可以表示是否是子序列boolean，但是状态转移要注意：dp[i][j] = dp[i][j-1]; 不能有dp[i-1][j]，因为可能去掉s的一个字符，可能就是子序列了，但是加上不行</span><br><span class="line">    public static boolean isSubsequence(String s, String t) &#123;</span><br><span class="line">        int len1 = s.length();</span><br><span class="line">        int len2 = t.length();</span><br><span class="line">        // 定义dp[i][j]表示s1前i个字符和s2前j个字符的最长公共子序列长度</span><br><span class="line">        int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">        // 初始化看状态转移方程依赖于哪些状态，这里是上和左</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">                if (s.charAt(i - 1) == t.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len1][len2] == len1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，结果需要对 109 + 7 取模。</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 不同的子序列</span><br><span class="line">    // 输入s1，s2，求s1的子序列中s2出现的次数</span><br><span class="line">    // 例如：rabbbit中rabbit出现了3次</span><br><span class="line">    // 两个字符串谁对应i谁对应j，无所谓。状态转移对了就行</span><br><span class="line">    // babgbag bag 返回5</span><br><span class="line">    public static int numDistinct(String s1, String s2) &#123;</span><br><span class="line">        int len1 = s1.length();</span><br><span class="line">        int len2 = s2.length();</span><br><span class="line">        // dp[i][j]表示字符串s1的前i个字符的子序列中s2的前j个字符出现的次数</span><br><span class="line">        int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">        // 初始化 其实dp[0][j] 和 dp[i][0] 没什么实际意义，但是看状态转移需要确定初始化</span><br><span class="line">        // 注意初始化，dp[i][0] 都需要初始化为1</span><br><span class="line">        for (int i = 0; i &lt; len1; i ++) &#123;</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">                if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                    // 相等的情况 j是要匹配的字符串，不能动</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 不相等的情况</span><br><span class="line">                    // 注意：不是 dp[i][j] = dp[i - 1][j] + dp[i - 2][j] + ....; 这种是重复计算的</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h2><p>给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。</p>
<p>每步 可以删除任意一个字符串中的一个字符。</p>
<p>输入: word1 = “sea”, word2 = “eat”<br>输出: 2</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   </span><br><span class="line">    // 两个字符串的互相删除操作</span><br><span class="line">    // 输入两个字符串，返回使得两个字符串相等的最小步数，每一步可以删除任意一个字符串中的任意一个字符</span><br><span class="line">    // 例如：sea、eat 两步</span><br><span class="line">    // 思路：直接动态规划</span><br><span class="line">    public static int minDistance(String s1, String s2) &#123;</span><br><span class="line">        int len1 = s1.length();</span><br><span class="line">        int len2 = s2.length();</span><br><span class="line">        // dp[i][j]表示s1的前i个字符和s2的前j个字符的删除距离，</span><br><span class="line">        int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">        // 根据下面的状态转移推断如何初始化：</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">            dp[0][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">                if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 不相等，不用考虑dp[i-1][j-1]，因为这俩已经考虑了</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<p>输入：word1 = “horse”, word2 = “ros”<br>输出：3</p>
<p>标签：动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    // 编辑距离</span><br><span class="line">    // 输入两个字符串，求编辑距离：可以删除、插入、替换。使得相等的最少操作数。</span><br><span class="line">    // intention、execution 5</span><br><span class="line">    public static int minDistance(String s1, String s2) &#123;</span><br><span class="line">        int len1 = s1.length();</span><br><span class="line">        int len2 = s2.length();</span><br><span class="line">        // dp[i][j]表示s1前i个字符和s2的前j个字符的最小编辑距离</span><br><span class="line">        int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line">        // 和删除距离一样的初始化</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">            dp[0][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= len1; i ++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len2; j ++) &#123;</span><br><span class="line">                if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 删一个/加一个/修改一个</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>输入：”abbaca”<br>输出：”ca”</p>
<p>标签：栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public static String removeDuplicates(String s) &#123;</span><br><span class="line">        Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            if (stack.isEmpty()) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                char top = stack.peek();</span><br><span class="line">                if (c == top) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(stack.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/leecode/" rel="tag"># leecode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/25/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/mysql%E6%8A%80%E5%B7%A7/" rel="prev" title="Mysql技巧">
      <i class="fa fa-chevron-left"></i> Mysql技巧
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/05/myblog/JAVA/Page%E5%88%86%E9%A1%B5/" rel="next" title="Page分页">
      Page分页 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#int%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">int数组的排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int-%E5%92%8CList%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.</span> <span class="nav-text">int[]和List转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">栈和队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">4.</span> <span class="nav-text">两数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">5.</span> <span class="nav-text">两链表表示的数相加</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E5%AD%90%E4%B8%B2"><span class="nav-number">6.</span> <span class="nav-text">字符串的最长无重复字符子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">寻找两个正序数组的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">8.</span> <span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="nav-number">9.</span> <span class="nav-text">Z字形变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">10.</span> <span class="nav-text">整数反转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86"><span class="nav-number">11.</span> <span class="nav-text">二分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0"><span class="nav-number">12.</span> <span class="nav-text">字符串转换为整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB"><span class="nav-number">13.</span> <span class="nav-text">到最近的人的最大距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E6%95%B0"><span class="nav-number">14.</span> <span class="nav-text">回文数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">15.</span> <span class="nav-text">盛最多水的容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="nav-number">16.</span> <span class="nav-text">整数转罗马数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">17.</span> <span class="nav-text">合并两个有序数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">18.</span> <span class="nav-text">移除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">19.</span> <span class="nav-text">删除有序数组中的重复项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II"><span class="nav-number">20.</span> <span class="nav-text">删除有序数组中的重复项 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-number">21.</span> <span class="nav-text">多数元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-number">22.</span> <span class="nav-text">轮转数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">23.</span> <span class="nav-text">买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2"><span class="nav-number">24.</span> <span class="nav-text">买卖股票的最佳时机2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA3"><span class="nav-number">25.</span> <span class="nav-text">买卖股票的最佳时机3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA4"><span class="nav-number">26.</span> <span class="nav-text">买卖股票的最佳时机4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="nav-number">27.</span> <span class="nav-text">买卖股票含冷冻期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="nav-number">28.</span> <span class="nav-text">买卖股票含手续费</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-number">29.</span> <span class="nav-text">跳跃游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F2"><span class="nav-number">30.</span> <span class="nav-text">跳跃游戏2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F3"><span class="nav-number">31.</span> <span class="nav-text">跳跃游戏3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#N%E7%9A%87%E5%90%8E"><span class="nav-number">32.</span> <span class="nav-text">N皇后</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#N%E7%9A%87%E5%90%8E2"><span class="nav-number">33.</span> <span class="nav-text">N皇后2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-number">34.</span> <span class="nav-text">括号生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98"><span class="nav-number">35.</span> <span class="nav-text">岛屿问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-number">36.</span> <span class="nav-text">岛屿的最大面积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%B3%E6%B0%94%E7%90%83"><span class="nav-number">37.</span> <span class="nav-text">戳气球</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F"><span class="nav-number">38.</span> <span class="nav-text">省份数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E5%88%B0%E8%BE%BE%E7%82%B9%E6%95%B0%E9%87%8F"><span class="nav-number">39.</span> <span class="nav-text">统计无向图中无法互相到达点数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF"><span class="nav-number">40.</span> <span class="nav-text">岛屿的周长</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A3%E6%A9%B1%E6%95%B4%E7%90%86-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="nav-number">41.</span> <span class="nav-text">衣橱整理&#x2F;机器人的运动范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-number">42.</span> <span class="nav-text">单词搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="nav-number">43.</span> <span class="nav-text">腐烂的橘子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96"><span class="nav-number">44.</span> <span class="nav-text">最小基因变化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99"><span class="nav-number">45.</span> <span class="nav-text">单词接龙</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F4"><span class="nav-number">46.</span> <span class="nav-text">跳跃游戏4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C1%EF%BC%88%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%E5%A4%8D%E5%8F%AF%E9%87%8D%E9%80%89%EF%BC%89"><span class="nav-number">47.</span> <span class="nav-text">组合总和1（元素无重复可重选）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C2%EF%BC%88%E5%85%83%E7%B4%A0%E9%87%8D%E5%A4%8D%E4%B8%8D%E5%8F%AF%E9%87%8D%E9%80%89%EF%BC%89"><span class="nav-number">48.</span> <span class="nav-text">组合总和2（元素重复不可重选）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C3%EF%BC%88k%E4%B8%AA%E6%95%B0%E5%92%8C%E4%B8%BAn%EF%BC%89"><span class="nav-number">49.</span> <span class="nav-text">组合总和3（k个数和为n）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-number">50.</span> <span class="nav-text">电话号码的字母组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">51.</span> <span class="nav-text">分割回文串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80"><span class="nav-number">52.</span> <span class="nav-text">复原 IP 地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E9%9B%86"><span class="nav-number">53.</span> <span class="nav-text">子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E9%9B%862"><span class="nav-number">54.</span> <span class="nav-text">子集2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">55.</span> <span class="nav-text">递增子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%EF%BC%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E9%80%89%EF%BC%89"><span class="nav-number">56.</span> <span class="nav-text">全排列（元素无重，不可重选）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%972%EF%BC%88%E5%85%83%E7%B4%A0%E5%8F%AF%E9%87%8D%EF%BC%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E9%80%89%EF%BC%89"><span class="nav-number">57.</span> <span class="nav-text">全排列2（元素可重，不可重选）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="nav-number">58.</span> <span class="nav-text">解数独</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">59.</span> <span class="nav-text">同构字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E4%B8%93%E6%A0%8F"><span class="nav-number">60.</span> <span class="nav-text">贪心专栏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="nav-number">61.</span> <span class="nav-text">分发饼干</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#K-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">62.</span> <span class="nav-text">K 次取反后最大化的数组和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="nav-number">63.</span> <span class="nav-text">柠檬水找零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="nav-number">64.</span> <span class="nav-text">整数拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">65.</span> <span class="nav-text">零钱兑换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="nav-number">66.</span> <span class="nav-text">摆动序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B3%B0%E4%B8%8E%E8%B0%B7"><span class="nav-number">67.</span> <span class="nav-text">峰与谷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">68.</span> <span class="nav-text">单调递增的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">69.</span> <span class="nav-text">最大子数组和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">70.</span> <span class="nav-text">最长连续递增子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="nav-number">71.</span> <span class="nav-text">分发糖果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">72.</span> <span class="nav-text">根据身高重建队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">73.</span> <span class="nav-text">合并区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="nav-number">74.</span> <span class="nav-text">用最少数量的箭引爆气球</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="nav-number">75.</span> <span class="nav-text">无重叠区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="nav-number">76.</span> <span class="nav-text">划分字母区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E8%A1%8C%E8%B5%B0%E6%9C%BA%E5%99%A8%E4%BA%BA"><span class="nav-number">77.</span> <span class="nav-text">模拟行走机器人</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="nav-number">78.</span> <span class="nav-text">加油站</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">79.</span> <span class="nav-text">监控二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-number">80.</span> <span class="nav-text">每日温度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="nav-number">81.</span> <span class="nav-text">移掉k位数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">82.</span> <span class="nav-text">下一个更大元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-II"><span class="nav-number">83.</span> <span class="nav-text">下一个更大元素 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">84.</span> <span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-number">85.</span> <span class="nav-text">完全平方数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">86.</span> <span class="nav-text">单词拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%8D%E8%BF%9E%E7%BB%AD%EF%BC%89"><span class="nav-number">87.</span> <span class="nav-text">最长公共子序列（不连续）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%EF%BC%88%E8%BF%9E%E7%BB%AD%EF%BC%89"><span class="nav-number">88.</span> <span class="nav-text">最长公共子串（连续）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-1"><span class="nav-number">89.</span> <span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">90.</span> <span class="nav-text">回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">91.</span> <span class="nav-text">最长回文子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">92.</span> <span class="nav-text">判断子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">93.</span> <span class="nav-text">不同的子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">94.</span> <span class="nav-text">两个字符串的删除操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">95.</span> <span class="nav-text">编辑距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">96.</span> <span class="nav-text">删除字符串中的所有相邻重复项</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jade liu"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Jade liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">104</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jadeliuliu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jadeliuliu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jadeliu1998@163.com" title="E-Mail → mailto:jadeliu1998@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jadeliu1998" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;jadeliu1998" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5823044646" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5823044646" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jade liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
