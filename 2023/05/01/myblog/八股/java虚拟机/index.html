<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="八股文 - java内存模型 ✅java内存模型虚拟机自动内存管理机制：不再需要像 C&#x2F;C++为每一个 new 操作去写对应的 delete&#x2F;free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机。JDK 1.8 之前 ：￼JDK 1.8 之后 ：￼线程私有的：  程序计数器 虚拟机栈 本地方法栈线程共享的： 堆 方法区 直接内存 (非运行">
<meta property="og:type" content="article">
<meta property="og:title" content="java虚拟机">
<meta property="og:url" content="http://example.com/2023/05/01/myblog/%E5%85%AB%E8%82%A1/java%E8%99%9A%E6%8B%9F%E6%9C%BA/index.html">
<meta property="og:site_name" content="Jadeliu&#39;s blog">
<meta property="og:description" content="八股文 - java内存模型 ✅java内存模型虚拟机自动内存管理机制：不再需要像 C&#x2F;C++为每一个 new 操作去写对应的 delete&#x2F;free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机。JDK 1.8 之前 ：￼JDK 1.8 之后 ：￼线程私有的：  程序计数器 虚拟机栈 本地方法栈线程共享的： 堆 方法区 直接内存 (非运行">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-05-01T10:19:42.337Z">
<meta property="article:modified_time" content="2023-05-01T10:21:15.486Z">
<meta property="article:author" content="Jade liu">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/05/01/myblog/%E5%85%AB%E8%82%A1/java%E8%99%9A%E6%8B%9F%E6%9C%BA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>java虚拟机 | Jadeliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jadeliu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/01/myblog/%E5%85%AB%E8%82%A1/java%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java虚拟机
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-01 18:19:42 / Modified: 18:21:15" itemprop="dateCreated datePublished" datetime="2023-05-01T18:19:42+08:00">2023-05-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>八股文 - java内存模型</p>
<h3 id="✅java内存模型"><a href="#✅java内存模型" class="headerlink" title="✅java内存模型"></a>✅java内存模型</h3><p>虚拟机自动内存管理机制：不再需要像 C/C++为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机。<br>JDK 1.8 之前 ：<br>￼<br>JDK 1.8 之后 ：<br>￼<br>线程私有的：</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈<br>线程共享的：</li>
<li>堆</li>
<li>方法区</li>
<li>直接内存 (非运行时数据区的一部分)<br>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</li>
</ul>
<p>1、程序计数器：<br>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<br>程序计数器主要有两个作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
<li>程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</li>
</ul>
<p>2、Java 虚拟机栈<br>1.存放：在函数中定义的一些基本类型的变量(8种，int, short, long, byte, float, double, boolean, char，不包含String)和对象的引用变量、main方法、方法函数、局部变量<br>2.Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。<br>3.栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。<br>4.方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。<br>5.栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。<br>6.局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。<br>7.操作数栈主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。<br>8.动态链接主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池（方法区里的）里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。<br>9.Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。<br>10.栈可能会出现两种错误：</p>
<ul>
<li>StackOverFlowError： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。（hotspot虚拟机的栈容量是不允许动态扩展的）</li>
<li>OutOfMemoryError： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。hotspot不支持扩展。</li>
</ul>
<p>3、本地方法栈<br>1.和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<br>2.本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。<br>3.方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p>
<p>4、堆<br>1.Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。<br>2.随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。<br>3.Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。<br>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永久代(Permanent Generation)<br>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存<br>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。<br>晋升到老年代的条件：<br>“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</li>
<li>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</li>
<li>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li>java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值</li>
</ol>
<p>5、方法区<br>1.方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。<br>2.当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。<br>3.方法区和永久代以及元空间是什么关系呢？<br>方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。<br>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</p>
<ol>
<li>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。当元空间溢出时会得到如下错误： java.lang.OutOfMemoryError: MetaSpace。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</li>
<li>元空间里面存放的是类的元数据，这样加载多少类的元数据就方法区大小控制, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</li>
<li>并非数据进入方法区后就“永久存在”了，元空间使用的是直接内存，与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存</li>
</ol>
<p>6、运行时常量池<br>1.Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 常量池表(Constant Pool Table) 。<br>2.字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量，符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。<br>3.常量池表会在类加载后存放到方法区的运行时常量池中。<br>5.运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。<br>6.既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>
<p>7、字符串常量池<br>1.字符串常量池是JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。<br>// 在堆中创建字符串对象”ab“<br>// 将字符串对象”ab“的引用保存在字符串常量池中<br>String aa = “ab”;<br>// 直接返回字符串常量池中字符串对象”ab“的引用<br>String bb = “ab”;<br>System.out.println(aa==bb);// true<br>2.HotSpot 虚拟机中字符串常量池的实现是 src/hotspot/share/classfile/stringTable.cpp ,StringTable 本质上就是一个HashSet<String> ,容量为 StringTableSize（可以通过 -XX:StringTableSize 参数来设置）<br>3.StringTable 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。<br>4.JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。<br>JDK 1.7 为什么要将字符串常量池移动到堆中？<br>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。还有：避免永久代溢出的问题。<br>5.JVM 常量池中存储的是对象还是引用呢？<br>目前认为是引用</String></p>
<p>8、直接内存<br>1.直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。<br>2.JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。<br>3.本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h3 id="✅string不可变"><a href="#✅string不可变" class="headerlink" title="✅string不可变"></a>✅string不可变</h3><p>1.什么是不可变对象？<br>在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ 可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。<br>String s = “123”;   s = “456”;<br>s只是一个String对象的引用，并不是对象本身。对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。当s=“456”; 这句代码执行过之后，又创建了一个新的对象“456”， 而引用s重新指向了这个新的对象，原来的对象“123”还在内存中存在，并没有改变。</p>
<p>2.java的引用和c++的指针<br>Java和C++的一个不同点是， 在Java中不可能直接操作对象本身，所有的对象都由一个引用指向，必须通过这个引用才能访问对象本身，包括获取成员变量的值，改变对象的成员变量，调用对象的方法等。而在C++中存在引用，对象和指针三个东西，这三个东西都可以访问对象。其实，Java中的引用和C++中的指针在概念上是相似的，他们都是存放的对象在内存中的地址值，只是在Java中，引用丧失了部分灵活性，比如Java中的引用不能像C++中的指针那样进行加减运算。</p>
<p>3.为什么String对象是不可变的？<br>JDK7中，String有： private final char value[]; 和private int hash; 是该String对象的哈希值的缓存。在Java中，数组也是对象，所以value也只是一个引用，它指向一个真正的数组对象。<br>被 final 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，final 关键字修饰的数组保存字符串并不是 String 不可变的根本原因，因为这个数组保存的字符串是可变的（final 修饰引用类型变量的情况）。<br>String 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。</li>
<li>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。</li>
</ol>
<p>4.在String中，存在一些方法，调用他们可以得到改变后的值。这些方法包括substring， replace， replaceAll， toLowerCase等，这些方法内部创建了一个新的String对象，并且返回这个新的对象，原来的对象是不会被改变的。这也是方法都存在返回值的原因。</p>
<p>6.String对象真的不可变吗？<br>String的成员变量是private final 的，也就是初始化之后不可改变。那么在这几个成员中， value比较特殊，因为他是一个引用变量，而不是真正的对象。value是final修饰的，也就是说final不能再指向其他数组对象，但是可以改变value指向的数组。<br>用反射， 可以反射出String对象中的value属性， 进而通过获得的value引用改变数组的结构。<br>public static void testReflection() throws Exception {</p>
<pre><code>//创建字符串&quot;Hello World&quot;， 并赋给引用s
String s = &quot;Hello World&quot;; 
    
System.out.println(&quot;s = &quot; + s);    //Hello World
    
//获取String类中的value字段
Field valueFieldOfString = String.class.getDeclaredField(&quot;value&quot;);
    
//改变value属性的访问权限
valueFieldOfString.setAccessible(true);
    
//获取s对象上的value属性的值
char[] value = (char[]) valueFieldOfString.get(s);
    
//改变value所引用的数组中的第5个字符
value[5] = &#39;_&#39;;
    
System.out.println(&quot;s = &quot; + s);  //Hello_World
</code></pre>
<p>}</p>
<p>在这个过程中，s始终引用的同一个String对象，但是再反射前后，这个String对象发生了变化， 也就是说，通过反射是可以修改所谓的“不可变”对象的。</p>
<p>7.字符串拼接用“+” 还是 StringBuilder?<br>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。<br>看对应的字节码就知道：字符串对象通过“+”的字符串拼接方式，实际上是通过创建StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。<br>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。如果直接使用 StringBuilder 对象进行字符串拼接的话，就不会存在这个问题了。</p>
<p>8.String s1 = new String(“abc”);这句话创建了几个字符串对象？<br>会创建 1 或 2 个字符串对象。<br>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。<br>ldc 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。<br>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>
<p>9.String的intern 方法<br>String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中。</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。（首次遇见的原则）</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<p>// 在堆中创建字符串对象”Java“<br>// 将字符串对象”Java“的引用保存在字符串常量池中<br>String s1 = “Java”;<br>// 直接返回字符串常量池中字符串对象”Java“对应的引用<br>String s2 = s1.intern();<br>// 会在堆中在单独创建一个字符串对象<br>String s3 = new String(“Java”);<br>// 直接返回字符串常量池中字符串对象”Java“对应的引用<br>String s4 = s3.intern();<br>// s1 和 s2 指向的是堆中的同一个对象<br>System.out.println(s1 == s2); // true<br>// s3 和 s4 指向的是堆中不同的对象<br>System.out.println(s3 == s4); // false<br>// s1 和 s4 指向的是堆中的同一个对象<br>System.out.println(s1 == s4); //true</p>
<p>String s5 = new StringBuilder(“hello”).append(“world”).toString();<br>//s5这种创建方式和String s = “sss”;  是一样的，在字符串常量池中<br>String s6 = s5.intern();<br>System.out.println(s5 == s6);  //true</p>
<p>10.String 类型的变量和常量做“+”运算时发生了什么？<br>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。<br>在编译过程中，Javac 编译器会进行一个叫做 常量折叠(Constant Folding) 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中。<br>只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。</li>
<li>final 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）<br>对于 String str3 = “str” + “ing”; 编译器会给你优化成 String str3 = “string”;<br>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</li>
</ul>
<h3 id="✅java对象的创建"><a href="#✅java对象的创建" class="headerlink" title="✅java对象的创建"></a>✅java对象的创建</h3><p>HotSpot 虚拟机在 Java 堆中对象的创建：</p>
<p>Step1:类加载检查<br>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>Step2:分配内存<br>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p>内存分配的两种方式 ：</p>
<ul>
<li>指针碰撞 ： <ul>
<li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li>空闲列表 ： <ul>
<li>适用场合 ： 堆内存不规整的情况下。</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p>
<p>内存分配并发问题<br>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li>CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li>
<li>TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<p>Step3:初始化零值<br>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>Step4:设置对象头<br>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>Step5:执行 init 方法<br>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</init></init></p>
<h3 id="✅java对象的内存布局"><a href="#✅java对象的内存布局" class="headerlink" title="✅java对象的内存布局"></a>✅java对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。</p>
<p>Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志、线程持有锁、偏向锁id、偏向时间戳等等）也叫Mark Word，32位虚拟机占32bit，64位占64bit，另一部分是类型指针，即对象指向它的类型元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是Java数组，还需要一块用于记录数组长度的数据。</p>
<p>实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</p>
<p>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="✅对象的访问定位"><a href="#✅对象的访问定位" class="headerlink" title="✅对象的访问定位"></a>✅对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。</p>
<p>句柄<br>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。<br>￼<br>直接指针<br>如果使用直接指针访问，reference 中存储的直接就是对象的地址。这样的话，java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息。<br>￼</p>
<p>这两种对象访问方式各有优势。<br>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。<br>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。<br>HotSpot 虚拟机主要使用的就是直接指针访问方式来进行对象访问。</p>
<h3 id="✅内存溢出和内存泄漏"><a href="#✅内存溢出和内存泄漏" class="headerlink" title="✅内存溢出和内存泄漏"></a>✅内存溢出和内存泄漏</h3><p>一、内存溢出 (OutOfMemory)<br>它是指程序在申请内存时，没有足够的内存空间供其使用，抛出OutOfMemory异常。<br>比如申请了一个8MB空间，但是当前内存可用空间只有5MB，那么就是内存溢出；<br>即：OutOfMemoryError，是指没有空闲内存，垃圾收集器回收后也不能提供更多的内存空间；</p>
<p>二、内存泄漏 (Memory Leak)<br>它是指程序运行后，没有释放所占用的内存空间（程序中有引用没有释放，不能被GC回收），一次内存泄漏可能不会有很大的影响，但长时间的内存泄漏，堆积到一定程度就会产生内存溢出。<br>（1）单例对象，生命周期和应用程序一样长，如果单例对象持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会产生内存泄漏。<br>（2）一些资源未关闭也会导致内存泄漏，比如数据库连接，网络连接socket的IO流的连接都必须在finally中close，否则不能被回收的。</p>
<p>内存泄漏的堆积最终会导致内存溢出，内存溢出，第一步要看导致OOM的对象是否是必要的，如果不是必要的，就有可能是内存泄漏。检查是否某些对象内存周期过长，持有状态时间过长，存储结构设计不合理等。</p>
<p>操作系统分配给每个进程的内存是有限的，32位windows是2GB。</p>
<h3 id="✅内存动态分配和垃圾收集技术"><a href="#✅内存动态分配和垃圾收集技术" class="headerlink" title="✅内存动态分配和垃圾收集技术"></a>✅内存动态分配和垃圾收集技术</h3><p>程序计数器、虚拟机栈、本地方法栈 随线程而生，随线程而灭。栈中的栈帧随方法的进入和退出执行出栈和入栈，每一个栈帧中分配多少内存载类结构确认下来时就已知了，在编译期间基本确定。<br>Java堆和方法区只有在运行期间才能知道要创建哪些对象多少对象，这部分内存的分配和回收是动态的。</p>
<p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收。<br>Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。<br>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p>
<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永久代(Permanent Generation)<br>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</li>
</ol>
<p>￼<br>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存 。</p>
<h3 id="✅死亡对象判断方法"><a href="#✅死亡对象判断方法" class="headerlink" title="✅死亡对象判断方法"></a>✅死亡对象判断方法</h3><p>对象已经死亡（即不能再被任何途径使用的对象）</p>
<p>1、引用计数法<br>给对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加 1；</li>
<li>当引用失效，计数器就减 1；</li>
<li>任何时候计数器为 0 的对象就是不可能再被使用的。<br>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</li>
</ul>
<p>2、可达性分析算法<br>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
<p>哪些对象可以作为 GC Roots 呢？</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<p>对象可以被回收，就代表一定会被回收吗？<br>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；<br>1.可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行finalize方法。<br>2.被判定为需要执行finalize方法的对象将会被放在一个队列中进行第二次标记，除非这个对象在finalize方法中与引用链上的任何一个对象建立关联。会被移出队列，否则就会被真的回收。</p>
<p>Object 类中的 finalize 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 finalize 方法会被逐渐弃用移除。用try-finally做外部资源的清理工作。</p>
<h3 id="✅对象的引用"><a href="#✅对象的引用" class="headerlink" title="✅对象的引用"></a>✅对象的引用</h3><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。<br>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）<br>1．强引用（StrongReference）<br>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj =new Object()”这种引用关系。无论任何情况下，是要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。<br>2．软引用（SoftReference）<br>软引用是用来描达一些还有用，但非必须的对象。只被软引用关联看的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出昇常。在JK 1.2版之后提供了SoftReference 类来实现软引用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。<br>3．弱引用（WeakReference）<br>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2 版之后提供了WeakReference 类来实现弱引用。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>4．虚引用（PhantomReference）<br>虚引用也称为“幽灵引用” 或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。</p>
<p>虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。<br>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</p>
<h3 id="✅回收方法区"><a href="#✅回收方法区" class="headerlink" title="✅回收方法区"></a>✅回收方法区</h3><p>方法区的垃圾收集回收两部分：废弃的常量和不再使用的类型。</p>
<p>1、如何判断一个常量是废弃常量？<br>运行时常量池主要回收的是废弃的常量。<br>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p>
<p>运行时常量池和字符串常量池关系：<br>1、JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代<br>2、JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。<br>3、JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</p>
<p>Java中的运行时常量池和字符串常量池是两个不同的概念，但它们之间存在一定的关系。<br>运行时常量池是位于方法区中的一块内存区域，用于存储编译期生成的各种字面量和符号引用。这些字面量包括整点、浮点数、字符、字符串等，符号引用包括类的全限定名、宇段名称、方法名称等。运行时常量池中的内容在类加载时被加载，并旦在运行期间不可更改。<br>字符串常量池是运行时常量池中的一部分，用于存储所有字符串字面量。当程序中使用字符串常量时，JVM会首先在字符串常量池中查找是否己经存在相同的宇符串，如果存在则直接返回常量池中的引用，否则将该字符串添加到常量池中。<br>因此，字符串常量池是运行时常池中的一个子集， 是用于存储字符串字面量的特殊区域。同时，由于字符串在Java中是非常常用的数据类型，因此字符串常量池在Java中也是一个比较重要的概念。<br>但是，不同的jdk版本字符串常量池的实现不同。</p>
<p>2、如何判断一个类是无用的类<br>类需要同时满足下面 3 个条件才能算是 “无用的类” ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</li>
</ul>
<h3 id="✅什么是java动态类"><a href="#✅什么是java动态类" class="headerlink" title="✅什么是java动态类"></a>✅什么是java动态类</h3><p>Java动态类是指在程序运行期间动态创建的类，在编写程序时不需要预先定义它们。这些类通常是通过反射机制创建的，并且可以在运行时添加、修改或删除类的属性和方法。<br>Java动态类可以有许多用途，例如在运行时生成代理类、动态加载类、实现动态代理等。它们通常使用java的反射机制和字节码操作技术实现，可以提供更加灵活和动态的程序设计方式。</p>
<p>在Java中，使用static关键字修饰的类被称为静态内部类，而不是静态类。静态内部类是指在类的内部定义的另一个类，与外部类同级别，但是可以使用static关键字修饰来标记为静态内部类，而不是非静态内部类。静态内部类可以直接通过外部类名来访问，无需通过外部类实例化对象，可以看做是外部类的一个静态成员。但需要注意的是，静态内部类不能访问外部类的非静态成员，只能访问静态成员。因此，静态内部类的作用范国只在外部类中，而不会影响到其他的类。</p>
<h3 id="✅垃圾收集算法"><a href="#✅垃圾收集算法" class="headerlink" title="✅垃圾收集算法"></a>✅垃圾收集算法</h3><p>根据如何判定对象消亡，分为引用计数式垃圾收集和追踪式垃圾收集。引用计数式垃圾收集在主流java虚拟机中未涉及。</p>
<h3 id="✅分代收集理论"><a href="#✅分代收集理论" class="headerlink" title="✅分代收集理论"></a>✅分代收集理论</h3><p>根据对象存活周期的不同将内存分为几块。一般将 java 堆根据对象年龄分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>
<p>基于的分代假说：<br>1.绝大多数对象朝生夕灭<br>2.熬过多次垃圾收集的对象越难以消亡<br>3.跨代引用相对于同代引用来说很少</p>
<p> 部分收集（Partial GC)：指目标不是完整收集整个Java堆的垃圾收集，其中分为：<br>◎新生代收集 (Minor GC/Young GC)：指目标只是新生代的垃圾收集。<br>◎老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。<br>◎混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1 收集器会有这种行为。<br>整堆收集(Full GC)：收集整个Java 堆和方法区的垃圾收集。</p>
<h3 id="✅标记-清除算法"><a href="#✅标记-清除算法" class="headerlink" title="✅标记-清除算法"></a>✅标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。或者标记需要回收的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。</p>
<p>这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li>效率问题（标记和清除的执行效率随着对象数量的增长而降低）</li>
<li>空间问题（标记清除后会产生大量不连续的碎片，后续分配较大对象无法找到足够的连续内存时会提前触发另一次垃圾收集动作）</li>
</ol>
<h3 id="✅标记-复制算法"><a href="#✅标记-复制算法" class="headerlink" title="✅标记-复制算法"></a>✅标记-复制算法</h3><p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>缺点：<br>1.如果内存中对象大多数数是存活的，将带来大量的内存间复制开销<br>2.可用内存缩小为原来的一半。</p>
<p>所以，主要用于新生代，新生代中98%的对象熬不过第一轮收集。<br>Appel式回收：新生代分为较大的（80%）Eden空间和两个较小的Survivor空间（10%）<br>可用的内存空间为Eden+其中一个Survivor。垃圾收集中存活的对象复制到另一个Survivor，如果空间容纳不下，有内存的分配担保：对象直接进入老年代。</p>
<h3 id="✅标记-整理算法"><a href="#✅标记-整理算法" class="headerlink" title="✅标记-整理算法"></a>✅标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>缺点：<br>移动存活对象并更新所以引用这些对象的地方负担大。即在内存回收时更复杂，且停顿时间长Stop the world。<br>但是，标记清除算法，不移动对象则在内存分配时更复杂。<br>和稀泥式：虚拟机平时多数时间都用标记-清除算法，暂时容忍内存碎片的存在，直到碎片化大到影响对象分配时，再标记-整理算法收集一次。</p>
<h3 id="✅垃圾收集器"><a href="#✅垃圾收集器" class="headerlink" title="✅垃圾收集器"></a>✅垃圾收集器</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<p>1、Serial 收集器<br>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。这个收集器是一个单线程收集器。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。<br>新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
<p>Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下管理内存不大的虚拟机来说是个不错的选择。</p>
<p>2、ParNew 收集器<br>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。<br>新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。但是G1出现之后，逐渐取代ParNew+CMS。</p>
<p>3、Parallel Scavenge 收集器<br>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样，但是Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 </p>
<p>Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。<br>新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
<p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p>
<p>4、Serial Old 收集器<br>Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<p>5、Parallel Old 收集器<br>Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<p>6、CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。<br>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>
<p>从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li>初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li>并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li>并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。<br>￼</li>
</ul>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：</p>
<ul>
<li>对 CPU 资源敏感（面向并发，所以处理器资源敏感，虽然不会导致用户线程停顿，但是因为占用处理器导致用户的应用程序执行变慢）</li>
<li>无法处理浮动垃圾（在并发标记和并发清理阶段，用户线程还在运行，产生的新的垃圾对象叫做浮动垃圾。并且还需要预留一部分内存空间供用户线程分配对象内存，但是预留的少的话会出现并发失败，这时虚拟机启用Serial Old收集器对老年代垃圾收集，导致full gc，停顿时间长。）；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。（导致没有足够大的连续空间分配给大对象，不得不触发一次full gc）</li>
</ul>
<p>7、G1 收集器<br>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间可控的同时,还具备高吞吐量性能特征.</p>
<p>G1目标是替换掉JDK5中发布的CMS收集器，JDK9发布时，G1宣告取代Parallel Scavenge + Parallel Old组合，成为服务端模式下的默认垃圾收集器。CMS沦为不推荐使用。</p>
<p>建立停顿时间模型，G1跳出垃圾收集范围要么是新生代Minor GC，要么是老年代Major GC，要么是整个堆Full GC，它面向内存任何部分来组成回收集。</p>
<p>G1 开创的基于 Region的堆内存布局是它能够实现这个目标的关键。虽然 G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1 不再坚持<br>固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region)，每一个 Region 都可以根据需要，扮演新生代的Eden室间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。<br>Resion中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象。每个Region 的大小可以通过参数-XX:G1HeapRegionSize 设定，取值范围为 IMB~32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的HumongousRegion<br>之中，G1 的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待。<br>虽然G1 仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，<br>是因力它将 Region 作力単次回收的最小単元，即每次收集到的内存空间都是 Region 大小<br>的整数倍，这样可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。更具体的处理<br>思路是让G1收集器去跟踪各个 Region 里面的垃圾堆积的〝价值” 大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据收集停顿时间优先处理回收价值收益大的gegion。<br>总之：G1使用Region划分内存空间，以及具有优先级的区域回收方式，保证G1收集器在有限时间内获取尽可能高的收集效率。</p>
<p>使用记忆集来避免全堆作为GC roots扫描。记录跨Region的引用对象。</p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p>
<ul>
<li>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li>空间整合：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
<li>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<p>1、初始标记(Initial Marking)：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC 的时候同生完成的，所以G1 收集器在这个阶段实际并没有额外的停顿。</p>
<p>2、并发标记 ( Concurrent Marking)：从GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理 SATB 记录下的在并发时有引用变动的对象。</p>
<p>3、 最终标记(Final Marking)：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。</p>
<p>4、筛选回收 (Live Data Counting and Evacnation)：负责更新 Region 的统计数据，对各个Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空问。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</p>
<p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<p>G1收集器的目标是用户指定期望的停顿时间（默认两百毫秒）的基础上，尽可能高的吞吐量，停顿用户线程可以提高垃圾回收效率，所以回收阶段没有做成与用户线程一起并非执行的，放在了ZGC里。</p>
<p>期望停顿时间如果设置很小，垃圾回收赶不上分配，会引发full gc。<br>（如果是新生代老年代都适用的收集器都有young gc full gc）</p>
<p>CMS和G1的对比：<br>1、相比 CMS, G1 的优点有很多，暂且不论可以指定最大停顿时间、分 Region 的内存布局、按收益动态确定回收集这些创新性设计带来的红利，单从最传统的算法理论上看，G1也更有发展潜力。与CMS 的“标记一清除”算法不同，G1从整体来看是基于“标记一整理” 算法实现的收集器，但从局部(两个 Region 之间）上看又是基于 “标记一复制”算法实现，无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。</p>
<p>2、不过，G1 相对于 CMS 仍然不是占全方位、压倒性优势的，从它出现几年仍不能在所有应用场景中代替 CMS 就可以得知这个结论。比起CMS， G1 的弱项也可以列举出不少，如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用 ( Footprint)还是程序运行时的额外执行负载(Overload）都要比 CMS 要高。<br>就内存占用来说，虽然G1 和 CMS 都使用卡表来处理跨代指针，但 G1 的卡表实现更为复杂，而且堆中每个 Region， 无论扮演的是新生代还是老年代角色，都必领有一份卡表，这导致 G1 的记忆集（和其他内存消耗）可能会占整个堆容量的 20% 乃至更多的内存空间；<br>相比起来 CMS 的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用，反过来则不需要，由于新生代的对象具有朝生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的。</p>
<p>结论：目前在小内存应用上CMS的表现大概率仍然要会优于 G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java 堆容量平衡点通常在 6GB至8GB 之间。</p>
<p>8、ZGC收集器<br>衡量垃圾收集齐的三项指标：内存占用、吞吐量、延迟。<br>随着硬件的发展，内存扩大，反而给延迟带来了负面效果。<br>CMS和G1虽然实现了标记阶段的并发，不会因为要标记的对象变多而导致停顿时间增长。但是CMS标记清除避免不了空间碎片的产生，最终逃不过Stop the world。<br>G1在标记整理阶段还是有暂停的。</p>
<p>Shenandoah收集器：被Oracle排斥在外的收集器。OpenJDK中会包含。<br>可以在任何堆内存下都实现10m以内的停顿时间。<br>与G1的区别：<br>1.支持并发的整理算法，意思是可以与用户线程并发<br>2.没有实现分代<br>3.摒弃了G1中耗费大量内存和计算资源维护的记忆集，改用全局的连接矩阵来记录跨Region的引用关系。</p>
<p>ZGC收集器：JDK11中新加入的具有实验性质的低延迟垃圾收集器。<br>可以实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。<br>ZGC是一款基于Region内存布局的，不设分代的，使用读屏障、染色指针和内存多重映射技术实现可并发标记整理算法的，以低延迟为首要目标的一款垃圾收集器。<br>ZGC的Region具有动态性（动态创建和销毁），以及动态的区域容量大小。<br>染色指针技术：一般情况下在对象头中增加额外的存储字段，如对象的哈希码、分代年龄、锁记录。染色指针是将少量额外的信息存储在引用对象的指针上的技术。缺点是由于占用了指针带宽，使得ZGC可以管理的内存变小。</p>
<p>9、Epsilon收集器<br>不能够进行垃圾收集的垃圾收集器。<br>垃圾收集器作为一个自动内存管理子系统，除了垃圾收集的本职工作外，它还负责堆的管理与布局、对象的分配、与解释器的协作、与监控子系统协作等职责，其中至少堆的管理和对象的分配是java虚拟机能够正常运作的必要支持。<br>Java体系的发展重心：面向长时间、大规模的企业级应用和服务端应用。近年来，大型系统从传统单体应用向微服务化、无服务化方向发展的趋势明显。传统java内存占用大、在容器中启动时间长、即时编译需要缓慢优化等特点。对短时间、小规模的服务形式有诸多不适。最近几个版本的jdk加入了提前编译、面向应用的类数据共享等支持。<br>Epsilon收集器适合运行时间短的虚拟机。</p>
<h3 id="✅自动内存管理：对象内存的分配、回收分配给对象的内存。"><a href="#✅自动内存管理：对象内存的分配、回收分配给对象的内存。" class="headerlink" title="✅自动内存管理：对象内存的分配、回收分配给对象的内存。"></a>✅自动内存管理：对象内存的分配、回收分配给对象的内存。</h3><p>对象分配原则：<br>1.对象优先在eden区中分配，当eden区没有足够的空间进行分配时，虚拟机会发生一次minor gc。如果没对象可以回收或者回收的对象少，eden区还是空间不够，会将存活对象移动至survivor区，如果survivor太小放不下，会通过分配担保机制提前转移到老年代。</p>
<p>2.大对象直接进入老年代<br>大对象：需要大量连续内存空间的java对象，例如很长的字符串、元素数量庞大的数组。<br>Java虚拟机中要避免大对象的原因：再分配空间时，大对象容易导致内存明明还有不少空间时就提前触发垃圾收集。以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。<br>所以，大对象直接进入老年代：目的是避免在eden区及两个survivor区之间来回复制，产生大量的内存复制操作。</p>
<p>3.长期存活的对象将进入老年代<br>虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在Eden区里诞生：如果经过第一次Minor Gc后仍然行活，并且能被 Survivor 容纳的话，该对象会被移动到 Survivor空间中，并且将其对象年龄设定为1岁。对象在 Survivor区中每熬过1次 Minor gc，年龄就增加1岁，当它的年龄增加到一定程度 （默认为 15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-Xx-MaXTenuring Threshold 设置。</p>
<p>4.动态对象年龄判定<br>为了更好适应程序的内存状况，如果survivor空间中满足同年龄对象大小总和达到survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。</p>
<p>5.空间分配担保<br>在发生minor gc之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，可以确保minor gc是安全的（所有对象存活需要老年代进行担保）。如果不成立，需要看虚拟机是否允许担保失败，允许的话检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小（经验值），如果大于，尝试进行一次minor gc（有风险的，担保失败则会重新发起一次full gc，停顿时间更长，但这么做是为了避免full gc过于频繁），如果小于或者不允许担保失败，直接full gc让老年代腾出空间。<br>（jdk6之后都是固定允许担保失败了）</p>
<h3 id="✅JDK-监控和故障处理工具"><a href="#✅JDK-监控和故障处理工具" class="headerlink" title="✅JDK 监控和故障处理工具"></a>✅JDK 监控和故障处理工具</h3><p>Java与c++之间：内存动态分配和垃圾收集技术的墙。<br>Jdk的bin目录下除了java.exe和javac.exe外还有很多工具。</p>
<p>1、jps<br>jps (JVM Process Status）: 类似 UNIX 的 ps 命令。用于查看所有 Java 进程的操作系统进程id、启动类、传入参数和 Java 虚拟机参数等信息；<br>-q 不输出类名、Jar名和传入main方法的参数<br>-m 输出传入main方法的参数<br>-l 输出main类或Jar的全限名<br>-v 输出传入JVM的参数</p>
<p>2、jstat<br>jstat（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据：类加载、垃圾收集、允许期编译状况<br>jstat -gc 进程id 250 4     //150ms一次，查4次<br>jstat -gcutil 23484 1000 5 监视内容基本与gc相同，但输出的主要是已占用的总空间的百分比。<br>S0     S1     E      O（老年代）     P（永久带）   YGC（young gc次数）  YGCT（young gc总耗时）    FGC    FGCT     GCT（所有gc总耗时）</p>
<p>3、jinfo<br>jinfo (Configuration Info for Java) : Configuration Info for Java,实时地查看和调整虚拟机各项参数;<br>例如查询CMSInitiatingOccupancyFraction的参数值：<br>jinfo -flag CMSInitiatingOccupancyFraction 进程id</p>
<p>4、jmap<br>jmap (Memory Map for Java) : 生成堆转储快照;<br>jmap 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。<br>jmap -dump:format=b,file=/tmp/dump.dat 进程id<br>jmap -heap pid查看进程堆内存使用情况，包括使用的GC算法、堆配置参数和各代中堆内存使用情况。</p>
<p>5、jhat<br>jhat (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;<br>jhat 用于分析 heapdump 文件。<br>一般工作中不用，因为要在自己机器上分析，可以用VisualVM等可视化工具。</p>
<p>6、jstack<br>jstack :生成虚拟机当前时刻的线程快照<br>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.<br>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。<br>jstack -l 进程id  ：除堆栈外，显示关于锁的附加信息<br>-F ： 当正常输出的请求不被响应时，强制输出线程堆栈<br>-m： 如果调用到本地方法的话，可以显示C/C++的堆栈</p>
<p>JDK5开始Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中的所有线程的StackTraceElement对象，可以完成jstack的大部分功能，实际项目中可以做个jsp管理员页面，在浏览器上就可以看线程堆栈。</p>
<h3 id="✅可视化故障处理工具"><a href="#✅可视化故障处理工具" class="headerlink" title="✅可视化故障处理工具"></a>✅可视化故障处理工具</h3><p>1、JHSDB：JDK提供的集成式多功能工具箱<br>jhsdb hsdb —pid 进程id    打开图形化模式<br>可以用来调试虚拟机进程或者dump出来的内存转储快照</p>
<p>2、JConsole<br>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出console命令启动或者在 JDK 目录下的 bin 目录找到jconsole.exe然后双击启动。<br>JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况。</p>
<p>3、Visual VM:多合一故障处理工具<br>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。<br>是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。<br>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。<br>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。<br>dump 以及分析堆转储快照（jmap、jhat）。<br>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。<br>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。<br>其他 plugins 的无限的可能性……</p>
<h3 id="✅java无关性"><a href="#✅java无关性" class="headerlink" title="✅java无关性"></a>✅java无关性</h3><p>平台无关性、语言无关性<br>平台无关性：<br>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。可以说.class文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</p>
<p>语言无关性：<br>以Class文件作为不同语言的交付媒介。<br>Kotlin、Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。不同的语言被不同的编译器编译成.class文件最终运行在 Java 虚拟机之上。<br>（《java虚拟机规范》描绘了共有设计：class文件格式和字节码指令集）</p>
<h3 id="✅Class类文件的结构"><a href="#✅Class类文件的结构" class="headerlink" title="✅Class类文件的结构"></a>✅Class类文件的结构</h3><p>Class文件结构很稳定，任何一个Class文件都对应唯一一个类/接口的定义信息。但是反过来，类或接口不一定都得定义在文件里（类或接口动态生成，直接送入类加载器中）。</p>
<p>根据 Java 虚拟机规范，Class 文件通过 ClassFile 定义，有点类似 C 语言的结构体的伪结构。只有两种数据结构：无符号数、表。</p>
<p>1、魔数与Class文件的版本<br>每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件。<br>使用魔数而不是扩展名来进行标识，主要是基于安全考虑。<br>Class文件的魔数是：CAFEBABE</p>
<p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是次版本号，第 7 和第 8 位是主版本号。<br>每当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。你可以使用 javap -v 命令来快速查看 Class 文件的版本号信息。<br>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。<br>jdk1.1 是45，jdk6是50.</p>
<p>2、常量池<br>紧接着主次版本号之后的是常量池，是Class文件结构中与其他项目关联最多的数据，通常是占用Class文件空间最大的数据项目之一，是表类型数据项目。常量池的数量是 constant_pool_count（常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”）。</p>
<p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符<br>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：开始的第一位是一个 u1 类型（1个字节）的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</li>
</ul>
<p>Java代码在虚拟机加载Class文件的时候进行动态连接，将会从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
<p>.class 文件可以通过javap -v class类名 指令来看一下其常量池中的信息(javap -v class类名-&gt; temp.txt ：将结果输出到 temp.txt 文件)。</p>
<p>3、访问标志(Access Flags)<br>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>
<p>4、当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合<br>Java 类的继承关系由类索引（u2两个字节）、父类索引（u2）和接口索引（一组u2）集合三项确定。类索引、父类索引和接口索引集合按照顺序排在访问标志之后，<br>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。<br>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implements (如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。</p>
<p>例如当前类索引，指向常量池中的一个常量，表示类名（不能无限长，64KB，因为一个u2表示长度）。</p>
<p>5、字段表（field info）<br>用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。<br>各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。例如字段的简单名称、字段和方法的描述符。<br>都是：前面一个容量计数器表示字段表数据，后面若干个固定格式。</p>
<p>Java中字段无法重载，但是Class文件中可以。</p>
<p>6、方法表（Method）<br>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。<br>因为volatile修饰符和transient修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了synchronized、native、abstract等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
<p>方法里的java代码经过javac编译器编译成字节码指令之后，存放在方法属性表集合中的一个code的属性中。属性表是class文件格式中最具扩展性的一种数据项目。</p>
<p>7、属性表集合（Attributes）<br>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h3 id="✅字节码指令"><a href="#✅字节码指令" class="headerlink" title="✅字节码指令"></a>✅字节码指令</h3><p>Java虚拟机的指令由一个字节长度的、 代表着某种特定操作含义的数字(称为操作码，Opcode)以及跟随其后的零至多个代表此操作所需参数(称为操作数，Operands)而构成。</p>
<p>Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码。<br>Java虚拟机操作码长度限制为一个字节（0-255），并且Class文件格式放弃类编译后代码的操作数长度对齐。所以虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体的数据的结构。这种操作会导致解释执行字节码时损失一些性能，但是这样意味着节省很多填充和间隔符号，编译代码也更加短小精干。这也是因为Java最初设计是面向网络、智能家电的技术背景，并且一直沿用至今。</p>
<p>字节码指令与数据类型<br>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。 例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。<br>这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。<br>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务，也有一些指令的助记符中没有明确地指明操作类型的字母，或与数据类型无关。</p>
<p>包括哪些指令：<br>1、加载和存储指令<br>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容。<br>将一个局部变量加载到操作栈：iload<br>将一个数值从操作数栈存储到局部变量表：istore<br>将一个常量加载到操作数栈：bipush</p>
<p>2、运算指令<br>运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。 大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令，无论是哪种算术指令，都使用Java虚拟机的数据类型，由于没有直接支持byte、short、 char和boolean类型的算术指令，对于这类数据的运算，应使用操作int类型的指令代替。 整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现。<br>加法指令：iadd、 ladd、 fadd、 dadd。<br>减法指令：isub</p>
<p>3、类型转换指令<br>类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作</p>
<p>4、对象创建与访问指令<br>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。 对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下。<br>创建类实例的指令：new。<br>创建数组的指令：newarray、 anewarray、 multianewarray。<br>访问类字段(static字段，或者称为类变量)和实例字段(非static字段，或者称为实例变量)的指令：getfield、 putfield、 getstatic、 putstatic。</p>
<p>5、控制转移指令<br>控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。<br>用于条件分支。</p>
<p>6、方法调用和返回指令<br>invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派(虚方法分派)，这也是Java语言中最常见的方法分派方式。<br>invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。<br>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn</p>
<p>7、异常处理指令</p>
<p>在Java程序中显式抛出异常的操作(throw语句)都由athrow指令来实现，除了用throw语句显式抛出异常情况之外，Java虚拟机规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。 例如，整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。</p>
<p>而在Java虚拟机中，处理异常(catch语句)不是由字节码指令来实现的(很久之前曾经使用jsr和ret指令来实现，现在已经不用了)，而是采用异常表来完成的。</p>
<p>8、同步指令</p>
<p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程(Monitor，就是锁)来支持的。</p>
<p>方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。 虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。 当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成(无论是正常完成还是非正常完成)时释放管程。 在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。 如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。</p>
<p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持（编译器保证两个指令一定成对出现）。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36380063/article/details/114746916">https://blog.csdn.net/weixin_36380063/article/details/114746916</a></p>
<h3 id="✅类加载的时机"><a href="#✅类加载的时机" class="headerlink" title="✅类加载的时机"></a>✅类加载的时机</h3><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>
<p>Java语言中，类的加载、连接、初始化过程都是在程序运行期间完成的。这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p>
<p>Class文件：一串二进制字节流。</p>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期如下图所示：<br>￼<br>如上图，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>
<p>虚拟机规范严格规定了有且只有6种情况必须对类进行“初始化”，当然初始化前的三个阶段（加载、验证、准备）就必须在此之前开始执行了。</p>
<p>1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有初始化，则需要先触发其初始化；这4条指令对应的的常见场景分别是：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</p>
<p>2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>注：反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。（一个接口在初始化时，并不要求其父接口全部完成初始化）<br>注：子类执行构造函数前需先执行父类构造函数。</p>
<p>4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
<p>5）当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化。则需要先触发其初始化。<br>注：JDK1.7的一种新增的反射机制，都是对类的一种动态操作。</p>
<p>6）当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p>
<p>这6种场景中的行为称为对类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。例如：</p>
<p>1）通过子类引用父类的静态字段，不会导致子类初始化<br>2）通过数组定义来引用类，不会触发此类的初始化<br>3）常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化<br>（在编译阶段通过常量传播优化，已经将此常量的值存储到类的常量池中，以后Test类对常量SuperClass.value的引用实际上都转化为Test类对自身常量池的引用了。）</p>
<h3 id="✅类加载的过程：加载"><a href="#✅类加载的过程：加载" class="headerlink" title="✅类加载的过程：加载"></a>✅类加载的过程：加载</h3><p>“加载”是“类加载”过程的一个阶段，最好不要被字眼迷惑。在加载阶段，虚拟机需要完成以下3件事情：<br>1）通过一个类的全限定名来获取此类的二进制字节流；<br>虚拟机规范并没有明确说明类的二进制字节流从何而来（一般是由java源码编译而来），所以这里可以有非常灵活的实现空间，例如可以用过ZIP包（如JAR、EAR、WAR格式）读取，从网络中获取，运行时计算生成（如动态代理技术，Proxy中，ProxyGenerator.generateProxyClass()来为特定接口生成形式为*$Proxy的代理类的二进制字节流），从数据库中读取，从加密文件中获取等等。</p>
<p>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；<br>方法区与Java堆一样，是各线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。而方法区中的数据存储结构格式虚拟机自行定义。</p>
<p>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。<br>注：加载阶段完成后，虚拟机在内存中实例化一个java.lang.Class类的对象（Class是一个实实在在的对象，是记录着类成员、接口等信息的对象）。Class对象时存在方法区还是堆中？方法区中存类型数据，堆中存Class类的对象）</p>
<p>非数组类和数据类的加载阶段有有所不同，数组类的应用是不会对该类进行初始化，而是虚拟机通过字节码指令“newarray”去创建一个Object”对象。</p>
<p>数组类加载过程要遵循的规则：<br>1）如果数组的组件类型（去掉一个维度）是引用类型（非基础类型），那就递归去加载这个组件类型。<br>2）如果数组组件类型不是引用类型（例如int[]数组），Java虚拟机将会把该数组标记为与引导类加载器关联。<br>3）数组类的可见性与他的组件类型可见性一致，如果组件类型不是引用类型，那数组的可见性将默认为public。</p>
<h3 id="✅类加载的过程：验证"><a href="#✅类加载的过程：验证" class="headerlink" title="✅类加载的过程：验证"></a>✅类加载的过程：验证</h3><p>加载阶段可以说是字节码进入Java虚拟机的入口，类加载过程的“验证阶段”是对类文件的字节码进行验证，才能确保Java虚拟机不受恶意代码的攻击。从性能上讲，这无疑是给虚拟机带来额外的性能消耗，但这也是无可厚非要付出的代价。</p>
<p>（java语言比C/C++要安全，如果使用java代码访问数组边界之外的数据，对象转换为它并未实现的类型，跳转到不存在的代码行，这些编译器都会抛出异常拒绝编译，但是Class文件不一定都是由java源码编译而来，所以以上java代码层面无法做到的，class文件可以做到）</p>
<p>验证阶段大致上会完成下面4个阶段的检查动作：</p>
<p>1）文件格式验证<br>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。目的是保证输入的字节流能够正确地解析并存储于方法区，该验证基于二进制字节流。<br>l  是否以魔数0xCAFEBABE开头；<br>l  主、次版本号是否在当前虚拟机处理范围内；<br>l  常量池的常量中是否有不被支持的常量类型（检查常量tag标志）；</p>
<p>2）元数据验证，保证不存在不符合Java语言规范的元数据信息，语义分析，基于方法区的存储结构进行的。<br>l  这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）；<br>l  这个类的父类是否继承了不允许被继承的类（被final修饰的类）；<br>l  如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法；</p>
<p>3）字节码验证，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件<br>l  保证任意时刻操作栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载如本地变量中；<br>l  保证跳转指令不会跳转到方法体以外的字节码指令上；<br>l  保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不安全）；<br>“字节码验证”是整个验证阶段最消耗时间的，虽然如此但也不能保证绝对安全。jdk6之后，把校验挪到了javac编译器中，方法体Code属性的属性表增加了StackMapTable的新属性（描述了方法体基本块开始时本地变量表和操作栈应有的状态），字节码验证期间不需要做类型推导，只需要类型检查。</p>
<p>4）符号引用验证，确保在后续的“解析”阶段能正常执行<br>l  符号引用中通过字符串描述的全限定名是否能找到对应的类；<br>l  在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段；<br>l  在符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问；<br>其实我们的IDE也虚拟机规范的检查，所以我们的代码加载几乎没有不通过的。</p>
<h3 id="✅类加载的过程：准备"><a href="#✅类加载的过程：准备" class="headerlink" title="✅类加载的过程：准备"></a>✅类加载的过程：准备</h3><p>准备阶段是正式为类变量（静态变量）分配内存设置类变量初始化值的阶段，这些变量所使用的内存都将在方法区中进行分配（方法区是一个逻辑上的区域，JDK及之前，永久代是方法区的实现，JDK8及之后类变量随着Class对象一起存放在java堆中）。这个阶段中有两个容易产生混淆的概念需要强调一下。首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值（final变量除外）</p>
<h3 id="✅类加载的过程：解析"><a href="#✅类加载的过程：解析" class="headerlink" title="✅类加载的过程：解析"></a>✅类加载的过程：解析</h3><p>解析阶段是虚拟机将常量池的符号引用直接替换为直接引用的过程。</p>
<p>l  符号引用（Symbolic References）：<br>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。<br> <br>l  直接引用（Direct References）：<br>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接点位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
<p>例如符号引用：“java/lang/Object;”这是我们熟知的Object类的全限定名。解析阶段就是要把这个“class”的字符引用换成直接指向这个Object类在内存中的地址（如指针 ）。那就说明，这个Object类必须同时也需要加载到内存中来。</p>
<p>虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。但对于invokedynamic指令，上面规则则不成立。当碰到某个前面已经由invokedynamic指令触发过解析的符号引用时，并不意味着这个解析结果对其他invokedynamic指令也同样生效。因为invokedynamic指令是JDK1.7新加入的指令，目的用于动态语言支持（还有jdk8中的lambda表达式和接口的默认方法）。</p>
<p>invokedynamic必须等到程序实际运行到这条指令的时候，解析动作才能进行。其余可触发解析的指令可以在还没有执行代码时就进行解析。</p>
<p>Java语言本身是一门静态类型语言。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号进行引用。</p>
<h3 id="✅类加载的过程：初始化"><a href="#✅类加载的过程：初始化" class="headerlink" title="✅类加载的过程：初始化"></a>✅类加载的过程：初始化</h3><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器之外，其余动作完全是由虚拟机主导和控制。初始化阶段将主导权移交给应用程序。</p>
<p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划其余初始化变量和其他资源，或者从另一个角度来表达，初始化阶段是执行类构造器<clinit>()方法（javac编译器的自动生成物）的过程。</clinit></p>
<p><clinit>()方法是有编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是有语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。</clinit></p>
<p><clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕；父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作；</clinit></clinit></clinit></init></clinit></p>
<p><clinit>()方法对于类和接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法；</clinit></clinit></p>
<p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</clinit></clinit></clinit></clinit></p>
<p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。</clinit></clinit></clinit></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%85%AB%E8%82%A1/" rel="tag"># 八股</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/26/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/%E6%9D%82/" rel="prev" title="比较杂的东西">
      <i class="fa fa-chevron-left"></i> 比较杂的东西
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/05/01/myblog/%E5%85%AB%E8%82%A1/java%E5%B9%B6%E5%8F%91/" rel="next" title="java并发">
      java并发 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">✅java内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85string%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="nav-number">2.</span> <span class="nav-text">✅string不可变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">3.</span> <span class="nav-text">✅java对象的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">4.</span> <span class="nav-text">✅java对象的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">5.</span> <span class="nav-text">✅对象的访问定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">✅内存溢出和内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%8A%80%E6%9C%AF"><span class="nav-number">7.</span> <span class="nav-text">✅内存动态分配和垃圾收集技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">✅死亡对象判断方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">9.</span> <span class="nav-text">✅对象的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">10.</span> <span class="nav-text">✅回收方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%8A%A8%E6%80%81%E7%B1%BB"><span class="nav-number">11.</span> <span class="nav-text">✅什么是java动态类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">✅垃圾收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="nav-number">13.</span> <span class="nav-text">✅分代收集理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">14.</span> <span class="nav-text">✅标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">15.</span> <span class="nav-text">✅标记-复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">16.</span> <span class="nav-text">✅标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">17.</span> <span class="nav-text">✅垃圾收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E3%80%81%E5%9B%9E%E6%94%B6%E5%88%86%E9%85%8D%E7%BB%99%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E3%80%82"><span class="nav-number">18.</span> <span class="nav-text">✅自动内存管理：对象内存的分配、回收分配给对象的内存。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85JDK-%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-number">19.</span> <span class="nav-text">✅JDK 监控和故障处理工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-number">20.</span> <span class="nav-text">✅可视化故障处理工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85java%E6%97%A0%E5%85%B3%E6%80%A7"><span class="nav-number">21.</span> <span class="nav-text">✅java无关性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">22.</span> <span class="nav-text">✅Class类文件的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="nav-number">23.</span> <span class="nav-text">✅字节码指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">24.</span> <span class="nav-text">✅类加载的时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%8A%A0%E8%BD%BD"><span class="nav-number">25.</span> <span class="nav-text">✅类加载的过程：加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A%E9%AA%8C%E8%AF%81"><span class="nav-number">26.</span> <span class="nav-text">✅类加载的过程：验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%87%86%E5%A4%87"><span class="nav-number">27.</span> <span class="nav-text">✅类加载的过程：准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A%E8%A7%A3%E6%9E%90"><span class="nav-number">28.</span> <span class="nav-text">✅类加载的过程：解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">29.</span> <span class="nav-text">✅类加载的过程：初始化</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jade liu"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Jade liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jadeliuliu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jadeliuliu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jadeliu1998@163.com" title="E-Mail → mailto:jadeliu1998@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jadeliu1998" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;jadeliu1998" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5823044646" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5823044646" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jade liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
